{"pages":[{"title":"关于","date":"2021-06-29T20:32:00.000Z","path":"about/index.html","text":"I AM我是查利鹏，C++ 与 UE4 开发者，热爱并专注于计算机科学相关技术，前 VR 从业者，游戏程序员，就职于腾讯光子工作室群，我的博客：imzlp.com。 Honour 2020 Unreal Open Day 杰出社区贡献奖 2020/2022 Unreal Open Day 技术主讲人 2021 Q1 腾讯开源热搜精品奖（个人项目获奖） 2021 Q1 腾讯开源协同项目奖（个人项目获奖） 2021 Q2 腾讯开源协同个人奖 2021 H2 Tencent Outstanding Contributor 2022 光子技术空间年度分享达人 一等奖 2022 Unreal Open Day 杰出社区贡献奖 Contact Me 我建立了一个 QQ 群：958363331，用于交流虚幻引擎相关技术。 Github：hxhb E-Mail：&#x69;&#x6d;&#122;&#108;&#112;&#64;&#102;&#x6f;&#120;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d; QQ：747010014 我的微信公众号，会定期发布博客的文章和一些对技术资讯分析与思考的内容：循迹研究室 。 如需技术支持或者咨询，请发邮件至imzlp@foxmail.com。 Copyright本站使用 Hexo 生成，Github Action部署，托管在 Github Pages，Theme 为Wikitten，SSL 证书由Let’s Encrypt 签发。使用 Github Gist 实现了动态更新内容的效果，并且使用 Lepton 作为编辑工具。本站内容默认采用「BY-BC-SA 4.0」知识共享协议。"},{"title":"分类","date":"2015-08-18T09:30:56.000Z","path":"categories/index.html","text":""},{"title":"站点日志","date":"2021-06-30T11:19:46.000Z","path":"changelog/index.html","text":"2021.07.13 支持左侧分类显示 New 按钮，直接跳转到 Github 上的创建页面，并会依据分类的结构创建目录。 2021.07.1 支持 MD Editor 支持在页面上直接 New（会根据分类自动创建） 支持添加外部链接（会生成一个临时文章，用于索引分类和 Tag 以及搜索） 支持外部链接的搜索 支持给 http 开头的本站网址添加nofollow 支持插入 B 站视频 为解决以上需求，修改了以下几个 Hexo 的插件： hexo-autonofollow hexo-generator-json-content hexo-directory-category hexo-bilibili 2021.07.08 支持 fied 的目录栏，并适配宽度、Mobile 支持作者信息列表 贡献者，并能够分析出每个作者发表了多少篇内容生成每个作者的归档页面 支持生成每个作者的文章列表，URL 规则为/contributor/authorname 作者可以在页面中通过配置定制化页面信息 大量的主题配置优化 集成 Google 翻译，支持 en,zh-CN,ru,ja 四种语言的翻译 集成 Valine 评论模块 集成 Google Aanalysic 为支持上面的需求，我写了两个 hexo 的插件： hexo-contributor：用于生成作者卡片信息，如 贡献者。 hexo-generator-authors：用于生成网站每个作者的文章归档页面，如contributor/lipengzha。 投稿的 md 配置： 12345678910111213141516171819202122232425262728---title: # 标题abbrlink: # 持久化链接，为一串随机数字（可不填）date: 2021-06-29 22:32:01 # 创建时间toc: true # 开启目录tag: # 标签可以指定多个（每行一个） - comments: true # 开启评论ue_version: UE4.25 # 文章使用的引擎版本author: # 作者信息，会显示在贡献者列表 name: # 名字 site_addr: # 网站链接 avatar_image: # 头像图片链接，如果为空则默认使用 github 头像 github_id: # github 账户 ID zhihu_addr: # 知乎链接 email: # 邮件地址 wechat_image: # 微信二维码图片地址postQR: enable: false # 开启文章末尾二维码 image: # 二维码链接 info: # 显示文字copyright: # 文章末尾的版权信息 enable: true history: true # 是否可查看文章编辑历史、RAW 文本 license: CC BY-NC-SA 4.0 # 文章的授权协议 backupAddr: # 文章的备份链接---&lt;!-- WIKI 内容 --&gt; 作者信息的生成和归档通过上面我写的那两个插件在生成时自动执行，无需手动介入。 2021.07.02 整理和归档博客内容 2021.06.39 创建 Hexo 站点 基于 Wikitten 的主题方案 主题优化 部署 Github Pages/Action 流程"},{"title":"贡献者","date":"2024-10-24T12:11:11.955Z","path":"contributor/index.html","text":"希望更多的开发者能踊跃投稿，分享自己的开发经验，为虚幻社区添砖加瓦！ 感谢以下组织对开发者的支持： Epic Games Tencent 本站的内容贡献者："},{"title":"编辑器","date":"2024-10-24T12:11:11.955Z","path":"editor/index.html","text":""},{"title":"外部链接","date":"2024-10-24T12:11:11.959Z","path":"elinks/index.html","text":""},{"title":"资源","date":"2021-06-30T11:19:46.000Z","path":"resources/index.html","text":"My Tools &amp; Services UE4 Console Help UE4 Wiki Archive UE4 C++ API Documents for DASH UE4 Feeds and Resources UE4 Notes UE5 Feeds Unreal Engine News MetaHuman Creator:HIGH-FIDELITY DIGITAL HUMANS MADE EASY Oodle now free to use in Unreal Engine via GitHub A sneak peek at MetaHuman Creator: high-fidelity digital humans made easy Unreal Engine Public Roadmap Unreal Engine 4.26 released! Unreal Engine Issues Unreal Engine Issues UE4 Release Notes Unreal Engine Release Notes Unreal Engine 4.26 Release Notes UE4 Hotfix Release notes 4.26.2 Hotfix released 4.26.1 Hotfix released 4.25.4 Hotfix released 4.25.3 Hotfix released 4.25.2 Hotfix released 4.25.1 Hotfix released UE4 Documents Unreal Engine 4 Documentation Unreal Engine API Reference Unreal Engine 4 Console Variables and Commands Coding Standard Unreal Architecture Unreal Engine Resource Unreal Engine Feeds Programming with C++ Other Docs Unreal Engine Community Wiki Unreal Art Optimization Plugins我开源的一些 Unreal Engine 相关的工具和插件： HotPatcher：UE4 插件，用于 UE 资源版本管理和打包的工具，用来打包热更资源并管理热更版本，支持一键 Cook 和打包多个平台的 patch，具有丰富的配置化选项和 commandlet 支持，编辑器支持 Windows/MacOS。详细的文档介绍：UE 资源热更打包工具 HotPatcher ，该热更新方案已在大量项目中使用，是目前应用最广泛的 UE4 热更新方案。 ue4-export-nav-data：UE4 插件，从 UE 中导出 Recast Navigation 导航数据的插件，该插件已上架 虚幻商城，详细的文档介绍：Export Recast Navigation Data from UE4 ue4-recast-detour：与 ue4-export-nav-data 配套使用，可以在非 Dedicated 服务器架构上无缝结合 UE 的 Recast detour 寻路。 ue4-zstd：为 UE4 集成 facebook 的 ZStandard 压缩算法，支持用来打包 Pak 时替换 UE 默认的 Zlib 压缩算法，具体的文档：ModularFeature：为 UE4 集成 ZSTD 压缩算法 UE4Launcher：UE4 项目的启动器，基于 UE 的 StandaloneApplication 模式编写的应用程序，用于方便地启动 UE 项目（或者引擎工具，方便扩展），支持扫描本地所有的引擎版本，支持添加启动参数，支持保存、加载配置，支持关联 .uejson 文件，支持检测源码版引擎并启动 VS。 ue4program：创建 UE StandaloneApplication 模板工程的工具，UE 没有提供创建这种类型工程的方法。可以用来编写独立于引擎的工具（把 UE 当作个第三方库来使用，如UE4Launcher），或者测试引擎中部分模块的特性，可以不用创建一个游戏工程，比较轻量。写过一篇文章来介绍：Create A Standalone Application in UE4 ue4-dtkit：基于 HTTP 的跨平台下载库，支持暂停 / 继续 / 分片下载 / 边下边存 / 边下边计算 MD5(OpenSSL)，支持 IOS/Android/Win/MacOS 四个平台。 UE4_API_FOR_DASH：从 UE API 抓取并生成的支持 Dash 索引的文档源，可以离线搜索 UE API。 PlatformUtils：封装的常用平台工具库，支持 IOS/Android/Windows/MacOS，对于移动平台可以比较方便地使用 JNI 调用和添加第三方库、IOS 的 Framework。 ue4-git-controller：UE4 插件，在 UE 中解析 git 命令的结果，可以用来扩展 UE 的版本控制功能。 ue4-jwt：UE4 插件，用于在 UE 中集成 jwt。 ue4-protobuf：UE4 插件，以插件的形式在项目中集成 Protobuf，并且有方便执行 protoc 的编辑器 Toolbar。 在开源版本上修改的项目： debugable-unlua：在 Tencent/UnLua 仓库的基础上修改(目前最新基础版本为b33c540)，目的是打造一个开箱即用的 UnLua，增加可调试方案和一些基础 lua 库到 unlua，支持 UE 的 UFS、编辑器优化、基础静态符号导出。 unlua-pb：集成 lua-ptorobuf 到 Unlua 的 Module，支持通过 pb.loadufsfile 来加载 UFS 内的文件，支持通过 protoc:loadfile/protoc:parserfile 时支持 UE 的 UFS 内文件、并且可以处理 Import 的其他 UFS 内的 proto 文件。 oodle-compression：从 UE5 中提取出的 Oodle 链接库，并实现集成至 UE 的插件，可以在 UE4 中使用该压缩算法进行打包，详细介绍：ue5/#Oodle-Compression VR Tools SideQuest Android-based 的开源 VR 应用商店 ALVR Standalone VR 玩 SteamVR 的串流工具 VirtualControllerDriver 拍摄 MR 视频时创建虚拟控制器 Boost boost_1602_vc140 boost_v162 Protobuf protobuf_v3.9.1 CodeWorks CodeWorks_1R7(百度网盘链接，提取码tkuj ) Lua Lua53-build-with-msvc14_x64-20191022 Lua53-build-with-msvc14_x86-20191022 luasocket_MSVC14_x64 HTTP模拟 HTTP 请求的工具: Postman 跨平台 / 功能全面 / 启动有点慢 Insomnia IOS在 Windows 上方便访问 IOS 设备的工具。 iOSLogInfo 在 Win 上类似 logcat 的工具 iMazing Window 上的 IOS 设备管理软件，可以访问应用的数据文件夹"},{"title":"标签","date":"2015-08-17T22:16:13.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"UE 热更新：一次资源异常的故障分析","date":"2024-10-17T00:00:00.000Z","path":"wiki/external1700004272/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 热更新：一次资源异常的故障分析 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/22890/"},{"title":"target.cs 中检测是否是源码版引擎","date":"2024-05-22T14:32:01.000Z","path":"wiki/3d4f2054/","text":"可以从 TargetRules 中使用 bIsEngineInstalled 来检查。 它调用的是 UnrealBuildTool.IsEngineInstalled()，检测的也是Engine/Build/InstalledBuild.txt 文件是否存在。 12345678/// &lt;summary&gt;/// Expose a setting for whether or not the engine is installed/// &lt;/summary&gt;/// &lt;returns&gt;Flag for whether the engine is installed&lt;/returns&gt;public bool bIsEngineInstalled&#123; get &#123; return UnrealBuildTool.IsEngineInstalled(); &#125;&#125; 在 UE4 与 5 中还有些区别，在 UE4 中调用的是 UnrealBuildTool.IsEngineInstalled()，定义在UnrealBuildTool.cs。 在 UE5 中，调用的是 Unreal.IsEngineInstalled() 定义在Unreal.cs。 UnrealBuildTool.cs or Unreal.cs(UE5)123456789101112/// &lt;summary&gt;/// Returns true if UnrealBuildTool is running using installed Engine components/// &lt;/summary&gt;/// &lt;returns&gt;True if running using installed Engine components&lt;/returns&gt;static public bool IsEngineInstalled()&#123; if (!bIsEngineInstalled.HasValue) &#123; bIsEngineInstalled = FileReference.Exists(FileReference.Combine(EngineDirectory, &quot;Build&quot;, &quot;InstalledBuild.txt&quot;)); &#125; return bIsEngineInstalled.Value;&#125;","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"target.cs","slug":"target-cs","permalink":"https://ue5wiki.com/tags/target-cs/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"利用 HotPatcher 加速真机资源验证","date":"2024-04-07T00:00:00.000Z","path":"wiki/external1038528457/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 利用 HotPatcher 加速真机资源验证 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/76004/"},{"title":"开源杂谈：HotPatcher 的开发进展","date":"2024-04-07T00:00:00.000Z","path":"wiki/external1617315395/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 开源杂谈：HotPatcher 的开发进展 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开源","slug":"开源","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E6%BA%90/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"}],"categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/16808/"},{"title":"虚幻周报 20240125 | 还有两周","date":"2024-01-25T00:00:00.000Z","path":"wiki/external1284538056/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20240125 | 还有两周 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/679761565"},{"title":"虚幻周报 20240117 | 还有一个月","date":"2024-01-17T00:00:00.000Z","path":"wiki/external1975367245/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20240117 | 还有一个月 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/678297071"},{"title":"虚幻周报 20240110 | 录播放送中","date":"2024-01-10T00:00:00.000Z","path":"wiki/external1832127816/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20240110 | 录播放送中 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/677045531"},{"title":"虚幻周报 20240131 | 等不及了！","date":"2024-01-10T00:00:00.000Z","path":"wiki/external1599147668/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20240131 | 等不及了！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/680755913"},{"title":"虚幻周报 20231214 | 又一年圆满落幕","date":"2023-12-14T00:00:00.000Z","path":"wiki/external1451954171/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20231214 | 又一年圆满落幕 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/672198957"},{"title":"虚幻周报 20231122 | 就在下周","date":"2023-11-22T00:00:00.000Z","path":"wiki/external1730042910/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20231122 | 就在下周 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/668177148"},{"title":"虚幻周报 20231115 | 最后两周了","date":"2023-11-15T00:00:00.000Z","path":"wiki/external1654740574/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20231115 | 最后两周了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/666961620"},{"title":"虚幻周报 20231101 | 买票要趁早","date":"2023-11-01T00:00:00.000Z","path":"wiki/external1387224613/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20231101 | 买票要趁早 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/664499469"},{"title":"UE 中利用反射为资产建立属性缓存","date":"2023-10-25T00:00:00.000Z","path":"wiki/external1990173550/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 中利用反射为资产建立属性缓存 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"反射","slug":"工具/资源管理/反射","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%8F%8D%E5%B0%84/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/71162/"},{"title":"UE 中资源自修正的设计与实现方案","date":"2023-10-18T00:00:00.000Z","path":"wiki/external1330219411/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 中资源自修正的设计与实现方案 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/19901/"},{"title":"虚幻周报 20231018 | 许久不见","date":"2023-10-18T00:00:00.000Z","path":"wiki/external1320858002/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20231018 | 许久不见 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/662004358"},{"title":"UE 插件与工具开发：j2 的设计思路与实现","date":"2023-10-14T00:00:00.000Z","path":"wiki/external1455460662/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 插件与工具开发：j2 的设计思路与实现 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/86105/"},{"title":"虚幻周报 20230927 | UFSH 2023 来了！","date":"2023-09-27T00:00:00.000Z","path":"wiki/external1515603348/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230927 | UFSH 2023 来了！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/658709774"},{"title":"虚幻周报 20230913 | 哪里贵了","date":"2023-09-13T00:00:00.000Z","path":"wiki/external1609100988/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230913 | 哪里贵了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/655981141"},{"title":"虚幻周报 20230907 | UE5.3 发布啦！","date":"2023-09-07T00:00:00.000Z","path":"wiki/external1649169223/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230907 | UE5.3 发布啦！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/654839088"},{"title":"虚幻周报 20230823 | 昨晚我真在写代码","date":"2023-08-23T00:00:00.000Z","path":"wiki/external1222542609/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230823 | 昨晚我真在写代码 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/651848449"},{"title":"虚幻周报 20230816 | 要开始了","date":"2023-08-16T00:00:00.000Z","path":"wiki/external1846586087/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230816 | 要开始了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/650365536"},{"title":"虚幻周报 20230809 | 周六苏州见","date":"2023-08-09T00:00:00.000Z","path":"wiki/external1797336171/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230809 | 周六苏州见 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/648931414"},{"title":"虚幻周报 20230802 | 又是一年","date":"2023-08-02T00:00:00.000Z","path":"wiki/external1096810021/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230802 | 又是一年 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/647487470"},{"title":"虚幻周报 20230719 | 好热好热","date":"2023-07-19T00:00:00.000Z","path":"wiki/external1751867492/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230719 | 好热好热 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/644528463"},{"title":"虚幻周报 20230629 | 要放暑假啦","date":"2023-06-29T00:00:00.000Z","path":"wiki/external1149088880/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230629 | 要放暑假啦 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/640380434"},{"title":"虚幻周报 20230621 | 粽子节快乐！","date":"2023-06-21T00:00:00.000Z","path":"wiki/external1655537268/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230621 | 粽子节快乐！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/638655932"},{"title":"虚幻周报 20230614 | 天热了啊","date":"2023-06-14T00:00:00.000Z","path":"wiki/external1099769251/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230614 | 天热了啊 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/636996586"},{"title":"UESlate 源码剖析","date":"2023-06-09T00:00:00.000Z","path":"wiki/external1388167213/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UESlate 源码剖析 。","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"UI","slug":"工具/UI","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UI/"}],"is_external":true,"jump_to":"https://myslate.readthedocs.io/en/latest/"},{"title":"虚幻周报 20230531 | 明天过节","date":"2023-05-31T00:00:00.000Z","path":"wiki/external1672843577/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230531 | 明天过节 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/633601615"},{"title":"虚幻周报 20230524 | 本周日见","date":"2023-05-24T00:00:00.000Z","path":"wiki/external1631247399/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230524 | 本周日见 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/631800013"},{"title":"虚幻周报 20230517 | 下一站北京","date":"2023-05-17T00:00:00.000Z","path":"wiki/external1072820005/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230517 | 下一站北京 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/630027891"},{"title":"虚幻周报 20230511 | 5.2 要来啦","date":"2023-05-11T00:00:00.000Z","path":"wiki/external1755787467/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230511 | 5.2 要来啦 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/628555743"},{"title":"虚幻周报 20230426 | 五一快乐！","date":"2023-04-26T00:00:00.000Z","path":"wiki/external1719895478/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230426 | 五一快乐！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/625066496"},{"title":"DevOps：虚幻引擎的 CI/CD 实践","date":"2023-04-15T00:00:00.000Z","path":"wiki/external1698384926/","text":"本篇文章为外部内容，请点击链接跳转至原站点：DevOps：虚幻引擎的 CI/CD 实践 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"构建系统","slug":"构建系统","permalink":"https://ue5wiki.com/tags/%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DevOps","slug":"DevOps","permalink":"https://ue5wiki.com/tags/DevOps/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"DevOps","slug":"工具/DevOps","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/DevOps/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/96336/"},{"title":"虚幻周报 20230412 | 春天来了","date":"2023-04-12T00:00:00.000Z","path":"wiki/external1544062841/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230412 | 春天来了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/621324922"},{"title":"资源管理：UASSET 资源加密方案","date":"2023-04-06T00:00:00.000Z","path":"wiki/external1842889295/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 资源管理：UASSET 资源加密方案 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/32412/"},{"title":"虚幻周报 20230405 | GDC 视频汉化中","date":"2023-04-05T00:00:00.000Z","path":"wiki/external1690806032/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230405 | GDC 视频汉化中 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/619575655"},{"title":"UE 插件与工具开发：Commandlet","date":"2023-03-23T00:00:00.000Z","path":"wiki/external1562775310/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 插件与工具开发：Commandlet。","tags":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"插件","slug":"插件","permalink":"https://ue5wiki.com/tags/%E6%8F%92%E4%BB%B6/"}],"categories":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/categories/Plugins/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/27475/"},{"title":"虚幻周报 20230315 | 周日厦门见","date":"2023-03-15T00:00:00.000Z","path":"wiki/external1682619011/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230315 | 周日厦门见 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/614222392"},{"title":"资源管理：重塑 UE 的包拆分方案","date":"2023-03-15T00:00:00.000Z","path":"wiki/external1086880409/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 资源管理：重塑 UE 的包拆分方案 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/37036/"},{"title":"虚幻周报 20230308 | 活动搞起来","date":"2023-03-08T00:00:00.000Z","path":"wiki/external1162953820/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230308 | 活动搞起来 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/612288548"},{"title":"虚幻周报 20230302 | 喜欢冰箱应该没错吧？","date":"2023-03-02T00:00:00.000Z","path":"wiki/external1735418196/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230302 | 喜欢冰箱应该没错吧？。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/610704105"},{"title":"虚幻周报 20230215 | 兔年的第一场直播","date":"2023-02-15T00:00:00.000Z","path":"wiki/external1464715932/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230215 | 兔年的第一场直播 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/606498781"},{"title":"虚幻周报 20230209 | 开工大吉！","date":"2023-02-09T00:00:00.000Z","path":"wiki/external1161936286/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230209 | 开工大吉！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/604829273"},{"title":"内存扩展：UE 中利用 IOS 新的内存特性","date":"2023-01-31T00:00:00.000Z","path":"wiki/external1165338292/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 内存扩展：UE 中利用 IOS 新的内存特性 。","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"优化","slug":"优化","permalink":"https://ue5wiki.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"Memory","slug":"Memory","permalink":"https://ue5wiki.com/tags/Memory/"},{"name":"内存","slug":"内存","permalink":"https://ue5wiki.com/tags/%E5%86%85%E5%AD%98/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"},{"name":"Memory","slug":"Optimization/Memory","permalink":"https://ue5wiki.com/categories/Optimization/Memory/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/56381/"},{"title":"UE 插件与工具开发：基础概念","date":"2023-01-29T00:00:00.000Z","path":"wiki/external1631269588/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 插件与工具开发：基础概念 。","tags":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"插件","slug":"插件","permalink":"https://ue5wiki.com/tags/%E6%8F%92%E4%BB%B6/"}],"categories":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/categories/Plugins/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/75405/"},{"title":"虚幻周报 20230119 | Happy New Year to 兔 you！","date":"2023-01-19T00:00:00.000Z","path":"wiki/external1642904561/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230119 | Happy New Year to 兔 you！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/600077412"},{"title":"HotPatcher 的模块化改造和开发规划","date":"2023-01-07T00:00:00.000Z","path":"wiki/external1223050263/","text":"本篇文章为外部内容，请点击链接跳转至原站点：HotPatcher 的模块化改造和开发规划 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/30178/"},{"title":"虚幻周报 20230104 | 新年新气象","date":"2023-01-04T00:00:00.000Z","path":"wiki/external1773660727/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20230104 | 新年新气象 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/596508977"},{"title":"虚幻周报 20221214 | 早晚的事","date":"2022-12-14T00:00:00.000Z","path":"wiki/external1736169713/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221214 | 早晚的事 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/591711145"},{"title":"虚幻周报 20221130 | UOD2022 录播放送中","date":"2022-11-30T00:00:00.000Z","path":"wiki/external1683281074/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221130 | UOD2022 录播放送中 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/588048495"},{"title":"虚幻周报 20221115 | 大的要来了","date":"2022-11-15T00:00:00.000Z","path":"wiki/external1909976704/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221115 | 大的要来了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/583572626"},{"title":"一种灵活与非侵入式的基础包拆分方案","date":"2022-11-10T00:00:00.000Z","path":"wiki/external1074252106/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 一种灵活与非侵入式的基础包拆分方案 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/24350/"},{"title":"虚幻周报 20221026 | 不给 PPT 就捣蛋","date":"2022-11-02T00:00:00.000Z","path":"wiki/external1238589689/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221026 | 不给 PPT 就捣蛋 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/579703531"},{"title":"虚幻周报 20221026 | 啊最后一周","date":"2022-10-26T00:00:00.000Z","path":"wiki/external1113686807/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221026 | 啊最后一周 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/577465104"},{"title":"UE5 VirtualHeightfieldMesh 简述","date":"2022-10-20T00:00:00.000Z","path":"wiki/external1077255389/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE5 VirtualHeightfieldMesh 简述 。","tags":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/tags/Rendering/"},{"name":"Landscape","slug":"Landscape","permalink":"https://ue5wiki.com/tags/Landscape/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"Landscape","slug":"Rendering/Landscape","permalink":"https://ue5wiki.com/categories/Rendering/Landscape/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/575398476"},{"title":"虚幻周报 20221019 | PPT 十天乐","date":"2022-10-19T00:00:00.000Z","path":"wiki/external1129049340/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221019 | PPT 十天乐 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/575114766"},{"title":"Editor 中资源打包和真机加载流程","date":"2022-10-18T12:29:01.000Z","path":"wiki/5b49d53f/","text":"随着游戏内资源越来越多，包体越来越大，但移动端的包大小是有限制的，不能无限度地把所有的资源都打到基础包中，Android 上限是 2G（可以开启 Allow Large Obb files 以支持 4G），IOS 提交到 AppStore 的上限也是 4G，通常会保持 IOS/Android 基础包内的资源统一，其余的资源用热更或动态下载的形式更新到设备上。 所以，实际上在 开发阶段 打进基础包内的资源，只是工程中的一部分。经常无法满足策划、美术、测试同学的验证需要。 新的地图、资源想要在真机查看 包内资源有问题，提交后等待整包构建时间太久 基础包的资源量超标，可能无法添加新的资源 基于这种需求，在开发阶段，可以使用 基础包 + 补丁 的形式实现。 资源的打包 在我们当前的工程中，在编辑器中，可以直接在资源、目录上右键选择Cook And Pak Actions，选择对应的平台，以及选择AnalysisDependencies（分析依赖）。 不同平台的包需要选择的不一样（根据自己项目实际情况选择）： 安卓：Android_ASTC IOS：IOS PCVersion：WindowsNoEditor 执行之后右下角会有执行提示： 需要等待执行完毕，这个过程不会卡住编辑器，可以做其他的编辑操作。 执行的耗时取决于引用的资源量，以及所选择的资源之前有没有执行过打包（DDC）。 执行完毕之后，会在项目的 Saved/HotPatcher/Paks/&#123;EXECUTE_TIME&#125;/Android_ASTC 下面创建出一个对应的 .pak 文件，这个 pak 文件就是打包资源的补丁包，文件名中包含了平台名，不同平台的 pak 文件 不能混用。 放入真机中PCVersionPCVersion 需要将这个 Pak 文件放到以下目录中： 1WindowsNoEditor\\PROJECT_NAME\\Content\\Paks 若不存在 Paks 目录，可手动创建。 Android在 Android 中，需要将这个 pak 文件放到下面目录中： 1UE4Game/PROJECT_NAME/PROJECT_NAME/Saved/Paks 如果修改了数据目录到沙盒路径，则是这个路径： 1Android/data/com.xxxx.yyyy/files/UE4Game/PROJECT_NAME/PROJECT_NAME/Saved/Paks 如果没有 Paks 目录，可以手动创建一个。 IOSIOS 则要复杂一些，需要用 爱思助手 或iMaZing等 IOS 管理工具传递文件。放入 文稿 - PROJECT_NAME - Saved - Paks 下，若不存在 Paks 目录，可手动创建。 检查挂载情况 当将 pak 文件放入上述目录之后，就可以启动游戏了。 如果为了确认 pak 文件是否生效，可以从 Log 中查看： 12LogPakFile: Display: Found Pak file ../../../PROJECT_NAME/Saved/Paks/2022.10.18-13.02.53_IOS_001_P.pak attempting to mount.LogPakFile: Display: Mounting pak file ../../../PROJECT_NAME/Saved/Paks/2022.10.18-13.02.53_IOS_001_P.pak. 有这样的 Log，就代表资源包被引擎读取成功，可以直接使用，就像它被打进了基础包中一样。 注意事项 手动打包 Pak 的优先级高于基础包内的资源，意味着一个资源如果 补丁包 和基础包 中同时 存在，就会 替换 基础包内的，就像热更新逻辑。 不同平台的 pak 不能混用！ 测试完毕之后要把设备上的 pak 文件删除，不然后面新打的包可能会出现资源表现错误。","tags":[{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"虚幻周报 20221012 | UOD2022 开票了","date":"2022-10-12T00:00:00.000Z","path":"wiki/external1454734125/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20221012 | UOD2022 开票了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/572818168"},{"title":"not-uasset 文件过滤规则","date":"2022-10-10T22:32:01.000Z","path":"wiki/61ac95b3/","text":"可以控制 not-uasset 文件进 Pak 的规则。AutomationTool/Scripts/CopyBuildToStagingDirectory.Automation.cs#L1887 Scripts/CopyBuildToStagingDirectory.Automation.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/// &lt;summary&gt;/// Reads Default/BasePakFileRules.ini and returns all PakFileRules objects that apply for this deployment/// &lt;/summary&gt;/// &lt;param name=&quot;Params&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;SC&quot;&gt;&lt;/param&gt;private static List&lt;PakFileRules&gt; GetPakFileRules(ProjectParams Params, DeploymentContext SC)&#123; bool bWarnedAboutMultipleTargets = false; bool bFoundConfig = false; List&lt;ConfigFile&gt; ConfigFiles = new List&lt;ConfigFile&gt;(); FileReference BaseConfigFileReference = FileReference.Combine(SC.EngineRoot, &quot;Config&quot;, &quot;BasePakFileRules.ini&quot;); if (FileReference.Exists(BaseConfigFileReference)) &#123; ConfigFiles.Add(new ConfigFile(BaseConfigFileReference)); bFoundConfig = true; &#125; FileReference ProjectConfigFileReference = FileReference.Combine(SC.ProjectRoot, &quot;Config&quot;, &quot;DefaultPakFileRules.ini&quot;); if (FileReference.Exists(ProjectConfigFileReference)) &#123; ConfigFiles.Add(new ConfigFile(ProjectConfigFileReference)); bFoundConfig = true; &#125; if (!bFoundConfig) &#123; return null; &#125; bool bChunkedBuild = SC.PlatformUsesChunkManifests &amp;&amp; DoesChunkPakManifestExist(Params, SC); ConfigHierarchy PakRulesConfig = new ConfigHierarchy(ConfigFiles); List&lt;PakFileRules&gt; RulesList = new List&lt;PakFileRules&gt;(); foreach (string SectionName in PakRulesConfig.SectionNames) &#123; //LogInformation(&quot;Building PakFileRules for Section &#123;0&#125;&quot;, SectionName); bool bOnlyChunkedBuilds = false; if (!PakRulesConfig.TryGetValue(SectionName, &quot;bOnlyChunkedBuilds&quot;, out bOnlyChunkedBuilds)) &#123; bOnlyChunkedBuilds = false; &#125; bool bOnlyNonChunkedBuilds = false; if (!PakRulesConfig.TryGetValue(SectionName, &quot;bOnlyNonChunkedBuilds&quot;, out bOnlyNonChunkedBuilds)) &#123; bOnlyNonChunkedBuilds = false; &#125; if (bChunkedBuild &amp;&amp; bOnlyNonChunkedBuilds) &#123; continue; &#125; if(!bChunkedBuild &amp;&amp; bOnlyChunkedBuilds) &#123; continue; &#125; string PlatformString; if (PakRulesConfig.TryGetValue(SectionName, &quot;Platforms&quot;, out PlatformString)) &#123; string[] PlatformStrings = PlatformString.Split(new char[] &#123; &#x27;,&#x27;, &#x27; &#x27; &#125;, StringSplitOptions.RemoveEmptyEntries); bool bMatches = false; // Check platform string foreach (string Platform in PlatformStrings) &#123; if (SC.StageTargetPlatform.PlatformType.ToString().Equals(Platform, StringComparison.OrdinalIgnoreCase)) &#123; bMatches = true; break; &#125; else if (SC.StageTargetPlatform.IniPlatformType.ToString().Equals(Platform, StringComparison.OrdinalIgnoreCase)) &#123; bMatches = true; break; &#125; &#125; if (!bMatches) &#123; //LogInformation(&quot;No matching platform for PakFileRules for Section &#123;0&#125; : &#123;1&#125;, &#123;2&#125;&quot;, SectionName, SC.StageTargetPlatform.PlatformType.ToString(), SC.StageTargetPlatform.IniPlatformType.ToString()); continue; &#125; &#125; string TargetString; if (PakRulesConfig.TryGetValue(SectionName, &quot;Targets&quot;, out TargetString)) &#123; string[] TargetStrings = TargetString.Split(new char[] &#123; &#x27;,&#x27;, &#x27; &#x27; &#125;, StringSplitOptions.RemoveEmptyEntries); bool bMatches = false; // Check target string foreach (string Target in TargetStrings) &#123; foreach (UnrealTargetConfiguration C in SC.StageTargetConfigurations) &#123; if (C.ToString() == Target) &#123; bMatches = true; break; &#125; &#125; &#125; if (!bMatches) &#123; continue; &#125; else if (SC.StageTargetConfigurations.Count &gt; 0 &amp;&amp; !bWarnedAboutMultipleTargets) &#123; bWarnedAboutMultipleTargets = true; LogInformation(&quot;Staging with more than one target, PakFileRules may apply too many rules!&quot;); &#125; &#125; PakFileRules PakRules = new PakFileRules(); PakRules.Name = SectionName; PakRulesConfig.TryGetValue(SectionName, &quot;bExcludeFromPaks&quot;, out PakRules.bExcludeFromPaks); PakRulesConfig.TryGetValue(SectionName, &quot;bOverrideChunkManifest&quot;, out PakRules.bOverrideChunkManifest); PakRulesConfig.TryGetValue(SectionName, &quot;bDisabled&quot;, out PakRules.bDisabled); string PakString; PakRulesConfig.TryGetValue(SectionName, &quot;OverridePaks&quot;, out PakString); if (PakString != null &amp;&amp; PakString.Length &gt; 0) &#123; PakRules.OverridePaks = PakString.Split(new char[] &#123; &#x27;,&#x27;, &#x27; &#x27; &#125;, StringSplitOptions.RemoveEmptyEntries).ToList(); &#125; else &#123; PakRules.OverridePaks = null; &#125; if (PakRules.bExcludeFromPaks &amp;&amp; PakRules.OverridePaks != null) &#123; LogWarning(&quot;Error in PakFileRules &#123;0&#125;, set to exclude but also sets override!&quot;, PakRules.Name); continue; &#125; else if (!PakRules.bExcludeFromPaks &amp;&amp; PakRules.OverridePaks == null) &#123; LogWarning(&quot;Error in PakFileRules &#123;0&#125;, set to include but did not specify paks!&quot;, PakRules.Name); continue; &#125; IReadOnlyList&lt;string&gt; FilesEnumberable; if (PakRulesConfig.TryGetValues(SectionName, &quot;Files&quot;, out FilesEnumberable)) &#123; // Only add if we have actual files, we can end up with none due to config overriding PakRules.Filter = new FileFilter(); foreach (string FileFilter in FilesEnumberable) &#123; //LogInformation(&quot;Adding to PakFileRules for Section &#123;0&#125; : &#123;1&#125;&quot;, SectionName, FileFilter); PakRules.Filter.AddRule(FileFilter); &#125; RulesList.Add(PakRules); &#125; &#125; return RulesList;&#125; 配置规则，在项目 Config 下创建一个 DefaultPakFileRules.ini： 1234567891011121314151617181920; These rules are applied in order, the first rule that applies per file is taken and no others are evaluated; [SectionName]; bOverrideChunkManifest=false ; If true this allows overriding assignments from the cooker; bExcludeFromPaks=false ; If true this removes entirely, cannot coexist with overridepaks; OverridePaks=&quot;pakchunk1&quot; ; If set this will override pak list, comma separated; Platforms=&quot;iOS,Android&quot; ; If set this rule will only apply to these platforms; Targets=&quot;Shipping,Test&quot; ; If set this rule will only apply to these configurations; bOnlyChunkedBuilds=true ; If set this rule will only apply to chunked builds; bOnlyNonChunkedBuilds=true ; If set this rule will only apply to non-chunked builds; +Files=&quot;.../*FileMask*.*&quot; ; List of file masks to apply to, using the C# FileFilter class[ExcludeContentForMobile]; Exclude specific large textures on mobile platforms, this was moved from CopyBuildToStagingDirectory.cs; This can be added to in a game&#x27;s DefaultPakFileRules.ini by using the same sections, and new sections can be added; To remove this rule, use !Files to clear the list of file pathsPlatforms=&quot;Android,iOS,tvOS&quot;bExcludeFromPaks=truebOverrideChunkManifest=true+Files=&quot;.../Engine/Content/EngineMaterials/DefaultBloomKernel.*&quot;","tags":[{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"虚幻周报 20220930 | 放假啦","date":"2022-09-30T00:00:00.000Z","path":"wiki/external1554461689/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220930 | 放假啦 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/569667750"},{"title":"虚幻周报 20220922 | 新的忙碌循环","date":"2022-09-22T00:00:00.000Z","path":"wiki/external1781044638/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220922 | 新的忙碌循环 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/567046523"},{"title":"虚幻周报 20220914 | 武汉我来了！","date":"2022-09-14T00:00:00.000Z","path":"wiki/external1721566552/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220914 | 武汉我来了！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/564277018"},{"title":"UE 中 ASTC 贴图压缩分析及效率优化","date":"2022-09-08T00:00:00.000Z","path":"wiki/external1194091674/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 中 ASTC 贴图压缩分析及效率优化 。","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"优化","slug":"优化","permalink":"https://ue5wiki.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"ASTC","slug":"ASTC","permalink":"https://ue5wiki.com/tags/ASTC/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/7181/"},{"title":"虚幻周报 20220907| 下周武汉见！","date":"2022-09-07T00:00:00.000Z","path":"wiki/external1266536179/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220907| 下周武汉见！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/562125164"},{"title":"虚幻周报 20220831| 神兽归笼","date":"2022-08-31T00:00:00.000Z","path":"wiki/external1021399063/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220831| 神兽归笼 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/559791051"},{"title":"UE 中多阶段的自动化资源检查方案","date":"2022-08-23T00:00:00.000Z","path":"wiki/external1172896530/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 中多阶段的自动化资源检查方案 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源审计","slug":"工具/资源审计","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/22655/"},{"title":"虚幻周报 20220817| 秋天第一个项目","date":"2022-08-17T00:00:00.000Z","path":"wiki/external1757811612/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220817| 秋天第一个项目 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/554726309"},{"title":"虚幻周报 20220810| 高温预警","date":"2022-08-10T00:00:00.000Z","path":"wiki/external1489254303/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220810| 高温预警 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/552068064"},{"title":"虚幻周报 20220825| 虚幻嘉年华见！","date":"2022-08-03T00:00:00.000Z","path":"wiki/external1964104163/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220825| 虚幻嘉年华见！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/557668437"},{"title":"虚幻周报 20220803| 下周开工！","date":"2022-08-03T00:00:00.000Z","path":"wiki/external1939418642/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220803| 下周开工！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/549365849"},{"title":"Log Timestamp","date":"2022-07-29T09:41:01.000Z","path":"wiki/85196df3/","text":"引擎默认的 Log 时间是 UTC，与国内的有差别，可以修改配置实现： BaseEngine.ini1234[LogFiles]PurgeLogsDays=5MaxLogFilesOnDisk=10LogTimes=True 通过控制 LogTimes 项的值可以设置不同的时区，可选项为None/UTC/SinceStart/Local/Timecode/(Ture/Flase(UTC))： Launch/Private/LaunchEngineLoop.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static void CheckForPrintTimesOverride()&#123; // Determine whether to override the default setting for including timestamps in the log. FString LogTimes; if (GConfig-&gt;GetString(TEXT(&quot;LogFiles&quot; ), TEXT(&quot;LogTimes&quot; ), LogTimes, GEngineIni )) &#123; if (LogTimes == TEXT(&quot;None&quot; )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::None, ECVF_SetBySystemSettingsIni); &#125; else if (LogTimes == TEXT(&quot;UTC&quot; )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::UTC, ECVF_SetBySystemSettingsIni); &#125; else if (LogTimes == TEXT(&quot;SinceStart&quot; )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::SinceGStartTime, ECVF_SetBySystemSettingsIni); &#125; else if (LogTimes == TEXT(&quot;Local&quot; )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::Local, ECVF_SetBySystemSettingsIni); &#125; else if (LogTimes == TEXT(&quot;Timecode&quot; )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::Timecode, ECVF_SetBySystemSettingsIni); &#125; // Assume this is a bool for backward compatibility else if (FCString::ToBool(*LogTimes)) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::UTC, ECVF_SetBySystemSettingsIni); &#125; &#125; if (FParse::Param(FCommandLine::Get(), TEXT(&quot;LOGTIMES&quot; ) )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::UTC, ECVF_SetByCommandline); &#125; else if (FParse::Param(FCommandLine::Get(), TEXT(&quot;UTCLOGTIMES&quot; ) )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::UTC, ECVF_SetByCommandline); &#125; else if (FParse::Param(FCommandLine::Get(), TEXT(&quot;NOLOGTIMES&quot; ) )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::None, ECVF_SetByCommandline); &#125; else if (FParse::Param(FCommandLine::Get(), TEXT(&quot;LOGTIMESINCESTART&quot; ) )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::SinceGStartTime, ECVF_SetByCommandline); &#125; else if (FParse::Param(FCommandLine::Get(), TEXT(&quot;LOCALLOGTIMES&quot; ) )) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::Local, ECVF_SetByCommandline); &#125; else if (FParse::Param(FCommandLine::Get(), TEXT(&quot;LOGTIMECODE&quot; ))) &#123; CVarLogTimestamp-&gt;Set((int)ELogTimes::Timecode, ECVF_SetByCommandline); &#125;&#125;","tags":[{"name":"Logging","slug":"Logging","permalink":"https://ue5wiki.com/tags/Logging/"},{"name":"Log Timestamp","slug":"Log-Timestamp","permalink":"https://ue5wiki.com/tags/Log-Timestamp/"}],"categories":[{"name":"Logging","slug":"Logging","permalink":"https://ue5wiki.com/categories/Logging/"}]},{"title":"虚幻周报 20220721| 下一站何处","date":"2022-07-21T00:00:00.000Z","path":"wiki/external1408947904/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220721| 下一站何处 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/544379818"},{"title":"UE 编译时 PCH 虚拟内存不足的错误","date":"2022-07-20T15:42:01.000Z","path":"wiki/5cc4f8a/","text":"在多核心 CPU 上编译 UE 时，如 Ryzen 线程撕裂者（64 核 128 线程），比较频繁的遇到以下错误： 123456789101112c1xx: note: 请访问 https://aka.ms/pch-help 了解更多详情c1xx: fatal error C1076: 编译器限制: 达到内部堆限制[12/1456] Module.Renderer.17_of_18.cppc1xx: error C3859: 未能创建 PCH 的虚拟内存c1xx: note: 系统返回代码 1455: 页面文件太小，无法完成操作。// english log2&gt; c1xx: note: please visit https://aka.ms/pch-help for more details2&gt;c1xx: Error C1076 : compiler limit: internal heap limit reached2&gt; [353/3017] Module.AdvancedPreviewScene.cpp2&gt; [354/3017] Module.PlacementMode.cpp2&gt;c1xx: Error C3859 : Failed to create virtual memory for PCH2&gt; c1xx: note: the system returned code 1455: The paging file is too small for this operation to complete. 默认情况下，UE 会拉起系统最大线程数量的编译进程。 如我的机器就是 128 个： UE 里每个编译任务的 /zm 值为 1000：VCToolChain.cs?q=%2Fzm#L354 表示每个 cl 进程会分配 750M 的虚拟内存：/Zm (Specify precompiled header memory allocation limit) Value of factor Memory allocation limit 10 7.5 MB 100 75 MB 200 150 MB 1000 750 MB 2000 1500 MB 而系统的虚拟内存大小是有上限的： 如果进程数 * 每个进程的 /zm 大于系统的虚拟内存，会导致虚拟内存分配失败： $TaskCount * PCHMemoryAllocationFactor &gt; SystemVirtualMemery$ 也就出现了前面的问题。 解决这个问题的办法有两个： 根据线程数 *750M 来设置系统的虚拟内存大小 限制并行的任务数量，避免大量的进程同时分配虚拟内存 注意：如果 /zm 值设置的太小，可能无法满足 UE 合并翻译单元的要求，导致编译错误，所以，最好还是修改系统虚拟内存大小或者控制并行的任务数量。 通过编辑 BuildConfiguration.xml 就可以控制编译进程的 /zm 值，以及能够使用多少个 Task： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt; &lt;WindowsPlatform&gt; &lt;PCHMemoryAllocationFactor&gt;1000&lt;/PCHMemoryAllocationFactor&gt; &lt;/WindowsPlatform&gt; &lt;LocalExecutor&gt; &lt;MaxProcessorCount&gt;60&lt;/MaxProcessorCount&gt; &lt;/LocalExecutor&gt; &lt;ParallelExecutor&gt; &lt;MaxProcessorCount&gt;60&lt;/MaxProcessorCount&gt; &lt;/ParallelExecutor&gt;&lt;/Configuration&gt; 按照 128*750M 的计算，在 Ryzen3990X 上，至少要设置 94G 的虚拟内存，才能够满足 UE 拉起 128 个进程编译的需要。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"PCH","slug":"PCH","permalink":"https://ue5wiki.com/tags/PCH/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"一种高效的 ZSTD Shader 字典训练方案","date":"2022-07-14T00:00:00.000Z","path":"wiki/external1946577463/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 一种高效的 ZSTD Shader 字典训练方案 。","tags":[{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"},{"name":"包体优化","slug":"包体优化","permalink":"https://ue5wiki.com/tags/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"},{"name":"Shader","slug":"Shader","permalink":"https://ue5wiki.com/tags/Shader/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/26943/"},{"title":"虚幻周报 20220713| 周日广州见！","date":"2022-07-13T00:00:00.000Z","path":"wiki/external1813860941/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220713| 周日广州见！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/541067431"},{"title":"VS 真机调试 Android","date":"2022-07-06T16:08:01.000Z","path":"wiki/6b9bc0ab/","text":"对于 UE 项目而言，绝大部分情况下，不需要关心 Apk 的构建流程，虽然 UE 在打包时会生成一个 Android Studio 的工程，但基本对于开发层而言是隔离的，UE 的构建工具会自动处理。 调试也是一样，在 UE 项目开发中，Coding 在 VS 或 Rider 等 游戏开发环境 中进行，直接在 VS 中进行调试也是最合适的，再去打开 Android Studio，一是工具的臃肿，二是额外的 IDE 熟悉成本。 好在，谷歌推出了 AGDE 扩展工具（Android Game Development Extension for Visual Studio），可以直接在 VS 中调试 Android 项目，而不用使用 Android Studio。 首先，就是要下载 AGDE 并安装。它支持 VS2017-2022（但 UE 的文档里建议使用 VS2019）。 Android 环境AGDE 对于 JDK 的要求是 JDK11+，太老的版本打开时会提示不支持。新版本的 JDK 可以从 Oracle 网站上下载：Java Downloads 在系统中，添加以下环境变量： 123456setx JAVA_HOME &quot;%current_dir_name%\\jdk-18.0.1.1&quot;setx ANDROID_HOME &quot;%current_dir_name%\\android-sdk-windows&quot;setx ANDROID_SDK_ROOT &quot;%current_dir_name%\\android-sdk-windows&quot;setx ANDROID_NDK_ROOT &quot;%current_dir_name%\\%ndk_version%&quot;setx ANT_HOME &quot;%current_dir_name%\\apache-ant-1.8.2&quot;setx GRADLE_HOME &quot;%current_dir_name%\\%grade_version%&quot; 路径可根据实际情况修改，我在 UE 开发笔记：Android 篇 文章中提供了一份完整的 Andoird 环境，只需要更新 JDK 版本即可开箱即用。 安装的 ADGE 会读取环境变量中的配置，无需再在 VS 中配置 JDK/NDK/SDK 的路径。 UE 侧的要求 调试环境包在 Project Settings-Package 中取消勾选For Distribution： 根据需要，打包为 Development 或Debug/DebugGame即可。 VS在 VS 解决方案的 Games 下，添加打包出的 APK： 会出现一个 PROJECT_NAME-armv7 等命名的项： 将其设置为启动项目： 即可在 VS 中看到设备： 之后就可以像在 Win 上调试编辑器一样了，F5 即可安装到设备上。 设备上运行的会进程会等待调试器附加： 附加之后就能正确地在 VS 中进行断点了。","tags":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/tags/Debugging/"},{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://ue5wiki.com/tags/Visual-Studio/"},{"name":"VS","slug":"VS","permalink":"https://ue5wiki.com/tags/VS/"},{"name":"调试","slug":"调试","permalink":"https://ue5wiki.com/tags/%E8%B0%83%E8%AF%95/"}],"categories":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/categories/Debugging/"},{"name":"Android","slug":"Debugging/Android","permalink":"https://ue5wiki.com/categories/Debugging/Android/"}]},{"title":"虚幻周报 20220706| 周六杭州见！","date":"2022-07-06T00:00:00.000Z","path":"wiki/external1934642032/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220706| 周六杭州见！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/538004938"},{"title":"虚幻周报 20220629| 杭州我来了！","date":"2022-06-29T00:00:00.000Z","path":"wiki/external1230348720/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220629| 杭州我来了！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/535320610"},{"title":"虚幻周报 20220622| 终于要动身了","date":"2022-06-22T00:00:00.000Z","path":"wiki/external1904921416/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220622| 终于要动身了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/532231206"},{"title":"虚幻周报 20220615|MetaHuman 觉醒","date":"2022-06-15T00:00:00.000Z","path":"wiki/external1752863627/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220615|MetaHuman 觉醒 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/529099320"},{"title":"使用 SequenceRecorder 无法录制面部 MorphTarget 问题的解决方法","date":"2022-06-09T00:00:00.000Z","path":"wiki/external1320739314/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 使用 SequenceRecorder 无法录制面部 MorphTarget 问题的解决方法 。","tags":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/tags/Animation/"},{"name":"MorphTarget","slug":"MorphTarget","permalink":"https://ue5wiki.com/tags/MorphTarget/"}],"categories":[{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/categories/Animation/"}],"is_external":true,"jump_to":"https://www.cnblogs.com/yejianying/p/record_morph_target_with_ue4_sequence_recorder.html"},{"title":"虚幻周报 20220608| 想要上班","date":"2022-06-08T00:00:00.000Z","path":"wiki/external1823497232/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220608| 想要上班 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/525894036"},{"title":"虚幻周报 20220601| 儿童节解封快乐！","date":"2022-06-01T00:00:00.000Z","path":"wiki/external1958299445/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220601| 儿童节解封快乐！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/523005911"},{"title":"虚幻周报 20220525| 应该是快了吧","date":"2022-05-25T00:00:00.000Z","path":"wiki/external1983017198/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220525| 应该是快了吧 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/519675285"},{"title":"虚幻引擎中 Pak 的运行时重组方案","date":"2022-05-23T00:00:00.000Z","path":"wiki/external1240235779/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻引擎中 Pak 的运行时重组方案 。","tags":[{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/12188/"},{"title":"虚幻周报 20220518| 随缘了","date":"2022-05-18T00:00:00.000Z","path":"wiki/external1128139694/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220518| 随缘了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/516220151"},{"title":"虚幻周报 20220511|memset(0)","date":"2022-05-11T00:00:00.000Z","path":"wiki/external1304759815/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220511|memset(0)。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/512701706"},{"title":"UE4 Chaos 基础使用及物理说明","date":"2022-04-28T00:00:00.000Z","path":"wiki/external1989449313/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 Chaos 基础使用及物理说明 。","tags":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"Chaos","permalink":"https://ue5wiki.com/tags/Chaos/"}],"categories":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"物理系统/Chaos","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/Chaos/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/506607859"},{"title":"虚幻周报 20220427| 五一想上班","date":"2022-04-27T00:00:00.000Z","path":"wiki/external1769271662/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220427| 五一想上班 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/505959032"},{"title":"虚幻周报 20220420| 有一就有二再有三","date":"2022-04-20T00:00:00.000Z","path":"wiki/external1770303570/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220420| 有一就有二再有三 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/501783535"},{"title":"基于 ZSTD 字典的 Shader 压缩方案","date":"2022-04-17T00:00:00.000Z","path":"wiki/external1376930294/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 基于 ZSTD 字典的 Shader 压缩方案 。","tags":[{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"},{"name":"包体优化","slug":"包体优化","permalink":"https://ue5wiki.com/tags/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"},{"name":"Shader","slug":"Shader","permalink":"https://ue5wiki.com/tags/Shader/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/24725/"},{"title":"虚幻周报 20220413|55555","date":"2022-04-13T00:00:00.000Z","path":"wiki/external1897115307/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220413|55555。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/497767596"},{"title":"虚幻周报 20220330| 前有珍贵的菜","date":"2022-03-30T00:00:00.000Z","path":"wiki/external1528124898/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220330| 前有珍贵的菜 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/490166688"},{"title":"虚幻周报 20220323| 世事无常珍惜当下","date":"2022-03-23T00:00:00.000Z","path":"wiki/external1492416133/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220323| 世事无常珍惜当下 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/486145269"},{"title":"虚幻周报 20220316| 大家保重！","date":"2022-03-16T00:00:00.000Z","path":"wiki/external1088777453/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220316| 大家保重！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/481866611"},{"title":"虚幻周报 20220309| 搞点活动吧","date":"2022-03-09T00:00:00.000Z","path":"wiki/external1853014985/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220309| 搞点活动吧 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/478104567"},{"title":"虚幻周报 20220302| 受苦很快乐","date":"2022-03-02T00:00:00.000Z","path":"wiki/external1821049606/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220302| 受苦很快乐 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/474661397"},{"title":"虚幻周报 20220223|UE5 预览版发布！","date":"2022-02-23T00:00:00.000Z","path":"wiki/external1052449895/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220223|UE5 预览版发布！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/471250861"},{"title":"虚幻周报 20220217| 先睹为快","date":"2022-02-17T00:00:00.000Z","path":"wiki/external1964078621/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220217| 先睹为快 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/468554791"},{"title":"虚幻周报 20220126| 还有几天！","date":"2022-01-26T00:00:00.000Z","path":"wiki/external1523936753/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220126| 还有几天！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/462004139"},{"title":"虚幻周报 20220119| 还有两周！","date":"2022-01-19T00:00:00.000Z","path":"wiki/external1400692830/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220119| 还有两周！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/459363704"},{"title":"虚幻周报 20220112|UOD2021 录播视频放送中！","date":"2022-01-12T00:00:00.000Z","path":"wiki/external1890155749/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220112|UOD2021 录播视频放送中！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/456290322"},{"title":"UE4Editor 对比蓝图","date":"2022-01-05T00:00:00.000Z","path":"wiki/external1312829900/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4Editor 对比蓝图 。","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"蓝图","slug":"蓝图","permalink":"https://ue5wiki.com/tags/%E8%93%9D%E5%9B%BE/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/453730729"},{"title":"虚幻周报 20220105| 开工啦！","date":"2022-01-05T00:00:00.000Z","path":"wiki/external1217791788/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20220105| 开工啦！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/453378749"},{"title":"高效调试：命令行参数启动 UE Android App","date":"2022-01-01T00:00:00.000Z","path":"wiki/external1556224286/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 高效调试：命令行参数启动 UE Android App。","tags":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/tags/Debugging/"},{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/29169/"},{"title":"UE 资源管理：引擎打包资源分析","date":"2021-12-31T00:00:00.000Z","path":"wiki/external1555331411/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 资源管理：引擎打包资源分析 。","tags":[{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/22570/"},{"title":"虚幻周报 20211229| 元蛋快乐！","date":"2021-12-29T00:00:00.000Z","path":"wiki/external1751555888/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211229| 元蛋快乐！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/450945001"},{"title":"虚幻周报 20211222| 圣蛋快乐哦~","date":"2021-12-22T00:00:00.000Z","path":"wiki/external1925260487/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211222| 圣蛋快乐哦~。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/448312989"},{"title":"虚幻周报 20211215| 照顾好自己","date":"2021-12-15T00:00:00.000Z","path":"wiki/external1392636298/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211215| 照顾好自己 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/445611048"},{"title":"定义外部可用的全局符号","date":"2021-12-14T12:13:01.000Z","path":"wiki/aef7be29/","text":"有时候，在插件或者其他的模块中，想要定义一个全局对象，供内部或者外部的模块访问，就像 UE 内置的 GEngine/GConfig 这些。 首先需要把 C++ 中 声明 和定义 的概念区分开，我之前有篇文章介绍：C++ 中 declaration 与 define 的区别。 因为我们想要访问的 全局对象，应该只有一个实例，而不是每个使用模块都包含了一个定义的实例，所以只应该在有一个定义，其他模块引用时只是一个声明，声明它在外部模块中定义，应该去其他模块中访问该实例。 以 Windows 为例，UE 的模块，会编译成 DLL，如果我们想要访问某个模块的符号，就是要访问它的 DLL 中的符号。在 UE 中，导出符号使用 XXXX_API 封装，同样在之前的笔记中有记录： MODULE_NAME_API 模块的宏定义 以 A、B 两个模块为例：A_API在 A 模块中被定义为 DLLEXPORT，在 B 模块中被定义为DLLIMPORT，所以，A 中使用A_API 定义一个符号，会控制它编译出的 A.dll 中该符号导出，在外部模块 B 中使用该符号时，就是导入。 理解起来或许有点绕，以代码来理解： 1234567// A.hextern A_API int32* GTestPtr; // declare a external pointer symbal// extern DLLEXPORT int32* GTestPtr = nullptr;// A.cppA_API int32* GTestPtr = nullptr; // define the global symbal// DLLEXPORT int32* GTestPtr = nullptr; 在 B 中访问它： 1234// B.cpp#include &quot;A.h&quot;if(GTestPtr)&#123;&#125; 在 B 中包含 A.h，在 B 中，A.h 中的 extern A_API int32* GTestPtr; 就变成了以下代码： 1extern DLLIMPORT int32* GTestPtr; 在编译 B 模块时，DLLIMPORT会指导链接器 (linker) 去外部的模块查找该符号，从而实现在 B 中访问 A 中定义的全局对象。 错误用法 1： 1234// A.hint32* GTestPtr;// A.cppint* GTestPtr = NULL; 如果在 A 中这么声明，在 B 中访问 GTestPtr 则会有符号未定义的链接错误。 错误用法 2： 12// A.hstatic int32* GTestPtr; 则每个包含 A.h 的翻译单元都包含了一个 GTestPtr 的符号实例，并不是全局唯一的。","tags":[{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"},{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/tags/Programming/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"}]},{"title":"UnrealPak 的加密参数","date":"2021-12-13T12:45:01.000Z","path":"wiki/8d44a949/","text":"UnrealPak 支持的命令行参数： 123456789101112131415161718192021222324252627282930LogPakFile: Display: Using command line for crypto configurationLogPakFile: Error: No pak file name specified. Usage:LogPakFile: Error: UnrealPak &lt;PakFilename&gt; -TestLogPakFile: Error: UnrealPak &lt;PakFilename&gt; -List [-ExcludeDeleted]LogPakFile: Error: UnrealPak &lt;PakFilename&gt; &lt;GameUProjectName&gt; &lt;GameFolderName&gt; -ExportDependencies=&lt;OutputFileBase&gt; -NoAssetRegistryCache -ForceDependsGatheringLogPakFile: Error: UnrealPak &lt;PakFilename&gt; -Extract &lt;ExtractDir&gt; [-Filter=&lt;filename&gt;]LogPakFile: Error: UnrealPak &lt;PakFilename&gt; -Create=&lt;ResponseFile&gt; [Options]LogPakFile: Error: UnrealPak &lt;PakFilename&gt; -Dest=&lt;MountPoint&gt;LogPakFile: Error: UnrealPak &lt;PakFilename&gt; -Repack [-Output=Path] [-ExcludeDeleted] [Options]LogPakFile: Error: UnrealPak &lt;PakFilename1&gt; &lt;PakFilename2&gt; -diffLogPakFile: Error: UnrealPak &lt;PakFolder&gt; -AuditFiles [-OnlyDeleted] [-CSV=&lt;filename&gt;] [-order=&lt;OrderingFile&gt;] [-SortByOrdering]LogPakFile: Error: UnrealPak &lt;PakFilename&gt; -WhatsAtOffset [offset1] [offset2] [offset3] [...]LogPakFile: Error: UnrealPak &lt;PakFolder&gt; -GeneratePIXMappingFile -OutputPath=&lt;Path&gt;LogPakFile: Error: Options:LogPakFile: Error: -blocksize=&lt;BlockSize&gt;LogPakFile: Error: -bitwindow=&lt;BitWindow&gt;LogPakFile: Error: -compressLogPakFile: Error: -encryptLogPakFile: Error: -order=&lt;OrderingFile&gt;LogPakFile: Error: -diff (requires 2 filenames first)LogPakFile: Error: -enginedir (specify engine dir for when using ini encryption configs)LogPakFile: Error: -projectdir (specify project dir for when using ini encryption configs)LogPakFile: Error: -encryptionini (specify ini base name to gather encryption settings from)LogPakFile: Error: -extracttomountpoint (Extract to mount point path of pak file)LogPakFile: Error: -encryptindex (encrypt the pak file index, making it unusable in unrealpak without supplying the key)LogPakFile: Error: -compressionformat[s]=&lt;Format[,format2,...]&gt; (set the format(s) to compress with, falling back on failures)LogPakFile: Error: -encryptionkeyoverrideguid (override the encryption key guid used for encrypting data in this pak file)LogPakFile: Error: -sign (generate a signature (.sig) file alongside the pak)LogPakFile: Error: -fallbackOrderForNonUassetFiles (if order is not specified for ubulk/uexp files, figure out implicit order based on the uasset order. Generally applies only to the cooker order)LogPakFile: Display: Unreal pak executed in 0.006367 seconds 关于包的加密，在 Project Settings-Crypto 中有四个选项： bEnablePakIndexEncryption: 加密 Pakindex bEnablePakIniEncryption：加密 pak 中的 ini bEnablePakUAssetEncryption：加密 pak 中的 uasset bEnablePakFullAssetEncryption：加密 Pak 中所有的文件 但是除了 bEnablePakIndexEncryption 之外，其他的参数并不是传递给 UnrealPak 的命令行参数，而是生成的 Paklist 中每个文件的参数： CopyBuildToStagingDirectory.Automation.cs#L154 对 paklist 中的对应格式文件添加 -encrypt 参数。 12345&quot;C:\\Users\\lipengzha\\Documents\\UnrealProjects\\Blank425\\Saved\\Cooked\\WindowsNoEditor\\Engine\\Content\\EngineResources\\GradientTexture0.uasset&quot; &quot;../../../Engine/Content/EngineResources/GradientTexture0.uasset&quot; -encrypt&quot;C:\\Users\\lipengzha\\Documents\\UnrealProjects\\Blank425\\Saved\\Cooked\\WindowsNoEditor\\Engine\\Content\\EngineResources\\GradientTexture0.uexp&quot; &quot;../../../Engine/Content/EngineResources/GradientTexture0.uexp&quot; -encrypt&quot;C:\\Users\\lipengzha\\Documents\\UnrealProjects\\Blank425\\Saved\\Temp\\Win64\\Engine\\Config\\Base.ini&quot; &quot;../../../Engine/Config/Base.ini&quot; -encrypt&quot;C:\\Users\\lipengzha\\Documents\\UnrealProjects\\Blank425\\Saved\\Temp\\Win64\\Engine\\Config\\BaseCompat.ini&quot; &quot;../../../Engine/Config/BaseCompat.ini&quot; -encrypt&quot;C:\\Users\\lipengzha\\Documents\\UnrealProjects\\Blank425\\Intermediate\\Staging\\Blank425.upluginmanifest&quot; &quot;../../../Blank425/Plugins/Blank425.upluginmanifest&quot; -encrypt 当开启了 bEnablePakIniEncryption，就会对当前 Paklist 中的 ini 文件添加-encrypt 参数。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"UnrealPak","slug":"UnrealPak","permalink":"https://ue5wiki.com/tags/UnrealPak/"},{"name":"加密","slug":"加密","permalink":"https://ue5wiki.com/tags/%E5%8A%A0%E5%AF%86/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"UnrealPak","slug":"工具/UnrealPak","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UnrealPak/"}]},{"title":"虚幻周报 20211208| 该醒醒了！","date":"2021-12-08T00:00:00.000Z","path":"wiki/external1555099185/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211208| 该醒醒了！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/442703964"},{"title":"虚幻周报 20211201|UOD2021 就在明天！","date":"2021-12-01T00:00:00.000Z","path":"wiki/external1731865802/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211201|UOD2021 就在明天！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/439915018"},{"title":"UE5：Game Feature 预研","date":"2021-11-17T00:00:00.000Z","path":"wiki/external1985524568/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE5：Game Feature 预研 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/tags/UE5/"},{"name":"Modular Gameplay","slug":"Modular-Gameplay","permalink":"https://ue5wiki.com/tags/Modular-Gameplay/"},{"name":"Game Feature","slug":"Game-Feature","permalink":"https://ue5wiki.com/tags/Game-Feature/"}],"categories":[{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/categories/UE5/"},{"name":"Game Feature","slug":"UE5/Game-Feature","permalink":"https://ue5wiki.com/categories/UE5/Game-Feature/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/17658/"},{"title":"虚幻周报 20211117| 好事多磨","date":"2021-11-17T00:00:00.000Z","path":"wiki/external1768125355/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211117| 好事多磨 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/434307199"},{"title":"开源一个虚幻引擎启动器 UE Launcher","date":"2021-11-10T00:00:00.000Z","path":"wiki/external1574333573/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 开源一个虚幻引擎启动器 UE Launcher。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Launcher","slug":"Launcher","permalink":"https://ue5wiki.com/tags/Launcher/"},{"name":"UELauncher","slug":"UELauncher","permalink":"https://ue5wiki.com/tags/UELauncher/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"UELauncher","slug":"工具/UELauncher","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UELauncher/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/3635/"},{"title":"虚幻周报 20211110| 万事开头难然后更难最后最难","date":"2021-11-10T00:00:00.000Z","path":"wiki/external1632081076/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211110| 万事开头难然后更难最后最难 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/431616269"},{"title":"虚幻周报 20211103| 不给 PPT 就捣蛋！","date":"2021-11-03T00:00:00.000Z","path":"wiki/external1558001029/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211103| 不给 PPT 就捣蛋！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/428861891"},{"title":"虚幻周报 20211028|UOD2021 演讲开始公布了","date":"2021-10-28T00:00:00.000Z","path":"wiki/external1618671308/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211028|UOD2021 演讲开始公布了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/426709740"},{"title":"Details Panel Customization in Unrea lEngine","date":"2021-10-25T00:00:00.000Z","path":"wiki/external1356736046/","text":"本篇文章为外部内容，请点击链接跳转至原站点：Details Panel Customization in Unrea lEngine。","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"Slate","slug":"Slate","permalink":"https://ue5wiki.com/tags/Slate/"},{"name":"Details","slug":"Details","permalink":"https://ue5wiki.com/tags/Details/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"},{"name":"Slate","slug":"Editor/Slate","permalink":"https://ue5wiki.com/categories/Editor/Slate/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/26919/"},{"title":"基于 ResScannerUE 的资源检查自动化实践","date":"2021-10-25T00:00:00.000Z","path":"wiki/external1535948165/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 基于 ResScannerUE 的资源检查自动化实践 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"},{"name":"ResScannerUE","slug":"ResScannerUE","permalink":"https://ue5wiki.com/tags/ResScannerUE/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源审计","slug":"工具/资源审计","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/20376/"},{"title":"虚幻周报 20211020|UOD2021 倒计时 1 个月","date":"2021-10-20T00:00:00.000Z","path":"wiki/external1566249995/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211020|UOD2021 倒计时 1 个月 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/423652760"},{"title":"UE 热更新：Config 的重载与应用","date":"2021-10-18T00:00:00.000Z","path":"wiki/external1703454788/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 热更新：Config 的重载与应用 。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/9028/"},{"title":"虚幻周报 20211013| 来成为蓝图大师吧！","date":"2021-10-13T00:00:00.000Z","path":"wiki/external1039860269/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20211013| 来成为蓝图大师吧！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/420985158"},{"title":"UE4 技术总结——委托","date":"2021-10-08T00:00:00.000Z","path":"wiki/external1670089210/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 技术总结——委托 。","tags":[{"name":"Delegate","slug":"Delegate","permalink":"https://ue5wiki.com/tags/Delegate/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}],"is_external":true,"jump_to":"https://www.cnblogs.com/yejianying/p/ue4_note_delegate.html"},{"title":"UE4 材质系统源码剖析","date":"2021-10-04T00:00:00.000Z","path":"wiki/external1815422399/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 材质系统源码剖析 。","tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/tags/Rendering/"},{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Material","slug":"Material","permalink":"https://ue5wiki.com/tags/Material/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"Material","slug":"Rendering/Material","permalink":"https://ue5wiki.com/categories/Rendering/Material/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/"},{"title":"虚幻周报 20210929|UOD2021 售票中！","date":"2021-09-29T00:00:00.000Z","path":"wiki/external1901544225/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210929|UOD2021 售票中！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/415311929"},{"title":"UE 资源合规检查工具 ResScannerUE","date":"2021-09-15T00:00:00.000Z","path":"wiki/external1704811846/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 资源合规检查工具 ResScannerUE。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"},{"name":"ResScannerUE","slug":"ResScannerUE","permalink":"https://ue5wiki.com/tags/ResScannerUE/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源审计","slug":"工具/资源审计","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/11750/"},{"title":"虚幻周报 20210915|UnrealCircle 北京站！","date":"2021-09-15T00:00:00.000Z","path":"wiki/external1584119025/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210915|UnrealCircle 北京站！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/410593946"},{"title":"UE 热更新：Shader 更新策略","date":"2021-09-13T00:00:00.000Z","path":"wiki/external1895410931/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 热更新：Shader 更新策略 。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/15810/"},{"title":"虚幻周报 20210908| 活动搞起来！","date":"2021-09-08T00:00:00.000Z","path":"wiki/external1066075067/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210908| 活动搞起来！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/408172902"},{"title":"UE 热更新：资源的二进制补丁方案","date":"2021-09-06T00:00:00.000Z","path":"wiki/external1501139690/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 热更新：资源的二进制补丁方案 。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"包体优化","slug":"包体优化","permalink":"https://ue5wiki.com/tags/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/25136/"},{"title":"虚幻周报 20210831| 本周继续直播","date":"2021-08-31T00:00:00.000Z","path":"wiki/external1690991244/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210831| 本周继续直播 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/405359156"},{"title":"UEAsLib 机制初探","date":"2021-08-24T00:00:00.000Z","path":"wiki/external1305107197/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UEAsLib 机制初探 。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"UEAsLib","slug":"UEAsLib","permalink":"https://ue5wiki.com/tags/UEAsLib/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/26475/"},{"title":"Profiling IOS With UnrealInsight","date":"2021-08-19T00:00:00.000Z","path":"wiki/external1605321656/","text":"本篇文章为外部内容，请点击链接跳转至原站点：Profiling IOS With UnrealInsight。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/14154/"},{"title":"虚幻周报 20210811|SIGGRAPH 好多干货","date":"2021-08-11T00:00:00.000Z","path":"wiki/external1070219978/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210811|SIGGRAPH 好多干货 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/398622312"},{"title":"UE 多用户协同编辑服务部署指南","date":"2021-08-05T00:00:00.000Z","path":"wiki/external1300081523/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE 多用户协同编辑服务部署指南 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}],"is_external":true,"jump_to":"https://imzlp.com/posts/25226/"},{"title":"虚幻周报 20210728| 虚幻嘉年华见吧！","date":"2021-07-28T00:00:00.000Z","path":"wiki/external1139461986/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210728| 虚幻嘉年华见吧！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/393910783"},{"title":"虚幻周报 20210825| 要有光！","date":"2021-07-25T00:00:00.000Z","path":"wiki/external1985729462/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210825| 要有光！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/403373161"},{"title":"UE4 中的 Subsystem","date":"2021-07-19T00:00:00.000Z","path":"wiki/external1291031363/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 中的 Subsystem。","tags":[{"name":"Subsystem","slug":"Subsystem","permalink":"https://ue5wiki.com/tags/Subsystem/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}],"is_external":true,"jump_to":"https://www.cnblogs.com/yejianying/p/15029111.html"},{"title":"给特定类型资源添加右键菜单选项","date":"2021-07-15T22:32:01.000Z","path":"wiki/a70352ea/","text":"有些需求，需要在 UE 的 Content Browser 里给某些资源添加一些处理功能，希望能直接选中右键进行处理。UE 中提供了这样的方式，用于扩展某种类型资源的右键菜单，需要继承自FAssetTypeActions_Base： .h12345678910111213141516171819202122232425#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Engine/StaticMesh.h&quot;#include &quot;Toolkits/IToolkitHost.h&quot;#include &quot;AssetTypeActions_Base.h&quot;#include &quot;Engine/PrimaryAssetLabel.h&quot;struct FToolMenuSection;class FMenuBuilder;class FAssetTypeActions_PrimaryAssetLabel : public FAssetTypeActions_Base&#123;public: // IAssetTypeActions Implementation virtual FText GetName() const override &#123; return NSLOCTEXT(&quot;AssetTypeActions&quot;, &quot;AssetTypeActions_PrimaryAssetLabel&quot;, &quot;Primary Asset Label&quot;); &#125; virtual FColor GetTypeColor() const override &#123; return FColor(0, 255, 255); &#125; virtual UClass* GetSupportedClass() const override &#123; return UPrimaryAssetLabel::StaticClass(); &#125; virtual bool HasActions(const TArray&lt;UObject*&gt;&amp; InObjects ) const override &#123; return true; &#125; virtual void GetActions(const TArray&lt;UObject*&gt;&amp; InObjects, FToolMenuSection&amp; Section) override; // virtual void OpenAssetEditor(const TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithinLevelEditor = TSharedPtr&lt;IToolkitHost&gt;() ) override; virtual uint32 GetCategories() override &#123; return EAssetTypeCategories::Basic; &#125; // virtual class UThumbnailInfo* GetThumbnailInfo(UObject* Asset) const override; virtual bool IsImportedAsset() const override &#123; return true; &#125; // virtual void GetResolvedSourceFilePaths(const TArray&lt;UObject*&gt;&amp; TypeAssets, TArray&lt;FString&gt;&amp; OutSourceFilePaths) const override;&#125;; 其中最关键的是重写 GetSupportedClass 返回想要添加到哪种资源的右键菜单里。 .cpp123456789101112131415161718192021void FAssetTypeActions_PrimaryAssetLabel::GetActions(const TArray&lt;UObject*&gt;&amp; InObjects, FToolMenuSection&amp; Section)&#123; auto Labels = GetTypedWeakObjectPtrs&lt;UPrimaryAssetLabel&gt;(InObjects); Section.AddMenuEntry( &quot;ObjectContext_AddToPatchIncludeFilters&quot;, NSLOCTEXT(&quot;AssetTypeActions_PrimaryAssetLabel&quot;, &quot;ObjectContext_AddToPatchIncludeFilters&quot;, &quot;Add To Patch Include Filters&quot;), NSLOCTEXT(&quot;AssetTypeActions_PrimaryAssetLabel&quot;, &quot;ObjectContext_AddToPatchIncludeFiltersTooltip&quot;, &quot;Add the label to HotPatcher Include Filters.&quot;), FSlateIcon(), FUIAction( FExecuteAction::CreateSP(this, &amp;FAssetTypeActions_PrimaryAssetLabel::ExecuteAddToPatchIncludeFilter, Labels) )); Section.AddMenuEntry( &quot;ObjectContext_AddToChunkConfig&quot;, NSLOCTEXT(&quot;AssetTypeActions_PrimaryAssetLabel&quot;, &quot;ObjectContext_AddToChunkConfig&quot;, &quot;Add To Chunk Config&quot;), NSLOCTEXT(&quot;AssetTypeActions_PrimaryAssetLabel&quot;, &quot;ObjectContext_AddToChunkConfigTooltip&quot;, &quot;Add Label To Chunk Config&quot;), FSlateIcon(), FUIAction( FExecuteAction::CreateSP(this, &amp;FAssetTypeActions_PrimaryAssetLabel::ExecuteAddToChunkConfig, Labels) ));&#125; 在绑定的事件里可以处理对资源的操作流程。 最后，需要把所写的这个类注册到 AssetTools 里，可以写到 Module 的 StartupModule 中： 1FAssetToolsModule::GetModule().Get().RegisterAssetTypeActions(MakeShareable(new FAssetTypeActions_PrimaryAssetLabel)); 效果：","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"Asset Tools","slug":"Asset-Tools","permalink":"https://ue5wiki.com/tags/Asset-Tools/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}]},{"title":"虚幻周报 20210714| 虚幻嘉年华！","date":"2021-07-14T00:00:00.000Z","path":"wiki/external1036572621/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210714| 虚幻嘉年华！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/389520888"},{"title":"虚幻周报 20210820|UE4.27 正式版发布！","date":"2021-07-14T00:00:00.000Z","path":"wiki/external1564884332/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210820|UE4.27 正式版发布！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/401742228"},{"title":"Zlib/Oodle/ZSTD 压缩算法性能对比","date":"2021-07-06T19:59:39.000Z","path":"wiki/30732/","text":"之前我写了一篇文章，在 UE 中集成了 ZSTD 压缩算法：ModularFeature：为 UE4 集成 ZSTD 压缩算法，并且把 UE5 中的 Oodle 的压缩算法库提取出来，可以在 UE4 中使用：Oodle Compression。最近分析了一下他们的压缩性能，分别测试了 WindowsNoEditor/Android_ASTC/IOS 三个平台。 打包和测试方法： 打出默认的 zlib 基础包，不包含任何资源 基础包内包含 oodle/zstd 等代码，在启动时可指定压缩器和 compresslevel 使用 HotPatcher 打包 StarterContent，每次打包三个平台，打包时通过命令指定使用的压缩算法、压缩器、压缩级别 运行时使用 Perfdog 和 stat compression 查看数据 使用不同的压缩算法打包 StarterContent 的大小（单位 MB）：以下数据中，Oodle 默认使用 Fast 压缩级别，区别是 compressor 的不同。 - ZLIB OODLE(Kraken) OODLE(Leviathan) Oodle(Hydra) ZSTD(Level22) WindowsNoEditor 295.93 284 273.18 278.40 286 Android_ASTC 177 170 165 167 171 IOS 174 162 155 158 163 在 Oodle 的 Fast 模式下，打包 StarterContent 为 Android_ASTC/IOS/WindowsNoEditor 三个平台，只是打包 Pak 的耗时，总共约 35 秒。 在压缩级别开到最高的Optimal5，压缩速度明显降低，但压缩率明显提升，三个平台约+00:06:55.764，大约七分钟。 - Leviathan(Fast) Leviathan(Optimal5) Leviathan(Optimal2) ZSTD Level 22 WindowsNoEditor 273.18 (13.54s) 263 (180.63s) 266 (41.69s) 286(31.24s) Android_ASTC 165 (8.39s.) 152 (95.59s) 157 (23.19s) 171(19.86s) IOS 155 (10.38s) 147 (138.13s) 150 (34.96s) 163(20.43s) Kraken 使用不同压缩级别的对比（文末有运行时对比数据）： - Kraken(Fast) Kraken(Optimal5) Kraken(Optimal2) WindowsNoEditor 283 (5.83s) 273 (82.24) 276 (41.69s) Android_ASTC 170 (3.52s.) 161 (49.88s) 166 (23.19s) IOS 161 (4.01s) 152 (57.34s) 155 (34.96s) 使用 stat 组合 PerfDog 分析各种压缩算法的效率，测试方法，加载不同压缩算法打包的 Pak，进入相同的地图（/Game/StarterContent/Maps/StarterMap），开启stat compression, 游览整个场景三分钟后的性能数据（移动端会开启 PerfDog 分析，会有一定的性能影响，但移动端所有的测试均使用相同的操作和流程，数据对比准确性还是 OK 的）。 WindowsNoEditor zlib oodle(Kraken+fast) oodle(Hydra+fast) oodle(Leviathan+fast) zstd(level22) Android_ASTC zlib oodle(Kraken+fast) oodle(Hydra+fast) oodle(Leviathan+fast) zstd(level22) IOS zlib oodle(Kraken+fast) oodle(Hydra+fast) oodle(Leviathan+fast) zstd(level22) Kraken 不同压缩级别对比 测试包与 perfdog 环境与上文相同。 WindowsNoEditor Fast Optimal2 Optimal5 Android_ASTC Fast Optimal2 Optimal5 IOS Fast Optimal2 Optimal5 总结 压缩率和解压性能，是一个相互取舍的因素，从对比数据来看，不管是 Oodle/ZSTD，都在保持压缩率的同时，解压效率都远超 Zlib。从对比数据看，ZSTD 的 22 级别性能与 Oodle 的 Leviathan 相近，Kraken 则在解压速度上更胜一筹，所以在游戏中使用 Kraken+fast 是比较合理的方案。虽然选用其他的 CompressLevel 如Optimal2/Optimal5，但是会增加数倍的压缩时间，在项目资源量巨大的情况下，有些得不偿失。","tags":[{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"接收命令行参数控制程序编译行为","date":"2021-07-06T15:23:46.000Z","path":"wiki/29447/","text":"在 build.cs 以及 target.cs 中可以获取命令行参数，对编译选项进行控制： 12345string[] CmdArgs = Environment.GetCommandLineArgs();foreach (string CmdLineArg in CmdArgs)&#123; Console.WriteLine(&quot;CmdLineArg: &quot; + CmdLineArg);&#125; 编译时输出： 1234567890&gt;E:\\UnrealEngine\\Launcher\\UE_4.26\\Engine\\Build\\BatchFiles\\Build.bat GWorldEditor Win64 Development -Project=&quot;E:\\UnrealProjects\\GWorld\\GWorld.uproject&quot; -WaitMutex -FromMsBuild -test0&gt;CmdLineArg: ..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe0&gt;CmdLineArg: GWorldEditor0&gt;CmdLineArg: Win640&gt;CmdLineArg: Development0&gt;CmdLineArg: -Project=E:\\UnrealProjects\\GWorld\\GWorld.uproject0&gt;CmdLineArg: -WaitMutex0&gt;CmdLineArg: -FromMsBuild0&gt;CmdLineArg: -test 基于传递的参数可以动态地修改编译行为，比如添加宏、依赖的模块等。 以动态开启 ASAN 的方法，开启 ADDRESS SANITIZER，可以更好的进行内存异常访问分析：iOS Address Sanitizer in UE4 在 Target.cs 中开启： 1Environment.SetEnvironmentVariable(&quot;ENABLE_ADDRESS_SANITIZER&quot;, &quot;YES&quot;); 使用命令行控制在打包阶段是否开启 ASAN： 123456789101112string[] CmdArgs = Environment.GetCommandLineArgs();foreach (string CmdLineArg in CmdArgs)&#123; if (CmdLineArg.Equals(&quot;-asan&quot;)) &#123; if (Target.Platform == UnrealTargetPlatform.Mac || Target.Platform == UnrealTargetPlatform.IOS) &#123; Environment.SetEnvironmentVariable(&quot;ENABLE_ADDRESS_SANITIZER&quot;, &quot;YES&quot;); &#125; &#125;&#125; 在打包时传递 -asan 参数给 UBT 即可，","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"TargetRules","slug":"TargetRules","permalink":"https://ue5wiki.com/tags/TargetRules/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"IOS Metal Shader 编译","date":"2021-07-06T12:39:45.000Z","path":"wiki/10076/","text":"Windows Metal Shader Compiler for IOS在 4.26 及更高的引擎版本中，支持在 Windows 上直接安装 Metal Sahder Compiler 来支持在 Windows 上编译 Metal 的 Shader，只需要在 Apple 开发者网站 上安装 Metal Developer Tools for Windows 工具安装即可。 Using the Windows Metal Shader Compiler for iOS More Downloads for Apple Developers 4.26 引擎执行 Cook 时的 Log，可以看到创建了 Metallib： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Running: C:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Binaries\\Win64\\UE4Editor-Cmd.exe &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\StarterContent426\\StarterContent426.uproject&quot; -run=Cook -TargetPlatform=IOS -fileopenlog -ddc=InstalledDerivedDataBackendGraph -unversioned -abslog=&quot;C:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2021.04.08-10.06.40.txt&quot; -stdout -CrashForUAT -unattended -NoLogTimes -UTF8Output LogInit: Display: Running engine for game: StarterContent426 LogHAL: Display: Platform has ~ 32 GB [34123063296 / 34359738368 / 32], which maps to Largest [LargestMinGB=32, LargerMinGB=12, DefaultMinGB=8, SmallerMinGB=6, SmallestMinGB=0) LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;AllDesktop&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_ASTC&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_DXT&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_ETC2&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;AndroidClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_ASTCClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_DXTClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_ETC2Client&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_Multi&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Android_MultiClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;IOSClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;IOS&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Linux&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxNoEditor&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxServer&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxAArch64NoEditor&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxAArch64Client&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LinuxAArch64Server&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Lumin&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;LuminClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;MacNoEditor&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Mac&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;MacClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;MacServer&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;TVOSClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;TVOS&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;WindowsNoEditor&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;Windows&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;WindowsClient&#x27; LogTargetPlatformManager: Display: Loaded TargetPlatform &#x27;WindowsServer&#x27; LogTargetPlatformManager: Display: Building Assets For IOS LogAudioDebug: Display: Lib vorbis DLL was dynamically loaded. LogShaderCompilers: Display: Using Local Shader Compiler. LogDerivedDataCache: Display: Max Cache Size: 512 MB LogDerivedDataCache: Display: Loaded Boot cache: C:/Users/lipengzha/AppData/Local/UnrealEngine/4.26/DerivedDataCache/Boot.ddc LogDerivedDataCache: Display: Pak cache opened for reading ../../../Engine/DerivedDataCache/Compressed.ddp. LogDerivedDataCache: Display: Performance to C:/Users/lipengzha/AppData/Local/UnrealEngine/Common/DerivedDataCache: Latency=0.06ms. RandomReadSpeed=291.68MBs, RandomWriteSpeed=137.99MBs. Assigned SpeedClass &#x27;Local&#x27; LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material Widget3DPassThrough, compiling. LogMaterial: Display: Missing cached shader map for material DefaultSpriteMaterial, compiling. LogAudioCaptureCore: Display: No Audio Capture implementations found. Audio input will be silent. LogAudioCaptureCore: Display: No Audio Capture implementations found. Audio input will be silent. LogCook: Display: CookSettings for Memory: MemoryMaxUsedVirtual 0MiB, MemoryMaxUsedPhysical 16384MiB, MemoryMinFreeVirtual 0MiB, MemoryMinFreePhysical 1024MiB LogCook: Display: Mobile HDR setting 1 LogCook: Display: Creating asset registry LogCook: Display: Discovering localized assets for cultures: en LogCook: Display: Unable to read previous cook inisettings for platform IOS invalidating cook LogCook: Display: Clearing all cooked content for platform IOS LogCook: Display: Sandbox cleanup took 0.025 seconds for platforms IOS LogMetalShaderCompiler: Display: Creating Native Library C:/Users/lipengzha/Documents/Unreal Projects/StarterContent426/Saved/Cooked/IOS/StarterContent426/Content/Global_SF_METAL.0.metallib LogMetalShaderCompiler: Display: Archiving 685 shaders for shader platform: SF_METAL LogZipArchiveWriter: Display: Closing zip file with 0 entries. LogMetalShaderCompiler: Display: Post-processing archive for shader platform: SF_METAL LogCook: Display: Cooked packages 0 Packages Remain 314 Total 314 打包出来的 Shadercode 不是 ushaderbytecode 文件，而是和 Mac 上打包一致的metallib。 Loaded a text shader (will be slower to load)当使用远程构建的方式打包了 IOS 包，在运行时会有以下 log： 1LogMetal: Display: Loaded a text shader (will be slower to load) 该日志在以下代码中输出： 1234567Source\\Runtime\\Apple\\MetalRHI\\Private\\MetalShaders.cpp/** Initialization constructor. */template&lt;typename BaseResourceType, int32 ShaderType&gt;void TMetalBaseShader&lt;BaseResourceType, ShaderType&gt;::Init(TArrayView&lt;const uint8&gt; InShaderCode, FMetalCodeHeader&amp; Header, mtlpp::Library InLibrary)&#123; // ...&#125; 这是因为加载的 Shader 需要实时编译，会比较慢，可以在项目设置中为 IOS 开启remote shader compile，在 UE4.26 之后，也可以通过本地安装 metal 的工具链在本地编译 metal 的 shader。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"Shader","slug":"Shader","permalink":"https://ue5wiki.com/tags/Shader/"},{"name":"Metal","slug":"Metal","permalink":"https://ue5wiki.com/tags/Metal/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"联机烘培光照","date":"2021-07-06T12:34:47.000Z","path":"wiki/41871/","text":"在 UE 编辑器中构建光照时，会拉起一个 SwarmAgent 进程在后台执行光照构建任务。UE 提供了多台机器联机构建光照的支持，通过配置 SwarmCoordinator 与SwarmAgent作为 C/S 的方式来下发构建任务，实现联机烘培的效果。官方文档：Unreal Swarm。 要求： 在局域网内需要一台设备当作调度器（Coordinator），该机器上需要具有完整的引擎，并且该机器需要开放 TCP 的 8008/8009 端口的 in/out，不然无法连接。 其余的机器上不要求安装引擎，但是需要运行 SwarmAgent。 SwarmAgent可以从引擎的 Engine\\Binaries\\DotNET 目录下提取以下文件： 12345678910111213C:\\build_agent\\workspace\\SwarmAgent&gt;tree /a /fC:. AgentInterface.dll SwarmAgent.DeveloperOptions.xml SwarmAgent.exe SwarmAgent.exe.config SwarmAgent.Options.xml SwarmCommonUtils.dll SwarmCoordinator.exe SwarmCoordinator.exe.config SwarmCoordinatorInterface.dll SwarmInterface.dll UnrealControls.dll 其中 SwarmAgent.Options.xml 与SwarmAgent.DeveloperOptions.xml是配置文件。 需要关注的参数： CacheFolder：注意该目录需要有读写权限，因为 SwarmAgent 可以脱离引擎单独运行，默认的引擎目录不适合，建议设置为C:\\tmp\\SwarmCache。 AllowedRemoteAgentNames：允许远程 Agent 分配任务到本地的名字，如果不做分组的情况，可以用通配符 * 允许所有的 Agent CoordinatorRemotingHost：局域网中运行 SwarmCoordinator 机器的 IP 地址（注意该机器需要开放 TCP 8008/8009 端口） AvoidLocalExecution：只允许从本地分发任务，但本地不执行任务。 EnableStandaloneMode：SwarmAgent 的独立模式，不允许传入任务，也不向其他机器分发任务。 ShowDeveloperMenu：显示 DeveloperSettings 菜单。 在 DevelopSettings 中可以控制超时时间、核心数等。当配置完之后把 SwarmAgent 运行在其余设备上，在 Coordinator 的机器上就可以看到以下连接： 展示了连接的机器数，工作状态（如果 SwarmCoordinator 进程关闭，重启后会自动连接 Agent）。在任意启动了 Agent 的机器上可以开启 UE 启动光照构建任务（注意一定要先单独启动被配置完成的 SwarmAgent，如果使用引擎自动拉起 SwarmAgent 则会使用一份额外的配置文件），就能在本地 SwarmAgent 进程中看到以下任务分配： 在 SwarmCoordinator 中可以看到任务分配情况： 注意：不一定所有的任务都会被分配至其他的 Agent 执行，取决于任务数量、Agent 的负载情况等。 当 Agent 处于 Busy 状态时，Coordinator 不会给其分配任务： 其他资料： Unreal:Swarm Agent Troubleshooting","tags":[{"name":"Lightmass","slug":"Lightmass","permalink":"https://ue5wiki.com/tags/Lightmass/"},{"name":"Swarm Agent","slug":"Swarm-Agent","permalink":"https://ue5wiki.com/tags/Swarm-Agent/"}],"categories":[{"name":"Lightmass","slug":"Lightmass","permalink":"https://ue5wiki.com/categories/Lightmass/"}]},{"title":"控制 AssetRegistry 的序列化","date":"2021-07-06T12:30:22.000Z","path":"wiki/41006/","text":"AssetRegistry 其实主要是在 Editor 下用来方便进行资源的查找和过滤操作，它的主要使用者是 ContentBrowser，这一点在 UE 的文档中也有描述：Asset Registry。 对于项目而言在 Runtime 可能没有需求来使用它，但是在 AssetRegistry 模块一启动就会把 AssetRegistry.bin 加载到内存中，如果对它没有需求其实这部分内存是浪费的。 关闭 AssetRegistry 的影响：无法在运行时通过 AssetRegistry 模块进行资源的依赖分析、以及通过 AssetRegistry 检测资源是否存在的判断。 好在 UE 提供了不序列化或者部分序列化 AssetRegistry 数据的方法，在 UAssetRegistryImpl 的构造函数中会调用 InitializeSerializationOptionsFromIni 函数来读取 DefaultEngine.ini 中的配置，并会构造出一个 FAssetRegistrySerializationOptions 结构来存储，它会在后续的 Serialize 函数中使用，用来控制把哪部分的数据序列化到 AssetRegistry 中。 12345678910111213141516171819202122232425// Runtime/AssetRegistry/Private/AssetRegistry.cppvoid UAssetRegistryImpl::InitializeSerializationOptionsFromIni(FAssetRegistrySerializationOptions&amp; Options, const FString&amp; PlatformIniName) const&#123; FConfigFile* EngineIni = nullptr;#if WITH_EDITOR // Use passed in platform, or current platform if empty FConfigFile PlatformEngineIni; FConfigCacheIni::LoadLocalIniFile(PlatformEngineIni, TEXT(&quot;Engine&quot;), true, (!PlatformIniName.IsEmpty() ? *PlatformIniName : ANSI_TO_TCHAR(FPlatformProperties::IniPlatformName()))); EngineIni = &amp;PlatformEngineIni;#else // In cooked builds, always use the normal engine INI EngineIni = GConfig-&gt;FindConfigFile(GEngineIni);#endif EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeAssetRegistry&quot;), Options.bSerializeAssetRegistry); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeDependencies&quot;), Options.bSerializeDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeNameDependencies&quot;), Options.bSerializeSearchableNameDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeManageDependencies&quot;), Options.bSerializeManageDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializePackageData&quot;), Options.bSerializePackageData); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bUseAssetRegistryTagsWhitelistInsteadOfBlacklist&quot;), Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterAssetDataWithNoTags&quot;), Options.bFilterAssetDataWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterDependenciesWithNoTags&quot;), Options.bFilterDependenciesWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterSearchableNames&quot;), Options.bFilterSearchableNames); // ...&#125; 这个控制方式可以在打包时控制是否生成 AssetRegistry.bin，以及控制在运行时反序列化哪些 AssetRegistry 的数据（但是不会对 DevelopmentAssetRegistry.bin 造成影响，可以用它来进行资产审计）。 它的反序列化流程为： 检测 bSerializeAssetRegistry，如果为true 则把 AssetRegistry.bin 以二进制形式加载到内存中 通过 Serialize 函数来把二进制数据反序列化 释放加载 AssetRegistry.bin 所占用的内存 所以，AssetRegistry 的内存占用是在序列化之后的数据，而 FAssetRegistrySerializationOptions 就是控制把哪些数据序列化的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Runtime/AssetRegistry/Public/AssetRegistryState.h/** Load/Save options used to modify how the cache is serialized. These are read out of the AssetRegistry section of Engine.ini and can be changed per platform. */struct FAssetRegistrySerializationOptions&#123; /** True rather to load/save registry at all */ bool bSerializeAssetRegistry; /** True rather to load/save dependency info. If true this will handle hard and soft package references */ bool bSerializeDependencies; /** True rather to load/save dependency info for Name references, */ bool bSerializeSearchableNameDependencies; /** True rather to load/save dependency info for Manage references, */ bool bSerializeManageDependencies; /** If true will read/write FAssetPackageData */ bool bSerializePackageData; /** True if CookFilterlistTagsByClass is a whitelist. False if it is a blacklist. */ bool bUseAssetRegistryTagsWhitelistInsteadOfBlacklist; /** True if we want to only write out asset data if it has valid tags. This saves memory by not saving data for things like textures */ bool bFilterAssetDataWithNoTags; /** True if we also want to filter out dependency data for assets that have no tags. Only filters if bFilterAssetDataWithNoTags is also true */ bool bFilterDependenciesWithNoTags; /** Filter out searchable names from dependency data */ bool bFilterSearchableNames; /** The map of classname to tag set of tags that are allowed in cooked builds. This is either a whitelist or blacklist depending on bUseAssetRegistryTagsWhitelistInsteadOfBlacklist */ TMap&lt;FName, TSet&lt;FName&gt;&gt; CookFilterlistTagsByClass; FAssetRegistrySerializationOptions() : bSerializeAssetRegistry(false) , bSerializeDependencies(false) , bSerializeSearchableNameDependencies(false) , bSerializeManageDependencies(false) , bSerializePackageData(false) , bUseAssetRegistryTagsWhitelistInsteadOfBlacklist(false) , bFilterAssetDataWithNoTags(false) , bFilterDependenciesWithNoTags(false) , bFilterSearchableNames(false) &#123;&#125; /** Options used to read/write the DevelopmentAssetRegistry, which includes all data */ void ModifyForDevelopment() &#123; bSerializeAssetRegistry = bSerializeDependencies = bSerializeSearchableNameDependencies = bSerializeManageDependencies = bSerializePackageData = true; DisableFilters(); &#125; /** Disable all filters */ void DisableFilters() &#123; bFilterAssetDataWithNoTags = false; bFilterDependenciesWithNoTags = false; bFilterSearchableNames = false; &#125;&#125;; 配置的读取在以下代码中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Runtime/AssetRegistry/Private/AssetRegistry.cppvoid UAssetRegistryImpl::InitializeSerializationOptionsFromIni(FAssetRegistrySerializationOptions&amp; Options, const FString&amp; PlatformIniName) const&#123; FConfigFile* EngineIni = nullptr;#if WITH_EDITOR // Use passed in platform, or current platform if empty FConfigFile PlatformEngineIni; FConfigCacheIni::LoadLocalIniFile(PlatformEngineIni, TEXT(&quot;Engine&quot;), true, (!PlatformIniName.IsEmpty() ? *PlatformIniName : ANSI_TO_TCHAR(FPlatformProperties::IniPlatformName()))); EngineIni = &amp;PlatformEngineIni;#else // In cooked builds, always use the normal engine INI EngineIni = GConfig-&gt;FindConfigFile(GEngineIni);#endif EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeAssetRegistry&quot;), Options.bSerializeAssetRegistry); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeDependencies&quot;), Options.bSerializeDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeNameDependencies&quot;), Options.bSerializeSearchableNameDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeManageDependencies&quot;), Options.bSerializeManageDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializePackageData&quot;), Options.bSerializePackageData); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bUseAssetRegistryTagsWhitelistInsteadOfBlacklist&quot;), Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterAssetDataWithNoTags&quot;), Options.bFilterAssetDataWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterDependenciesWithNoTags&quot;), Options.bFilterDependenciesWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterSearchableNames&quot;), Options.bFilterSearchableNames); TArray&lt;FString&gt; FilterlistItems; if (Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist) &#123; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsWhitelist&quot;), FilterlistItems); &#125; else &#123; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsBlacklist&quot;), FilterlistItems); &#125; &#123; // this only needs to be done once, and only on builds using USE_COMPACT_ASSET_REGISTRY TArray&lt;FString&gt; AsFName; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsFName&quot;), AsFName); TArray&lt;FString&gt; AsPathName; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsPathName&quot;), AsPathName); TArray&lt;FString&gt; AsLocText; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsLocText&quot;), AsLocText); FAssetRegistryState::IngestIniSettingsForCompact(AsFName, AsPathName, AsLocText); &#125; // ... &#125; 在 Config/DefaultEngine.ini 中创建AssetRegistrySection 使用上面的名字就可以控制 AssetRegistry 的序列化，减少打包时的包体大小以及内存占用（AssetRegistry 在引擎启动时会加载到内存中） 123456[AssetRegistry]bSerializeAssetRegistry=falsebSerializeDependencies=falsebSerializeNameDependencies=falsebSerializeManageDependencies=falsebSerializePackageData=false 也可以对某个平台来单独指定，只需要修改平台相关的 Ini 文件： 123Config/Windows/WindowsEngine.iniConfig/Android/AndroidEngine.iniConfig/IOS/IOSEngine.ini","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"Memory","slug":"Memory","permalink":"https://ue5wiki.com/tags/Memory/"},{"name":"AssetRegistry","slug":"AssetRegistry","permalink":"https://ue5wiki.com/tags/AssetRegistry/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"},{"name":"Memory","slug":"Optimization/Memory","permalink":"https://ue5wiki.com/categories/Optimization/Memory/"}]},{"title":"裁剪不必要的引擎模块","date":"2021-07-06T09:56:26.000Z","path":"wiki/10845/","text":"可以根据项目需求可以裁剪以下的引擎模块支持，降低编译的可执行文件、包体大小： APEX如果不适用 Nvidia 的 APEX 破碎系统，可以在编译引擎时去掉 APEX 的支持。 可以在 BuildSetting 或者 TargetRules 设置bCompileAPEX=true。 Recast(NavMesh)如果客户端在运行时不需要 Recast 的支持，并且不需要客户端本地进行 NavMesh 寻路操作，可以运行时裁剪掉 NavMesh 的支持。可以在 BuildSetting 或者 TargetRules 设置bCompileRecast=true。 FreeType是否需要 FreeType 字库支持，可以在 BuildSetting 或者 TargetRules 设置bCompileFreeType=true。 ICU(unicode/i18n)引擎 Core 模块中对 unicode/i18n 的支持，可以在 BuildSetting 或者 TargetRules 设置bCompileICU=true。 CompileForSizeUE 提供的优化选项，可以控制编译时严格控制大小，但是会牺牲性能。可以在 BuildSetting 或者 TargetRules 设置bCompileForSize=true。 CEF3可选是否支持 Chromium Embedded Framework，Google 的嵌入式浏览器支持。 可以在 BuildSetting 或者 TargetRules 设置bCompileCEF3=true。 Audio 模块 因为项目使用 WWise 作为音频播放接口，如果完全不需要引擎中内置的 Audio 模块，该部分功能是冗余的，在后续的优化中可以裁剪掉。 国际化模块 如果游戏的多语言支持不依赖 UE 的文本采集和翻译功能，可以裁剪掉该模块。 Steam游戏不需要 Steam 的支持，可以去掉，在 TargetRules 中通过 bUsesSteam 控制。 SpeedTree如果游戏中不需要使用 SpeedTree 进行植被建模，可以关闭编译 SpeedTree，通过 TargetRules 中的 bOverrideCompileSpeedTree 控制。","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}]},{"title":"集成第三方压缩算法","date":"2021-07-06T09:52:24.000Z","path":"wiki/10054/","text":"使用 ModularFeature 集成第三方压缩算法，以 ZSTD 为例。 在 UE 中如果想要自己添加一个压缩算法的实现则需要自己实现一个继承自 ICompressionFormat 的类，然后注册给IModulelarFeatures，那么以 ZSTD 为例，来示范一下怎么真实地添加一个压缩算法。 首先还是要来介绍一下 ICompressionFormat 中提供的四个接口函数的语义要求： 1234567891011struct ICompressionFormat : public IModularFeature, public IModuleInterface&#123; // 获取当前实现的压缩算法的名字 virtual FName GetCompressionFormatName() = 0; // 执行压缩 virtual bool Compress(void* CompressedBuffer, int32&amp; CompressedSize, const void* UncompressedBuffer, int32 UncompressedSize, int32 CompressionData) = 0; // 执行解压 virtual bool Uncompress(void* UncompressedBuffer, int32&amp; UncompressedSize, const void* CompressedBuffer, int32 CompressedSize, int32 CompressionData) = 0; // 获取压缩算法可以执行压缩的数据大小 virtual int32 GetCompressedBufferSize(int32 UncompressedSize, int32 CompressionData) = 0;&#125;; 然后开干，集成 ZSTD 首先需要去 facebook/zstd 上把代码拉取下来，然后把代码提取出来（Lib 目录下除了 dll 目录外都可以拷贝过来），放到插件的 Souce/ThirdParty 下，并在插件的 *.build.cs 中将其添加至 PublicIncludePaths 中。 首先先要对 ZSTD 的代码进行修改，因为 UE 的编译环境和警告等级的关系是没办法把代码拷过来就可以直接编译过的，常见的操作为忽略某些警告，但是 ZSTD 有一点特别的地方在于它里面具有 XXHash 的代码在编译时会与 LiveCoding 中的有冲突会有重定义错误，所以需要对 ZSTD 代码中的 XXHash 进行改名。 当把 ZSTD 的代码在 UE 中能够顺利的编译过的时候可以进入下一个流程，创建并实现 ZSTD 的ICompressionFormat实现。 123456789struct FZstdCompressionFormat : public ICompressionFormat&#123; virtual FName GetCompressionFormatName()override; virtual bool Compress(void* CompressedBuffer, int32&amp; CompressedSize, const void* UncompressedBuffer, int32 UncompressedSize, int32 CompressionData)override; virtual bool Uncompress(void* UncompressedBuffer, int32&amp; UncompressedSize, const void* CompressedBuffer, int32 CompressedSize, int32 CompressionData)override; virtual int32 GetCompressedBufferSize(int32 UncompressedSize, int32 CompressionData)override; static int32 Level;&#125;; 只是继承了 ICompressionFormat 然后添加了一个 Level 的 static 数据成员，用于记录在 ZSTD 中使用哪个压缩级别。 剩下的事情就是从 ZSTD 的代码里找到能够实现 ICompressionFormat 接口语义的函数： 123ZSTDLIB_API size_t ZSTD_compress(void* dst, size_t dstCapacity,const void* src, size_t srcSize,int compressionLevel);ZSTDLIB_API size_t ZSTD_decompress(void* dst, size_t dstCapacity,const void* src, size_t compressedSize);ZSTDLIB_API size_t ZSTD_compressBound(size_t srcSize); /*!&lt; maximum compressed size in worst case single-pass scenario */ 通过查看 ZSTD 的代码可以发现这三个函数组合起来就可以实现 ICompressionFormat 中的所有功能，比较简单，都是转发调用：PS: 通过实现 GetCompressionFormatName 来指定该压缩 Feature 的名字，我这里给了zstd，在项目设置里指定的时候就要使用这个名字。 123456789101112131415161718192021222324252627282930313233343536FName FZstdCompressionFormat::GetCompressionFormatName()&#123; return TEXT(&quot;zstd&quot;);&#125;bool FZstdCompressionFormat::Compress(void* CompressedBuffer, int32&amp; CompressedSize, const void* UncompressedBuffer, int32 UncompressedSize, int32 CompressionData)&#123; UE_LOG(LogTemp, Log, TEXT(&quot;FZstdCompressionFormat::Compress level is %d&quot;), FZstdCompressionFormat::Level); int32 Result = ZSTD_compress(CompressedBuffer, CompressedSize, UncompressedBuffer, UncompressedSize, FZstdCompressionFormat::Level); if (Result &gt; 0) &#123; if (Result &gt; GetCompressedBufferSize(UncompressedSize, CompressionData)) &#123; FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;%d &lt; %d&quot;), Result, GetCompressedBufferSize(UncompressedSize, CompressionData)); // we cannot safely go over the BufferSize needed! return false; &#125; CompressedSize = Result; return true; &#125; return false;&#125;bool FZstdCompressionFormat::Uncompress(void* UncompressedBuffer, int32&amp; UncompressedSize, const void* CompressedBuffer, int32 CompressedSize, int32 CompressionData)&#123; int32 Result = ZSTD_decompress(UncompressedBuffer, UncompressedSize, CompressedBuffer, CompressedSize); if (Result &gt; 0) &#123; UncompressedSize = Result; return true; &#125; return false;&#125;int32 FZstdCompressionFormat::GetCompressedBufferSize(int32 UncompressedSize, int32 CompressionData)&#123; return ZSTD_compressBound(UncompressedSize);&#125; 到这里 ZSTD 的的集成工作就完毕了，只剩下最后一步，那就是把这个 Feature 添加到 IModularFeatures 中，可以供引擎使用。 因为我是创建了一个插件，所以可以把注册的逻辑写到模块的 StartupModule 中，反之卸载模块时取消注册。 12345678910111213141516171819202122#define ZSTD_LEVEL_OPTION_STRING TEXT(&quot;-ZstdLevel=&quot;)void FlibzstdModule::StartupModule()&#123; FString CommandLine = FCommandLine::Get(); if (CommandLine.Contains(ZSTD_LEVEL_OPTION_STRING, ESearchCase::IgnoreCase)) &#123; int32 level; FParse::Value(FCommandLine::Get(), *FString(ZSTD_LEVEL_OPTION_STRING).ToLower(), level); FZstdCompressionFormat::Level = FMath::Clamp(level, ZSTD_minCLevel(),ZSTD_maxCLevel()); &#125; ZstdCompressionFormat = new FZstdCompressionFormat(); IModularFeatures::Get().RegisterModularFeature(COMPRESSION_FORMAT_FEATURE_NAME, ZstdCompressionFormat);&#125;void FlibzstdModule::ShutdownModule()&#123; IModularFeatures::Get().UnregisterModularFeature(COMPRESSION_FORMAT_FEATURE_NAME, ZstdCompressionFormat); delete ZstdCompressionFormat;&#125; 与前面讲的注册方法一致，我这里还添加了一个引擎启动时的命令行参数 -ZstdLevel= 可以用来传递使用 ZSTD 进行压缩的的压缩等级。 打包 Pak 使用 ZSTD 算法，使用我的 HotPatcher 可以在 UnrealPakOptions 中添加 -compressionformats=zstd,zlib 参数： 使用 UnrealPak 检测压缩格式： 注意，因为没有编译引擎，所以是不能直接通过 UnrealPak.exe 来解压使用 ZSTD 压缩的 Pak 的。","tags":[{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"ZSTD","slug":"ZSTD","permalink":"https://ue5wiki.com/tags/ZSTD/"},{"name":"ModularFeature","slug":"ModularFeature","permalink":"https://ue5wiki.com/tags/ModularFeature/"}],"categories":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/categories/ThirdParty/"}]},{"title":"App 版本号","date":"2021-07-05T14:19:01.000Z","path":"wiki/36762/","text":"IOS 在 IOS 包的 plist 中可以通过控制以下两个值： 1234&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;&lt;string&gt;1.0&lt;/string&gt;&lt;key&gt;CFBundleVersion&lt;/key&gt;&lt;string&gt;0.1&lt;/string&gt; CFBundleShortVersionString CFBundleVersion iOS 中的 CFBundleShortVersionString 与 CFBundleVersion 一般使用 CFBundleVersion 来作为游戏版本号，在 UE 中可以通过 UPL 来控制 plist。 AndroidAndroid 通过控制以下值： 123[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]VersionDisplayName=1.0.0StoreVersion=1","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"}]},{"title":"源码版与安装版 IOS 数据路径差异","date":"2021-07-05T14:17:05.000Z","path":"wiki/36383/","text":"使用安装版引擎打包 IOS 时，开启 FileSharing 能够在通过工具访问程序的 Document 目录，里面类似 Android 的 UE4Game 目录结构。但是当使用源码版引擎打包时，开启 FileSharing 的包，UE 的数据目录并不在 Document 目录下，因为项目配置没有任何更改，怀疑是引擎中有些地方对源码版或安装版做了检测。搜索代码发现，引擎中通过 FILESHARING_ENABLED 宏进行检测，当开启时，数据目录位于 Library 目录下，没有开启时则位于 Document 目录下。 Core/Private/IOS/IOSPlatformMisc.cpp12345678910void FIOSPlatformMisc::PlatformInit()&#123; // ...#if FILESHARING_ENABLED FString DownloadPath = FString([NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0]) + TEXT(&quot;/&quot;);#else FString DownloadPath = FString([NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]) + TEXT(&quot;/&quot;);#endif // ...&#125; 这个宏由 UBT 生成，通过读取 DefaultEngine.ini 中[/Script/IOSRuntimeSettings.IOSRuntimeSettings]下的 bSupportsITunesFileSharing 来确定宏的值。 Source/Programs/UnrealBuildTool/Platform/IOS/UEBuildIOS.cs1234567891011121314/// &lt;summary&gt;/// Stores project-specific IOS settings. Instances of this object are cached by IOSPlatform./// &lt;/summary&gt;public class IOSProjectSettings&#123; // ... /// &lt;summary&gt; /// true if iTunes file sharing support is enabled /// &lt;/summary&gt; [ConfigFile(ConfigHierarchyType.Engine, &quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;, &quot;bSupportsITunesFileSharing&quot;)] public readonly bool bFileSharingEnabled = false; // ...&#125; 添加宏的代码如下： Source/Programs/UnrealBuildTool/Platform/IOS/UEBuildIOS.cs12345678910111213141516171819/// &lt;summary&gt;/// Setup the target environment for building/// &lt;/summary&gt;/// &lt;param name=&quot;Target&quot;&gt;Settings for the target being compiled&lt;/param&gt;/// &lt;param name=&quot;CompileEnvironment&quot;&gt;The compile environment for this target&lt;/param&gt;/// &lt;param name=&quot;LinkEnvironment&quot;&gt;The link environment for this target&lt;/param&gt;public override void SetUpEnvironment(ReadOnlyTargetRules Target, CppCompileEnvironment CompileEnvironment, LinkEnvironment LinkEnvironment)&#123; // ... if (ProjectSettings.bFileSharingEnabled) &#123; CompileEnvironment.Definitions.Add(&quot;FILESHARING_ENABLED=1&quot;); &#125; else &#123; CompileEnvironment.Definitions.Add(&quot;FILESHARING_ENABLED=0&quot;); &#125; // ...&#125; 原因分析： 因为编译安装版引擎时，没有项目，引擎中 BaseEngine.ini 中bSupportsITunesFileSharing=False，所以通过 BuildGraph 编译安装版引擎时，bFileSharingEnabled默认值是 false，通过安装版引擎打包项目引擎也不会编译了，所以 bFileSharingEnabled 的值一直是 false，使用的是 NSDocumentDirectory 目录 相同的道理，使用源码版引擎打包项目时，因为需要通过打包项目才编译引擎，如果项目中指定了 bSupportsITunesFileSharing=True，则编译引擎时bFileSharingEnabled 就为 true，导致 FILESHARING_ENABLED=1，则使用了NSLibraryDirectory 目录。 需要注意的是：bSupportsITunesFileSharing不仅仅只是控制数据存储路径，还控制打包时 plist 的生成： Programs/UnrealBuildTool/Platform/IOS/UEDeployIOS.cs12345678910111213141516171819public static bool GenerateIOSPList(FileReference ProjectFile, UnrealTargetConfiguration Config, string ProjectDirectory, bool bIsUE4Game, string GameName, bool bIsClient, string ProjectName, string InEngineDir, string AppDirectory, VersionNumber SdkVersion, UnrealPluginLanguage UPL, string BundleID, bool bBuildAsFramework, out bool bSupportsPortrait, out bool bSupportsLandscape, out bool bSkipIcons)&#123; // ITunes file sharing bool bSupportsITunesFileSharing = false; Ini.GetBool(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;, &quot;bSupportsITunesFileSharing&quot;, out bSupportsITunesFileSharing); bool bSupportsFilesApp = false; Ini.GetBool(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;, &quot;bSupportsFilesApp&quot;, out bSupportsFilesApp); // ... Text.AppendLine(&quot;\\t&lt;key&gt;UIFileSharingEnabled&lt;/key&gt;&quot;); Text.AppendLine(string.Format(&quot;\\t&lt;&#123;0&#125;/&gt;&quot;, bSupportsITunesFileSharing ? &quot;true&quot; : &quot;false&quot;)); if (bSupportsFilesApp) &#123; Text.AppendLine(&quot;\\t&lt;key&gt;LSSupportsOpeningDocumentsInPlace&lt;/key&gt;&quot;); Text.AppendLine(&quot;\\t&lt;true/&gt;&quot;); &#125; // ...&#125; 所以，为了同时支持数据存储在 Document 下和开启 plist 中的UIFileSharingEnabled，对于 FileSharing 功能的支持需要进行以下操作： DefaultEngine.ini中的bSupportsITunesFileSharing=False 修改引擎中生成 FILESHARING_ENABLED 宏的代码，保持为 false 即可","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"关闭 UnityBuild","date":"2021-07-05T14:15:31.000Z","path":"wiki/36076/","text":"默认情况下，UE 默认开启了 bUseUnityBuild，会把多个 cpp 合并成一个翻译单元进行编译，加快项目的编译速度，编译时有*_1_of_8.cpp.obj 等 log。所以如果项目的头文件包含不规范，编译时头文件检测可能会出现问题：修改了 A 文件导致 B 文件出现错误。 所以，想在检测出中这种错误，可以关闭UnityBuild，使每个 cpp 都作为单独的翻译单元编译，有两种方法： 对整个工程（包含插件）关闭bUseUnityBuild，在项目的 Target.cs 中添加 target.cs12bForceUnityBuild = false;bUseUnityBuild = false; 不修改代码，也可以在 BuildCongiguration.xml 中配置关闭： 12345678910111213/// &lt;summary&gt;/// Whether to unify C++ code into larger files for faster compilation./// &lt;/summary&gt;[CommandLine(&quot;-DisableUnity&quot;, Value = &quot;false&quot;)][XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bUseUnityBuild = true;/// &lt;summary&gt;/// Whether to force C++ source files to be combined into larger files for faster compilation./// &lt;/summary&gt;[CommandLine(&quot;-ForceUnity&quot;)][XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bForceUnityBuild = false; 对单个模块关闭UnityBuild，在 Build.cs 中关闭 1bUseUnity = false; 可以在 Target.cs 中指定关闭 UnityBuild 的模块，也可以配置在 BuildConfiguration.xml 中： 12345/// &lt;summary&gt;/// List of modules to disable unity builds for/// &lt;/summary&gt;[XmlConfigFile(Category = &quot;ModuleConfiguration&quot;, Name = &quot;DisableUnityBuild&quot;)]public string[] DisableUnityBuildForModules = null; 可以在 Intermediate\\Build\\Win64\\UE4Editor\\Development\\Client 等路径下看到生成的大量 .response 文件。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UnityBuild","slug":"UnityBuild","permalink":"https://ue5wiki.com/tags/UnityBuild/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"UnityBuild","slug":"BuildSystem/UnityBuild","permalink":"https://ue5wiki.com/categories/BuildSystem/UnityBuild/"}]},{"title":"UE4 Cook 一致性实践","date":"2021-07-05T00:00:00.000Z","path":"wiki/external1092230984/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 Cook 一致性实践 。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"}],"is_external":true,"jump_to":"https://jashking.github.io/2021/07/15/2021-ue4-deterministic-cook/"},{"title":"UE4 灯光的移动性","date":"2021-07-05T00:00:00.000Z","path":"wiki/external1229427375/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 灯光的移动性 。","tags":[{"name":"Lighting","slug":"Lighting","permalink":"https://ue5wiki.com/tags/Lighting/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"Lighting","slug":"Rendering/Lighting","permalink":"https://ue5wiki.com/categories/Rendering/Lighting/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4%E7%81%AF%E5%85%89%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%80%A7/"},{"title":"移动端相对到绝对路径转换","date":"2021-07-03T23:58:16.000Z","path":"wiki/17479/","text":"IOS 相对到绝对路径转换 在接入的一些库中，需要传递文件的绝对路径，可以通过下面的方式进行转换： 1IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*InRelatePath);; 它是定义在 IFileManager 接口中的一个虚函数，应该在各个平台的 PlatformFile 中均有自己的实现，但是在 Android 中依然是相对路径的，不知道 UE 是不是忘了实现了。 IOS：Runtime/Core/Public/IOS/IOSPlatformFile.h Android 上相对路径转换成绝对路径的方式在之前的笔记中有写。 Android 相对路径转绝对路径 有些需求需要把 FPaths::ProjectDir() 等路径转换为移动设备上的绝对路径，可以参考 Core/Private/Android/AndroidPlatformFile.cpp#L126 中的实现： 123456789101112131415161718192021// Constructs the base path for any files which are not in OBB/pak dataconst FString &amp;GetFileBasePath()&#123; static FString BasePath = GFilePathBase + FString(FILEBASE_DIRECTORY) + FApp::GetProjectName() + FString(&quot;/&quot;); return BasePath;&#125;FString AndroidRelativeToAbsolutePath(bool bUseInternalBasePath, FString RelPath)&#123; if (RelPath.StartsWith(TEXT(&quot;../&quot;), ESearchCase::CaseSensitive)) &#123; do &#123; RelPath.RightChopInline(3, false); &#125; while (RelPath.StartsWith(TEXT(&quot;../&quot;), ESearchCase::CaseSensitive)); return (bUseInternalBasePath ? GInternalFilePath : GetFileBasePath()) / RelPath; &#125; return RelPath;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"}]},{"title":"Texture 的压缩和 Profiling","date":"2021-07-03T23:55:32.000Z","path":"wiki/16943/","text":"ASTC Compression Quality By Size在项目的 DefaultEngine.ini 中的 [/Script/UnrealEd.CookerSettings] 中通过 DefaultASTCQualityBySize 设置（0-4）： 123[/Script/UnrealEd.CookerSettings] DefaultASTCQualityBySize=2 DefaultASTCQualityBySpeed=3 0-4 分别对应以下压缩级别： 123450=12x12 1=10x10 2=8x8 3=6x6 4=4x4 Custom ASTC compression format Using ASTC Texture Compression for Game Assets Texture 的压缩 之前的笔记中，提到过可以在 Project Settings-Cooker-Texture-ASTC Compression vs Size 可以设置默认的资源质量和大小的级别： 123450=12x12 1=10x10 2=8x8 3=6x6 4=4x4 在 Texture 的资源编辑中也可以针对某个 Texture 单独设置： Lowest-&gt;Hightest 对应着 0-4 的值，使用 Default 则使用项目设置中的配置。 并且，设置 Compression Settings 的类型也会对资源压缩的类型有差别，Default 则是项目设置中的参数，如果设置成 NormalMap 的类型会是 ASTC_4x4 的。 Using ASTC Texture Compression for Game Assets Texture Compression Settings listtextures控制台命令 listtextures 可以列出已被加载过的 Texture 的信息。","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"Texture","slug":"Texture","permalink":"https://ue5wiki.com/tags/Texture/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}]},{"title":"upluginmanifest","date":"2021-07-03T23:54:02.000Z","path":"wiki/16649/","text":"项目打包时会根据项目启用的插件生成一个 PROJECT_NAME.upluginmanifest 文件，其中记录了每个启用的插件的 uplugin 的路径和内容信息，该文件也会打包到 pak 中。 Mount Point 为：../../../PROJECT_NAME/Plugins/PROJECT_NAME.upluginmanifest 在 Editor 下运行时不会读取这个文件，通过扫描引擎和项目以及 Mods 目录下的 Plugin 目录来查找插件的，相关的逻辑在 Runtime/Projects/Private/PluginManager.cpp 的ReadAllPlugins函数中。 123456#if !WITH_EDITOR if (Project != nullptr) &#123; FindPluginManifestsInDirectory(*FPaths::ProjectPluginsDir(), ManifestFileNames); &#125;#endif // !WITH_EDITOR 在非 Editor 下通过加载 upluginmanifest 文件来确定当前工程中有哪些插件的（upluginmanifest 文件可以有多个，只要放在 ../../../PROJECT_NAME/Plugins 目录下即可），如果一个插件在基础包中不存在，但是热更时新建了一个 Content Only 插件打包资源，需要把该插件添加至 upluginmanifest 中并且也需要把该插件的 uplugin 打包至 pak 中。 upluginmanifest 文件在 AutomationTool 中被创建，在 CopyBuildToStagingDirectory.Automation.cs 中有 CreatePluginManifest 函数。","tags":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"Manifest","slug":"Manifest","permalink":"https://ue5wiki.com/tags/Manifest/"}],"categories":[{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/categories/Plugins/"}]},{"title":"UE4.25 中 ShaderPatch 问题","date":"2021-07-03T23:52:09.000Z","path":"wiki/16280/","text":"在 4.25 引擎版本中调用 FShaderCodeLibrary::CreatePatchLibrary 来创建 ShaderCode Patch 会触发 check 抛异常： 这是因为 FEditorShaderCodeArchive 的构造函数中调用了 ShaderHashTable 的 Initialize，并给了默认值0x1000： 12345678910FEditorShaderCodeArchive(FName InFormat) : FormatName(InFormat) , Format(nullptr)&#123; Format = GetTargetPlatformManagerRef().FindShaderFormat(InFormat); check(Format); SerializedShaders.ShaderHashTable.Initialize(0x10000); SerializedShaders.ShaderMapHashTable.Initialize(0x10000);&#125; 导致在后续的流程中 (FSerializedShaderArchive::Serialize) 调用 Initialize 的时候 check 失败了(因为 HaseSize 已经有值了，并不是 0，对其再调用 Initialize 就触发了 check)： 查了下 FEditorShaderCodeArchive 构造函数中调用 Initialize 的代码是在 4.25 之后的引擎版本才有的，所以影响到的之后 4.25+ 的版本。代码对比： 4.24.3-release/Engine/Source/Runtime/RenderCore/Private/ShaderCodeLibrary.cpp#L922 4.25.0-release/Engine/Source/Runtime/RenderCore/Private/ShaderCodeLibrary.cpp#L801 解决方案：把 FSerializedShaderArchive::Serialize 中ShaderMapHashTable的 Initialize 和ShaderHashTable的 Initialize 在 Editor 下注释掉，因为 FEditorShaderCodeArchive 的代码只在 Editor 下有效，并且是只在生成 ShaderPatch 时有用。 这就造成了以下几个问题： FEditorShaderCodeArchive的构造只有 Eidotor 并且 ShaderPatch 是才有用，也就意味着这里写的 ShaderMapHashTable 的Initialize和 ShaderHashTable 的Initialize只有在创建 ShaderPatch 时才会执行 在打基础包时执行 Cook 会编译 shader，但是不会执行 FEditorShaderCodeArchive 的构造，ShaderMapHashTable的 Initialize 和ShaderHashTable的 Initialize 也就不会执行，就需要在使用的地方来调用它们的初始化 这也是 UE 中没有管理好这两个状态的地方：在 FEditorShaderCodeArchive 和FSerializedShaderArchive::Serialize中都做了 Initialize 的操作，在打基础包时造成了 ShaderMapHashTable 和ShaderHashTable的 Initialize 已经被 FEditorShaderCodeArchive 初始化的情况下又被 FSerializedShaderArchive::Serialize 执行了一遍，导致 Crash，但是我们又不能粗暴地把任何一处的初始化操作去掉，只能通过检测 ShaderMapHashTable 和ShaderHashTable的 Initialize 是否已经被执行，来选择性的跳过。 阅读代码可以知道 ShaderMapHashTable 和ShaderHashTable的 Initialize 只应该执行一次，并且初始化之后 HashSize 和 IndexSize 应该具有非 0 值： Runtime/Core/Public/Containers/HashTable.h123456789101112131415161718192021FORCEINLINE void FHashTable::Initialize(uint32 InHashSize, uint32 InIndexSize)&#123; check(HashSize == 0u); check(IndexSize == 0u); HashSize = InHashSize; IndexSize = InIndexSize; check(HashSize &lt;= 0x10000); check(FMath::IsPowerOfTwo(HashSize)); if (IndexSize) &#123; HashMask = (uint16)(HashSize - 1); Hash = new uint32[HashSize]; NextIndex = new uint32[IndexSize]; FMemory::Memset(Hash, 0xff, HashSize * 4); &#125;&#125; 在 Initialize 时会检测当前的 HashSize 和IndexSize是否为 0，并在之后进行赋值。所以，我们只要获取 FHashTable 的HashSize和 IndexSize 检测它们是否为 0 即可判断当前的 HashTable 对象是否已经被 Initialize 过，但是，UE 里的 FHashTable 里这两个成员都是 protected 的，只能修改引擎来实现了： 添加获取 FHashTable 的HashSize和 IndexSize 属性的成员函数： 12345678class FHashTable&#123;public: // ... FORCEINLINE uint32 GetHashSize()const&#123;return HashSize;&#125;; FORCEINLINE uint32 GetIndexSize()const&#123;return IndexSize;&#125;; // ...&#125;; 然后在 FSerializedShaderArchive::Serialize 进行检测，如果已被初始化则跳过 Initialize 逻辑： Runtime/RenderCore/Private/ShaderCodeArchive.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void FSerializedShaderArchive::Serialize(FArchive&amp; Ar)&#123; Ar &lt;&lt; ShaderMapHashes; Ar &lt;&lt; ShaderHashes; Ar &lt;&lt; ShaderMapEntries; Ar &lt;&lt; ShaderEntries; Ar &lt;&lt; PreloadEntries; Ar &lt;&lt; ShaderIndices; check(ShaderHashes.Num() == ShaderEntries.Num()); check(ShaderMapHashes.Num() == ShaderMapEntries.Num()); if (Ar.IsLoading()) &#123; // ++[SHADER_PATCH][lipengzha] auto ShaderHashInitialized = [](const FHashTable&amp; HashTable)-&gt;bool &#123; return HashTable.GetHashSize() || HashTable.GetIndexSize(); &#125;; // ++[SHADER_PATCH][lipengzha] &#123; const uint32 HashSize = FMath::Min&lt;uint32&gt;(0x10000, 1u &lt;&lt; FMath::CeilLogTwo(ShaderMapHashes.Num())); // ++[SHADER_PATCH][lipengzha] if(!ShaderHashInitialized(ShaderMapHashTable)) &#123; ShaderMapHashTable.Initialize(HashSize, ShaderMapHashes.Num()); &#125; // ++[SHADER_PATCH][lipengzha] for (int32 Index = 0; Index &lt; ShaderMapHashes.Num(); ++Index) &#123; const uint32 Key = GetTypeHash(ShaderMapHashes[Index]); ShaderMapHashTable.Add(Key, Index); &#125; &#125; &#123; const uint32 HashSize = FMath::Min&lt;uint32&gt;(0x10000, 1u &lt;&lt; FMath::CeilLogTwo(ShaderHashes.Num())); // ++[SHADER_PATCH][lipengzha] if(!ShaderHashInitialized(ShaderHashTable)) &#123; ShaderHashTable.Initialize(HashSize, ShaderHashes.Num()); &#125; // ++[SHADER_PATCH][lipengzha] for (int32 Index = 0; Index &lt; ShaderHashes.Num(); ++Index) &#123; const uint32 Key = GetTypeHash(ShaderHashes[Index]); ShaderHashTable.Add(Key, Index); &#125; &#125; &#125;&#125; 这样可以统一 ShaderPatch 和 Runtime 的 HashTable 的 Initialize 流程。 而且，需要注意的是：生成出来的 ShaderPatch 的 ushaderbytecode 文件是与基础包内的文件名一致的，所以不能使用引擎启动时的默认挂载（会导致基础包内的 ushaderbytecode 文件无法被加载，从而 crash）。 应该在挂载之后自己处理 ShaderPatch 的 ushaderbytecode 文件的加载，使用以下函数加载： 1234bool UFlibPatchParserHelper::LoadShaderbytecode(const FString&amp; LibraryName, const FString&amp; LibraryDir)&#123; return FShaderCodeLibrary::OpenLibrary(LibraryName, LibraryDir);&#125; 注意：ShaderPatch 的更新不直接支持 Patch 的迭代，如：1.0 Metadata + 1.1 的 ShaderPatch，并不能生成 1.2 的 ShaderPatch，必须要基于 1.1 的完整 Metadata 才可以，即每次 Patch 必须要基于上一次完整的 Metadate 数据（Project 和 Global 的 ushaderbytecode 文件），在工程管理上每次打包都需要把完整的 Metadata 收集起来。","tags":[{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"},{"name":"ShaderPatcher","slug":"ShaderPatcher","permalink":"https://ue5wiki.com/tags/ShaderPatcher/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"},{"name":"4.25","slug":"Engine/Bug/4-25","permalink":"https://ue5wiki.com/categories/Engine/Bug/4-25/"}]},{"title":"UE4 编译代码的真正命令参数","date":"2021-07-03T23:50:31.000Z","path":"wiki/15960/","text":"在之前的文章 Build flow of the Unreal Engine4 project 中有提到，UE 编译模块的时候会执行到 ExecuteActions 中。那么 UE 真正编译每个翻译单元的编译器参数是什么呢？在 UBT 调用 ExecuteAction 之前，会完成所有编译参数的拼接和预处理。 1static void ExecuteAction(ManagedProcessGroup ProcessGroup, BuildAction Action, List CompletedActions, AutoResetEvent CompletedEvent) 在 Win 上是通过调用 cl-filter.exe 来执行的，而如何把代码和编译参数喂给编译器呢？UE 是通过生成了一个 .cpp.obj.response 来记录当前编译单元的信息的，包含编译器参数和包含目录 / 输出等等。 该文件在生成位置在模块的 Intermediate 目录下： 1Intermediate\\Build\\Win64\\UE4Editor\\Development\\HotPatcherRuntime\\FlibPakReader.cpp.obj.response 文件内容太长，可以下载该文件查看：FlibPakReader.cpp.obj.response 可以使用手动调用 cl.exe 的方式来执行测试： 12cl.exe @CPP_OBJ_RESPONSE_PATH //showIncludes// &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.27.29110\\bin\\HostX64\\x64\\cl.exe&quot; @&quot;C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Plugins\\UnLua\\Intermediate\\Build\\Win64\\UE4\\Development\\LuaProtobuf\\Module.LuaProtobuf.cpp.obj.response&quot; /showIncludes","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"OptimizeCode 代码优化","date":"2021-07-03T23:48:55.000Z","path":"wiki/15647/","text":"注意：如果 关闭代码优化 导致构造对象 Crash（或者 new 走不到对象的构造函数），需要检查项目和插件的代码中是否有重名的类，会导致一些奇怪的问题。在 build.cs 中可以通过 OptimizeCode 来控制是否执行代码优化： 1OptimizeCode = CodeOptimization.InShippingBuildsOnly; 有以下几个可选值： 12345678public enum CodeOptimization &#123; Never, InNonDebugBuilds, InShippingBuildsOnly, Always, Default, &#125; 当开启优化时，对翻译单元的编译指令参数： 1234/Ox /Ot /GF /Zo 并且会使用优化版本的Engine/SharedPCH.Engine.h。 当关闭优化时的编译指令为： 1/Od 会使用非优化版本的Engine/SharedPCH.Engine.NonOptimized.h.","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"Optimization","slug":"BuildSystem/Optimization","permalink":"https://ue5wiki.com/categories/BuildSystem/Optimization/"}]},{"title":"IOS 远程构建最大文件不能超过 2G","date":"2021-07-03T23:33:17.000Z","path":"wiki/12584/","text":"Win 上远程构建出 IOS 包的流程是代码和 bundle 都上传到 Mac 上编译，生成不包含资源的 IPA，拉回本地执行资源 Cook 生成 Pak 后，把代码的 IPA 和资源的 Pak 合并成真正的 IPA 文件。但是这样有个问题，UE 里的实现是把所有要合并的文件读到内存中再合并打包的： 123456789101112131415161718192021222324252627282930313233343536373839static public void RepackageIPAFromStub()&#123; // ... // Add all of the payload files, replacing existing files in the stub IPA if necessary (should only occur for icons) &#123; string SourceDir = Path.GetFullPath(ZipSourceDir); string[] PayloadFiles = Directory.GetFiles(SourceDir, &quot;*.*&quot;, Config.bIterate ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories); foreach (string Filename in PayloadFiles) &#123; // Get the relative path to the file (this implementation only works because we know the files are all // deeper than the base dir, since they were generated from a search) string AbsoluteFilename = Path.GetFullPath(Filename); string RelativeFilename = AbsoluteFilename.Substring(SourceDir.Length + 1).Replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); string ZipAbsolutePath = String.Format(&quot;Payload/&#123;0&#125;&#123;1&#125;.app/&#123;2&#125;&quot;, Config.GetTargetName(), Program.Architecture, RelativeFilename); byte[] FileContents = File.ReadAllBytes(AbsoluteFilename); if (FileContents.Length == 0) &#123; // Zero-length files added by Ionic cause installation/upgrade to fail on device with error 0xE8000050 // We store a single byte in the files as a workaround for now FileContents = new byte[1]; FileContents[0] = 0; &#125; FileSystem.WriteAllBytes(RelativeFilename, FileContents); if ((FileContents.Length &gt;= 1024 * 1024) || (Config.bVerbose)) &#123; FilesBeingModifiedToPrintOut.Add(ZipAbsolutePath); &#125; &#125; &#125; // ...&#125; 可以看到是把 Payload 的每个文件读到 byte[] 里的，这就有了一个限制，在 C# 中，数组的长度最大是 int32.MaxValue，意味着byte[] 不能存储超过 2G 的文件，不然就会触发异常。查询了 MSDN 的文档，发现设置 gcAllowVeryLargeObjects 也不会改变单个维度的数组的大小。 Maximum length of byte[]? 所以这个问题只能从其他方面入手了，让 UE 进行资源打包的时候把 Pak 的文件拆分，让每个文件都小于 2GB 即可，可以通过 UE 里的 Chunk 机制进行拆分。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"Android 基础包拆分","date":"2021-07-03T23:31:44.000Z","path":"wiki/12280/","text":"在打包时，不想要把所有的资源都打包到 apk 中，所以可以在打包时进行拆分，只把必要资源打包到 apk 中，首先需要把基础包中的资源进行 pak 拆分，可以把通过 Project Settings-Asset Manager 中进行设置或者通过创建 PrimaryAssetLable 资源进行标记。 目标是： 把基础包的打包资源拆分到多个 Pak 中 只把必要的 pak 文件打包到 apk 里 其余的 pak 在运行时进行下载 第一步都可以通过项目设置进行控制，第二部的条件就是要实现一个过滤规则，不过 UE 已经提供了这个机制，可以指定过滤掉哪些文件，只需要添加配置即可。 12345# Config/DefaultEngine.ini[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]+ObbFilters=-pakchunk1-*+ObbFilters=-pakchunk2-*+ObbFilters=-pakchunk3-* ObbFilters 的规则以 - 开头就是排除规则，会把基础包中的 chunk1-3 的 pak 给过滤掉，可以用于后续的下载流程。 也可以指定 Exclute 和Include规则组合来用： 12+ObbFilters=-*.pak+ObbFilters=pakchunk0-* 第一步忽略掉所有的 pak 文件，然后把 pakchunk0-*.pak 显式添加至 obb 中。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"IOS 基础包拆分","date":"2021-07-03T23:31:06.000Z","path":"wiki/12156/","text":"在前面提到了 UE 为 Android 提供了打包到 obb 中的文件过滤规则： 123# Config/DefaultEngine.ini[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]+ObbFilters=-pakchunk1-* 但是 UE 并没有为 IOS 提供相应的操作，默认情况下会把 IOS 的所有的 pak 文件都打包至 IPA 中。 为了统一 Android 和 IOS 的基础包规则，我自己实现了 IOS 上类似 Android 那种指定过滤规则的功能，做个简单的介绍。 我使用的是 Mac 远程打包，流程是在 Mac 上编译代码生成 IPA，拉回 Win，在 Win 上进行 Cook，生成 Pak 文件，最后把原始 IPA 解包，再添加 Pak 等文件组合成最终 IPA。 我的需求是，自定义指定过滤规则，可以把某些文件忽略，不打包到 IPA 中。那么这一步的操作其实就位于把 IPA 解包再打包的流程里，经过翻阅 UE 的代码，发现这个操作是通过 iPhonePackager 这个独立程序来实现的，那么就需要对这个程序的代码进行改造了。 经过调试分析，发现真正实现重新打包 IPA 的操作是在以下函数中执行的： Programs/IOS/iPhonePackager/CookTime.cs1234/** * Using the stub IPA previously compiled on the Mac, create a new IPA with assets*/static public void RepackageIPAFromStub(); 该函数位于 iPhonePackager-CookTime 类中。 123456789101112static public void RepackageIPAFromStub()&#123; // ... string SourceDir = Path.GetFullPath(ZipSourceDir); string[] PayloadFiles = Directory.GetFiles(SourceDir, &quot;*.*&quot;, Config.bIterate ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories); foreach (string Filename in PayloadFiles) &#123; // read file to memory,add to ZipFileSystem // generate stub and ipa &#125; //...&#125; 需要做的操作就是介入这个过程，把 PayloadFiles 中的文件列表通过我们自定义的规则来执行过滤。 从流程上分为以下几个步骤： 从项目中读取 Filter 的配置 创建出真正的过滤器 在 RepackageIPAFromStub 遍历文件的流程里使用过滤器进行检测是否需要被打入 ipa 只需要几十行代码就可以实现，首先需要添加一个 IniReader 的类： 123456789101112131415161718192021222324252627using Tools.DotNETCommon;using System.Runtime.InteropServices;using Ini;namespace Ini&#123; public class IniReader &#123; private string path; [DllImport(&quot;kernel32&quot;)] private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath); public IniReader(string INIPath) &#123; path = INIPath; &#125; public string ReadValue(string Section, string Key) &#123; StringBuilder ReaderBuffer = new StringBuilder(255); int ret = GetPrivateProfileString(Section, Key, &quot;&quot;, ReaderBuffer, 255, this.path); return ReaderBuffer.ToString(); &#125; &#125;&#125; 然后在 RepackageIPAFromStub 函数中创建过滤器： 123456789101112131415161718FileFilter IpaPakFileFilter = new FileFilter(FileFilterType.Include);&#123; string ProjectDir = Directory.GetParent(Path.GetFullPath(Config.ProjectFile)).FullName; // Program.Log(&quot;ProjectDir path &#123;0&#125;&quot;, ProjectDir); string EngineIni = Path.Combine(ProjectDir,&quot;Config&quot;,&quot;DefaultEngine.ini&quot;); // Program.Log(&quot;EngineIni path &#123;0&#125;&quot;, EngineIni); IniReader EngineIniReader = new IniReader(EngineIni); // string RawPakFilterRules = EngineIniReader.ReadValue(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;, &quot;IPAFilters&quot;); Program.Log(&quot;RawPakFilterRules &#123;0&#125;&quot;, RawPakFilterRules); string[] PakRules = RawPakFilterRules.Split(&#x27;,&#x27;); // foreach(string Rule in PakRules) &#123;Program.Log(&quot;PakRules &#123;0&#125;&quot;, Rule);&#125; List&lt;string&gt; PakFilters = new List&lt;string&gt;(PakRules); if (PakFilters != null) &#123; IpaPakFileFilter.AddRules(PakFilters); &#125;&#125; 这里从项目的 Config/DefaultEngine.ini 的[/Script/IOSRuntimeSettings.IOSRuntimeSettings]项读取 IPAFilters 的值，规则与 Android 相同，但是要把规则都写在一行，多个规则以逗号分隔。 12[/Script/IOSRuntimeSettings.IOSRuntimeSettings]IPAFilters=-*.pak,pakchunk0-* 最终，还需要在 RepackageIPAFromStub 遍历 Payload 文件的循环中进行检测是否匹配我们指定的过滤规则： 12345678910111213141516static public void RepackageIPAFromStub()&#123; // ... string SourceDir = Path.GetFullPath(ZipSourceDir); string[] PayloadFiles = Directory.GetFiles(SourceDir, &quot;*.*&quot;, Config.bIterate ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories); foreach (string Filename in PayloadFiles) &#123; if (!IpaPakFileFilter.Matches(Filename)) &#123; Program.Log(&quot;IpaPakFileFilter not match file &#123;0&#125;&quot;, Filename); continue; &#125; // Program.Log(&quot;IpaPakFileFilter match file &#123;0&#125;&quot;, Filename); &#125; //...&#125; 这样再执行打包 IOS，就会按照指定的过滤规则来添加文件了，实现了与 Android 上一致的行为。 打包过程中的 Log 如下（上文代码已注释）： 123456789101112131415161718192021222324Saving IPA ...ProjectDir path C:\\BuildAgent\\workspace\\PackageWindows\\ClientEngineIni path C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Config\\DefaultEngine.iniRawPakFilterRules -*.pak,pakchunk0-*PakRules -*.pakPakRules pakchunk0-*IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Assets.carIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Info.plistIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\LaunchScreenIOS.webpIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Manifest_DebugFiles_IOS.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Manifest_NonUFSFiles_IOS.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\mute.cafIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\ue4commandline.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\movies\\logo.mp4IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\movies\\sparkmore.mp4IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk0-ios.pakIpaPakFileFilter not match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk1-ios.pakIpaPakFileFilter not match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk2-ios.pakIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Engine\\Content\\SlateDebug\\Fonts\\LastResort.ttfIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\GCloudVoice.bundle\\files\\config.jsonIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\GCloudVoice.bundle\\files\\libwxvoiceembed.binIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\GCloudVoice.bundle\\files\\mute_detection.aiffIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\GRobotResource.bundle\\config.json... 可以看到，过滤规则已经生效了。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"资源调试命令","date":"2021-07-03T23:29:59.000Z","path":"wiki/11937/","text":"可以在 Console 中使用以下命令： 1obj list 会列出当前的资源加载信息： 12345678910111213141516171819202122 Class Count NumKB MaxKB ResExcKB ResExcDedSysKB ResExcShrSysKB ResExcDedVidKB ResExcShrVidKB ResExcUnkKB Class 4331 10240.85 12969.37 0.00 0.00 0.00 0.00 0.00 0.00 FontFace 9 9498.02 9498.02 9495.54 9495.54 0.00 0.00 0.00 0.00 MetaData 732 8441.93 8441.93 0.00 0.00 0.00 0.00 0.00 0.00 ScriptStruct 2165 3923.20 5156.56 0.00 0.00 0.00 0.00 0.00 0.00 SkeletalMesh 1 3988.86 3989.04 1974.06 30.55 0.00 0.00 0.00 1943.52 Function 7928 2012.63 2457.73 0.00 0.00 0.00 0.00 0.00 0.00 Package 732 1316.65 1453.87 0.00 0.00 0.00 0.00 0.00 0.00 Enum 1275 312.38 760.76 0.00 0.00 0.00 0.00 0.00 0.00 DeviceProfile 85 409.36 661.37 0.00 0.00 0.00 0.00 0.00 0.00 Material 103 418.41 467.83 4722.42 4722.42 0.00 0.00 0.00 0.00 ToolMenu 36 193.83 466.16 0.00 0.00 0.00 0.00 0.00 0.00 DelegateFunction 652 165.51 185.93 0.00 0.00 0.00 0.00 0.00 0.00 Texture2D 146 111.05 111.05 56192.00 0.00 0.00 56192.00 0.00 0.00 MaterialExpressionMultiply 194 66.84 98.67 0.00 0.00 0.00 0.00 0.00 0.00 StaticMesh 29 77.02 98.41 2055.31 23.56 0.00 0.00 0.00 2031.75MaterialExpressionTextureSample 61 44.87 79.66 0.00 0.00 0.00 0.00 0.00 0.00 MaterialExpressionCustom 68 59.53 70.68 0.00 0.00 0.00 0.00 0.00 0.00 MaterialInstanceDynamic 32 53.74 65.76 16.45 16.45 0.00 0.00 0.00 0.00 GameNetworkMgr 1 64.43 64.43 0.00 0.00 0.00 0.00 0.00 0.00 BodySetup 41 42.91 62.30 1158.44 1158.44 0.00 0.00 0.00 0.00 MaterialExpressionConstant 153 36.16 61.26 0.00 0.00 0.00 0.00 0.00 0.00 还有下列相关的命令： 123456789101112131415Mem FromReportobj list -alphasortrhi.DumpMemoryLogOutStatLevelsListSpawnedActorsDumpParticleMemConfigMemr.DumpRenderTargetPoolMemoryListTextures -alphasortListSounds -alphasortListParticleSystems -alphasortobj list class=SoundWave -alphasortobj list class=SkeletalMesh -alphasortobj list class=StaticMesh -alphasortobj list class=Level -alphasort 也可以使用 memreport 来进行详细的分析： 1memreport -full 会在 Saved/Profiling/MemReports 下创建 .memreport 文件。 Debugging and Optimizing Memory Limitations of memory tracking features in Unreal Engine 4","tags":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"UE4 中 ES3.1 的 75 根骨骼限制","date":"2021-07-03T23:28:43.000Z","path":"wiki/11689/","text":"之前提到过在 ES2.0 上使用单个材质蒙皮的骨骼不能超过 75 根，在 ES3 之后就没有这个限制了，但是 UE 里目前还有这个限制。 Warning: SkeletalMesh SK_m0146b0003, is not supported for current feature level (ES3_1) and will not be rendered. NumBones 78 (supported 75), NumBoneInfluences: 4 Runtime/RHI/Public/RHIDefinitions.h1234567891011121314inline int32 GetFeatureLevelMaxNumberOfBones(const FStaticFeatureLevel FeatureLevel)&#123; switch (FeatureLevel) &#123; case ERHIFeatureLevel::ES3_1: return 75; case ERHIFeatureLevel::SM5: return 65536; // supports uint16 default: checkf(0, TEXT(&quot;Unknown FeatureLevel %d&quot;), (int32)FeatureLevel); &#125; return 0;&#125; 看了下相关的代码，UE 在下面这次提交中修改了 ES3.1 原本 256 到 75，commit 里提到的是修复了 Mobile Preview 的 Crash: Fixed: Skeletal Mesh with more than 75 bones crashes Mobile Preview Limit ES3.1 to 75 bones like ES2. All ES3.1 feature level platforms use UB for Bones. Project has to set Compat.MAX_GPUSKIN_BONES=75 to support SkelMeshes with more than 75 bones for ES3.1 and ES2. 该代码在 4.21 Preview 4 中提交：Unreal Engine 4.21 Preview 在 answers 上也有一些相关的问题： Change ES3_1 bone number limit to 256","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"ES3","slug":"ES3","permalink":"https://ue5wiki.com/tags/ES3/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"DoesPackageExists 分析","date":"2021-07-03T23:26:33.000Z","path":"wiki/11264/","text":"该函数用来检测 Package 是否 在磁盘上存在： 12345678910111213class COREUOBJECT_API FPackageName&#123;public: /** * Checks if the package exists on disk. * * @param LongPackageName Package name. * @param OutFilename Package filename on disk. * @param InAllowTextFormats Detect text format packages as well as binary (priority to text) * @return true if the specified package name points to an existing package, false otherwise. **/ static bool DoesPackageExist(const FString&amp; LongPackageName, const FGuid* Guid = NULL, FString* OutFilename = NULL, bool InAllowTextFormats = true);&#125;; 注意：在磁盘上存在在 UE 里有两个情况： Editor 下存在 uasset 文件 打包模式下 uasset 是否在 Mounted 的 Pak 中存在 事实上，UE 也是这么做检测的： 首先把要检测的 LongPackageName 根据规则转换为文件路径 通过 FileManager 来检测文件路径是否存在 在 Editor 和打包模式下，FileManager 通过 GetLowLevel() 拿到IPlatformFile，之后再进行 FileExist 的检测，UE 针对各个平台封装了IPlatformFile，而且也具有 PakPlatformFile 的实现，可以实现从 Pak 中读取文件与在普通文件系统中访问一样的接口。 UE 的跨平台写法，声明在通用接口里，定义在各个平台的单独文件中： 在引擎启动时会把这些 IPlatformFile 的对象创建： Runtime/Launch/Private/LaunchEngineLoop.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** * Look for any file overrides on the command line (i.e. network connection file handler) */bool LaunchCheckForFileOverride(const TCHAR* CmdLine, bool&amp; OutFileOverrideFound)&#123; OutFileOverrideFound = false; // Get the physical platform file. IPlatformFile* CurrentPlatformFile = &amp;FPlatformFileManager::Get().GetPlatformFile(); // Try to create pak file wrapper &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;PakFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;CachedReadFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; // Try to create sandbox wrapper &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;SandboxFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125;#if !UE_BUILD_SHIPPING // UFS clients are not available in shipping builds. // Streaming network wrapper (it has a priority over normal network wrapper) bool bNetworkFailedToInitialize = false; do &#123; bool bShouldUseStreamingFile = false; IPlatformFile* NetworkPlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;StreamingFile&quot;), CurrentPlatformFile, CmdLine, &amp;bNetworkFailedToInitialize, &amp;bShouldUseStreamingFile); if (NetworkPlatformFile) &#123; CurrentPlatformFile = NetworkPlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; bool bShouldUseCookedIterativeFile = false; if (!bShouldUseStreamingFile &amp;&amp; !NetworkPlatformFile) &#123; NetworkPlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;CookedIterativeFile&quot;), CurrentPlatformFile, CmdLine, &amp;bNetworkFailedToInitialize, &amp;bShouldUseCookedIterativeFile); if (NetworkPlatformFile) &#123; CurrentPlatformFile = NetworkPlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; // if streaming network platform file was tried this loop don&#x27;t try this one // Network file wrapper (only create if the streaming wrapper hasn&#x27;t been created) if (!bShouldUseStreamingFile &amp;&amp; !bShouldUseCookedIterativeFile &amp;&amp; !NetworkPlatformFile) &#123; NetworkPlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;NetworkFile&quot;), CurrentPlatformFile, CmdLine, &amp;bNetworkFailedToInitialize); if (NetworkPlatformFile) &#123; CurrentPlatformFile = NetworkPlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; if (bNetworkFailedToInitialize) &#123; FString HostIpString; FParse::Value(CmdLine, TEXT(&quot;-FileHostIP=&quot;), HostIpString);#if PLATFORM_REQUIRES_FILESERVER FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Failed to connect to file server at %s. RETRYING in 5s.\\n&quot;), *HostIpString); FPlatformProcess::Sleep(5.0f); uint32 Result = 2;#else //PLATFORM_REQUIRES_FILESERVER // note that this can&#x27;t be localized because it happens before we connect to a filserver - localizing would cause ICU to try to load.... from over the file server connection! FString Error = FString::Printf(TEXT(&quot;Failed to connect to any of the following file servers:\\n\\n %s\\n\\nWould you like to try again? No will fallback to local disk files, Cancel will quit.&quot;), *HostIpString.Replace(TEXT(&quot;+&quot;), TEXT(&quot;\\n &quot;))); uint32 Result = FMessageDialog::Open(EAppMsgType::YesNoCancel, FText::FromString(Error) );#endif //PLATFORM_REQUIRES_FILESERVER if (Result == EAppReturnType::No) &#123; break; &#125; else if (Result == EAppReturnType::Cancel) &#123; // Cancel - return a failure, and quit return false; &#125; &#125; &#125; while (bNetworkFailedToInitialize);#endif#if !UE_BUILD_SHIPPING // Try to create file profiling wrapper &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;ProfileFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;SimpleProfileFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; // Try and create file timings stats wrapper &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;FileReadStats&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; // Try and create file open log wrapper (lists the order files are first opened) &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;FileOpenLog&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125;#endif //#if !UE_BUILD_SHIPPING // Wrap the above in a file logging singleton if requested &#123; IPlatformFile* PlatformFile = ConditionallyCreateFileWrapper(TEXT(&quot;LogFile&quot;), CurrentPlatformFile, CmdLine); if (PlatformFile) &#123; CurrentPlatformFile = PlatformFile; FPlatformFileManager::Get().SetPlatformFile(*CurrentPlatformFile); &#125; &#125; // If our platform file is different than it was when we started, then an override was used OutFileOverrideFound = (CurrentPlatformFile != &amp;FPlatformFileManager::Get().GetPlatformFile()); return true;&#125;","tags":[{"name":"Package","slug":"Package","permalink":"https://ue5wiki.com/tags/Package/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"DDC 共享","date":"2021-07-03T23:25:19.000Z","path":"wiki/11023/","text":"共享 DDC 的作用是：当同一网络内共享 DDC 的人只要有一个人编译了 DDC，其他人就无需重新编译，节省 Shader 的编译时间，提高效率。 所以，一般情况下只需要在局域网内部署一个高 IO 吞吐的机器，每个人都把该机器的共享目录挂载到本地，就可以实现 DDC 的共享，因为 DDC 的目录是相对于网络路径的，所以每个人的修改都会影响到其他人，从而实现一个编译多人共享的效果。 UE 的文档里介绍了三种设置的方法： Derived Data Cache 修改 DefaultEngine.ini 添加 DerivedDataBackendGraph 项； 系统中添加 UE-SharedDataCachePath 环境变量； 在 UE 的 Editor Preferences-Global-Shared Derived Data Cache 设置共享的 DDC 目录； UE 推荐的是使用第一种方法，但是具体实践和文档中介绍的略有不同。 对于源码版引擎，使用 DDC 文档中介绍的第一种方法，在项目的 DefaultEngine.ini 中添加以下项： DefaultEngine.ini12[DerivedDataBackendGraph]Shared=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, DeleteUnused=true, UnusedFileAge=10, FoldersToClean=10, MaxFileChecksPerSec=1, ConsiderSlowAt=70, PromptIfMissing=false, Path=\\\\YourDDCServer\\DDC, EnvPathOverride=UE-SharedDataCachePath, EditorOverrideSetting=SharedDerivedDataCache) 但是对于安装版引擎（Installed），要把 DerivedDataBackendGraph 改成InstalledDerivedDataBackendGraph： DefaultEngine.ini12[InstalledDerivedDataBackendGraph]Shared=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, DeleteUnused=true, UnusedFileAge=10, FoldersToClean=10, MaxFileChecksPerSec=1, ConsiderSlowAt=70, PromptIfMissing=false, Path=\\\\YourDDCServer\\FMGame\\DDC, EnvPathOverride=UE-SharedDataCachePath, EditorOverrideSetting=SharedDerivedDataCache) 这是因为引擎在 Developer/DerivedDataCache/Private/DerivedDataBackends.cpp 中对安装版和源码版做了区分： 1234567891011FDerivedDataBackendGraph() // ...&#123; // ... if(!RootCache) &#123; // Use default graph GraphName = FApp::IsEngineInstalled() ? TEXT(&quot;InstalledDerivedDataBackendGraph&quot;) : TEXT(&quot;DerivedDataBackendGraph&quot;); // ... &#125;&#125;; 在设置完之后就可以通过 Commandlet 来执行 DDC 的生成了： 1Engine\\Binaries\\Win64\\UE4Editor.exe Client\\Client.uproject -run=DerivedDataCache -fill 该 Commandlet 定义在Editor/UnrealEd/Classes/Commandlets/DerivedDataCacheCommandlet.h。 如果想要在配置文件添加之后关闭掉 DDC，可以在 Editor 启动时添加参数-ddc=noshared。","tags":[{"name":"DDC","slug":"DDC","permalink":"https://ue5wiki.com/tags/DDC/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"DDC","slug":"Engine/DDC","permalink":"https://ue5wiki.com/categories/Engine/DDC/"}]},{"title":"代码编译时执行脚本","date":"2021-07-03T23:23:58.000Z","path":"wiki/10758/","text":"在插件的 uplugin 文件中可以写入 PreBuildSteps/PostBuildSteps 以下两个元素： 12345678910111213&#123; &quot;PostBuildSteps&quot;: &#123; &quot;Win64&quot;: [ &quot;\\&quot;$(PluginDir)\\\\Source\\\\AkAudio\\\\WwisePostBuildSteps.bat\\&quot; \\&quot;$(EngineDir)\\\\Binaries\\\\Win64\\\\UE4Editor-cmd.exe\\&quot; \\&quot;$(ProjectFile)\\&quot; $(TargetType) -run=AkPluginActivator -platform=$(TargetPlatform) -configuration=Profile -targetconfig=$(TargetConfiguration)&quot; ], &quot;PS4&quot;: [ &quot;\\&quot;$(PluginDir)\\\\Source\\\\AkAudio\\\\WwisePostBuildSteps.bat\\&quot; \\&quot;$(EngineDir)\\\\Binaries\\\\Win64\\\\UE4Editor-cmd.exe\\&quot; \\&quot;$(ProjectFile)\\&quot; -run=AkPluginActivator -platform=$(TargetPlatform) -configuration=Profile -targetconfig=$(TargetConfiguration)&quot; ] &#125;&#125; 可以在构建时指定自动执行一个脚本，用来处理一些特殊的功能。 ProjectDescriptor的声明：Source\\Programs\\UnrealBuildTool\\System\\ProjectDescriptor.cs 在 UBT 的 Source\\Programs\\UnrealBuildTool\\Configuration\\UEBuildTarget.cs 中被解析: Source\\Programs\\UnrealBuildTool\\Configuration\\UEBuildTarget.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// Creates scripts for executing the pre-build scripts/// &lt;/summary&gt;public FileReference[] CreatePreBuildScripts() &#123; // Find all the pre-build steps List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; PreBuildCommandBatches = new List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; (); if (ProjectDescriptor != null &amp;&amp; ProjectDescriptor.PreBuildSteps != null) &#123; AddCustomBuildSteps(ProjectDescriptor.PreBuildSteps, null, PreBuildCommandBatches); &#125; if (Rules.PreBuildSteps.Count &gt; 0) &#123; PreBuildCommandBatches.Add(new Tuple &lt; string[], UEBuildPlugin &gt; (Rules.PreBuildSteps.ToArray(), null)); &#125; foreach(UEBuildPlugin BuildPlugin in BuildPlugins.Where(x =&gt;x.Descriptor.PreBuildSteps != null)) &#123; AddCustomBuildSteps(BuildPlugin.Descriptor.PreBuildSteps, BuildPlugin, PreBuildCommandBatches); &#125; return WriteCustomBuildStepScripts(BuildHostPlatform.Current.Platform, ProjectIntermediateDirectory, &quot;PreBuild&quot;, PreBuildCommandBatches);&#125;/// &lt;summary&gt;/// Creates scripts for executing post-build steps/// &lt;/summary&gt;/// &lt;returns&gt;Array of post-build scripts&lt;/returns&gt;private FileReference[] CreatePostBuildScripts() &#123; // Find all the post-build steps List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; PostBuildCommandBatches = new List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; (); if (!Rules.bDisableLinking) &#123; if (ProjectDescriptor != null &amp;&amp; ProjectDescriptor.PostBuildSteps != null) &#123; AddCustomBuildSteps(ProjectDescriptor.PostBuildSteps, null, PostBuildCommandBatches); &#125; if (Rules.PostBuildSteps.Count &gt; 0) &#123; PostBuildCommandBatches.Add(new Tuple &lt; string[], UEBuildPlugin &gt; (Rules.PostBuildSteps.ToArray(), null)); &#125; foreach(UEBuildPlugin BuildPlugin in BuildPlugins.Where(x =&gt;x.Descriptor.PostBuildSteps != null)) &#123; AddCustomBuildSteps(BuildPlugin.Descriptor.PostBuildSteps, BuildPlugin, PostBuildCommandBatches); &#125; &#125; return WriteCustomBuildStepScripts(BuildHostPlatform.Current.Platform, ProjectIntermediateDirectory, &quot;PostBuild&quot;, PostBuildCommandBatches);&#125;/// &lt;summary&gt;/// Adds custom build steps from the given JSON object to the list of command batches/// &lt;/summary&gt;/// &lt;param name=&quot;BuildSteps&quot;&gt;The custom build steps&lt;/param&gt;/// &lt;param name=&quot;Plugin&quot;&gt;The plugin to associate with these commands&lt;/param&gt;/// &lt;param name=&quot;CommandBatches&quot;&gt;List to receive the command batches&lt;/param&gt;private void AddCustomBuildSteps(CustomBuildSteps BuildSteps, UEBuildPlugin Plugin, List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; CommandBatches) &#123; string[] Commands; if (BuildSteps.TryGetCommands(BuildHostPlatform.Current.Platform, out Commands)) &#123; CommandBatches.Add(Tuple.Create(Commands, Plugin)); &#125;&#125;/// &lt;summary&gt;/// Write scripts containing the custom build steps for the given host platform/// &lt;/summary&gt;/// &lt;param name=&quot;HostPlatform&quot;&gt;The current host platform&lt;/param&gt;/// &lt;param name=&quot;Directory&quot;&gt;The output directory for the scripts&lt;/param&gt;/// &lt;param name=&quot;FilePrefix&quot;&gt;Bare prefix for all the created script files&lt;/param&gt;/// &lt;param name=&quot;CommandBatches&quot;&gt;List of custom build steps, and their matching PluginInfo (if appropriate)&lt;/param&gt;/// &lt;returns&gt;List of created script files&lt;/returns&gt;private FileReference[] WriteCustomBuildStepScripts(UnrealTargetPlatform HostPlatform, DirectoryReference Directory, string FilePrefix, List &lt; Tuple &lt; string[], UEBuildPlugin &gt;&gt; CommandBatches) &#123; List &lt; FileReference &gt; ScriptFiles = new List &lt; FileReference &gt; (); foreach(Tuple &lt; string[], UEBuildPlugin &gt; CommandBatch in CommandBatches) &#123; // Find all the standard variables Dictionary &lt; string, string &gt; Variables = GetTargetVariables(CommandBatch.Item2); // Get the output path to the script string ScriptExtension = (HostPlatform == UnrealTargetPlatform.Win64) ? &quot;.bat&quot;: &quot;.sh&quot;; FileReference ScriptFile = FileReference.Combine(Directory, String.Format(&quot;&#123;0&#125;-&#123;1&#125;&#123;2&#125;&quot;, FilePrefix, ScriptFiles.Count + 1, ScriptExtension)); // Write it to disk List &lt; string &gt; Contents = new List &lt; string &gt; (); if (HostPlatform == UnrealTargetPlatform.Win64) &#123; Contents.Insert(0, &quot;@echo off&quot;); &#125; foreach(string Command in CommandBatch.Item1) &#123; Contents.Add(Utils.ExpandVariables(Command, Variables)); &#125; if (!DirectoryReference.Exists(ScriptFile.Directory)) &#123; DirectoryReference.CreateDirectory(ScriptFile.Directory); &#125; File.WriteAllLines(ScriptFile.FullName, Contents); // Add the output file to the list of generated scripts ScriptFiles.Add(ScriptFile); &#125; return ScriptFiles.ToArray();&#125; 在编译代码之后会执行指定的脚本，会有以下 Log： 12&gt;8&gt; Exec: PostBuild-1.bat.ran 注意：测试中发现如果插件的代码没有变动，它不会执行。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"UE 内置的 Release/Patch 分析","date":"2021-07-03T23:21:26.000Z","path":"wiki/10262/","text":"UE 的 Patch 有一些缺点： 无法精确地控制 Patch 包含的内容且不方便拆分。 无法进行迭代 Patch，不能直观预览资源信息。 无法方便地管理工程和 Patch 版本。 开发阶段无法方便地进行测试补丁打包。 具体操作是在 Project Launcher 中进行 Release 打包： Cook 时的命令： 1UE4Editor-Cmd.exe &quot;D:\\ThirdPerson425\\ThirdPerson425.uproject&quot; -run=Cook -TargetPlatform=WindowsNoEditor -fileopenlog -unversioned -createreleaseversion=1.0.0.0 -compressed -abslog=&quot;C:\\Program Files\\Epic Games\\UE_4.25\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2021.03.19-19.00.30.txt&quot; -stdout -CrashForUAT -unattended -NoLogTimes -UTF8Output 当打包成功后会在项目的根目录中创建出一个 Releases 目录，存储以下文件： 123456789D:\\ThirdPerson425\\Releases&gt;tree /a /fD:.\\---1.0.0.0 \\---WindowsNoEditor | AssetRegistry.bin | ThirdPerson425-WindowsNoEditor.pak | \\---Metadata DevelopmentAssetRegistry.bin 可以看到它的实现实际上是备份了当前打包版本的 AssetRegistry 文件，但经过分析发现，它并不会用来和后续的版本做比对，使用的是另一种方式。 在基于某个 Release 进行 Patch 时会自动把 AssetRegistry.bin 和 ushaderbytecode 包含到 pak 中（并且 shaderbytecode 并没有进行 patch）： 当基于某个基础版本进行 Patch 的时候，在 Project Launher 的设置如下： 执行流程中首先需要对项目进行 Cook，但是 Cook 时不需要指定任何版本信息： 123456789101112UE4Editor-Cmd.exe &quot;D:\\Project\\ThirdPerson425.uproject&quot; -run=Cook -TargetPlatform=WindowsNoEditor -fileopenlog -unversioned -abslog=&quot;C:\\Program Files\\Epic Games\\UE_4.25\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2021.03.22-15.29.04.txt&quot; -stdout -CrashForUAT -unattended -NoLogTimes -UTF8Output 当 Cook 完毕，执行 Pak 打包的时候，需要传入版本信息： 123456789101112UnrealPak.exe &quot;D:\\Projects\\ThirdPerson425.uproject&quot; &quot;D:\\Projects\\Package\\1.0.0.0_patch1\\WindowsNoEditor\\ThirdPerson425\\Content\\Paks\\ThirdPerson425-WindowsNoEditor_0_P.pak&quot; -create=&quot;C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.25\\PakList_ThirdPerson425-WindowsNoEditor_0_P.txt&quot; -cryptokeys=&quot;D:\\Projects\\Saved\\Cooked\\WindowsNoEditor\\ThirdPerson425\\Metadata\\Crypto.json&quot; -order=&quot;D:\\Projects\\Build\\WindowsNoEditor\\FileOpenOrder\\CookerOpenOrder.log&quot; -generatepatch=&quot;D:\\Projects\\Releases\\1.0.0.0\\WindowsNoEditor\\ThirdPerson425-WindowsNoEditor*.pak&quot; -tempfiles=&quot;C:\\Program Files\\Epic Games\\UE_4.25\\TempFilesThirdPerson425-WindowsNoEditor_0_P&quot; -patchpaddingalign=2048 -platform=Windows -multiprocess -abslog=&quot;C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.25\\UnrealPak-ThirdPerson425-WindowsNoEditor_0_P-2021.03.22-15.29.17.txt&quot; 注意： -create=传递进去的 Response 的 txt 中是包含整个项目的资源列表的，并非是差异的文件列表。(-create= 也可以传递 pak 文件，用来生成差异) 需要通过 -generatepatch= 传递基础包中的 pak 文件 读取基础版本包 pak 中所有文件，计算出每个文件的 hash 值 与 Response 中的资源进行比对，得到新加或者与基础包 pak 中 Hash 文件不同的文件列表 把差异部分打包至新的 pak 中。 执行时会加载基础包中 pak 的文件，计算 pak 中资源的 hash 值： 1234567891011121314151617LogPakFile: Display: Parsing crypto keys from a crypto key cache fileLogPakFile: Display: Loading response file C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.25\\PakList_ThirdPerson425-WindowsNoEditor_0_P.txtLogPakFile: Display: Added 1559 entries to add to pak file.LogPakFile: Display: Loading pak order file C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson425\\Build\\WindowsNoEditor\\FileOpenOrder\\CookerOpenOrder.log...LogPakFile: Display: Finished loading pak order file C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson425\\Build\\WindowsNoEditor\\FileOpenOrder\\CookerOpenOrder.log.LogPakFile: Display: Generating patch from C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson425\\Releases\\1.0.0.0\\WindowsNoEditor\\ThirdPerson425-WindowsNoEditor*.pak.LogPakFile: Display: Generated hash for &quot;Engine/Content/Animation/DefaultAnimBoneCompressionSettings.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/Animation/DefaultAnimCurveCompressionSettings.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/Animation/DefaultAnimBoneCompressionSettings.uexp&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/Animation/DefaultAnimCurveCompressionSettings.uexp&quot;LogPakFile: Display: Generated hash for &quot;Engine/GlobalShaderCache-PCD3D_SM5.bin&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/Functions/Engine_MaterialFunctions01/Opacity/CameraDepthFade.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/Functions/Engine_MaterialFunctions01/Opacity/CameraDepthFade.uexp&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/EngineMaterials/T_Default_Material_Grid_M.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/EngineMaterials/T_Default_Material_Grid_N.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/EngineMaterials/WorldGridMaterial.uasset&quot;LogPakFile: Display: Generated hash for &quot;Engine/Content/EngineMaterials/DefaultMaterial.uasset&quot; 生成 hash 的函数在 GenerateHashesFromPak 中，位于 PakFileUtilities/Private/PakFileUtilities.cpp 中。其作用是：读取基础包中的文件，计算 hash 值，用作与新 Cook 之后的文件进行比对。 核心的代码在以下部分： PakFileUtilities/Private/PakFileUtilities.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120bool ExecuteUnrealPak(const TCHAR* CmdLine)&#123; // ... // List of all items to add to pak file TArray&lt;FPakInputPair&gt; Entries; FPakCommandLineParameters CmdLineParameters; ProcessCommandLine(CmdLine, NonOptionArguments, Entries, CmdLineParameters); // ... if(NonOptionArguments.Num() &gt; 0) &#123; CheckAndReallocThreadPool(); // since this is for creation, we pass true to make it not look in LaunchDir FString PakFilename = GetPakPath(*NonOptionArguments[0], true); // List of all items to add to pak file TArray&lt;FPakInputPair&gt; Entries; FPakCommandLineParameters CmdLineParameters; ProcessCommandLine(CmdLine, NonOptionArguments, Entries, CmdLineParameters); FPakOrderMap OrderMap; FString ResponseFile; if (FParse::Value(CmdLine, TEXT(&quot;-order=&quot;), ResponseFile) &amp;&amp; !OrderMap.ProcessOrderFile(*ResponseFile)) &#123; return false; &#125; FString SecondaryResponseFile; if (FParse::Value(CmdLine, TEXT(&quot;-secondaryOrder=&quot;), SecondaryResponseFile) &amp;&amp; !OrderMap.ProcessOrderFile(*SecondaryResponseFile, true)) &#123; return false; &#125; int32 LowestSourcePakVersion = 0; TMap&lt;FString, FFileInfo&gt; SourceFileHashes; if (CmdLineParameters.GeneratePatch) &#123; FString OutputPath; if (!FParse::Value(CmdLine, TEXT(&quot;TempFiles=&quot;), OutputPath)) &#123; OutputPath = FPaths::GetPath(PakFilename) / FString(TEXT(&quot;TempFiles&quot;)); &#125; IFileManager::Get().DeleteDirectory(*OutputPath); // Check command line for the &quot;patchcryptokeys&quot; param, which will tell us where to look for the encryption keys that // we need to access the patch reference data FString PatchReferenceCryptoKeysFilename; FKeyChain PatchKeyChain; if (FParse::Value(FCommandLine::Get(), TEXT(&quot;PatchCryptoKeys=&quot;), PatchReferenceCryptoKeysFilename)) &#123; LoadKeyChainFromFile(PatchReferenceCryptoKeysFilename, PatchKeyChain); ApplyEncryptionKeys(PatchKeyChain); &#125; UE_LOG(LogPakFile, Display, TEXT(&quot;Generating patch from %s.&quot;), *CmdLineParameters.SourcePatchPakFilename, true ); if (!GenerateHashesFromPak(*CmdLineParameters.SourcePatchPakFilename, *PakFilename, SourceFileHashes, true, PatchKeyChain, /*Out*/LowestSourcePakVersion)) &#123; if (ExtractFilesFromPak(*CmdLineParameters.SourcePatchPakFilename, SourceFileHashes, *OutputPath, true, PatchKeyChain, nullptr) == false) &#123; UE_LOG(LogPakFile, Warning, TEXT(&quot;Unable to extract files from source pak file for patch&quot;)); &#125; else &#123; CmdLineParameters.SourcePatchDiffDirectory = OutputPath; &#125; &#125; ApplyEncryptionKeys(KeyChain); &#125; // Start collecting files TArray&lt;FPakInputPair&gt; FilesToAdd; CollectFilesToAdd(FilesToAdd, Entries, OrderMap, CmdLineParameters); if (CmdLineParameters.GeneratePatch) &#123; // We need to get a list of files that were in the previous patch(&#x27;s) Pak, but NOT in FilesToAdd TArray&lt;FPakInputPair&gt; DeleteRecords = GetNewDeleteRecords(FilesToAdd, SourceFileHashes); //if the patch is built using old source pak files, we need to handle the special case where a file has been moved between chunks but no delete record was created (this would cause a rogue delete record to be created in the latest pak), and also a case where the file was moved between chunks and back again without being changed (this would cause the file to not be included in this chunk because the file would be considered unchanged) if (LowestSourcePakVersion &lt; FPakInfo::PakFile_Version_DeleteRecords) &#123; int32 CurrentPatchChunkIndex = GetPakChunkIndexFromFilename(PakFilename); UE_LOG(LogPakFile, Display, TEXT(&quot;Some patch source paks were generated with an earlier version of UnrealPak that didn&#x27;t support delete records. checking for historic assets that have moved between chunks to avoid creating invalid delete records&quot;)); FString SourcePakFolder = FPaths::GetPath(CmdLineParameters.SourcePatchPakFilename); //remove invalid items from DeleteRecords and set &#x27;bForceInclude&#x27; on some SourceFileHashes ProcessLegacyFileMoves(DeleteRecords, SourceFileHashes, SourcePakFolder, FilesToAdd, CurrentPatchChunkIndex); &#125; FilesToAdd.Append(DeleteRecords); // if we are generating a patch here we remove files which are already shipped... RemoveIdenticalFiles(FilesToAdd, CmdLineParameters.SourcePatchDiffDirectory, SourceFileHashes, CmdLineParameters.SeekOptParams, CmdLineParameters.ChangedFilesOutputFilename); &#125; bool bResult = CreatePakFile(*PakFilename, FilesToAdd, CmdLineParameters, KeyChain); if (CmdLineParameters.GeneratePatch) &#123; FString OutputPath = FPaths::GetPath(PakFilename) / FString(TEXT(&quot;TempFiles&quot;)); // delete the temporary directory IFileManager::Get().DeleteDirectory(*OutputPath, false, true); &#125; GetDerivedDataCacheRef().WaitForQuiescence(true); return bResult; &#125;&#125; 通过分析 UE 的 Patch 机制可以知道，它的版本比对比较粗暴，是直接得到 Pak 中文件的二进制信息计算 Hash 值与当前工程中 Cook 之后的 HASH 值来进行比对的，本质上就是基于二进制的比对，这就需要管理好 DDC 等 COOK 之后生成的文件，我觉得这样是不合理的，所以 HotPatcher 是基于原始资源的 GUID 的比对。","tags":[{"name":"Release","slug":"Release","permalink":"https://ue5wiki.com/tags/Release/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"打包 IOS 签名错误排查","date":"2021-07-03T23:15:07.000Z","path":"wiki/41792/","text":"IOS 签名错误排查 在 Mac 上直接打包 iOS 时遇到以下错误： 123456789101112131415162020-09-27 19:23:48:778 : /usr/bin/codesign --force --sign 2C74981D1576F95021XXXXXXXXXXA7ECBD8A81A0 --entitlements /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Intermediate/ProjectFilesIOS/build/FGame.build/Development-iphoneos/FGame.build/FGame.app.xcent --timestamp=none /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Binaries/IOS/Payload/FGame.app2020-09-27 19:23:59:896 : /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Binaries/IOS/Payload/FGame.app: errSecInternalComponent2020-09-27 19:23:59:896 : Command /usr/bin/codesign failed with exit code 12020-09-27 19:23:59:896 : 2020-09-27 19:23:59:899 : ** BUILD FAILED **2020-09-27 19:23:59:899 : 2020-09-27 19:23:59:899 : The following build commands failed:2020-09-27 19:23:59:899 : CodeSign /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Binaries/IOS/Payload/FGame.app2020-09-27 19:23:59:900 : (1 failure)2020-09-27 19:23:59:915 : Took 15.181822s to run env, ExitCode=652020-09-27 19:23:59:920 : ERROR: CodeSign Failed2020-09-27 19:23:59:920 : (see /Users/buildmachine/Library/Logs/Unreal Engine/LocalBuildLogs/BuildCookRun/Log.txt for full exception trace)2020-09-27 19:23:59:922 : AutomationTool exiting with ExitCode=32 (Error_FailedToCodeSign)2020-09-27 19:23:59:962 : Took 568.832115s to run mono, ExitCode=322020-09-27 19:23:59:974 : AutomationTool exiting with ExitCode=1 (Error_Unknown)2020-09-27 19:24:00:010 : RunUAT ERROR: AutomationTool was unable to run successfully. 可以看到是执行 codesign 的时候遇到了错误导致打包失败的。 这是因为打包时会访问钥匙串，需要输入密码授权，如果弹窗之后没有授权就会导致 codesign 执行失败。Stack overflow 上有相同的问题：Xcode Command /usr/bin/codesign failed with exit code 1 : errSecInternalComponent 解决方案有三种： 在打包时的弹窗中输入密码解锁钥匙串 在打包之前的解锁钥匙串 在弹窗中输入密码后选择始终允许 codesign 访问钥匙串 解锁钥匙串使用以下终端命令： 1$ security unlock-keychain login.keychain No certificate for team xxxx matching如果有以下错误提示： 1Code Signing Error: No certificate for team &#x27;9TV4ZYSS4J&#x27; matching &#x27;iPhone Developer: Created via API (JDPXHYVWYZ)&#x27; found: Select a different signing certificate for CODE_SIGN_IDENTITY, a team that matches your selected certificate, or switch to autom atic provisioning. 解决办法： 在 Mac 上的 ~/Library/MobileDevice/Provisioning\\ Profiles 清理掉多余的 mobileprovision 文件。 在 Mac 钥匙串中清理掉过期的开发者证书 重新导入 mobileprovision 与证书 注意：导入的 mobileprovision 的文件命名要与在 BaseEngine.ini 中指定的 MobileProvision 相同。 errSecInternalComponent 错误 Xcode Command /usr/bin/codesign failed with exit code 1 : errSecInternalComponent iOS 远程自动打包问题 How to Fix iOS Application Code Signing Error? 是因为通过 ssh 去调用 /usr/bin/codesign 访问钥匙串没有权限，可以使用以下命令在 ssh 中执行解锁： 1security unlock-keychain -p password login.keychain 在 UE 远程构建时，可以先执行这条命令在当前的 ssh 环境下解锁 keychain，使后面的签名可以正常执行。修改 UE 中的 Engine\\Build\\BatchFiles\\Mac\\Build.sh 文件，在调用 UBT 编译之前，写入以下内容： 1234567891011121314151617181920212223#!/bin/shcd &quot;`dirname &quot;$0&quot;`/../../../..&quot;# Setup Monosource Engine/Build/BatchFiles/Mac/SetupMono.sh Engine/Build/BatchFiles/Macif [&quot;$4&quot; == &quot;-buildscw&quot; ] || [&quot;$5&quot; == &quot;-buildscw&quot; ]; then echo Building ShaderCompileWorker... mono Engine/Binaries/DotNET/UnrealBuildTool.exe ShaderCompileWorker Mac Developmentfiecho unlock mac keychain...security unlock-keychain -p password login.keychainecho Running command : Engine/Binaries/DotNET/UnrealBuildTool.exe &quot;$@&quot;mono Engine/Binaries/DotNET/UnrealBuildTool.exe &quot;$@&quot;ExitCode=$?if [$ExitCode -eq 254 ] || [$ExitCode -eq 255 ] || [$ExitCode -eq 2 ]; then exit 0else exit $ExitCodefi 因为编译时会把 Build.sh 通过 RSync 传递到 Mac 上，所以可以看到以下 log: 1234567891011[Remote] Executing build Running bundled mono, ue_version: Mono JIT compiler version 5.16.0.220 (2018-06/bb3ae37d71a Fri Nov 16 17:12:11 EST 2018) unlock mac keychain... Running command : Engine/Binaries/DotNET/UnrealBuildTool.exe UnrealHeaderTool Mac Development -SkipRulesCompile -XmlConfigCache=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Intermediate/Build/XmlConfigCache.bin -precompile -allmodules -Log=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Programs/AutomationTool/Saved/Logs/UBT-UnrealHeaderTool-Mac-Development_Remote.txt -Manifest=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Intermediate/Remote/UnrealHeaderTool/Mac/Development/Manifest.xml Target is up to date Deploying UnrealHeaderTool Mac Development... Deploying now! Total execution time: 1.01 seconds[Remote] Downloading C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Remote\\UnrealHeaderTool\\Mac\\Development\\Manifest.xml[Remote] Downloading build products receiving file list ... done 这样每次编译都会解锁 keychain，从而避免 ssh 连接时没有访问 codesign 导致的签名错误。 注意：也需要排查 BaseEngine.ini 中 SigningCertificate 的值是否被指定。 Invalid trust settings.如果 Log 中出现以下错误： 12Code Signing Error: Invalid trust settings. Restore system default trust settings for certificate &quot;iPhone Developer: Created via API (JDPXHYVWYZ)&quot; in order to sign code with it.Code Signing Error: Code signing is required for product type &#x27;Application&#x27; in SDK &#x27;iOS 13.6&#x27; 这是因为在 Mac 上的钥匙串中对证书的设置被修改为了 始终信任 ，修改回 使用系统默认 即可。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"codesign","slug":"codesign","permalink":"https://ue5wiki.com/tags/codesign/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"TargetRules 导入证书和 Provision","date":"2021-07-03T23:13:36.000Z","path":"wiki/41495/","text":"传统的打包 ios 时，需要手动在 Project Settings-Platforms-IOS 中选择打包要使用的 Certificate 和Provision，当需要切换打包 Configuration 的时候就需要打开编辑器重新选择一遍（因为 Development 和 Shipping 用到的证书不同），很麻烦，我是一个非常讨厌做重复操作的人，所以研究了一下解决了这个问题。也是得益于 UE 本身提供了代码中导入 Certificate 和Provision的方式（之前我还写了自动化把证书导入到系统中，其实不用了）。在前面的笔记中提到过 UE 的 Target 也提供了平台相关的 Target 对象：平台相关 Target，要实现本文提到的需求就要通过控制 IOSPlatform 来实现。 IOSPlatform提供了以下几个属性： 12345678910111213141516171819// UnrealBuildTool/Platform/UEBuildIOS.cs/// &lt;summary&gt;/// Manual override for the provision to use. Should be a full path./// &lt;/summary&gt;[CommandLine(&quot;-ImportProvision=&quot;)]public string ImportProvision = null;/// &lt;summary&gt;/// Imports the given certificate (inc private key) into a temporary keychain before signing./// &lt;/summary&gt;[CommandLine(&quot;-ImportCertificate=&quot;)]public string ImportCertificate = null;/// &lt;summary&gt;/// Password for the imported certificate/// &lt;/summary&gt;[CommandLine(&quot;-ImportCertificatePassword=&quot;)]public string ImportCertificatePassword = null; 通过操作它们的值来实现自动化导入证书和 Provision，我写了一段使用代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class FGameTarget : TargetRules&#123; public FGameTarget( TargetInfo Target) : base(Target) &#123; Type = TargetType.Game; DefaultBuildSettings = BuildSettingsVersion.V1; ExtraModuleNames.AddRange(new string[] &#123; &quot;FGame&quot; &#125; ); // for package dSYM bDisableDebugInfo = true; if(Target.Platform == UnrealTargetPlatform.IOS) &#123; DirectoryReference ProjectDir = ProjectFile.Directory; IOSPlatform.bGeneratedSYM = true; string PackageConfiguration = &quot;&quot;; // import cer/provision switch (Target.Configuration) &#123; case UnrealTargetConfiguration.Debug: case UnrealTargetConfiguration.Development: case UnrealTargetConfiguration.Test: &#123; PackageConfiguration = &quot;Development&quot;; IOSPlatform.bForDistribution = false; break; &#125;; case UnrealTargetConfiguration.Shipping: &#123; PackageConfiguration = &quot;Distibution&quot;; IOSPlatform.bForDistribution = true; break; &#125;; &#125; string cerPath = Path.Combine(ProjectDir.FullName, &quot;Source/ThirdParty/iOS/&quot;,PackageConfiguration,&quot;XXXXXX_IOS.p12&quot;); string proversionPath = Path.Combine(ProjectDir.FullName, &quot;Source/ThirdParty/iOS/&quot;,PackageConfiguration,&quot;com.tencent.xxxx.xx_SignProvision.mobileprovision&quot;); string cerPassword = &quot;password&quot;; Console.WriteLine(&quot;Import Certificate:&quot;+cerPath); Console.WriteLine(&quot;Import Provision:&quot;+proversionPath); if (File.Exists(cerPath) &amp;&amp; File.Exists(proversionPath)) &#123; Console.WriteLine(&quot;Import Certificate &amp; Provision set to IOSPlatform&quot;); IOSPlatform.ImportCertificate = cerPath; IOSPlatform.ImportProvision = proversionPath; IOSPlatform.ImportCertificatePassword = cerPassword; &#125; &#125; &#125;&#125; 在打包 IOS 时就会自动使用所指定的证书了，并且会在 Shipping 时自动化启用 Distribution，这样就可以避免要事先把证书和provision 导入到系统中。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"WITH_EDITOR 包裹反射属性的问题","date":"2021-07-03T23:11:29.000Z","path":"wiki/41080/","text":"有时只想要一些属性在编辑器下存在，打包时不需要，按照常规的思路，需要对这些属性使用 WITH_EDITOR 包裹： 1234#if WITH_EDITOR UPROPERTY() int32 ival;#endif 这个代码在 Editor 的 Configuration 下没有问题，但是一旦编译非 Editor 就会产生如下错误： 1ERROR: Build/Win64/FGame/Inc/FGame/NetActor.gen.cpp(97): error C2039: &#x27;ival&#x27;: is not a member of &#x27;ANetActor&#x27; 那么，既然我们明明已经用 WITH_EDITOR 包裹了 ival 的属性，为什么在编译非 Editor 的时候 UHT 还会为这个属性生成反射代码呢？这个问题涉及到了以下几个概念： gen.cpp 中是 UHT 为反射标记的类和属性生成的反射信息 UHT 的生成流程在调用编译器之前 UE 构建系统的流程我之前做过分析：Build flow of the Unreal Engine4 project 因为 C++ 的宏是在调用编译器后预处理阶段做的事情，在执行 UHT 时，压根不会检测宏条件，所以上面的代码，UHT 依然会为 ival 生成反射信息到 gen.cpp 中，而 UHT 执行完毕之后进入编译阶段 WITH_EDITOR 会参与预处理，ival因此在类定义中不存在，但是 UHT 已经为它生成了反射代码，会通过获取成员函数指针的方式访问到它，进而产生了上述的编译错误。 所以这是 UE 反射代码生成先于预处理造成的问题，在写代码时是比较反直觉的。但是这个问题也并非不能解决，UE 提供了 WITH_EDITORONLY_DATA 宏来专门处理这个问题，一个宏解决不了，就引入一个新的。 但是为什么 WITH_EDITOR 不可以，而 WITH_EDITORONLY_DATA 就可以呢？因为 UHT 在生成反射代码时为 WITH_EDITORONLY_DATA 做了特殊检测： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void FNativeClassHeaderGenerator::ExportProperties(FOutputDevice&amp; Out, UStruct* Struct, int32 TextIndent)&#123; FProperty* Previous = NULL; FProperty* PreviousNonEditorOnly = NULL; FProperty* LastInSuper = NULL; UStruct* InheritanceSuper = Struct-&gt;GetInheritanceSuper(); // Find last property in the lowest base class that has any properties UStruct* CurrentSuper = InheritanceSuper; while (LastInSuper == NULL &amp;&amp; CurrentSuper) &#123; for(TFieldIterator&lt;FProperty&gt; It(CurrentSuper,EFieldIteratorFlags::ExcludeSuper); It; ++It ) &#123; FProperty* Current = *It; // Disregard properties with 0 size like functions. if(It.GetStruct() == CurrentSuper &amp;&amp; Current-&gt;ElementSize) &#123; LastInSuper = Current; &#125; &#125; // go up a layer in the hierarchy CurrentSuper = CurrentSuper-&gt;GetSuperStruct(); &#125; FMacroBlockEmitter WithEditorOnlyData(Out, TEXT(&quot;WITH_EDITORONLY_DATA&quot;)); // Iterate over all properties in this struct. for(TFieldIterator&lt;FProperty&gt; It(Struct, EFieldIteratorFlags::ExcludeSuper); It; ++It ) &#123; FProperty* Current = *It; // Disregard properties with 0 size like functions. if (It.GetStruct() == Struct) &#123; WithEditorOnlyData(Current-&gt;IsEditorOnlyProperty()); // Export property specifiers // Indent code and export CPP text. &#123; FUHTStringBuilder JustPropertyDecl; const FString* Dim = GArrayDimensions.Find(Current); Current-&gt;ExportCppDeclaration(JustPropertyDecl, EExportedDeclaration::Member, Dim ? **Dim : NULL); ApplyAlternatePropertyExportText(*It, JustPropertyDecl, EExportingState::TypeEraseDelegates); // Finish up line. Out.Logf(TEXT(&quot;%s%s;\\r\\n&quot;), FCString::Tab(TextIndent + 1), *JustPropertyDecl); &#125; LastInSuper = NULL; Previous = Current; if (!Current-&gt;IsEditorOnlyProperty()) &#123; PreviousNonEditorOnly = Current; &#125; &#125; &#125;&#125; 看下 FMacroBlockEmitter 的定义： 123456789101112131415161718192021222324252627282930313233343536373839struct FMacroBlockEmitter&#123; explicit FMacroBlockEmitter(FOutputDevice&amp; InOutput, const TCHAR* InMacro) : Output(InOutput) , bEmittedIf(false) , Macro(InMacro) &#123; &#125; ~FMacroBlockEmitter() &#123; if (bEmittedIf) &#123; Output.Logf(TEXT(&quot;#endif // %s\\r\\n&quot;), Macro); &#125; &#125; void operator()(bool bInBlock) &#123; if (!bEmittedIf &amp;&amp; bInBlock) &#123; Output.Logf(TEXT(&quot;#if %s\\r\\n&quot;), Macro); bEmittedIf = true; &#125; else if (bEmittedIf &amp;&amp; !bInBlock) &#123; Output.Logf(TEXT(&quot;#endif // %s\\r\\n&quot;), Macro); bEmittedIf = false; &#125; &#125; FMacroBlockEmitter(const FMacroBlockEmitter&amp;) = delete; FMacroBlockEmitter&amp; operator=(const FMacroBlockEmitter&amp;) = delete;private: FOutputDevice&amp; Output; bool bEmittedIf; const TCHAR* Macro;&#125;; 当生成代码时会为使用 WITH_EDITORONLY_DATA 包裹的属性在 gen.cpp 中添加 WITH_EDITORONLY_DATA 宏（有点套娃的感觉），使 gen.cpp 在非 EDITOR 下编译时也不会把这部分反射代码参与真正的编译，从而解决了上面的问题。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"跨 Level 选择 Actor","date":"2021-07-03T23:06:08.000Z","path":"wiki/40032/","text":"在场景中，美术和游戏逻辑是区分开的，所以有时候需要程序关卡去操控美术关卡的对象，但是 UE 的不同关卡其实是不同的资源，属于不同的 Pacakge，是不能直接跨关卡来选择对象实例的。选择时会有以下错误： 1LogProperty: Warning: Illegal TEXT reference to a private object in external package (StaticMeshActor /Game/Test/Map/Level_Sub2.Level_Sub2:PersistentLevel.Cube_2) from referencer (BP_AActor_C /Game/Test/Map/Level_Sub1.Level_Sub1:PersistentLevel.BP_AActor_2). Import failed... 这是因为在 PropertyBaseObject.cpp 的FObjectPropertyBase::ImportText_Internal中对 Object 属性是否可以跨关卡做了检测： 123456789101112131415UObject* FObjectPropertyBase::FindImportedObject(const FProperty* Property, UObject* OwnerObject, UClass* ObjectClass, UClass* RequiredMetaClass, const TCHAR* Text, uint32 PortFlags/*=0*/, FUObjectSerializeContext* InSerializeContext /*= nullptr*/, bool bAllowAnyPackage /*= true*/)&#123; // ... // if we found an object, and we have a parent, make sure we are in the same package if the found object is private, unless it&#x27;s a cross level property if (Result &amp;&amp; !Result-&gt;HasAnyFlags(RF_Public) &amp;&amp; OwnerObject &amp;&amp; Result-&gt;GetOutermost() != OwnerObject-&gt;GetOutermost()) &#123; const FObjectPropertyBase* ObjectProperty = CastField&lt;const FObjectPropertyBase&gt;(Property); if (!ObjectProperty || !ObjectProperty-&gt;AllowCrossLevel()) &#123; UE_LOG(LogProperty, Warning, TEXT(&quot;Illegal TEXT reference to a private object in external package (%s) from referencer (%s). Import failed...&quot;), *Result-&gt;GetFullName(), *OwnerObject-&gt;GetFullName()); Result = nullptr; &#125; &#125; // ...&#125; 其中 AllowCrossLevel 有两个继承类有覆写： 123456789101112131415// Runtime/CoreUObject/Private/UObject/PropertyBaseObject.cppbool FObjectPropertyBase::AllowCrossLevel() const&#123; return false;&#125;// Runtime/CoreUObject/Private/UObject/PropertyLazyObjectPtr.cppbool FLazyObjectProperty::AllowCrossLevel() const&#123; return true;&#125;// Runtime/CoreUObject/Private/UObject/PropertySoftObjectPtr.cppbool FSoftObjectProperty::AllowCrossLevel() const&#123; return true;&#125; 所以，不能够直接通过创建 FObjectPropertyBase 这种硬引用方式的属性从 SubLevel1 选择 SubLevel2 中的 Actor。那么如何解决这么问题呢？，上面已经列出了两个可以跨平台选择的属性，分别是 FLazyObjectProperty 和FSoftObjectProperty，那么以 FSoftObjectProperty 为例，可以通过 TSoftObjectPtr 来实现： 1TSoftObjectPtr&lt;AActor&gt; Actor; TSoftObjectPtr获取到的其实是 SubLevel2 中的资源的路径： 1/Game/Test/Map/Level_Sub2.Level_Sub2:PersistentLevel.Cube_2 在运行时访问需要使用以下操作来获取： 上面蓝图中节点 Load Asset Blocking 是UKismetSystemLibrary中的函数： 12345// Runtime/Engine/Private/KismetSystemLibrary.cppUObject* UKismetSystemLibrary::LoadAsset_Blocking(TSoftObjectPtr&lt;UObject&gt; Asset)&#123; return Asset.LoadSynchronous();&#125; 看来 UE 加载资源时，并没有区分真正的物理资源和场景中的实例，统一使用资源的路径来加载，这一点做的非常爽，可以把另一个关卡中的 Actor 当作资源来读取，并且获取的还就是运行时的那个实例，非常 Nice。","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}]},{"title":"添加外部库的注意事项","date":"2021-07-03T23:04:38.000Z","path":"wiki/39738/","text":"在添加外部的代码库时，需要关注以下几个问题： 纯代码的库，要测试是否具有平台相关的写法，需要同时支持 Win/Android/IOS/Mac 四个平台 对于 Android 的 so 要同时支持 arm64/armv7，打包时 so 文件的拷贝需要使用 UPL 执行 ios 的 .a 要同时具有 bitcode 和非 bitcode 版本，不然在 shipping 时如果开启了 bitcode，链接不支持 bitcode 的库会有链接错误的问题。 检测当前构建是否支持 bitcode 的流程： 12345678if (Target.IOSPlatform.bShipForBitcode)&#123; // add support bitcode lib&#125;&#123; // add not-support bitcode lib&#125; 在 Target.cs 中可以直接通过 IOSPlatform 获取当前构建是否支持 bitcode，在其他的 Module 中，可以通过 target.cs 中的 Target.IOSPlatform 获取。","tags":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/tags/ThirdParty/"}],"categories":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/categories/ThirdParty/"}]},{"title":"UE4.25.1 的 Assembly 路径错误","date":"2021-07-03T23:03:27.000Z","path":"wiki/39506/","text":"在 UE4.25.1 中，引擎生成的 Engine/Intermediate/Build/BuildRules/UE4Rules.dll 等文件具有路径错误。 具体的原因是在 UnrealBuildTool/System/RulesCompiler.cs 的CreateEngineOrEnterpriseRulesAssembly函数： 123456789101112131415161718192021// UE 4.25.1private static RulesAssembly CreateEngineOrEnterpriseRulesAssembly(RulesScope Scope, List&lt;DirectoryReference&gt; RootDirectories, string AssemblyPrefix, IReadOnlyList&lt;PluginInfo&gt; Plugins, bool bReadOnly, bool bSkipCompile, RulesAssembly Parent)&#123; // ... // Get the path to store any generated assemblies DirectoryReference AssemblyDir = RootDirectories[0]; if (UnrealBuildTool.IsFileInstalled(FileReference.Combine(AssemblyDir, AssemblyPrefix))) &#123; DirectoryReference UserDir = Utils.GetUserSettingDirectory(); if (UserDir != null) &#123; ReadOnlyBuildVersion Version = ReadOnlyBuildVersion.Current; AssemblyDir = DirectoryReference.Combine(UserDir, &quot;UnrealEngine&quot;, String.Format(&quot;&#123;0&#125;.&#123;1&#125;&quot;, Version.MajorVersion, Version.MinorVersion)); &#125; &#125; // Create the assembly FileReference EngineAssemblyFileName = FileReference.Combine(AssemblyDir, &quot;Intermediate&quot;, &quot;Build&quot;, &quot;BuildRules&quot;, AssemblyPrefix + &quot;Rules&quot; + FrameworkAssemblyExtension); RulesAssembly EngineAssembly = new RulesAssembly(Scope, RootDirectories, Plugins, ModuleFileToContext, new List&lt;FileReference&gt;(), EngineAssemblyFileName, bContainsEngineModules: true, DefaultBuildSettings: BuildSettingsVersion.Latest, bReadOnly: bReadOnly, bSkipCompile: bSkipCompile, Parent: Parent); //...&#125; 上面的代码中 AssemblyDir 是引擎目录，AssemblyPrefix是 UE4，拼接起来能够通过UnrealBuildTool.IsFileInstalled 的检测。但是，在 if 的代码块中，获取了用户目录，在 IOS 中就是： 1234# winC:\\Users\\lipengzha\\AppData\\Local\\UnrealEngine\\4.25# Mac/Users/buildmachine/Library/Application Support/Epic 拼接起来就是上面这两个 USER_DIR 的UnrealEngine/4.25/，在下面读取 Assembly 的流程中就会使用这个路径。 在使用 Win 的时候，其实没有问题，因为就算把 UE4Rules.dll 写入到用户目录下，在 Win 上同样是可以访问到的。但是 ，在使用 Win 远程构建 IOS 的时候就会出现问题。 在远程构建时，会使用 Rsync 把引擎的文件同步到 Mac 上再执行编译，其中就包括 Engine/Intermediate/Build/BuildRuls/ 下的所有文件，因为 4.25.1 中的代码会把 Build/BuildRuls/UE4Rules.dll 等生成到 Win 的用户目录下，所以远程构建，RSync 就不能正确地把 BuildRuls 下的文件上传到 Mac 上，故而引起打包错误： 12ERROR: Precompiled rules assembly &#x27;/Users/buildmachine/Library/Application Support/Epic/UnrealEngine/4.25/Intermediate/Build/BuildRules/UE4Rules.dll&#x27; does not exist. 可以看到，在 Mac 上也是从 Mac 的用户目录查找的，因为压根 Mac 上就没有这俩文件，所以就会产生这个错误。解决这个问题的办法，就是修改 UnrealBuildTool/System/RulesCompiler.cs 的CreateEngineOrEnterpriseRulesAssembly函数，把 BuildRules 相关的文件写入到 Engine/Intermediate/Build/BuildRules 中，在 UE4.25.2 中已经修复了这个错误。在 4.25.2 Hotfix released 中列出了 Fixed! UE-94140 Fix assembly location for remote toolchain，其实就是直接修改了CreateEngineOrEnterpriseRulesAssembly 函数: 123456789// UE 4.25.2private static RulesAssembly CreateEngineOrEnterpriseRulesAssembly(RulesScope Scope, List&lt;DirectoryReference&gt; RootDirectories, string AssemblyPrefix, IReadOnlyList&lt;PluginInfo&gt; Plugins, bool bReadOnly, bool bSkipCompile, RulesAssembly Parent)&#123; // ... // Create the assembly FileReference EngineAssemblyFileName = FileReference.Combine(RootDirectories[0], &quot;Intermediate&quot;, &quot;Build&quot;, &quot;BuildRules&quot;, AssemblyPrefix + &quot;Rules&quot; + FrameworkAssemblyExtension); RulesAssembly EngineAssembly = new RulesAssembly(Scope, RootDirectories[0], Plugins, ModuleFileToContext, new List&lt;FileReference&gt;(), EngineAssemblyFileName, bContainsEngineModules: true, DefaultBuildSettings: BuildSettingsVersion.Latest, bReadOnly: bReadOnly, bSkipCompile: bSkipCompile, Parent: Parent); // ...&#125; 可以直接在 github 中查看:UnrealBuildTool/System/RulesCompiler.cs#L442","tags":[{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"},{"name":"4.25","slug":"Engine/Bug/4-25","permalink":"https://ue5wiki.com/categories/Engine/Bug/4-25/"}]},{"title":"UE4.25 Mac 字符转换 bug","date":"2021-07-03T23:00:14.000Z","path":"wiki/38876/","text":"在 4.26+ 中已修复。 Mac 用的是 2 字节的宽字符，但却按 4 字节的去转，当材质里参数有中文时，就会出现不一致的 bug： Runtime/Core/Private/Serialization/MemoryImage.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647FHashedName::FHashedName(const FName&amp; InName)&#123; if (!InName.IsNone()) &#123; const FNameEntry* Entry = InName.GetComparisonNameEntry(); const int32 InternalNumber = InName.GetNumber(); if (Entry-&gt;IsWide()) &#123; WIDECHAR WideNameBuffer[NAME_SIZE]; Entry-&gt;GetWideName(WideNameBuffer); for (int32 i = 0; i &lt; Entry-&gt;GetNameLength(); ++i) &#123; WideNameBuffer[i] = FCharWide::ToUpper(WideNameBuffer[i]); &#125; // Bug // const FTCHARToUTF8 NameUTF8(WCHAR_TO_TCHAR(WideNameBuffer)); // Hash = CityHash64WithSeed(NameUTF8.Get(), NameUTF8.Length(), InternalNumber); // WChar conversion bug in Mac if (sizeof(WIDECHAR) != sizeof(TCHAR)) &#123; const FTCHARToUTF8 NameUTF8(WCHAR_TO_TCHAR(WideNameBuffer)); Hash = CityHash64WithSeed(NameUTF8.Get(), NameUTF8.Length(), InternalNumber); &#125; else &#123; const FTCHARToUTF8 NameUTF8((TCHAR*)WideNameBuffer); Hash = CityHash64WithSeed(NameUTF8.Get(), NameUTF8.Length(), InternalNumber); &#125; // &#125; else &#123; ANSICHAR AnsiNameBuffer[NAME_SIZE]; Entry-&gt;GetAnsiName(AnsiNameBuffer); for (int32 i = 0; i &lt; Entry-&gt;GetNameLength(); ++i) &#123; AnsiNameBuffer[i] = FCharAnsi::ToUpper(AnsiNameBuffer[i]); &#125; Hash = CityHash64WithSeed(AnsiNameBuffer, Entry-&gt;GetNameLength(), InternalNumber); &#125; &#125; else &#123; Hash = 0u; &#125;&#125;","tags":[{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"},{"name":"4.25","slug":"Engine/Bug/4-25","permalink":"https://ue5wiki.com/categories/Engine/Bug/4-25/"}]},{"title":"模块的宏定义","date":"2021-07-03T22:58:34.000Z","path":"wiki/38550/","text":"MODULE_NAME_APIUE 中的模块，如果定义的符号允许被外部模块访问，则需要在 class 前加 MODULE_NAME_API，这个宏是什么意思呢？ 打开 Definitions.MODULE_NAME.h 这个文件可以知道，MODULE_NAME_API这个宏的定义是 DLLEXPORT，看名字就知道是导出符号的，但是针对不同的平台是不一样的，DLLEXPORT 和DLLIMPORT的宏是定义在 Runtime\\Core\\Public\\$&#123;PLATFROM&#125;\\$&#123;PLATFROM&#125;Platfrom.h 下的(Android 与 Linux 的相同)： 123456// Runtime\\Core\\Public\\Android\\AndroidPlatform.h// Runtime\\Core\\Public\\Linux\\LinuxPlatform.h// DLL export and import definitions#define DLLEXPORT __attribute__((visibility(&quot;default&quot;)))#define DLLIMPORT __attribute__((visibility(&quot;default&quot;))) MacOS 则是一个空的宏定义： 12345// Runtime\\Core\\Public\\Mac\\MacPlatform.h// DLL export and import definitions#define DLLEXPORT#define DLLIMPORT Windows 的为__declspec： 12345// Runtime\\Core\\Public\\Windows\\WIndowsPlatform.h// DLL export and import definitions#define DLLEXPORT __declspec(dllexport)#define DLLIMPORT __declspec(dllimport) 模块的宏定义UE 中模块的宏定义会汇总在这个文件下： 1Intermediate\\Build\\Win64\\UE4Editor\\Development\\NetExampleDemo\\Definitions.MODULE_NAME.h 其中定义了 MODULE_NAME_API 为DLLEXPORT，导出自己模块内的符号，还有引用的其他模块的 MODULE_NAME_API 为DLLIMPORT，导入引用模块内的符号，在编译时链接可用，还有一些宏开关。类似于这样：Definations.WebBrowserEx.h","tags":[{"name":"Module","slug":"Module","permalink":"https://ue5wiki.com/tags/Module/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"ON_SCOPE_EXIT","date":"2021-07-03T22:57:23.000Z","path":"wiki/38318/","text":"UE 中有一个宏ON_SCOPE_EXIT，它的用法为： 12345// Make sure module info is added to known modules and proper delegates are fired on exit.ON_SCOPE_EXIT&#123; FModuleManager::Get().AddModuleToModulesList(InModuleName, ModuleInfo);&#125;; 在 UE4 Modules:Find the DLL and load it 里曾提到过这种用法： 这段代码的意思是在退出当前的作用域 (Scope) 时执行 &#123;&#125; 中的逻辑，简单地来说，它定义了一个当前作用域的对象并托管了一个 Lambda，在离开当前作用域的时候通过 C++ 的 RAII 机制来调用托管的 Lambda. 今天来简单分析一下它的实现。 首先，ON_SCOPE_EXIT的宏定义为： 1#define ON_SCOPE_EXIT const auto ANONYMOUS_VARIABLE(ScopeGuard_) = ::ScopeExitSupport::FScopeGuardSyntaxSupport() + [&amp;]() 由此展开，最开始的那个使用的宏就等价替换为： 123const auto ANONYMOUS_VARIABLE(ScopeGuard_) = ::ScopeExitSupport::FScopeGuardSyntaxSupport() + [&amp;]()&#123; FModuleManager::Get().AddModuleToModulesList(InModuleName, ModuleInfo);&#125;; 通常 lambda 用在谓词和调用的时候还好理解，但是这个搞了个 + 有点不走寻常路，由此可以推断类型 ::ScopeExitSupport::FScopeGuardSyntaxSupport 必然重载了 operator+ 操作符，并且是个模板函数。 查看 ::ScopeExitSupport::FScopeGuardSyntaxSupport 的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Runtime\\Core\\Public\\Misc\\ScopeExit.hnamespace ScopeExitSupport&#123; /** * Not meant for direct consumption : use ON_SCOPE_EXIT instead. * * RAII class that calls a lambda when it is destroyed. */ template &lt;typename FuncType&gt; class TScopeGuard : public FNoncopyable &#123; public: // Given a lambda, constructs an RAII scope guard. explicit TScopeGuard(FuncType&amp;&amp; InFunc) : Func(MoveTemp(InFunc))&#123;&#125; // This constructor needs to be available for the code to compile. // It will be almost definitely be RVOed out (even in DEBUG). TScopeGuard(TScopeGuard&amp;&amp; Other) : Func(MoveTemp(Other.Func)) &#123; Other.Func.Reset(); &#125; // Causes ~TScopeGuard() &#123; if (Func.IsSet()) &#123; Func.GetValue()(); &#125; &#125; private: // The lambda to be executed when this guard goes out of scope. TOptional&lt;FuncType&gt; Func; &#125;; struct FScopeGuardSyntaxSupport &#123; template &lt;typename FuncType&gt; TScopeGuard&lt;FuncType&gt; operator+(FuncType&amp;&amp; InFunc) &#123; return TScopeGuard&lt;FuncType&gt;(Forward&lt;FuncType&gt;(InFunc)); &#125; &#125;;&#125; 果然！类型 FScopeGuardSyntaxSupport 通过模板重载了 operator+，它要求接收一个重载了operator() 的泛型 ** 函数对象 (functional object)** 类型，据此产生一个TScopeGuard 的类型，并将传递进来的函数对象托管，在这个 TScopeGuard 的对象的析构函数中 (destructor) 调用了托管的函数对象。 其中隐藏的关键是通过 ::ScopeExitSupport::FScopeGuardSyntaxSupport() + [&amp;]()&#123;&#125; 得到的 TScopeGuard 的对象是个 ** 局部对象 (automattic storage duration)**，只存在于当前的作用域(Scope) 中，在离开当前作用域时会自动销毁(调用析构函数)，离开作用域时局部变量的销毁顺序为按定义的逆序执行。 [ISO/IEC 14882:2014 § 6.6]On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been constructed in that scope are destroyed in the reverse order of their construction.","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"Tricks","slug":"Programming/Tricks","permalink":"https://ue5wiki.com/categories/Programming/Tricks/"}]},{"title":"编译目标的 RuntimeLibrary 类型","date":"2021-07-03T22:55:19.000Z","path":"wiki/37913/","text":"与普通的 c++ 项目不一样，UE 的 Game 工程是不能在项目属性中设置 RuntimeLibrary 的，这部分有 UBT 代劳替我们处理。其相关的代码在 UnrealBuildTool\\Windows\\VCToolchain.cs(UE_4.22) 中： 12345678910111213141516171819202122232425262728void AppendCLArguments_Global(CppCompileEnvironment CompileEnvironment, List&lt;string&gt; Arguments)&#123;// ...// Specify the appropriate runtime library based on the platform and config.if (CompileEnvironment.bUseStaticCRT)&#123; if (CompileEnvironment.bUseDebugCRT) &#123; Arguments.Add(&quot;/MTd&quot;); &#125; else &#123; Arguments.Add(&quot;/MT&quot;); &#125;&#125;else&#123; if (CompileEnvironment.bUseDebugCRT) &#123; Arguments.Add(&quot;/MDd&quot;); &#125; else &#123; Arguments.Add(&quot;/MD&quot;); &#125;&#125;// ...&#125; 在 *.target.cs 中使用了 bUseStaticCRT=true 后（默认为 false），编译 Debug 版本是 /MTd，其他版本是MT。 在*.target.cs中不能直接控制 bUseDebugCRT, 但是可以控制bDebugBuildsActuallyUseDebugCRT（默认为 false）, 它由我们在VS 选的 Configuration 和bDebugBuildsActuallyUseDebugCRT的值来控制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// UEBuildTarget.cs// GetCppConfigurationstatic CppConfiguration GetCppConfiguration(UnrealTargetConfiguration Configuration)&#123; switch (Configuration) &#123; case UnrealTargetConfiguration.Debug: return CppConfiguration.Debug; case UnrealTargetConfiguration.DebugGame: case UnrealTargetConfiguration.Development: return CppConfiguration.Development; case UnrealTargetConfiguration.Shipping: return CppConfiguration.Shipping; case UnrealTargetConfiguration.Test: return CppConfiguration.Shipping; default: throw new BuildException(&quot;Unhandled target configuration&quot;); &#125;&#125;// CreateCompileEnvironmentForProjectFilespublic CppCompileEnvironment CreateCompileEnvironmentForProjectFiles()&#123; CppPlatform CppPlatform = UEBuildPlatform.GetBuildPlatform(Platform).DefaultCppPlatform; CppConfiguration CppConfiguration = GetCppConfiguration(Configuration); SourceFileMetadataCache MetadataCache = SourceFileMetadataCache.CreateHierarchy(ProjectFile); CppCompileEnvironment GlobalCompileEnvironment = new CppCompileEnvironment(CppPlatform, CppConfiguration, Architecture, MetadataCache); LinkEnvironment GlobalLinkEnvironment = new LinkEnvironment(GlobalCompileEnvironment.Platform, GlobalCompileEnvironment.Configuration, GlobalCompileEnvironment.Architecture); UEToolChain TargetToolChain = CreateToolchain(CppPlatform); SetupGlobalEnvironment(TargetToolChain, GlobalCompileEnvironment, GlobalLinkEnvironment); return GlobalCompileEnvironment;&#125;// SetupGlobalEnvironmentprivate void SetupGlobalEnvironment(UEToolChain ToolChain, CppCompileEnvironment GlobalCompileEnvironment, LinkEnvironment GlobalLinkEnvironment)&#123; // ... GlobalCompileEnvironment.bUseDebugCRT = GlobalCompileEnvironment.Configuration == CppConfiguration.Debug &amp;&amp; Rules.bDebugBuildsActuallyUseDebugCRT; // ...&#125; 所以，总结上面的代码，只有当 VS 的编译选项选的是 Debug，并且在*.Target.cs 中bDebugBuildsActuallyUseDebugCRT=true的时候，bUseDebugCRT才为true。 情况一 当bUseStaticCRT=true; 以及bDebugBuildsActuallyUseDebugCRT=true; 以及 VS 中的 Configuration 为Debug 以上三个条件全部满足的时候，编译的 Runtime Library 为/MTd。 情况二 当bUseStaticCRT=false;(默认) 以及bDebugBuildsActuallyUseDebugCRT=true; 以及 VS 中的 Configuration 为Debug 这三个条件，编译的 Runtime Library 为/MDd。 情况三 在情况二 基础上把下列条件改为： 以及bDebugBuildsActuallyUseDebugCRT=false;(默认) 或者： 以及 VS 中的 Configuration 不是Debug 则这种情况下，编译的 Runtime Library 都是/MD.","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"UE 集成 Protobuf","date":"2021-07-03T22:53:09.000Z","path":"wiki/37488/","text":"我之前的文章 Build protobuf with MSVC on Windows 中介绍了在 Windows 上使用 MSVC 编译 Protobuf，最近的项目中有用到 Protobuf，就把 Protobuf 集成 UE4 做了一个插件，无需在系统和项目设置中添加任何环境变量以及文件包含，也不需要考虑 protobuf 的lib的链接，方便在项目中使用，并且对 UE 不兼容 cc 格式写了编辑器插件，.pb.cc都会被转换为pb.cpp。 代码我放在了 github 上：hxhb/ue4-protobuf 下面是简单的使用介绍： What is this?This is an Unreal Engine 4 plugin that integrates Protobuf into the project without requiring you to add system PATH or anything else. How do use? add the plugin to the project and enable it. add the following property to build.cs of the project : 1234PublicDependencyModuleNames.Add(&quot;Protobuf&quot;);bEnableUndefinedIdentifierWarnings = false;bUseRTTI = true;bEnableExceptions = true; Create .proto file into project source code folder Launch the Project in Editor, Click the Protoc button. Protobuf Version Protobuf v3.9.1 build with MSVC 15 64bit (Visual Studio 2017). protoc 处理目录中的.proto 文件1$ protoc --proto_path=PROTO_FILE_PATH PROTO_FILE --cpp_out=OUT_FILE_PATH PROTO_FILE_PATH\\*.proto 如： 1$ protoc --proto_path=&quot;d:\\protoc&quot; MyName.proto --cpp_out=&quot;d:\\&quot; Was only expecting C++ files to have CachedCPPEnvironments!写了个插件在 UE 中使用 protobuf，在从 proto 文件生成 .cc/.h 之后编译报这个错误，分析了一下是 UBT 的代码文件类型不支持.cc。 12341&gt;------ Build started: Project: GWorld, Configuration: Development x64 ------1&gt;Using &#x27;git status&#x27; to determine working set for adaptive non-unity build (C:\\Users\\imzlp\\Documents\\Unreal Projects\\GWorld).1&gt;UnrealBuildTool : error : Was only expecting C++ files to have CachedCPPEnvironments!1&gt;(see ../Programs/UnrealBuildTool/Log.txt for full exception trace) 在引擎中搜索代码，发现这个错误是在 UnrealBuildTools\\System\\ActionGraph.cs 中IsActionOutdated里的： 12345678910111213141516171819202122232425262728293031323334public bool IsActionOutdated(BuildConfiguration BuildConfiguration, UEBuildTarget Target, CPPHeaders Headers, Action RootAction, bool bIsAssemblingBuild, bool bNeedsFullCPPIncludeRescan, Dictionary&lt;Action, bool&gt; OutdatedActionDictionary, ActionHistory ActionHistory, Dictionary&lt;UEBuildTarget, List&lt;FileItem&gt;&gt; TargetToOutdatedPrerequisitesMap)&#123; // ... // @todo ubtmake: we may be scanning more files than we need to here -- indirectly outdated files are bIsOutdated=true by this point (for example basemost includes when deeper includes are dirty) if (bIsOutdated &amp;&amp; RootAction.ActionType == ActionType.Compile)// @todo ubtmake: Does this work with RC files? See above too. &#123; Log.TraceVerbose(&quot;Outdated action: &#123;0&#125;&quot;, RootAction.StatusDescription); foreach (FileItem PrerequisiteItem in RootAction.PrerequisiteItems) &#123; if (PrerequisiteItem.CachedIncludePaths != null) &#123; if (!IsCPPFile(PrerequisiteItem)) &#123; throw new BuildException(&quot;Was only expecting C++ files to have CachedCPPEnvironments!&quot;); &#125; Log.TraceVerbose(&quot; -&gt; DEEP include scan: &#123;0&#125;&quot;, PrerequisiteItem.AbsolutePath); List&lt;FileItem&gt; OutdatedPrerequisites; if (!TargetToOutdatedPrerequisitesMap.TryGetValue(Target, out OutdatedPrerequisites)) &#123; OutdatedPrerequisites = new List&lt;FileItem&gt;(); TargetToOutdatedPrerequisitesMap.Add(Target, OutdatedPrerequisites); &#125; OutdatedPrerequisites.Add(PrerequisiteItem); &#125; else if (IsCPPImplementationFile(PrerequisiteItem) || IsCPPResourceFile(PrerequisiteItem)) &#123; Log.TraceVerbose(&quot; -&gt; WARNING: No CachedCPPEnvironment: &#123;0&#125;&quot;, PrerequisiteItem.AbsolutePath); &#125; &#125; &#125; // ...&#125; 重点就是 IsCPPFile 这个函数，报这个错误是因为 UBT 检测到了项目中不能识别的文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// Checks if the specified file is a C++ source file/// &lt;/summary&gt;/// &lt;param name=&quot;FileItem&quot;&gt;The file to check&lt;/param&gt;/// &lt;returns&gt;True if this is a C++ source file&lt;/returns&gt;private static bool IsCPPFile(FileItem FileItem)&#123; return IsCPPImplementationFile(FileItem) || IsCPPIncludeFile(FileItem) || IsCPPResourceFile(FileItem);&#125;/// &lt;summary&gt;/// Checks if the specified file is a C++ source implementation file (e.g., .cpp)/// &lt;/summary&gt;/// &lt;param name=&quot;FileItem&quot;&gt;The file to check&lt;/param&gt;/// &lt;returns&gt;True if this is a C++ source file&lt;/returns&gt;private static bool IsCPPImplementationFile(FileItem FileItem)&#123; return (FileItem.AbsolutePath.EndsWith(&quot;.cpp&quot;, StringComparison.InvariantCultureIgnoreCase) || FileItem.AbsolutePath.EndsWith(&quot;.c&quot;, StringComparison.InvariantCultureIgnoreCase) || FileItem.AbsolutePath.EndsWith(&quot;.mm&quot;, StringComparison.InvariantCultureIgnoreCase));&#125;/// &lt;summary&gt;/// Checks if the specified file is a C++ source header file (e.g., .h or .inl)/// &lt;/summary&gt;/// &lt;param name=&quot;FileItem&quot;&gt;The file to check&lt;/param&gt;/// &lt;returns&gt;True if this is a C++ source file&lt;/returns&gt;private static bool IsCPPIncludeFile(FileItem FileItem)&#123; return (FileItem.AbsolutePath.EndsWith(&quot;.h&quot;, StringComparison.InvariantCultureIgnoreCase) || FileItem.AbsolutePath.EndsWith(&quot;.hpp&quot;, StringComparison.InvariantCultureIgnoreCase) || FileItem.AbsolutePath.EndsWith(&quot;.inl&quot;, StringComparison.InvariantCultureIgnoreCase));&#125;/// &lt;summary&gt;/// Checks if the specified file is a C++ resource file (e.g., .rc)/// &lt;/summary&gt;/// &lt;param name=&quot;FileItem&quot;&gt;The file to check&lt;/param&gt;/// &lt;returns&gt;True if this is a C++ source file&lt;/returns&gt;private static bool IsCPPResourceFile(FileItem FileItem)&#123; return (FileItem.AbsolutePath.EndsWith(&quot;.rc&quot;, StringComparison.InvariantCultureIgnoreCase));&#125; 可以看到，UBT 只认下列几种文件： IsCPPImplementationFile：.cpp/.c/.m IsCPPIncludeFile：.h/.hpp/.inl IsCPPResourceFile：.rc 因为 Protobuf 产生的是 .cc 文件，所以就会报开头的错误。 既然问题找到了。那么解决办法有两个： 改 UBT 的代码，让其支持.cc 改 protobuf 产生的 .cc 为.cpp","tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"https://ue5wiki.com/tags/Protobuf/"}],"categories":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/categories/ThirdParty/"}]},{"title":"枚举的反射信息","date":"2021-07-03T22:51:27.000Z","path":"wiki/37155/","text":"下列枚举类型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ETargetPlatform.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ETargetPlatform.generated.h&quot;UENUM(BlueprintType)enum class ETargetPlatform : uint8&#123; AllDesktop, MacClient, MacNoEditor, MacServer, Mac, WindowsClient, WindowsNoEditor, WindowsServer, Windows, Android, Android_ASTC, Android_ATC, Android_DXT, Android_ETC1, Android_ETC1a, Android_ETC2, Android_PVRTC, AndroidClient, Android_ASTCClient, Android_ATCClient, Android_DXTClient, Android_ETC1Client, Android_ETC1aClient, Android_ETC2Client, Android_PVRTCClient, Android_Multi, Android_MultiClient, HTML5, IOSClient, IOS, TVOSClient, TVOS, LinuxClient, LinuxNoEditor, LinuxServer, Linux, Lumin, LuminClient&#125;; 经过 UHT 之后的反射代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ETargetPlatform.generated.h#include &quot;UObject/ObjectMacros.h&quot;#include &quot;UObject/ScriptMacros.h&quot;PRAGMA_DISABLE_DEPRECATION_WARNINGS#ifdef HOTPATCHERRUNTIME_ETargetPlatform_generated_h#error &quot;ETargetPlatform.generated.h already included, missing &#x27;#pragma once&#x27; in ETargetPlatform.h&quot;#endif#define HOTPATCHERRUNTIME_ETargetPlatform_generated_h#undef CURRENT_FILE_ID#define CURRENT_FILE_ID HotThirdPerson_Plugins_ue4_HotPackage_HotPatcher_Source_HotPatcherRuntime_Public_ETargetPlatform_h#define FOREACH_ENUM_ETARGETPLATFORM(op) \\ op(ETargetPlatform::AllDesktop) \\ op(ETargetPlatform::MacClient) \\ op(ETargetPlatform::MacNoEditor) \\ op(ETargetPlatform::MacServer) \\ op(ETargetPlatform::Mac) \\ op(ETargetPlatform::WindowsClient) \\ op(ETargetPlatform::WindowsNoEditor) \\ op(ETargetPlatform::WindowsServer) \\ op(ETargetPlatform::Windows) \\ op(ETargetPlatform::Android) \\ op(ETargetPlatform::Android_ASTC) \\ op(ETargetPlatform::Android_ATC) \\ op(ETargetPlatform::Android_DXT) \\ op(ETargetPlatform::Android_ETC1) \\ op(ETargetPlatform::Android_ETC1a) \\ op(ETargetPlatform::Android_ETC2) \\ op(ETargetPlatform::Android_PVRTC) \\ op(ETargetPlatform::AndroidClient) \\ op(ETargetPlatform::Android_ASTCClient) \\ op(ETargetPlatform::Android_ATCClient) \\ op(ETargetPlatform::Android_DXTClient) \\ op(ETargetPlatform::Android_ETC1Client) \\ op(ETargetPlatform::Android_ETC1aClient) \\ op(ETargetPlatform::Android_ETC2Client) \\ op(ETargetPlatform::Android_PVRTCClient) \\ op(ETargetPlatform::Android_Multi) \\ op(ETargetPlatform::Android_MultiClient) \\ op(ETargetPlatform::HTML5) \\ op(ETargetPlatform::IOSClient) \\ op(ETargetPlatform::IOS) \\ op(ETargetPlatform::TVOSClient) \\ op(ETargetPlatform::TVOS) \\ op(ETargetPlatform::LinuxClient) \\ op(ETargetPlatform::LinuxNoEditor) \\ op(ETargetPlatform::LinuxServer) \\ op(ETargetPlatform::Linux) \\ op(ETargetPlatform::Lumin) \\ op(ETargetPlatform::LuminClient) enum class ETargetPlatform : uint8;template&lt;&gt; HOTPATCHERRUNTIME_API UEnum* StaticEnum&lt;ETargetPlatform&gt;();PRAGMA_ENABLE_DEPRECATION_WARNINGS 产生的 gen.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &quot;UObject/GeneratedCppIncludes.h&quot;#include &quot;HotPatcherRuntime/Public/ETargetPlatform.h&quot;#ifdef _MSC_VER#pragma warning (push)#pragma warning (disable : 4883)#endifPRAGMA_DISABLE_DEPRECATION_WARNINGSvoid EmptyLinkFunctionForGeneratedCodeETargetPlatform() &#123;&#125;// Cross Module References HOTPATCHERRUNTIME_API UEnum* Z_Construct_UEnum_HotPatcherRuntime_ETargetPlatform(); UPackage* Z_Construct_UPackage__Script_HotPatcherRuntime();// End Cross Module References static UEnum* ETargetPlatform_StaticEnum() &#123; static UEnum* Singleton = nullptr; if (!Singleton) &#123; Singleton = GetStaticEnum(Z_Construct_UEnum_HotPatcherRuntime_ETargetPlatform, Z_Construct_UPackage__Script_HotPatcherRuntime(), TEXT(&quot;ETargetPlatform&quot;)); &#125; return Singleton; &#125; template&lt;&gt; HOTPATCHERRUNTIME_API UEnum* StaticEnum&lt;ETargetPlatform&gt;() &#123; return ETargetPlatform_StaticEnum(); &#125; static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETargetPlatform(ETargetPlatform_StaticEnum, TEXT(&quot;/Script/HotPatcherRuntime&quot;), TEXT(&quot;ETargetPlatform&quot;), false, nullptr, nullptr); uint32 Get_Z_Construct_UEnum_HotPatcherRuntime_ETargetPlatform_Hash() &#123; return 2902485356U; &#125; UEnum* Z_Construct_UEnum_HotPatcherRuntime_ETargetPlatform() &#123;#if WITH_HOT_RELOAD UPackage* Outer = Z_Construct_UPackage__Script_HotPatcherRuntime(); static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT(&quot;ETargetPlatform&quot;), 0, Get_Z_Construct_UEnum_HotPatcherRuntime_ETargetPlatform_Hash(), false);#else static UEnum* ReturnEnum = nullptr;#endif // WITH_HOT_RELOAD if (!ReturnEnum) &#123; static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = &#123; &#123; &quot;ETargetPlatform::AllDesktop&quot;, (int64)ETargetPlatform::AllDesktop &#125;, &#123; &quot;ETargetPlatform::MacClient&quot;, (int64)ETargetPlatform::MacClient &#125;, &#123; &quot;ETargetPlatform::MacNoEditor&quot;, (int64)ETargetPlatform::MacNoEditor &#125;, &#123; &quot;ETargetPlatform::MacServer&quot;, (int64)ETargetPlatform::MacServer &#125;, &#123; &quot;ETargetPlatform::Mac&quot;, (int64)ETargetPlatform::Mac &#125;, &#123; &quot;ETargetPlatform::WindowsClient&quot;, (int64)ETargetPlatform::WindowsClient &#125;, &#123; &quot;ETargetPlatform::WindowsNoEditor&quot;, (int64)ETargetPlatform::WindowsNoEditor &#125;, &#123; &quot;ETargetPlatform::WindowsServer&quot;, (int64)ETargetPlatform::WindowsServer &#125;, &#123; &quot;ETargetPlatform::Windows&quot;, (int64)ETargetPlatform::Windows &#125;, &#123; &quot;ETargetPlatform::Android&quot;, (int64)ETargetPlatform::Android &#125;, &#123; &quot;ETargetPlatform::Android_ASTC&quot;, (int64)ETargetPlatform::Android_ASTC &#125;, &#123; &quot;ETargetPlatform::Android_ATC&quot;, (int64)ETargetPlatform::Android_ATC &#125;, &#123; &quot;ETargetPlatform::Android_DXT&quot;, (int64)ETargetPlatform::Android_DXT &#125;, &#123; &quot;ETargetPlatform::Android_ETC1&quot;, (int64)ETargetPlatform::Android_ETC1 &#125;, &#123; &quot;ETargetPlatform::Android_ETC1a&quot;, (int64)ETargetPlatform::Android_ETC1a &#125;, &#123; &quot;ETargetPlatform::Android_ETC2&quot;, (int64)ETargetPlatform::Android_ETC2 &#125;, &#123; &quot;ETargetPlatform::Android_PVRTC&quot;, (int64)ETargetPlatform::Android_PVRTC &#125;, &#123; &quot;ETargetPlatform::AndroidClient&quot;, (int64)ETargetPlatform::AndroidClient &#125;, &#123; &quot;ETargetPlatform::Android_ASTCClient&quot;, (int64)ETargetPlatform::Android_ASTCClient &#125;, &#123; &quot;ETargetPlatform::Android_ATCClient&quot;, (int64)ETargetPlatform::Android_ATCClient &#125;, &#123; &quot;ETargetPlatform::Android_DXTClient&quot;, (int64)ETargetPlatform::Android_DXTClient &#125;, &#123; &quot;ETargetPlatform::Android_ETC1Client&quot;, (int64)ETargetPlatform::Android_ETC1Client &#125;, &#123; &quot;ETargetPlatform::Android_ETC1aClient&quot;, (int64)ETargetPlatform::Android_ETC1aClient &#125;, &#123; &quot;ETargetPlatform::Android_ETC2Client&quot;, (int64)ETargetPlatform::Android_ETC2Client &#125;, &#123; &quot;ETargetPlatform::Android_PVRTCClient&quot;, (int64)ETargetPlatform::Android_PVRTCClient &#125;, &#123; &quot;ETargetPlatform::Android_Multi&quot;, (int64)ETargetPlatform::Android_Multi &#125;, &#123; &quot;ETargetPlatform::Android_MultiClient&quot;, (int64)ETargetPlatform::Android_MultiClient &#125;, &#123; &quot;ETargetPlatform::HTML5&quot;, (int64)ETargetPlatform::HTML5 &#125;, &#123; &quot;ETargetPlatform::IOSClient&quot;, (int64)ETargetPlatform::IOSClient &#125;, &#123; &quot;ETargetPlatform::IOS&quot;, (int64)ETargetPlatform::IOS &#125;, &#123; &quot;ETargetPlatform::TVOSClient&quot;, (int64)ETargetPlatform::TVOSClient &#125;, &#123; &quot;ETargetPlatform::TVOS&quot;, (int64)ETargetPlatform::TVOS &#125;, &#123; &quot;ETargetPlatform::LinuxClient&quot;, (int64)ETargetPlatform::LinuxClient &#125;, &#123; &quot;ETargetPlatform::LinuxNoEditor&quot;, (int64)ETargetPlatform::LinuxNoEditor &#125;, &#123; &quot;ETargetPlatform::LinuxServer&quot;, (int64)ETargetPlatform::LinuxServer &#125;, &#123; &quot;ETargetPlatform::Linux&quot;, (int64)ETargetPlatform::Linux &#125;, &#123; &quot;ETargetPlatform::Lumin&quot;, (int64)ETargetPlatform::Lumin &#125;, &#123; &quot;ETargetPlatform::LuminClient&quot;, (int64)ETargetPlatform::LuminClient &#125;, &#125;;#if WITH_METADATA const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = &#123; &#123; &quot;BlueprintType&quot;, &quot;true&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;Public/ETargetPlatform.h&quot; &#125;, &#125;;#endif static const UE4CodeGen_Private::FEnumParams EnumParams = &#123; (UObject*(*)())Z_Construct_UPackage__Script_HotPatcherRuntime, nullptr, &quot;ETargetPlatform&quot;, &quot;ETargetPlatform&quot;, Enumerators, ARRAY_COUNT(Enumerators), RF_Public|RF_Transient|RF_MarkAsNative, UE4CodeGen_Private::EDynamicType::NotDynamic, (uint8)UEnum::ECppForm::EnumClass, METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams)) &#125;; UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams); &#125; return ReturnEnum; &#125;PRAGMA_ENABLE_DEPRECATION_WARNINGS#ifdef _MSC_VER#pragma warning (pop)#endif 枚举值的名字可以通过下列方法获得： 1FString PlatformName = StaticEnum&lt;ETargetPlatform&gt;()-&gt;GetNameByValue((int64)Platform).ToString(); 其得到的值是具有 namespace 的，如 ETargetPlatform::WindowsNoEditor. 如果不想要 namespace 可以使用： 12345FString PlatformName;&#123; FString EnumName; StaticEnum&lt;ETargetPlatform&gt;()-&gt;GetNameByValue((int64)Platform).ToString().Split(TEXT(&quot;::&quot;), &amp;EnumName, &amp;PlatformName,ESearchCase::CaseSensitive,ESearchDir::FromEnd);&#125;","tags":[],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"Delegate 分析","date":"2021-07-03T22:49:47.000Z","path":"wiki/36829/","text":"UE 的 Delegate 分了几个不同的种类，普通的代理是模板类，Dynamic Delegate是通过宏展开生成类，Dynamic Mulitcast Delegate需要 UHT 参与生成代码，所以动态多播代理只能写到包含 generated.h 的文件中。 Delegates Multi-cast Delegates Dynamic Delegates Delegate DECLARE_DELEGATE：普通代理，可以被值传递，本质实现是 TBaseDelegare&lt;__VA_ARGS__&gt; 的对象，可以使用 BindUObject 等函数。 TBaseDelegate里定义了很多的辅助函数，如 BindSP/BindRaw/BindStatic/CreateSP 等。 Dynamic Delegate DECLARE_DYNAMIC_DELEGATE：动态代理可以序列化，其函数可按命名查找，执行速度比常规代理慢。 动态代理本质上是继承自 TBaseDynamicDelegate 的类，TBaseDynamicDelegate又继承自TScriptDelegate，所以动态代理可以绑定 UObject 和绑定 UFUNCTION。 其中 BindUFunction 是TScriptInterface的函数，而 BindUbject 是个宏，定义在 Delegate.h 中。 代码分析： 1DECLARE_DYNAMIC_DELEGATE_OneParam(FOnTestDynamicDelegate, const FString&amp;, InStr); DECLARE_DYNAMIC_DELEGATE_OneParam的宏定义为： 1#define DECLARE_DYNAMIC_DELEGATE_OneParam(DelegateName, Param1Type, Param1Name) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_DELEGATE) FUNC_DECLARE_DYNAMIC_DELEGATE(FWeakObjectPtr, DelegateName, DelegateName##_DelegateWrapper, FUNC_CONCAT( Param1Type InParam1), FUNC_CONCAT(*this, InParam1), void, Param1Type ) BODY_MACRO_COMBINE宏其经过 UHT 之后生成的代码为： 1234567891011#define GWorldClient_Plugins_HotPackage_HotPatcher_Source_HotPatcherEditor_Private_CreatePatch_ExportPatchSettings_h_22_DELEGATE \\struct _Script_HotPatcherEditor_eventOnTestDynamicDelegate_Parms \\&#123; \\ FString InStr; \\&#125;; \\static inline void FOnTestDynamicDelegate_DelegateWrapper(const FScriptDelegate&amp; OnTestDynamicDelegate, const FString&amp; InStr) \\&#123; \\ _Script_HotPatcherEditor_eventOnTestDynamicDelegate_Parms Parms; \\ Parms.InStr=InStr; \\ OnTestDynamicDelegate.ProcessDelegate&lt;UObject&gt;(&amp;Parms); \\&#125; 进行展开之后，可以看到使用 DECLARE_DYNAMIC_DELEGATE_OneParam 声明的代理实际上是就被定义了一个 static 函数。 FUNC_DECLARE_DYNAMIC_DELEGATE宏是裹了一个TBaseDynamicDelegate： 12345678910111213141516171819202122232425262728293031323334/** Declare user&#x27;s dynamic delegate, with wrapper proxy method for executing the delegate */#define FUNC_DECLARE_DYNAMIC_DELEGATE(TWeakPtr, DynamicDelegateName, ExecFunction, FuncParamList, FuncParamPassThru, ...) \\ class DynamicDelegateName : public TBaseDynamicDelegate&lt;TWeakPtr, __VA_ARGS__&gt; \\ &#123; \\ public: \\ /** Default constructor */ \\ DynamicDelegateName() \\ &#123; \\ &#125; \\ \\ /** Construction from an FScriptDelegate must be explicit. This is really only used by UObject system internals. */ \\ explicit DynamicDelegateName(const TScriptDelegate&lt;&gt;&amp; InScriptDelegate ) \\ : TBaseDynamicDelegate&lt;TWeakPtr, __VA_ARGS__&gt;(InScriptDelegate) \\ &#123; \\ &#125; \\ \\ /** Execute the delegate. If the function pointer is not valid, an error will occur. */ \\ inline void Execute(FuncParamList) const \\ &#123; \\ /* Verify that the user object is still valid. We only have a weak reference to it. */ \\ checkSlow(IsBound() ); \\ ExecFunction(FuncParamPassThru); \\ &#125; \\ /** Execute the delegate, but only if the function pointer is still valid */ \\ inline bool ExecuteIfBound(FuncParamList) const \\ &#123; \\ if(IsBound() ) \\ &#123; \\ ExecFunction(FuncParamPassThru); \\ return true; \\ &#125; \\ return false; \\ &#125; \\ &#125;; 所有的宏都被展开之后： 12345678910111213141516171819202122232425262728struct _Script_HotPatcherEditor_eventOnTestDynamicDelegate_Parms&#123; FString InStr;&#125;;static inline void FOnTestDynamicDelegate_DelegateWrapper(const FScriptDelegate&amp; OnTestDynamicDelegate, const FString&amp; InStr)&#123; _Script_HotPatcherEditor_eventOnTestDynamicDelegate_Parms Parms; Parms.InStr=InStr; OnTestDynamicDelegate.ProcessDelegate&lt;UObject&gt;(&amp;Parms);&#125;class FOnTestDynamicDelegate : public TBaseDynamicDelegate&lt;FWeakObjectPtr, void, const FString&amp;&gt;&#123; public: FOnTestDynamicDelegate() &#123; &#125; explicit FOnTestDynamicDelegate(const TScriptDelegate&lt;&gt;&amp; InScriptDelegate ) : TBaseDynamicDelegate&lt;FWeakObjectPtr, void, const FString&amp;&gt;(InScriptDelegate) &#123; &#125; inline void Execute(const FString&amp; InStr ) const &#123; checkSlow(IsBound()); FOnTestDynamicDelegate_DelegateWrapper(*this, InStr ); &#125; inline bool ExecuteIfBound(const FString&amp; InStr ) const &#123; if(IsBound()) &#123; FOnTestDynamicDelegate_DelegateWrapper(*this, InStr ); return true; &#125; return false; &#125; &#125;; 在使用的时候可以通过 BindUFunction 来绑定函数，通过 Execute 或者 ExecuteIfBound 来调用。 在当作回调函数传递的时候比较方便，因为它继承自FScriptDelegate，可以当作通用的方式传递。 Multicast Delegate 多播代理 ：与普通代理的大部分功能相同，它们只拥有对象的弱引用，可以和结构体一起使用，可以复制。其本质是TMulticastDelegate&lt;__VA_ARGS__&gt; 的对象。多播代理可以被加载 / 保存和远程触发，但多播代理不能使用返回值。 多播代理可以具有多个绑定，当 Broadcast 触发时，所有的绑定都会被调用。 多播代理可以使用 Add/AddStatic/AddRaw/AddSP/AddUObject/Remove/RemoveAll 等函数。 注意：RemoveAll 会删除所有绑定时提供指针的代理，未绑定到对象的 Raw 代理不会被该函数删除。 Dynamic Multicast Delegate DECLARE_DYNAMIC_MULITCAST_DELEGATE：动态多播代理。 动态多播代理必须要绑定到 UFUNCTION 的函数，使用宏 AddDynamic 或者 AddUnique 来添加绑定。 代码分析： 1DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTestDynamicMultiDelegate, const FString&amp;, InStr); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam其宏定义为： 123#define DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(DelegateName, Param1Type, Param1Name)\\ BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_DELEGATE)\\ FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE(FWeakObjectPtr, DelegateName, DelegateName##_DelegateWrapper, FUNC_CONCAT( Param1Type InParam1), FUNC_CONCAT(*this, InParam1), void, Param1Type ) 其中 BODY_MACRO_COMBINE 经过 UHT 之后生成下列代码： 1234567891011#define GWorldClient_Plugins_HotPackage_HotPatcher_Source_HotPatcherEditor_Private_CreatePatch_ExportPatchSettings_h_22_DELEGATE \\struct _Script_HotPatcherEditor_eventOnTestDynamicMultiDelegate_Parms \\&#123; \\ FString InStr; \\&#125;; \\static inline void FOnTestDynamicMultiDelegate_DelegateWrapper(const FMulticastScriptDelegate&amp; OnTestDynamicMultiDelegate, const FString&amp; InStr) \\&#123; \\ _Script_HotPatcherEditor_eventOnTestDynamicMultiDelegate_Parms Parms; \\ Parms.InStr=InStr; \\ OnTestDynamicMultiDelegate.ProcessMulticastDelegate&lt;UObject&gt;(&amp;Parms); \\&#125; FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE则创建了一个继承自 TBaseDynamicMulticastDelegate 类： 12345678910111213141516171819202122/** Declare user&#x27;s dynamic multi-cast delegate, with wrapper proxy method for executing the delegate */#define FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE(TWeakPtr, DynamicMulticastDelegateName, ExecFunction, FuncParamList, FuncParamPassThru, ...) \\class DynamicMulticastDelegateName : public TBaseDynamicMulticastDelegate&lt;TWeakPtr, __VA_ARGS__&gt; \\ &#123; \\ public: \\ /** Default constructor */ \\ DynamicMulticastDelegateName() \\ &#123; \\ &#125; \\ \\ /** Construction from an FMulticastScriptDelegate must be explicit. This is really only used by UObject system internals. */ \\ explicit DynamicMulticastDelegateName(const TMulticastScriptDelegate&lt;&gt;&amp; InMulticastScriptDelegate ) \\ : TBaseDynamicMulticastDelegate&lt;TWeakPtr, __VA_ARGS__&gt;(InMulticastScriptDelegate) \\ &#123; \\ &#125; \\ \\ /** Broadcasts this delegate to all bound objects, except to those that may have expired */ \\ void Broadcast(FuncParamList) const \\ &#123; \\ ExecFunction(FuncParamPassThru); \\ &#125; \\ &#125;; FUNC_CONCT宏只是简单的拼接： 12/** Helper macro that enables passing comma-separated arguments as a single macro parameter */#define FUNC_CONCAT(...) __VA_ARGS__ 展开所有宏之后的代码： 12345678910111213141516171819struct _Script_HotPatcherEditor_eventOnTestDynamicMultiDelegate_Parms&#123; FString InStr;&#125;;static inline void FOnTestDynamicMultiDelegate_DelegateWrapper(const FMulticastScriptDelegate&amp; OnTestDynamicMultiDelegate, const FString&amp; InStr)&#123; _Script_HotPatcherEditor_eventOnTestDynamicMultiDelegate_Parms Parms; Parms.InStr=InStr; OnTestDynamicMultiDelegate.ProcessMulticastDelegate&lt;UObject&gt;(&amp;Parms);&#125;class FOnTestDynamicMultiDelegate : public TBaseDynamicMulticastDelegate&lt;FWeakObjectPtr, void, const FString&amp;&gt;&#123;public: FOnTestDynamicMultiDelegate() &#123; &#125; explicit FOnTestDynamicMultiDelegate(const TMulticastScriptDelegate&lt;&gt;&amp; InMulticastScriptDelegate ) : TBaseDynamicMulticastDelegate&lt;FWeakObjectPtr, void, const FString&amp;&gt;(InMulticastScriptDelegate) &#123; &#125; void Broadcast(const FString&amp; InStr ) const &#123; FOnTestDynamicMultiDelegate_DelegateWrapper(*this, InStr ); &#125; &#125;; 注，由上面的代码可知，只有普通代理（DECLARE_DELEGATE）声明的代理才可以使用 TBaseDelegate 的BindUObject等函数，动态代理和多播代理都不可以。","tags":[{"name":"Delegate","slug":"Delegate","permalink":"https://ue5wiki.com/tags/Delegate/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"ES2.0 最多 75 根骨骼的限制","date":"2021-07-03T22:47:58.000Z","path":"wiki/36473/","text":"因为移动平台缺少 32 位的索引支持，所以最多支持 65k 个顶点和 75 根骨骼。 但是可以通过拆分骨骼模型的材质来实现，每个材质支持 75 根，这是单次 drawcall 的限制，分成不同的批次就可以了。 Meshes for Mobile Platforms Character’s skeletal mesh disappears under Mobile/HTML 5 Preview Rendering Level PS: 不能用 uniform 了，换其他方式，比如 VTF，也可以实现超过 75 根骨骼。 在 UE 中如果在 ES2.0 中（目前 UE 的 ES3.0 也是 75）想要更高的骨骼数量，需要拆分模型使用的材质： Warning: SkeletalMesh SK_m0146b0003, is not supported for current feature level (ES3_1) and will not be rendered. NumBones 78 (supported 75), NumBoneInfluences: 4 材质和模型插槽的关系： How to distinguish material and material slot","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"ES2.0","slug":"ES2-0","permalink":"https://ue5wiki.com/tags/ES2-0/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"FCommandLine 过滤模式","date":"2021-07-03T22:46:34.000Z","path":"wiki/36198/","text":"FCommandLine是 UE 封装的启动参数的管理类，在 Launch 模块下的 FEngineLoop::PreInit 中被初始化 (FCommandLine::Set) 为程序启动的 CmdLine。FCommandLine 支持 Append 和Parser这是比较常用的功能，但是今天要说的是另外一个：CommandLine 的白名单和黑名单模式。考虑这样的需求：在游戏开发阶段，有很多参数可以在启动时配置，方便测试，但是在发行时需要把启动时从命令行读取配置的功能给去掉，强制使用我们设置的默认参数。 OVERRIDE_COMMANDLINE_WHITELIST怎么才是最简单的办法？其实这一点根本不需要自己去处理这部分的内容，因为 FCommandLine 支持白名单模式。开启的方法为在 target.cs 中增加 WANTS_COMMANDLINE_WHITELIST 宏： 1GlobalDefinitions.Add(&quot;WANTS_COMMANDLINE_WHITELIST=1&quot;); 如果只开启这个，则默认情况下不允许接收任何外部传入的参数，但具有默认的参数 -fullscreen /windowed。 当然，我们可以自己指定这个 WHITLIST，那么就是在target.cs 中使用 OVERRIDE_COMMANDLINE_WHITELIST 宏： 1GlobalDefinitions.Add(&quot;OVERRIDE_COMMANDLINE_WHITELIST=\\&quot;-arg1 -arg2 -arg3 -arg4\\&quot;&quot;); 这样就只有我们指定的这些参数才可以在运行时接收，防止玩家恶意传递参数导致游戏出错。这部分的代码是写在 Misc/CommandLine.cpp 中的。 Example: 123// target.csGlobalDefinitions.Add(&quot;WANTS_COMMANDLINE_WHITELIST=1&quot;);GlobalDefinitions.Add(&quot;OVERRIDE_COMMANDLINE_WHITELIST=\\&quot;-e -c\\&quot;&quot;); 这里只指定了 -e/-c 两个参数，如果程序在启动时被指定了其他的参数，如： 1D:/UnrealEngine/EngineSource/UE_4.21_Source/Engine/Binaries/Win64/UE4Launcher.exe -e -c -d 在 FCommandLine::Get() 只能得到 -e 和-c，-d和 exe 路径都被丢弃了，只能用在指定开关，不能用来传递值。 FILTER_COMMANDLINE_LOGGING还可以在 target.cs 中指定 FILTER_COMMANDLINE_LOGGING 来控制对 FCommandLine::LoggingCmdLine 的过滤： 1GlobalDefinitions.Add(&quot;FILTER_COMMANDLINE_LOGGING=\\&quot;-arg1 -arg2 -arg3 -arg4\\&quot;&quot;); 它会在程序从命令行中接收的参数中过滤所指定的参数，类似于参数的黑名单。 Example: 12GlobalDefinitions.Add(&quot;WANTS_COMMANDLINE_WHITELIST=1&quot;);GlobalDefinitions.Add(&quot;FILTER_COMMANDLINE_LOGGING=\\&quot;-e -c\\&quot;&quot;); 在运行时传入参数： 1D:/UnrealEngine/EngineSource/UE_4.21_Source/Engine/Binaries/Win64/UE4Launcher.exe -e -c -d 得到的是： 1-D:/UnrealEngine/EngineSource/UE_4.21_Source/Engine/Binaries/Win64/UE4Launcher.exe -d -e和 -c 被过滤掉了。","tags":[{"name":"Commandline","slug":"Commandline","permalink":"https://ue5wiki.com/tags/Commandline/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"COMPILED_PLATFORM_HEADER","date":"2021-07-03T22:42:49.000Z","path":"wiki/35464/","text":"在 UE4.22 之前，UE 的跨平台库的实现方式都是创建一个泛型平台类： 1234struct FGenericPlatformUtils&#123; static void GenericMethod()&#123;&#125;&#125;; 然后每个平台实现： 12345678// Windows/WindowsPlatformUtils.hstruct FWindowsPlatformUtils:public FGenericPlatformUtils&#123; static void GenericMethod()&#123; //doSomething... &#125;&#125;;typedef FWindowsPlatformUtils FPlatformUtils; 在 UE4.22 之前，需要使用下面这种方法： 12345678910// PlatformUtils.h #if PLATFORM_ANDROID #include &quot;Android/AndroidPlatformUtils.h&quot; #elif PLATFORM_IOS #include &quot;IOS/IOSPlatformUtils.h&quot; #elif PLATFORM_WINDOWS #include &quot;Windows/WindowsPlatformUtils.h&quot; #elif PLATFORM_MAC #include &quot;Mac/MacPlatformUtils.h&quot; #endif 需要手动判断每个平台再进行包含，也是比较麻烦的，在 4.23 之后，UE 引入了一个宏：COMPILED_PLATFORM_HEADER，可以把上面的包含简化为下面的代码： 1#include COMPILED_PLATFORM_HEADER(PlatformUtils.h) 它是定义在 Runtime/Core/Public/HAL/PreprocessorHelpers.h 下的宏： 1234567#if PLATFORM_IS_EXTENSION// Creates a string that can be used to include a header in the platform extension form &quot;PlatformHeader.h&quot;, not like below form#define COMPILED_PLATFORM_HEADER(Suffix) PREPROCESSOR_TO_STRING(PREPROCESSOR_JOIN(PLATFORM_HEADER_NAME, Suffix))#else// Creates a string that can be used to include a header in the form &quot;Platform/PlatformHeader.h&quot;, like &quot;Windows/WindowsPlatformFile.h&quot;#define COMPILED_PLATFORM_HEADER(Suffix) PREPROCESSOR_TO_STRING(PREPROCESSOR_JOIN(PLATFORM_HEADER_NAME/PLATFORM_HEADER_NAME, Suffix))#endif 注释已经比较说明作用了。而且它还有兄弟宏： 1234567#if PLATFORM_IS_EXTENSION// Creates a string that can be used to include a header with the platform in its name, like &quot;Pre/Fix/PlatformNameSuffix.h&quot;#define COMPILED_PLATFORM_HEADER_WITH_PREFIX(Prefix, Suffix) PREPROCESSOR_TO_STRING(Prefix/PREPROCESSOR_JOIN(PLATFORM_HEADER_NAME, Suffix))#else// Creates a string that can be used to include a header with the platform in its name, like &quot;Pre/Fix/PlatformName/PlatformNameSuffix.h&quot;#define COMPILED_PLATFORM_HEADER_WITH_PREFIX(Prefix, Suffix) PREPROCESSOR_TO_STRING(Prefix/PLATFORM_HEADER_NAME/PREPROCESSOR_JOIN(PLATFORM_HEADER_NAME, Suffix))#endif 命名有规律是多么重要的一件事…","tags":[{"name":"跨平台","slug":"跨平台","permalink":"https://ue5wiki.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UnLua 函数覆写实现分析","date":"2021-07-03T22:41:50.000Z","path":"wiki/35271/","text":"概括来说：UnLua 绑定了 UE 创建对象的事件，当创建 CDO 时会调用到 UnLua 的 NotifyUObjectCreated，在其中拿到了该对象的 UClass，对该对象的 UClass 中的 UFUNCTION 通过SetNativeFunc 修改为 CallLua 函数，这样就实现了覆写 UFUNCTION。 下面来具体分析一下实现。UnLua 实现覆写完整的调用栈： 替换 Thunk 函数 在 UnLua 的 FLuaContext 的 initialize 函数中，将 GLuaCxt 注册到了 GUObjectArray 中： 123456// LuaContext.cppif (!bAddUObjectNotify)&#123; GUObjectArray.AddUObjectCreateListener(GLuaCxt); // add listener for creating UObject GUObjectArray.AddUObjectDeleteListener(GLuaCxt); // add listener for deleting UObject&#125; 而 FLuaContext 继承自 FUObjectArray::FUObjectCreateListener 和FUObjectArray::FUObjectDeleteListener，所以当 UE 的对象系统创建对象的时候会把调用到 FLuaContext 的 NotifyUObjectCreated 与NotifyUObjectDeleted。 当创建一个 UObject 的时候会在 FObjectArray 的AllocateUObjectIndex中对多有注册过的 CreateListener 调用 NotifyUObjectDeleted 函数。 而 UnLua 实现覆写 UFUNCTION 的逻辑就是写在 NotifyUObjectCreated 中的 TryBindLua 调用中，栈如下：一个一个来说他们的作用： FLuaContext::TryBindUnlua12// Try to bind Lua module for a UObjectbool FLuaContext::TryToBindLua(UObjectBaseUtility *Object); 主要作用是：如果创建的对象继承了 UUnLuaInterface，具有GetModuleName 函数，则通过传进来的 UObject 获取到它的 UCclass，然后再通过 UClass 得到 GetModuleName 函数的UFunction，并通过 CDO 对象调用该 UFunction，得到该 CLass 绑定的 Lua 模块名。 若没有静态绑定，则检查是否具有动态绑定。 UUnLuaManager::Bind该函数定义在 UnLua/pRIVATE/UnLuaManager.cpp 文件中。 在 TryBindUnlua 中得到了当前创建对象的 UClass 和绑定的模块名，传递到了 Bind 函数中，它主要做了几件事情： 注册 Class 到 lua require 对应的 lua 模块 调用 UnLuaManager::BindInternal 函数 为当前对象创建一个 lua 端对象并 push 上一个 Initialize 函数并调用 BindInternal其中的关键函数为UnLuaManager::BindInternal： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Bind a Lua module for a UObject */bool UUnLuaManager::BindInternal(UObjectBaseUtility *Object, UClass *Class, const FString &amp;InModuleName, bool bNewCreated)&#123; if (!Object || !Class) &#123; return false; &#125; lua_State *L = *GLuaCxt; TStringConversion&lt;TStringConvert&lt;TCHAR, ANSICHAR&gt;&gt; ModuleName(*InModuleName); if (!bNewCreated) &#123; if (!BindSurvivalObject(L, Object, Class, ModuleName.Get())) // try to bind Lua module for survival UObject again... &#123; return false; &#125; FString *ModuleNamePtr = ModuleNames.Find(Class); if (ModuleNamePtr) &#123; return true; &#125; &#125; ModuleNames.Add(Class, InModuleName); Classes.Add(InModuleName, Class);#if UE_BUILD_DEBUG TSet&lt;FName&gt; *LuaFunctionsPtr = ModuleFunctions.Find(InModuleName); check(!LuaFunctionsPtr); TMap&lt;FName, UFunction*&gt; *UEFunctionsPtr = OverridableFunctions.Find(Class); check(!UEFunctionsPtr);#endif TSet&lt;FName&gt; &amp;LuaFunctions = ModuleFunctions.Add(InModuleName); GetFunctionList(L, ModuleName.Get(), LuaFunctions); // get all functions defined in the Lua module TMap&lt;FName, UFunction*&gt; &amp;UEFunctions = OverridableFunctions.Add(Class); GetOverridableFunctions(Class, UEFunctions); // get all overridable UFunctions OverrideFunctions(LuaFunctions, UEFunctions, Class, bNewCreated); // try to override UFunctions return ConditionalUpdateClass(Class, LuaFunctions, UEFunctions);&#125; 这个函数接受到的参数是创建出来的 UObject，以及它的 UClass，还有对应的 Lua 的模块名。 把对象的 UClass 与 Lua 的模块名对应添加到 ModuleNames 和Classes中 从 Lua 端通过 L 获取所指定模块名中的所有函数 从 UClass 获取所有的 BlueprintEvent、RepNotifyFunc 函数 对两边获取的结果调用 UUnLuaManager::OverrideFunctions 执行替换 UUnLuaManager::OverrideFunctions对从 Lua 端获取的函数使用名字在当前类的 UFunction 中查找，依次对其调用UUnLuaManager::OverrideFunction. UUnLuaManager::OverrideFunction 判断传入的 UFunction 是不是属于传入的 Outer UClasss 判断是否允许调用被覆写的函数 调用 AddFunction 函数 UUnLuaManager::AddFunction 如果函数为 FUNC_Native 则将 FLuaInvoker::execCallLua 和所覆写的函数名通过 AddNativeFunction 添加至 UClass 将 UFunction 内的函数指针替换为(FNativeFuncPtr)&amp;FLuaInvoker::execCallLua 如果开启了允许调用被覆写的函数，则把替换 NativeFunc 之前的 UFunction 对象存到 GReflectionRegistry 中 Call lua首先，需要说的一点是，当使用 UEC++ 写的带有 UFUNCTION 并具有 BlueprintNativeEvent 或者 BlueprintImplementableEvent 标记的函数，UHT 会给生成对应名字的函数： 123456UFUNCTION(BlueprintNativeEvent,BlueprintCallable) bool TESTFUNC(); bool TESTFUNC_Implementation();UFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = &quot;BeginPlay&quot;)) bool TESTImplEvent(AActor* InActor,int32 InIval); UHT 生成的函数和传递的数据结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// generated.h#define MicroEnd_423_Source_MicroEnd_423_Public_MyActor_h_13_EVENT_PARMS \\ struct MyActor_eventReceiveBytes_Parms \\ &#123; \\ TArray&lt;uint8&gt; InData; \\ &#125;; \\ struct MyActor_eventTESTFUNC_Parms \\ &#123; \\ bool ReturnValue; \\ \\ /** Constructor, initializes return property only **/ \\ MyActor_eventTESTFUNC_Parms() \\ : ReturnValue(false) \\ &#123; \\ &#125; \\ &#125;; \\ struct MyActor_eventTESTImplEvent_Parms \\ &#123; \\ AActor* InActor; \\ int32 InIval; \\ bool ReturnValue; \\ \\ /** Constructor, initializes return property only **/ \\ MyActor_eventTESTImplEvent_Parms() \\ : ReturnValue(false) \\ &#123; \\ &#125; \\ &#125;;// gen.cppstatic FName NAME_AMyActor_TESTFUNC = FName(TEXT(&quot;TESTFUNC&quot;));bool AMyActor::TESTFUNC()&#123; MyActor_eventTESTFUNC_Parms Parms; ProcessEvent(FindFunctionChecked(NAME_AMyActor_TESTFUNC),&amp;Parms); return !!Parms.ReturnValue;&#125;static FName NAME_AMyActor_TESTImplEvent = FName(TEXT(&quot;TESTImplEvent&quot;));bool AMyActor::TESTImplEvent(AActor* InActor, int32 InIval)&#123; MyActor_eventTESTImplEvent_Parms Parms; Parms.InActor=InActor; Parms.InIval=InIval; ProcessEvent(FindFunctionChecked(NAME_AMyActor_TESTImplEvent),&amp;Parms); return !!Parms.ReturnValue;&#125; 可以看到，UHT 帮我们定义了同名函数，并将其转发给ProcessEvent。 注意：这里通过 FindFunctionChecked 方法是调用的UObject::FindFunctionChecked： 1234567891011121314UFunction* UObject::FindFunction(FName InName) const&#123; return GetClass()-&gt;FindFunctionByName(InName);&#125;UFunction* UObject::FindFunctionChecked(FName InName) const&#123; UFunction* Result = FindFunction(InName); if (Result == NULL) &#123; UE_LOG(LogScriptCore, Fatal, TEXT(&quot;Failed to find function %s in %s&quot;), *InName.ToString(), *GetFullName()); &#125; return Result;&#125; 可以看到，这里传递给 ProcessEvent 的UFunction*就是从当前对象的 UClass 中得到的。 经过前面分分析可以知道，UnLua 实现的函数覆写，就是把 UClass 中的 UFunction 中的原生 thunk 函数指针替换为 FLuaInvoker::execCallLua，而且当一个对象的BlueprintNativeEvent 和BlueprintImplementableEvent函数被调用的时候会调用到 ProcessEvent 并传入对应的 UFunction*，在ProcessEvent 中又调Invork（调用其中的原生指针），也就是实现调用到了 unlua 中替换绑定的FLuaInvoker::execCallLua，在这个函数中再转发给调用 lua 端的函数，从而实现了覆写函数的目的。","tags":[{"name":"UnLua","slug":"UnLua","permalink":"https://ue5wiki.com/tags/UnLua/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"Lua","slug":"Programming/Lua","permalink":"https://ue5wiki.com/categories/Programming/Lua/"}]},{"title":"UObject 的 FObjectInitializer 构造函数的调用","date":"2021-07-03T22:39:51.000Z","path":"wiki/34882/","text":"注意：只有 GENERATED_UCLASS_BODY 才可以实现 FObjectInitializer 的构造函数。 在继承自 UObject 的类中，都可以自己写一个接收 const FObjectInitializer&amp; 参数的构造函数，在创建对象时会被调用： 1UMyObject::UMyObject(const FObjectInitializer&amp; Initializer)&#123;&#125; 在类中的 GENERATED_UCLASS_BODY 中默认声明这样一个构造函数。并且，在 UHT 生成的代码中通过宏还定义了一个函数： 1DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UMyObject) 这个宏经过展开之后就是这样的: 1static void __DefaultConstructor(const FObjectInitializer&amp; X) &#123; new((EInternal*)X.GetObj())UMyObject(X); &#125; 为当前的对象类型 UMyObject 定义了一个 __DefaultConstructor 函数，作用是在当前 FObjectInitializer 传入的参数的 Object 上调用 FObjectInitializer 的构造函数。 注意 ：如果是GENERATED_BODY 则不会声明这个构造函数，使用的就是另一个宏： 1DEFINE_DEFAULT_CONSTRUCTOR_CALL(UMyObject) 展开之后是这样的： 1static void __DefaultConstructor(const FObjectInitializer&amp; X) &#123; new((EInternal*)X.GetObj())UMyObject; &#125; 是通过 GANERATED_BODY 和GENERATED_UCLASS_BODY来定义了两种 __DefaultConstructor 的实现，一种是调用 FObjectInitializer 的构造函数，另一种是调用类的默认构造函数。 所以，默认情况下 FObjectInitializer 的构造函数和 UObject 的默认构造函数在调用时只会走一个。 那么它是如何被调用到的呢？ 在 NewObject 中调用的 StaticConstructObject_Internal 中有以下代码： 123456789bool bRecycledSubobject = false; Result = StaticAllocateObject(InClass, InOuter, InName, InFlags, InternalSetFlags, bCanRecycleSubobjects, &amp;bRecycledSubobject);check(Result != NULL);// Don&#x27;t call the constructor on recycled subobjects, they haven&#x27;t been destroyed.if (!bRecycledSubobject)&#123; STAT(FScopeCycleCounterUObject ConstructorScope(InClass, GET_STATID(STAT_ConstructObject))); (*InClass-&gt;ClassConstructor)(FObjectInitializer(Result, InTemplate, bCopyTransientsFromClassDefaults, true, InInstanceGraph) );&#125; 通过传入进来的 UClass 对象获取其中的 ClassConstructor 函数指针，并构造出一个 FObjectInitializer 作为参数传递。 在之前的笔记 (StaticClass 是如何定义的) 中，写到了，通过 GetPrivateStaticClass 获取到当前 UObject 类的 UClass 实例会实例化出一个当前类的 InternalConstructor 函数（注意这个模板参数 T 是 UObject 的类）： 12345678// class.h// Helper template to call the default constructor for a classtemplate&lt;class T&gt;void InternalConstructor(const FObjectInitializer&amp; X )&#123; T::__DefaultConstructor(X);&#125; 就将其转发到了上面讲到的 __DefaultConstructor 函数上，然后它里面又转发到了所传入 FObjectInitializer 对象上的 const FObjectInitializer&amp; 构造函数上（或者默认构造函数上）。 创建对象并调用 const FObjectInitializer&amp; 构造函数的调用流程为： 通过调用 StaticAllocateObject 根据传入的 UClass 创建出对象 通过传入的 UClass 对象内的 ClassConstructor 函数指针调用所创建 UObject 类的 InternalConstructor 函数 UMyObject::InternalConstructor会转发到UMyObject::__DefaultConstructor UMyObject::__DefaultConstructor会从接收到的 FObjectInitializer 对象上获取到通过 StaticAllocateObject 创建的对象，然后通过 placement-new 的方式，在这块内存上调用 UMyObject 类的 const FObjectInitializer&amp; 构造函数。 通过以上的流程就实现了 NewObject 时会自动调用到它的 FObjectInitializer 构造函数。 注意：在 CDO 的构造上有点区别，CDO 的构造是通过 UClass::GetDefaultObject 中实现上述流程的。","tags":[{"name":"UObject","slug":"UObject","permalink":"https://ue5wiki.com/tags/UObject/"},{"name":"ObjectInitializer","slug":"ObjectInitializer","permalink":"https://ue5wiki.com/tags/ObjectInitializer/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"属性反射实现分析","date":"2021-07-03T22:37:53.000Z","path":"wiki/34497/","text":"当在 UCLASS 类中给一个属性添加 UPROPERTY 标记时： 123456789101112131415UCLASS()class MICROEND_423_API AMyActor : public AActor&#123; GENERATED_BODY()protected: // Called when the game starts or when spawned virtual void BeginPlay() override;public: // Called every frame virtual void Tick(float DeltaTime) override; UPROPERTY(EditAnywhere) int32 ival;&#125;； 会生成反射代码，生成反射代码的代码是在 UHT 中的Programs/UnrealHeaderTool/Private/CodeGenerator.cpp： 12345678910111213141516#if WITH_METADATA const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData[] = &#123; &#123; &quot;Category&quot;, &quot;MyActor&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;Public/MyActor.h&quot; &#125;, &#125;;#endifconst UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AMyActor_Statics::NewProp_ival = &#123; &quot;ival&quot;, nullptr, (EPropertyFlags) 0x0010000000000001, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public | RF_Transient | RF_MarkAsNative, 1, STRUCT_OFFSET(AMyActor, ival), METADATA_PARAMS(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData, ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData))&#125;; 首先 const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AMyActor_Statics::NewProp_ival 是创建出一个结构，用于记录当前属性的信息，比如变量名、相对于对象起始地址的偏移。 注意 UE4CodeGen_Private::FIntPropertyParams 这样的类型都是定义在 UObject/UObjectGlobals.h 中的，对于基础类型的属性（如 int8/int32/float/array/map）等使用的都是FGenericPropertyParams。 F*PropertyParams在 UObject/UObjectGlobals.h 文件中，引擎里定义了很多的F*PropertyParams，但是他们的数据结构基本相同（但是他们并没有继承关系），都是 POD 的类型，每个数据依次排列，而且不同类型的 Params 尽量都保持了一致的顺序。 123456789101112131415// UObject/UObjectGlobals.hstruct FGenericPropertyParams // : FPropertyParamsBaseWithOffset&#123; const char* NameUTF8; const char* RepNotifyFuncUTF8; EPropertyFlags PropertyFlags; EPropertyGenFlags Flags; EObjectFlags ObjectFlags; int32 ArrayDim; int32 Offset;#if WITH_METADATA const FMetaDataPairParam* Z_Construct_UClass_; int32 NumMetaData;#endif&#125;; 一个一个来分析它的参数。 NameUTF8NameUTF8 是属性的 UTF8 的名字，在运行时可以通过 UProperty 的GetNameCPP来获取。 RepNotifyFuncUTF8RepNotifyFuncUTF8 是在当前属性绑定的修改之后的函数名字。 如果属性是这样声明： 1234UPROPERTY(EditAnywhere,ReplicatedUsing=OnRep_Replicatedival) int32 ival;UFUNCTION() virtual void OnRep_Replicatedival() &#123;&#125; 这样生成的反射代码就为： 12345678910const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_AMyActor_Statics::NewProp_ival = &#123; &quot;ival&quot;, &quot;OnRep_Replicatedival&quot;, (EPropertyFlags)0x0010000100000021, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(AMyActor, ival), METADATA_PARAMS(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData,ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData))&#125;; 因为 OnRep_Replicatedival 也是 UFUNCTION 的函数，所以可以通过反射来访问。 PropertyFlagsPropertyFlags是一个类型为 EPropertyFlags 的枚举，枚举值按照位排列，根据在 UPROPERTY 中的标记来按照位或来记录当前属性包含的标记信息。在 UnrealHeaderTool/Private/CodeGenerator.cpp 中生成代码时会根据当前属性的 flag 和 CPF_ComputedFlags 做位运算： 12345678910/*// All the properties that should never be loaded or saved#define CPF_ComputedFlags (CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor | CPF_HasGetValueTypeHash)0x0000000040000000 CPF_IsPlainOldData 0x0000001000000000 CPF_NoDestructor 0x0000000000000200 CPF_ZeroConstructor 0x0008000000000000 CPF_HasGetValueTypeHash*/EPropertyFlags PropFlags = Prop-&gt;PropertyFlags &amp; ~CPF_ComputedFlags; 在运行时可以通过 UProperty 的HasAnyPropertyFlags函数来检测是否具有特定的 flag。 一般情况下，可以通过 UProperty 来获取到该参数的标记属性，比如当通过 UFunction 获取函数的参数时，可以区分哪个 UProperty 是输入参数、哪个是返回值。 Flags第四个参数 Flags 是类型为 UE4CodeGen_Private::EPropertyGenFlags 是一个枚举，定义在 UObject/UObjectGlobals.h 中，标记了当前 Property 的类型。 ObjectFlagsObjectFlags 是 EObjectFlags 类型的枚举，其枚举值也是按照位来划分的。定义在CoreUObject/Public/UObject/ObjectMacros.h UHT 生成这部分代码在 Programs/UnrealHeaderTool/Private/CodeGenerator.cpp 中： 1const TCHAR* FPropertyObjectFlags = FClass::IsOwnedByDynamicType(Prop) ? TEXT(&quot;RF_Public|RF_Transient&quot;) : TEXT(&quot;RF_Public|RF_Transient|RF_MarkAsNative&quot;); 通过 FClass::IsOwnedByDynamicType 函数来检测是否为 PROPERTY 添加 RF_MarkAsNative 的 flag。 12345678910111213141516171819202122232425262728293031323334353637// Programs/UnrealHeaderTool/Public/ParserClass.h/** Helper function that checks if the field is a dynamic type (can be constructed post-startup) */template &lt;typename T&gt;static bool IsDynamic(const T* Field)&#123; return Field-&gt;HasMetaData(NAME_ReplaceConverted);&#125; // Programs/UnrealHeaderTool/Private/ParserClass.cppbool FClass::IsOwnedByDynamicType(const UField* Field)&#123; for (const UField* OuterField = Cast&lt;const UField&gt;(Field-&gt;GetOuter()); OuterField; OuterField = Cast&lt;const UField&gt;(OuterField-&gt;GetOuter())) &#123; if (IsDynamic(OuterField)) &#123; return true; &#125; &#125; return false;&#125;bool FClass::IsOwnedByDynamicType(const FField* Field)&#123; for (FFieldVariant Owner = Field-&gt;GetOwnerVariant(); Owner.IsValid(); Owner = Owner.GetOwnerVariant()) &#123; if (Owner.IsUObject()) &#123; return IsOwnedByDynamicType(Cast&lt;const UField&gt;(Owner.ToUObject())); &#125; else if (IsDynamic(Owner.ToField())) &#123; return true; &#125; &#125; return false;&#125; 通过调用 UField 的HasMetaData检测是否具有 TEXT(&quot;ReplaceConverted&quot;) 的元数据（该元数据就是后面要讲到的 Metadata）。 ArrayDimArrayDim 用于记录当前属性的元素数量，当只是声明一个单个对象时，如： 123456789101112UPROPERTY() float fval;UPROPERTY(EditAnywhere) FString StrVal = TEXT(&quot;123456&quot;);UPROPERTY(EditAnywhere) TSubclassOf&lt;UObject&gt; ClassVal;UPROPERTY(EditAnywhere) UTexture2D* Texture2D;UPROPERTY() FResultDyDlg ResultDlg;UPROPERTY() UMySceneComponent* SceneComp; 这些属性所有的 ArrayDim 均为 1. 但是当使用 C++ 原生数组时： 12UPROPERTY() int32 iArray[12]; 它的 ArrayDim 就为： 1CPP_ARRAY_DIM(iArray, AMyActor) CPP_ARRAY_DIM这个宏定义在CoreUObject/Public/UObject/UnrealType.h： 123/** helper to calculate an array&#x27;s dimensions **/#define CPP_ARRAY_DIM(ArrayName, ClassName) \\ (sizeof(((ClassName*)0)-&gt;ArrayName) / sizeof(((ClassName*)0)-&gt;ArrayName[0])) 就是用来计算数组内的元素数量的，普通的非数组属性其值为 1，可以当作是元素数量为 1 的数组。 OffsetSTRUCT_OFFSET宏的作用为得到数据成员相对于类起始地址的偏移，通过获取 数据成员指针 得到，类型为size_t。 然后当前类中的反射属性都会被添加到 PropPointers 中，也是 UHT 生成的代码： 123const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_AMyActor_Statics::PropPointers[] = &#123; (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_AMyActor_Statics::NewProp_ival,&#125;; 在运行时可以通过 UProperty 得到指定的对象值： 123456789for (TFieldIterator&lt;UProperty&gt; It(InActor-&gt;GetClass()); It; ++It) &#123; UProperty* Property = *It; if (Property-&gt;GetNameCPP() == FString(&quot;ival&quot;)) &#123; int32* i32 = Property-&gt;ContainerPtrToValuePtr&lt;int32&gt;(InActor); UE_LOG(LogTemp, Log, TEXT(&quot;Property:%s value:%d&quot;), *Property-&gt;GetNameCPP(),i32); &#125; &#125; 其中 UProperty 中的 ContainerPtrToValuePtr 系列函数都会转发到ContainerVoidPtrToValuePtrInternal： 1234567891011FORCEINLINE void* ContainerVoidPtrToValuePtrInternal(void* ContainerPtr, int32 ArrayIndex) const&#123; check(ArrayIndex &lt; ArrayDim); check(ContainerPtr); if (0) &#123; // in the future, these checks will be tested if the property is NOT relative to a UClass check(!Cast&lt;UClass&gt;(GetOuter())); // Check we are _not_ calling this on a direct child property of a UClass, you should pass in a UObject* in that case &#125; return (uint8*)ContainerPtr + Offset_Internal + ElementSize * ArrayIndex;&#125; 其实就是拿到 UObject 的指针，然后偏移到指定位置（第二个参数用在对象是数组的情况，用来访问指定下标的元素，默认情况下访问下标为 0）。 Z_Construct_UClass_和 NumMetaData它们的类型分别为 FMetaDataPairParam 和int32，用来记录当前反射属性的元数据：比如属性的 Category、注释、所属的文件、ToolTip 信息等等，比如在 C++ 函数上添加的注释能够在编辑器蓝图中看到注释的信息，都是靠解析这些元数据来实现的。 12345678// CoreUObject/Public/UObject/UObjectGlobals.h#if WITH_METADATA struct FMetaDataPairParam &#123; const char* NameUTF8; const char* ValueUTF8; &#125;;#endif 这两个参数通过 METADATA_PARAMS 包裹，用于处理 WITH_MATEDATA 的不同情况： 123456// METADATA_PARAMS(x, y) expands to x, y, if WITH_METADATA is set, otherwise expands to nothing#if WITH_METADATA #define METADATA_PARAMS(x, y) x, y,#else #define METADATA_PARAMS(x, y)#endif 把 UHT 生成的代码宏展开为： 12345678#if WITH_METADATA const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData[] = &#123; &#123; &quot;Category&quot;, &quot;MyActor&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;Public/MyActor.h&quot; &#125; &#125;;#endifMETADATA_PARAMS(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData, ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::NewProp_ival_MetaData)) 就是把 UE4CodeGen_Private::FMetaDataPairParam 这个类型的数组和数组元素个数传递给 F*PropertyParams，实现在WITH_METADATA 的情况下处理是否具有 Metadata 的情况。 运行时的 Property引擎中通过 UE4CodeGen_Private::ConstructFProperty 来创建出真正 Runtime 使用的UProperty(4.25 之后是FProperty)，定义在UObject/UObjectGlobals.cpp。 FBoolPropertyParams 特例 当一个反射的数据是 bool 类型时，引擎产生的反射信息中有一个比较有意思的特例，FBoolPropertyParams，可以看一下它的结构： 12345678910111213141516struct FBoolPropertyParams // : FPropertyParamsBase&#123; const char* NameUTF8; const char* RepNotifyFuncUTF8; EPropertyFlags PropertyFlags; EPropertyGenFlags Flags; EObjectFlags ObjectFlags; int32 ArrayDim; uint32 ElementSize; SIZE_T SizeOfOuter; void (*SetBitFunc)(void* Obj);#if WITH_METADATA const FMetaDataPairParam* MetaDataArray; int32 NumMetaData;#endif&#125;; 它具有一个 SetBitFunc 的函数指针。看一下生成的反射代码： 12345678910// source code UPROPERTY() bool bEnabled;// gen.cppvoid Z_Construct_UClass_AMyActor_Statics::NewProp_bEnabled_SetBit(void* Obj)&#123; ((AMyActor*)Obj)-&gt;bEnabled = 1;&#125;const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UClass_AMyActor_Statics::NewProp_bEnabled = &#123; &quot;bEnabled&quot;, nullptr, (EPropertyFlags)0x0010000000000000, UE4CodeGen_Private::EPropertyGenFlags::Bool | UE4CodeGen_Private::EPropertyGenFlags::NativeBool, RF_Public|RF_Transient|RF_MarkAsNative, 1, sizeof(bool), sizeof(AMyActor), &amp;Z_Construct_UClass_AMyActor_Statics::NewProp_bEnabled_SetBit, METADATA_PARAMS(Z_Construct_UClass_AMyActor_Statics::NewProp_bEnabled_MetaData, ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::NewProp_bEnabled_MetaData)) &#125;; 注意 ：其中的关键是，UHT 给该属性生成了一个SetBit 的函数，why？其他类型的属性都可以通过 STRUCT_OFFSET 来获取该成员的类内偏移，为什么 bool 就不行了呢？ 这是因为 C++ 有位域 (bit-field) 这个概念，一个 bool 可能只占 1bit，而不是 1byte，但这不是真正的原因。 真正的原因是，C++ 标准规定了不能对位域进行取地址操作！前面已经提到了 STRUCT_OFFSET 实际上是获取到数据成员的指针，得到的是类内偏移，但是因为 C++ 的不能对位域取地址的规定，STRUCT_OFFSET无法用在位域的成员上的。 [IOS/IEC 14882:2014 §9.6]The address-of operator &amp; shall not be applied to a bit-ﬁeld, so there are no pointers to bit-ﬁelds. 那么这又是因为什么呢？因为系统编址的最小单位是字节而不是位，所以没办法取到 1 字节零几位的地址。也就决定了不能对位域的数据成员取地址。 UE 内其实大量用到了 bool 使用位域的方式来声明（如果不使用位域，bool 类型的空间浪费率达到 87.5% :)），所以 UE 就生成了一个函数来为以位域方式声明的成员设置值。 但是！UE 不支持直接对加了 UPROPERTY 的 bool 使用位域： 12UPROPERTY() bool bEnabled:1; 编译时会有下列错误： LogCompile: Error: bool bitfields are not supported. 要写成下列方式： 12UPROPERTY() uint8 bEnabled:1; 使用这种方式和使用 bool bEnabled; 方式生成的反射代码一模一样，所以，UE 之所以会生成一个函数来设置 bool 的值，是因为既要支持原生 bool，也要支持位域。 通过 UProperty 获取值 如果我知道某个类的对象内有一个属性名字，那么怎么能够得到它的值呢？这个可以基于 UE 的属性反射来实现： 首先通过 TFieldIterator 可以遍历该对象的 UProperty： 1234for (TFieldIterator&lt;UProperty&gt; It(InActor-&gt;GetClass()); It; ++It)&#123; UProperty* Property = *It;&#125; 然后可以根据得到的 Property 来判读名字： 1if (Property-&gt;GetNameCPP() == FString(&quot;ival&quot;)) 检测是指定名字的 Property 后可以通过 UProperty 上的 ContainerPtrToValuePtr 函数来获取对象内该属性的指针： 1int32* i32 = Property-&gt;ContainerPtrToValuePtr&lt;int32&gt;(InActor) 前面讲到过，UPropery 里存储 Offdet 值就是当前属性相对于对象起始地址的偏移。而 ContainerPtrToValuePtr 函数所做的就是得到当前对象偏移 Offset 的地址然后做了类型转换。 Property 的 Flag通过上面的分析，可以看到 UPROPERTY 添加的标记，如 EditAnywhere 等，会给指定的 Property 生成 FLAG 存储在 F*PropertyParams 结构的第三个参数中，是位描述的。 可选值为 EPropertyFlags 枚举值： Runtime/CoreUObject/Public/UObject/ObjectMacros.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Flags associated with each property in a class, overriding the * property&#x27;s default behavior. * @warning When adding one here, please update ParsePropertyFlags() */enum EPropertyFlags : uint64&#123; CPF_None = 0, CPF_Edit = 0x0000000000000001, ///&lt; Property is user-settable in the editor. CPF_ConstParm = 0x0000000000000002, ///&lt; This is a constant function parameter CPF_BlueprintVisible = 0x0000000000000004, ///&lt; This property can be read by blueprint code CPF_ExportObject = 0x0000000000000008, ///&lt; Object can be exported with actor. CPF_BlueprintReadOnly = 0x0000000000000010, ///&lt; This property cannot be modified by blueprint code CPF_Net = 0x0000000000000020, ///&lt; Property is relevant to network replication. CPF_EditFixedSize = 0x0000000000000040, ///&lt; Indicates that elements of an array can be modified, but its size cannot be changed. CPF_Parm = 0x0000000000000080, ///&lt; Function/When call parameter. CPF_OutParm = 0x0000000000000100, ///&lt; Value is copied out after function call. CPF_ZeroConstructor = 0x0000000000000200, ///&lt; memset is fine for construction CPF_ReturnParm = 0x0000000000000400, ///&lt; Return value. CPF_DisableEditOnTemplate = 0x0000000000000800, ///&lt; Disable editing of this property on an archetype/sub-blueprint //CPF_ = 0x0000000000001000, ///&lt; CPF_Transient = 0x0000000000002000, ///&lt; Property is transient: shouldn&#x27;t be saved or loaded, except for Blueprint CDOs. CPF_Config = 0x0000000000004000, ///&lt; Property should be loaded/saved as permanent profile. //CPF_ = 0x0000000000008000, ///&lt; CPF_DisableEditOnInstance = 0x0000000000010000, ///&lt; Disable editing on an instance of this class CPF_EditConst = 0x0000000000020000, ///&lt; Property is uneditable in the editor. CPF_GlobalConfig = 0x0000000000040000, ///&lt; Load config from base class, not subclass. CPF_InstancedReference = 0x0000000000080000, ///&lt; Property is a component references. //CPF_ = 0x0000000000100000, ///&lt; CPF_DuplicateTransient = 0x0000000000200000, ///&lt; Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.) CPF_SubobjectReference = 0x0000000000400000, ///&lt; Property contains subobject references (TSubobjectPtr) //CPF_ = 0x0000000000800000, ///&lt; CPF_SaveGame = 0x0000000001000000, ///&lt; Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame CPF_NoClear = 0x0000000002000000, ///&lt; Hide clear (and browse) button. //CPF_ = 0x0000000004000000, ///&lt; CPF_ReferenceParm = 0x0000000008000000, ///&lt; Value is passed by reference; CPF_OutParam and CPF_Param should also be set. CPF_BlueprintAssignable = 0x0000000010000000, ///&lt; MC Delegates only. Property should be exposed for assigning in blueprint code CPF_Deprecated = 0x0000000020000000, ///&lt; Property is deprecated. Read it from an archive, but don&#x27;t save it. CPF_IsPlainOldData = 0x0000000040000000, ///&lt; If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue CPF_RepSkip = 0x0000000080000000, ///&lt; Not replicated. For non replicated properties in replicated structs CPF_RepNotify = 0x0000000100000000, ///&lt; Notify actors when a property is replicated CPF_Interp = 0x0000000200000000, ///&lt; interpolatable property for use with matinee CPF_NonTransactional = 0x0000000400000000, ///&lt; Property isn&#x27;t transacted CPF_EditorOnly = 0x0000000800000000, ///&lt; Property should only be loaded in the editor CPF_NoDestructor = 0x0000001000000000, ///&lt; No destructor //CPF_ = 0x0000002000000000, ///&lt; CPF_AutoWeak = 0x0000004000000000, ///&lt; Only used for weak pointers, means the export type is autoweak CPF_ContainsInstancedReference = 0x0000008000000000, ///&lt; Property contains component references. CPF_AssetRegistrySearchable = 0x0000010000000000, ///&lt; asset instances will add properties with this flag to the asset registry automatically CPF_SimpleDisplay = 0x0000020000000000, ///&lt; The property is visible by default in the editor details view CPF_AdvancedDisplay = 0x0000040000000000, ///&lt; The property is advanced and not visible by default in the editor details view CPF_Protected = 0x0000080000000000, ///&lt; property is protected from the perspective of script CPF_BlueprintCallable = 0x0000100000000000, ///&lt; MC Delegates only. Property should be exposed for calling in blueprint code CPF_BlueprintAuthorityOnly = 0x0000200000000000, ///&lt; MC Delegates only. This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly. CPF_TextExportTransient = 0x0000400000000000, ///&lt; Property shouldn&#x27;t be exported to text format (e.g. copy/paste) CPF_NonPIEDuplicateTransient = 0x0000800000000000, ///&lt; Property should only be copied in PIE CPF_ExposeOnSpawn = 0x0001000000000000, ///&lt; Property is exposed on spawn CPF_PersistentInstance = 0x0002000000000000, ///&lt; A object referenced by the property is duplicated like a component. (Each actor should have an own instance.) CPF_UObjectWrapper = 0x0004000000000000, ///&lt; Property was parsed as a wrapper class like TSubclassOf&lt;T&gt;, FScriptInterface etc., rather than a USomething* CPF_HasGetValueTypeHash = 0x0008000000000000, ///&lt; This property can generate a meaningful hash value. CPF_NativeAccessSpecifierPublic = 0x0010000000000000, ///&lt; Public native access specifier CPF_NativeAccessSpecifierProtected = 0x0020000000000000, ///&lt; Protected native access specifier CPF_NativeAccessSpecifierPrivate = 0x0040000000000000, ///&lt; Private native access specifier CPF_SkipSerialization = 0x0080000000000000, ///&lt; Property shouldn&#x27;t be serialized, can still be exported to text&#125;;","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UProperty","slug":"UProperty","permalink":"https://ue5wiki.com/tags/UProperty/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"函数反射实现分析","date":"2021-07-03T22:36:17.000Z","path":"wiki/34184/","text":"UHT 生成的反射信息 在 UE 的代码中加了 UFUNCTION() 修饰后 UHT 就会为该函数生成反射代码。 每一个支持反射的函数 UHT 都会给它生成一个类和一个函数：如在 AMyActor 这个类下有一个 ReflexFunc 的函数： 12345UFUNCTION()bool ReflexFunc(int32 InIval, UObject* InObj)&#123; return false;&#125; UHT 会生成这样命名规则的一个类和函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// UHT 为 ReflexFunc 生成的反射代码struct Z_Construct_UFunction_AMyActor_ReflexFunc_Statics&#123; struct MyActor_eventReflexFunc_Parms &#123; int32 InIval; UObject* InObj; bool ReturnValue; &#125;; static void NewProp_ReturnValue_SetBit(void* Obj); static const UE4CodeGen_Private::FBoolPropertyParams NewProp_ReturnValue; static const UE4CodeGen_Private::FObjectPropertyParams NewProp_InObj; static const UE4CodeGen_Private::FIntPropertyParams NewProp_InIval; static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];#if WITH_METADATA static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];#endif static const UE4CodeGen_Private::FFunctionParams FuncParams;&#125;;void Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_ReturnValue_SetBit(void* Obj)&#123; ((MyActor_eventReflexFunc_Parms*)Obj)-&gt;ReturnValue = 1;&#125;const UE4CodeGen_Private::FBoolPropertyParams Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_ReturnValue = &#123; &quot;ReturnValue&quot;, nullptr, (EPropertyFlags)0x0010000000000580, UE4CodeGen_Private::EPropertyGenFlags::Bool | UE4CodeGen_Private::EPropertyGenFlags::NativeBool, RF_Public|RF_Transient|RF_MarkAsNative, 1, sizeof(bool), sizeof(MyActor_eventReflexFunc_Parms), &amp;Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_ReturnValue_SetBit, METADATA_PARAMS(nullptr, 0)&#125;;const UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_InObj = &#123; &quot;InObj&quot;, nullptr, (EPropertyFlags)0x0010000000000080, UE4CodeGen_Private::EPropertyGenFlags::Object, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(MyActor_eventReflexFunc_Parms, InObj), Z_Construct_UClass_UObject_NoRegister, METADATA_PARAMS(nullptr, 0)&#125;;const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_InIval = &#123; &quot;InIval&quot;, nullptr, (EPropertyFlags)0x0010000000000080, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(MyActor_eventReflexFunc_Parms, InIval), METADATA_PARAMS(nullptr, 0)&#125;;const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::PropPointers[] = &#123; (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_ReturnValue, (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_InObj, (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::NewProp_InIval,&#125;;#if WITH_METADATAconst UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::Function_MetaDataParams[] = &#123; &#123; &quot;ModuleRelativePath&quot;, &quot;MyActor.h&quot; &#125;,&#125;;#endifconst UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::FuncParams = &#123; (UObject*(*)())Z_Construct_UClass_AMyActor, nullptr, &quot;ReflexFunc&quot;, nullptr, nullptr, sizeof(MyActor_eventReflexFunc_Parms), Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::PropPointers, UE_ARRAY_COUNT(Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::PropPointers), RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x00020401, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::Function_MetaDataParams))&#125;;// 通过 UHT 生成的反射信息来构造出 UFunctionUFunction* Z_Construct_UFunction_AMyActor_ReflexFunc()&#123; static UFunction* ReturnFunction = nullptr; if (!ReturnFunction) &#123; UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AMyActor_ReflexFunc_Statics::FuncParams); &#125; return ReturnFunction;&#125; 定义的 Z_Construct_UFunction_AMyActor_ReflexFunc_Statics 类中包含了以下信息： 存储函数的参数、返回值的结构体(POD)，注意该结构的声明顺序是按照函数参数的顺序 + 最后一个成员是函数返回值的方式排列。 函数参数、返回值的F*PropertyParams，用来给函数的每个参数以及返回值生成反射信息，用于构造出 UProperty，static 成员； 成员 static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];，数组，用于记录该函数的参数和返回值的类型为FPropertyParamsBase 的 static 数据成员的地址。 成员static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];，用于记录函数的元数据。如所属文件、Category、注释等等。 成员 static const UE4CodeGen_Private::FFunctionParams FuncParams; 用于记录当前函数的名字、Flag、参数的F*PropertyParams、参数数量，参数的结构大小等等，用于通过它来创建出UFunction*。 至于生成的SetBitd 的函数的作用，在上面属性反射的部分已经讲到了。 UE4CodeGen_Private::FFunctionParams结构声明为： 1234567891011121314151617181920// Source/Runtime/CoreUObject/Public/UObject/UObjectGlobals.hstruct FFunctionParams&#123; UObject* (*OuterFunc)(); UFunction* (*SuperFunc)(); const char* NameUTF8; const char* OwningClassName; const char* DelegateName; SIZE_T StructureSize; const FPropertyParamsBase* const* PropertyArray; int32 NumProperties; EObjectFlags ObjectFlags; EFunctionFlags FunctionFlags; uint16 RPCId; uint16 RPCResponseId;#if WITH_METADATA const FMetaDataPairParam* MetaDataArray; int32 NumMetaData;#endif&#125;; UHT 生成的 Z_Construct_UFunction_AMyActor_ReflexFunc 函数做了以下事情： 123456789UFunction* Z_Construct_UFunction_AMyActor_ReflexFunc()&#123; static UFunction* ReturnFunction = nullptr; if (!ReturnFunction) &#123; UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AMyActor_Add_Statics::FuncParams); &#125; return ReturnFunction;&#125; 根据定义的 Z_Construct_UFunction_AMyActor_ReflexFunc_Statics 结构中的 FuncParams 成员来创建出真正的 UFunction 对象。 最后，Z_Construct_UFunction_AMyActor_ReflexFunc这个函数会被注册到当前类反射数据的 FuncInfo 中。 Thunk 函数 UE 会为标记为UFUNCTION 的 Native 函数生成对应的 Thunk 函数 (BlueprintImplementableEvent 的函数不会)。如下列函数： 12345UFUNCTION()bool ReflexFunc(int32 InIval, UObject* InObj)&#123; return false;&#125; 生成的 Thunk 函数形式如下： 12345678910111213// generated.hDECLARE_FUNCTION(execReflexFunc);// gen.cppDEFINE_FUNCTION(AMyActor::execReflexFunc)&#123; P_GET_PROPERTY(FIntProperty,Z_Param_InIval); P_GET_OBJECT(UObject,Z_Param_InObj); P_FINISH; P_NATIVE_BEGIN; *(bool*)Z_Param__Result=P_THIS-&gt;ReflexFunc(Z_Param_InIval,Z_Param_InObj); P_NATIVE_END;&#125; DECLARE_FUNCTION/DEFINE_FUNCTION这两个宏是定义在 CoreUObject/Public/UObject/ObjectMacros.h 中的： 12345// This macro is used to declare a thunk function in autogenerated boilerplate code#define DECLARE_FUNCTION(func) static void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL)// This macro is used to define a thunk function in autogenerated boilerplate code#define DEFINE_FUNCTION(func) void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL) 展开这两个宏： 123456789101112// generated.hstatic void AMyActor::execReflexFunc(UObject* Context, FFrame&amp; Stack, RESULT_DECL);// gen.cppvoid AMyActor::execReflexFunc(UObject* Context, FFrame&amp; Stack, RESULT_DECL)&#123; P_GET_PROPERTY(FIntProperty,Z_Param_InIval); P_GET_OBJECT(UObject,Z_Param_InObj); P_FINISH; P_NATIVE_BEGIN; *(bool*)Z_Param__Result=P_THIS-&gt;ReflexFunc(Z_Param_InIval,Z_Param_InObj); P_NATIVE_END;&#125; 可以看到，UHT 为每个反射函数生成的都是一个参数一致的 static 成员函数，接收通用的参数，就可以用来处理所有的函数调用。 Thunk 函数中用到的这些宏： RESULT_DECL(CoreUObject/Public/UObject/Script.h)： 12345//// Blueprint VM intrinsic return value declaration.//#define RESULT_PARAM Z_Param__Result#define RESULT_DECL void*const RESULT_PARAM 其他的形如 P_GET_PROPERTY 之类的宏，都是定义在 CoreUObject/Public/UObject/ScriptMacros.h 文件中的，作用就是从栈上操作参数（因为 Thunk 函数是通用的参数，所以要从通用的参数中获取到每个函数具体的参数，UE 提供这些宏来做这些事情）。 这些 Thunk 函数通过 UHT 生成的 StaticRegisterNatives* 函数注册到 UClass 中（在 GetPrivateStaticClass 把该函数指针传递了进去）： 123456789void AMyActor::StaticRegisterNativesAMyActor()&#123; UClass* Class = AMyActor::StaticClass(); static const FNameNativePtrPair Funcs[] = &#123; &#123; &quot;BPNativeEvent&quot;, &amp;AMyActor::execBPNativeEvent &#125;, &#123; &quot;ReflexFunc&quot;, &amp;AMyActor::execReflexFunc &#125;, &#125;; FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));&#125; UE 不会为 BlueprintImplementableEvent 生成 Thunk 函数，但是会为它生成函数的反射信息，所以也可以通过反射的信息来调用 BlueprintImplementableEvent 的函数。 因为 `BlueprintImplementatableEventd 的函数是 C++ 提供原型不提供实现，让蓝图来进行覆写的，所以它不使用 Thunk 的形式调用（应该执行字节码的方式，这个暂时还没看到，有时间再来分析）。 Custom Thunk前面讲到当给函数加了 UFUNCTION 标记时 UHT 会给我们生成对应的 Thunk 函数，但是有些情况下需要我们自己来写 Thunk 的函数，如 UKismetArrayLibrary 中的对 Array 进行操作的函数，或者 UDataTableFunctionLibrary 中的 GetDataTableRowFromName 函数。 UE 提供了让我们自己实现 Thunk 函数的方法，在 UFUNCTION 中添加 CustomThunk 标记： 12UFUNCTION(CustomThunk)bool ReflexFunc(int32 InIval, UObject* InObj) 这样 UHT 就不会为这个函数生成出它的 Thunk 函数，这种情况下就需要自己提供了。自己写的方式和 UHT 生成的代码一样，可以使用 DECLARE_FUNCTION 或者DEFINE_FUNCTION（手动写按照 Thunk 函数的签名规则也是没问题的） 1234DECLARE_FUNCTION(execReflexFunc)&#123; // do something...&#125; 运行时访问反射函数123456789101112for (TFieldIterator&lt;UFunction&gt; It(InActor-&gt;GetClass()); It; ++It)&#123; UFunction* FuncProperty = *It; if (FuncProperty-&gt;GetName() == TEXT(&quot;GetIval&quot;)) &#123; struct CallParam &#123; int32 ival; &#125;CallParamIns; InActor-&gt;ProcessEvent(FuncProperty, &amp;CallParamIns); &#125;&#125; 通过 ProcessEvent 来调用，第二个参数传递进去参数和返回值的结构。 每个被反射的函数 UHT 都会给它生成一个 参数的结构体，其排列的顺序为：函数参数依次排列，最后一个成员为返回值。如： 12UFUNCTION() int32 Add(int32 R, int32 L); UHT 为其生成的参数结构为： 123456struct MyActor_eventAdd_Parms&#123; int32 R; int32 L; int32 ReturnValue;&#125;; 在通过 UFunction* 来调用函数时，需要把这个布局的结构传递作为传递给函数的参数以及接收返回值： 1234567891011121314151617for (TFieldIterator&lt;UFunction&gt; It(InActor-&gt;GetClass()); It; ++It)&#123; UFunction* Property = *It; if (Property-&gt;GetName() == TEXT(&quot;Add&quot;)) &#123; struct AddFuncCallParam &#123; int32 R; int32 L; int32 RetValue; &#125;CallParamIns; CallParamIns.R = 123; CallParamIns.L = 456; InActor-&gt;ProcessEvent(Property, &amp;CallParamIns); UE_LOG(LogTemp, Log, TEXT(&quot;UFunction:%s value:%d&quot;), *Property-&gt;GetName(), CallParamIns.RetValue); &#125;&#125; 可以通过 UFunction 拿到当前函数的参数的结构的大小UFunction::ParmsSize，在运行时动态访问的话可以通过这个结构大小分配出一块内存，然后用 UProperty 对这块内存进行访问，因为通过 UProperty 访问成员其实本质上也是通过该成员在类内的偏移来做的（对数据成员获取成员指针得到的是一个相对于对象基址的偏移值）。 坑点 注意：通过 UE 的 UFunction 调用并不能正确地处理引用类型，如： 12UFUNCTION() int32&amp; Add(int32 R, int32&amp; L); 这个函数生成的反射代码和非引用的一摸一样（对 L 参数生成的 UProperty 的 Flag 会多一个 CPF_OutParm，返回值的 UProperty 还具有CPF_ReturnParm）。 这会造成通过 UFunction* 调用传递的参数和想要获取的返回值都只是一份拷贝（因为本来调用时的参数传递到 ProcessEvent 之前都会被赋值到 UHT 创建出来的参数结构），不能再后续的流程中对得到的结果进行赋值。 而且，通过遍历 UFunction 得到的参数和返回值UProperty，其中的 Offset 值是相对于 UHT 生成的参数结构。 在获取蓝图或者 C++ 中具有多个返回值 UFunction 的时候，因为 UE 的具有多个返回值的机制是通过传递进来引用实现的，所以不能够只是通过检测 UProperty 是否具有 CPF_ReturnValue 来检测，因为包含该 flag 的 UProperty 只有一个，还需要检测 CPF_OutParam 来判断是都是通过引用方式传递的“返回值”。","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UFunction","slug":"UFunction","permalink":"https://ue5wiki.com/tags/UFunction/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"类反射实现分析","date":"2021-07-03T22:34:03.000Z","path":"wiki/33746/","text":"UHT 为类产生的反射信息 当在 UE 中新建一个类并继承自 UObject 时，可以在类声明的上一行添加 UCLASS 标记，当执行编译的时候 UBT 会调用 UHT 来根据标记来生成 C++ 代码（不过非 UCLASS 的类也可以用宏来生成反射信息）。 UHT 为类生成的代码为： 为所有的 UFUNCTION 的函数创建 FName，命名规则为NAME_CLASSNAME_FUNCTIONNAME，如NAME_AMyActor_TestFunc BlueprintNativeEvent 和 BlueprintImplementEvent 创建同名函数实现，并通过 ProcessEvent 转发调用 为所有加了 UFUNCTION 的函数生成 Thunk 函数，为当前类的 static 函数，原型为static void execFUNCNAME(UObject* Context, FFrame&amp; Stack, RESULT_DECL)； 创建当前类的 StaticRegisterNatives* 函数，并把上一步提到的 exec 这样的 thunk 函数通过 Name-execFunc 指针 的形式通过 FNativeFunctionRegistrar::RegisterFunctions 注册到 UClass； 创建出 Z_Construct_UClass_CLASSNAME_NoRegister 函数，返回值是CLASSNAME::StaticClass() 创建出 Z_Construct_UClass_CLASSNAME_Statics 类（GENERATED_BODY 等宏会把该类添加为我们创建类的友元，使其可以访问私有成员，用于获取成员指针） Z_Construct_UClass_CLASSNAME_Statics类的结构为： 1234567891011121314151617181920212223242526272829303132333435363738// AMyActor.hUCLASS(BlueprintType)class XXXX_API AMyActor:public AActor&#123; GENERATED_BODY() // ... UPROPERTY() int32 ival; UFUNCTION() int32 GetIval(); UFUNCTION() void TESTFUNC();&#125;;// generated code in AMyActor.gen.cppstruct Z_Construct_UClass_AMyActor_Statics&#123; static UObject* (*const DependentSingletons[])(); static const FClassFunctionLinkInfo FuncInfo[];#if WITH_METADATA static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ival_MetaData[];#endif static const UE4CodeGen_Private::FIntPropertyParams NewProp_ival; static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[]; static const UE4CodeGen_Private::FImplementedInterfaceParams InterfaceParams[]; static const FCppClassTypeInfoStatic StaticCppClassTypeInfo; static const UE4CodeGen_Private::FClassParams ClassParams; &#125;; UObject* (*const Z_Construct_UClass_AMyActor_Statics::DependentSingletons[])() = &#123; (UObject* (*)())Z_Construct_UClass_AActor, (UObject* (*)())Z_Construct_UPackage__Script_MicroEnd_423, &#125;; const FClassFunctionLinkInfo Z_Construct_UClass_AMyActor_Statics::FuncInfo[] = &#123; &#123; &amp;Z_Construct_UFunction_AMyActor_GetIval, &quot;GetIval&quot; &#125;, // 3480851337 &#123; &amp;Z_Construct_UFunction_AMyActor_TESTFUNC, &quot;TESTFUNC&quot; &#125;, // 2984899165&#125;; 该类中的成员为： static UObject* (*const DependentSingletons[])();记录当前类基类的 Z_Construct_UClass_BASECLASSNAME 函数指针，用它可以构造出基类的 UClass，还记录了当前类属于哪个 Package 的函数指针Z_Construct_UPackage__Script_MODULENAME。 Z_Construct_UPackage__Script_MODULENAME函数是定义在 MODULE_NAME.init.gen.cpp 里。 static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];用于记录 UCLASS 的元数据，如 BlueprintType 标记 反射属性的 F*PropertyParams 以及其 Metadata，均为 static 成员 static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];，数组，用于存储当前类所有的反射属性的信息（是个指针数组，用于存储 5.3 中的 static 成员的地址） static const UE4CodeGen_Private::FImplementedInterfaceParams InterfaceParams[];，数组，用于存储当前类所有的接口信息 123const UE4CodeGen_Private::FImplementedInterfaceParams Z_Construct_UClass_AMyActor_Statics::InterfaceParams[] = &#123; &#123; Z_Construct_UClass_UUnLuaInterface_NoRegister, (int32)VTABLE_OFFSET(AMyActor, IUnLuaInterface), false &#125;,&#125;; static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;用于类型萃取，记录当前类是否是抽象类。 123const FCppClassTypeInfoStatic Z_Construct_UClass_AMyActor_Statics::StaticCppClassTypeInfo = &#123; TCppClassTypeTraits&lt;AMyActor&gt;::IsAbstract, &#125;; static const UE4CodeGen_Private::FClassParams ClassParams;构造出 UClass 需要的所有反射数据，统一记录上面所有生成的反射信息。 123456789101112131415const UE4CodeGen_Private::FClassParams Z_Construct_UClass_AMyActor_Statics::ClassParams = &#123; &amp;AMyActor::StaticClass, nullptr, &amp;StaticCppClassTypeInfo, DependentSingletons, FuncInfo, Z_Construct_UClass_AMyActor_Statics::PropPointers, InterfaceParams, ARRAY_COUNT(DependentSingletons), ARRAY_COUNT(FuncInfo), ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::PropPointers), ARRAY_COUNT(InterfaceParams), 0x009000A0u, METADATA_PARAMS(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams, ARRAY_COUNT(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams))&#125;; 全局函数 Z_Construct_UClass_AMyActor 通过 ClassParams 构造出真正的 UClass 对象。 使用 IMPLEMENT_CLASS 注册当前类到 GetDeferredClassRegistration()，如果在WITH_HOT_RELOAD 为 true 的情况下也会注册到 GetDeferRegisterClassMap() 中。 12345678910111213141516171819202122232425262728// Register a class at startup time.#define IMPLEMENT_CLASS(TClass, TClassCrc) \\ static TClassCompiledInDefer&lt;TClass&gt; AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \\ UClass* TClass::GetPrivateStaticClass() \\ &#123; \\ static UClass* PrivateStaticClass = NULL; \\ if (!PrivateStaticClass) \\ &#123; \\ /* this could be handled with templates, but we want it external to avoid code bloat */ \\ GetPrivateStaticClassBody(\\ StaticPackage(), \\ (TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), \\ PrivateStaticClass, \\ StaticRegisterNatives##TClass, \\ sizeof(TClass), \\ alignof(TClass), \\ (EClassFlags)TClass::StaticClassFlags, \\ TClass::StaticClassCastFlags(), \\ TClass::StaticConfigName(), \\ (UClass::ClassConstructorType)InternalConstructor&lt;TClass&gt;, \\ (UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;TClass&gt;, \\ &amp;TClass::AddReferencedObjects, \\ &amp;TClass::Super::StaticClass, \\ &amp;TClass::WithinClass::StaticClass \\ ); \\ &#125; \\ return PrivateStaticClass; \\ &#125; 如 AMyActor 的IMPLEMENT_CLASS(AMyActor,3240835608)经过预处理之后为： 123456789101112131415161718192021222324static TClassCompiledInDefer&lt;AMyActor&gt; AutoInitializeAMyActor(TEXT(&quot;AMyActor&quot;), sizeof(AMyActor), 3240835608);UClass * AMyActor::GetPrivateStaticClass() &#123; static UClass * PrivateStaticClass = NULL; if (!PrivateStaticClass) &#123; GetPrivateStaticClassBody( StaticPackage(), (TCHAR*)TEXT(&quot;AMyActor&quot;) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), PrivateStaticClass, StaticRegisterNativesAMyActor, sizeof(AMyActor), alignof(AMyActor), (EClassFlags)AMyActor::StaticClassFlags, AMyActor::StaticClassCastFlags(), AMyActor::StaticConfigName(), (UClass::ClassConstructorType)InternalConstructor&lt;AMyActor&gt;, (UClass::ClassVTableHelperCtorCallerType) InternalVTableHelperCtorCaller&lt;AMyActor&gt;, &amp;AMyActor::AddReferencedObjects, &amp;AMyActor::Super::StaticClass, &amp;AMyActor::WithinClass::StaticClass ); &#125; return PrivateStaticClass;&#125;; 其中 TClassCompiledInDefer&lt;TClass&gt; 这个模板类的构造函数中通过调用 UClassCompiledInDefer 将当前反射类的注册到 GetDeferredClassRegistration()，它得到的是一个类型为FFieldCompiledInInfo* 的数组，用于记录引擎中所有反射类的信息，用于在 CoreUObjectModule 启动时将 UHT 生成的这些反射信息在 ProcessNewlyLoadedUObjects 函数中通过 UClassRegisterAllCompiledInClasses 将所有反射类的 UClass 构造出来。 12345678910111213141516171819202122232425262728/** Register all loaded classes */void UClassRegisterAllCompiledInClasses()&#123;#if WITH_HOT_RELOAD TArray&lt;UClass*&gt; AddedClasses;#endif SCOPED_BOOT_TIMING(&quot;UClassRegisterAllCompiledInClasses&quot;); TArray&lt;FFieldCompiledInInfo*&gt;&amp; DeferredClassRegistration = GetDeferredClassRegistration(); for (const FFieldCompiledInInfo* Class : DeferredClassRegistration) &#123; UClass* RegisteredClass = Class-&gt;Register();#if WITH_HOT_RELOAD if (GIsHotReload &amp;&amp; Class-&gt;OldClass == nullptr) &#123; AddedClasses.Add(RegisteredClass); &#125;#endif &#125; DeferredClassRegistration.Empty();#if WITH_HOT_RELOAD if (AddedClasses.Num() &gt; 0) &#123; FCoreUObjectDelegates::RegisterHotReloadAddedClassesDelegate.Broadcast(AddedClasses); &#125;#endif&#125; 而 TClassCompiledInDefer&lt;AMyActor&gt; 的Register函数就是调用 AMyActor::StaticClass 的，然后 StaticClass 中调用 GetPrivateStaticClass，其中有一个 static 对象，就是当前类的 UClass，所以它只会构造依次，使用UXXXX::StaticClass 都是直接获得。 注意：UClass 的构造是跟着模块的启动创建的，所以之后当引擎启动到一个模块的时候它的 UClass 才被创建出来）。 非 UCLASS 的反射 有些继承自 UObject 的类是没有加 UCLASS 标记的，所以也不会包含 gen.cpp 和generated.h文件，但是 UE 也提供了非 UCLASS 的反射方法，类似于 UTextureBuffer 这个类。 在类内时添加 DECLARE_CASTED_CLASS_INTRINSIC_WITH_API 宏用于手动添加，实现类似 UHT 生成 GENERATED_BODY 宏的操作： 123456class UTextBuffer : public UObject , public FOutputDevice&#123; DECLARE_CASTED_CLASS_INTRINSIC_WITH_API(UTextBuffer, UObject, 0, TEXT(&quot;/Script/CoreUObject&quot;), CASTCLASS_None, COREUOBJECT_API)&#125; DECLARE_CASTED_CLASS_INTRINSIC_WITH_API可以处理类似 generated.h 的行为，但是 gen.cpp 里创建出 static TClassCompiledInDefer&lt;CLASS_NAME&gt; 的代码还没有，UE 提供了另一个宏: 1IMPLEMENT_CORE_INTRINSIC_CLASS(UTextBuffer, UObject, &#123; &#125;); IMPLEMENT_CORE_INTRINSIC_CLASS，用来生成类似 gen.cpp 中的代码， 还可以通过宏的第三个参数来传入代码。 虽然和 gen.cpp 里通过 UHT 生成的代码不同，但是统一使用 TClassCompiledInDefer&lt;TClass&gt; 和FCompiledInDefer来注册到引擎中。这样就实现了可以不使用 UCLASS 标记也可以为继承自 UObject 的类生成反射信息。 UClass 的构造思路 前面讲了这么多都是在分析 UE 创建 UClass 的代码，我想从 UE 的实现思路上分析一下设计过程。 首先 UHT 通过分析代码创建出 gen.cpp 和 generated.h 中间记录着当前类的反射信息、类本身的反射信息、类中函数的反射信息、类数据成员的反射信息。 当前类的反射信息（类、成员函数、数据成员）等被统一存储在一个名为 Z_Construct_UClass_CLASSNAME_Statics 的结构中； 该结构通过 IMPLEMENT_CLASS 生成的代码将当前类添加到 GetDeferredClassRegistration() 中。因为 全局作用域 static 对象的构造时机 是先于主函数的第一条语句的，所以当进入引擎逻辑的时候，引擎内置的模块中类的 TClassCompiledInDefer&lt;&gt; 都已经被创建完毕，在编辑器模式下， 因为不同的模块都是编译为 DLL 的，所以在加载模块的时候它们的 static 对象才会被创建。 12// gen.cppstatic TClassCompiledInDefer&lt;AMyActor&gt; AutoInitializeAMyActor(TEXT(&quot;AMyActor&quot;), sizeof(AMyActor), 3240835608); 与上一步同样的手法，把类生成的反射信息通过 FCompiledInDefer 收集到GetDeferredCompiledInRegistration() 1static FCompiledInDefer Z_CompiledInDefer_UClass_AMyActor(Z_Construct_UClass_AMyActor, &amp;AMyActor::StaticClass, TEXT(&quot;/Script/MicroEnd_423&quot;), TEXT(&quot;AMyActor&quot;), false, nullptr, nullptr, nullptr); 引擎如何使用生成的反射信息 在 UHT 生成反射的代码之后，引擎会根据这些代码生成 UClass、UStruct、UEnum、UFunction 和 UProperty 等。 它们都是在 ProcessNewlyLoadedUObjects 中被执行的，注意 该函数会进来很多次，当每一个模块被加载的时候都会走一遍，因为在 Obj.cpp 的InitUObject函数中，把函数 ProcessNewlyLoadedUObjects 添加到了 FModuleManager::Get().OnProcessLoadedObjectsCallback() 中： 123#if !USE_PER_MODULE_UOBJECT_BOOTSTRAP // otherwise this is already done FModuleManager::Get().OnProcessLoadedObjectsCallback().AddStatic(ProcessNewlyLoadedUObjects);#endif 之所以 要这么做，是因为 UE 的 Module 中都会有很多的反射类，但引擎一启动并不是所有的类在同一时刻都被加载了，因为模块有不同的加载时机，所以引擎中对于 UClass 的构造也不是一个一次性过程。 1234567891011121314151617181920212223242526272829// CoreUObject/Private/UObject/UObjectBase.cppvoid ProcessNewlyLoadedUObjects()&#123; LLM_SCOPE(ELLMTag::UObject); DECLARE_SCOPE_CYCLE_COUNTER(TEXT(&quot;ProcessNewlyLoadedUObjects&quot;), STAT_ProcessNewlyLoadedUObjects, STATGROUP_ObjectVerbose); UClassRegisterAllCompiledInClasses(); const TArray&lt;UClass* (*)()&gt;&amp; DeferredCompiledInRegistration = GetDeferredCompiledInRegistration(); const TArray&lt;FPendingStructRegistrant&gt;&amp; DeferredCompiledInStructRegistration = GetDeferredCompiledInStructRegistration(); const TArray&lt;FPendingEnumRegistrant&gt;&amp; DeferredCompiledInEnumRegistration = GetDeferredCompiledInEnumRegistration(); bool bNewUObjects = false; while(GFirstPendingRegistrant || DeferredCompiledInRegistration.Num() || DeferredCompiledInStructRegistration.Num() || DeferredCompiledInEnumRegistration.Num()) &#123; bNewUObjects = true; UObjectProcessRegistrants(); UObjectLoadAllCompiledInStructs(); UObjectLoadAllCompiledInDefaultProperties(); &#125;#if WITH_HOT_RELOAD UClassReplaceHotReloadClasses();#endif if (bNewUObjects &amp;&amp; !GIsInitialLoad) &#123; UClass::AssembleReferenceTokenStreams(); &#125;&#125; UClass 构造的调用栈： 12345678910111213141516171819202122232425262728// CoreUObject/Private/UObject/UObjectBase.cpp/** Register all loaded classes */void UClassRegisterAllCompiledInClasses()&#123;#if WITH_HOT_RELOAD TArray&lt;UClass*&gt; AddedClasses;#endif TArray&lt;FFieldCompiledInInfo*&gt;&amp; DeferredClassRegistration = GetDeferredClassRegistration(); for (const FFieldCompiledInInfo* Class : DeferredClassRegistration) &#123; UClass* RegisteredClass = Class-&gt;Register();#if WITH_HOT_RELOAD if (GIsHotReload &amp;&amp; Class-&gt;OldClass == nullptr) &#123; AddedClasses.Add(RegisteredClass); &#125;#endif &#125; DeferredClassRegistration.Empty();#if WITH_HOT_RELOAD if (AddedClasses.Num() &gt; 0) &#123; FCoreUObjectDelegates::RegisterHotReloadAddedClassesDelegate.Broadcast(AddedClasses); &#125;#endif&#125; 可以看到，在 UClassRegisterAllCompiledInClasses 只是去调用了每个反射类的 StaticClass 函数（Class-&gt;Register()内部是对类型的 StaticClass 的转发调用），在开启 WITH_HOT_RELOAD 的情况下也会把新的 UClass 给代理调用传递出去，然后把当前的数组置空。 之所以要置空，就是因为前面说的，UE 的 UClass 构造是一个模块一个模块来执行的，当一个模块执行完毕之后就把当前模块注册到 GetDeferredClassRegistration() 里的元素置空，等着下个模块启动的时候（加载 DLL 时它们的 static 成员会构造然后注册到里面），再执行 LoadModuleWithFailureReason 就是又一遍循环。 在模块启动的时候会执行 LoadModuleWithFailureReason 里面调用了这个 Delegate，所以每一个模块启动的时候都会执行ProcessNewlyLoadedUObjects，把自己当前模块中的 UClass/UStruct/UEnum 都构造出来。","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UClass","slug":"UClass","permalink":"https://ue5wiki.com/tags/UClass/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"Struct 反射实现分析","date":"2021-07-03T22:32:40.000Z","path":"wiki/33475/","text":"前面讲到了 Class/function/property 的反射，UE 还支持结构体的反射，其实从 C++ 的标准语义来说并没有区分“结构”和“类”，关键字 struct 和class的区别只在于默认的访问权限。 在 UE 里面，支持反射的结构提只能使用struct，并且不能包含任何 UFUNCTION 的函数，命名必须以 F 开头。 12345678910USTRUCT(BlueprintType)struct FTestStruct&#123; GENERATED_USTRUCT_BODY() UPROPERTY(EditAnywhere) int32 ival; UPROPERTY(EditAnywhere) UTexture2D* Texture;&#125;; UE 的标记语法和 Class 的类似，不过 UHT 为 Struct 生成的代码要简单许多，因为没有 UFUNCTION 也没有继承 UObject。 GENERATED_USTRUCT_BODY这个标记 UHT 会展开生成一个真正的 C++ 宏(在 genreated.h 中)： 123456// generated.h#define HotPatcherExample_Source_HotPatcherExample_TestStruct_h_11_GENERATED_BODY \\ friend struct Z_Construct_UScriptStruct_FTestStruct_Statics; \\ HOTPATCHEREXAMPLE_API static class UScriptStruct* StaticStruct();template&lt;&gt; HOTPATCHEREXAMPLE_API UScriptStruct* StaticStruct&lt;struct FTestStruct&gt;(); 把 UHT 生成的用于记录当前 struct 反射数据的结构 Z_Construct_UScriptStruct_FTestStruct_Statis 声明为当前 struct 类的友元，可以让它访问到自己的私有成员。而且还声明了当前 Struct 的 static 成员函数 StaticStruct 和全局模板函数StaticStruct&lt;FTestStruct&gt;。 对 Struct 生成的反射数； 据的结构与 class 的类似，只有 Property 的反射信息。 gen.cpp中有以下内容： 123456789101112131415161718192021222324252627282930313233343536373839class UScriptStruct* FTestStruct::StaticStruct()&#123; static class UScriptStruct* Singleton = NULL; if (!Singleton) &#123; extern HOTPATCHEREXAMPLE_API uint32 Get_Z_Construct_UScriptStruct_FTestStruct_Hash(); Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FTestStruct, Z_Construct_UPackage__Script_HotPatcherExample(), TEXT(&quot;TestStruct&quot;), sizeof(FTestStruct), Get_Z_Construct_UScriptStruct_FTestStruct_Hash()); &#125; return Singleton;&#125;template&lt;&gt; HOTPATCHEREXAMPLE_API UScriptStruct* StaticStruct&lt;FTestStruct&gt;()&#123; return FTestStruct::StaticStruct();&#125;static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FTestStruct(FTestStruct::StaticStruct, TEXT(&quot;/Script/HotPatcherExample&quot;), TEXT(&quot;TestStruct&quot;), false, nullptr, nullptr);static struct FScriptStruct_HotPatcherExample_StaticRegisterNativesFTestStruct&#123; FScriptStruct_HotPatcherExample_StaticRegisterNativesFTestStruct() &#123; UScriptStruct::DeferCppStructOps(FName(TEXT(&quot;TestStruct&quot;)),new UScriptStruct::TCppStructOps&lt;FTestStruct&gt;); &#125;&#125; ScriptStruct_HotPatcherExample_StaticRegisterNativesFTestStruct;UScriptStruct* Z_Construct_UScriptStruct_FTestStruct()&#123;#if WITH_HOT_RELOAD extern uint32 Get_Z_Construct_UScriptStruct_FTestStruct_Hash(); UPackage* Outer = Z_Construct_UPackage__Script_HotPatcherExample(); static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT(&quot;TestStruct&quot;), sizeof(FTestStruct), Get_Z_Construct_UScriptStruct_FTestStruct_Hash(), false);#else static UScriptStruct* ReturnStruct = nullptr;#endif if (!ReturnStruct) &#123; UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, Z_Construct_UScriptStruct_FTestStruct_Statics::ReturnStructParams); &#125; return ReturnStruct;&#125;uint32 Get_Z_Construct_UScriptStruct_FTestStruct_Hash() &#123; return 4266809061U; &#125; 上面的代码包含了从 UHT 生成的反射信息中构造出 UStructSctruct 以及延迟注册的方法，和 Class 的方式类似。 还包含生成的结构 Z_Construct_UScriptStruct_STRUCTNAME_Statics 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182struct Z_Construct_UScriptStruct_FTestStruct_Statics&#123;#if WITH_METADATA static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[];#endif static void* NewStructOps();#if WITH_METADATA static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Texture_MetaData[];#endif static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Texture;#if WITH_METADATA static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ival_MetaData[];#endif static const UE4CodeGen_Private::FIntPropertyParams NewProp_ival; static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[]; static const UE4CodeGen_Private::FStructParams ReturnStructParams;&#125;;#if WITH_METADATAconst UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FTestStruct_Statics::Struct_MetaDataParams[] = &#123; &#123; &quot;BlueprintType&quot;, &quot;true&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;TestStruct.h&quot; &#125;,&#125;;#endifvoid* Z_Construct_UScriptStruct_FTestStruct_Statics::NewStructOps()&#123; return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps&lt;FTestStruct&gt;();&#125;#if WITH_METADATAconst UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_Texture_MetaData[] = &#123; &#123; &quot;Category&quot;, &quot;TestStruct&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;TestStruct.h&quot; &#125;,&#125;;#endifconst UE4CodeGen_Private::FObjectPropertyParams Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_Texture = &#123; &quot;Texture&quot;, nullptr, (EPropertyFlags)0x0010000000000001, UE4CodeGen_Private::EPropertyGenFlags::Object, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(FTestStruct, Texture), Z_Construct_UClass_UTexture2D_NoRegister, METADATA_PARAMS(Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_Texture_MetaData, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_Texture_MetaData)) &#125;;#if WITH_METADATAconst UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_ival_MetaData[] = &#123; &#123; &quot;Category&quot;, &quot;TestStruct&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;TestStruct.h&quot; &#125;,&#125;;#endifconst UE4CodeGen_Private::FIntPropertyParams Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_ival = &#123; &quot;ival&quot;, nullptr, (EPropertyFlags)0x0010000000000001, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(FTestStruct, ival), METADATA_PARAMS(Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_ival_MetaData, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_ival_MetaData)) &#125;;const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UScriptStruct_FTestStruct_Statics::PropPointers[] = &#123; (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_Texture, (const UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UScriptStruct_FTestStruct_Statics::NewProp_ival,&#125;;const UE4CodeGen_Private::FStructParams Z_Construct_UScriptStruct_FTestStruct_Statics::ReturnStructParams = &#123; (UObject* (*)())Z_Construct_UPackage__Script_HotPatcherExample, nullptr, &amp;NewStructOps, &quot;TestStruct&quot;, sizeof(FTestStruct), alignof(FTestStruct), Z_Construct_UScriptStruct_FTestStruct_Statics::PropPointers, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FTestStruct_Statics::PropPointers), RF_Public|RF_Transient|RF_MarkAsNative, EStructFlags(0x00000001), METADATA_PARAMS(Z_Construct_UScriptStruct_FTestStruct_Statics::Struct_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FTestStruct_Statics::Struct_MetaDataParams))&#125;; 可以看到 Struct 的每个属性也是通过 FPropertyParamsBase 来存储的，与 Class 一致。 区别在于，Struct 使用 UE4CodeGen_Private::FStructParams 来存储当前结构的反射信息，其声明如下(CoreUObject/Public/UObject/UObjectGlobals.h)： 123456789101112131415161718// CoreUObject/Public/UObject/UObjectGlobals.hstruct FStructParams&#123; UObject* (*OuterFunc)(); UScriptStruct* (*SuperFunc)(); void* (*StructOpsFunc)(); // really returns UScriptStruct::ICppStructOps* const char* NameUTF8; SIZE_T SizeOf; SIZE_T AlignOf; const FPropertyParamsBase* const* PropertyArray; int32 NumProperties; EObjectFlags ObjectFlags; uint32 StructFlags; // EStructFlags#if WITH_METADATA const FMetaDataPairParam* MetaDataArray; int32 NumMetaData;#endif&#125;; 这个结构中比较特殊的一点是 StructOpsFunc 是一个函数指针，用来管理 C++ 结构的构造和析构，使用的也是 placement-new 的方式，TCppStructOps&lt;&gt;模板定义在CoreUObject/Public/UObject/Class.h。","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UStruct","slug":"UStruct","permalink":"https://ue5wiki.com/tags/UStruct/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"Enum 反射实现分析","date":"2021-07-03T22:31:06.000Z","path":"wiki/33168/","text":"UHT 为 Enum 生成的代码 在 UE 中，当我们声明一个枚举类型时可以像 UClass 一样地形式为其添加 UENUM 标记，指导 UHT 为其生成反射代码： 1234567UENUM(BlueprintType)enum class ETypeName :uint8&#123; None, Int, Float&#125;; 经过 UHT 之后就变成了： 12345678// generated.h#define FOREACH_ENUM_ETYPENAME(op) \\ op(ETypeName::None) \\ op(ETypeName::Int) \\ op(ETypeName::Float) enum class ETypeName : uint8;template&lt;&gt; TOPDOWNEXAMPLE_API UEnum* StaticEnum&lt;ETypeName&gt;(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// .gen.cpp// End Cross Module References static UEnum* ETypeName_StaticEnum() &#123; static UEnum* Singleton = nullptr; if (!Singleton) &#123; Singleton = GetStaticEnum(Z_Construct_UEnum_TopdownExample_ETypeName, Z_Construct_UPackage__Script_TopdownExample(), TEXT(&quot;ETypeName&quot;)); &#125; return Singleton; &#125; template&lt;&gt; TOPDOWNEXAMPLE_API UEnum* StaticEnum&lt;ETypeName&gt;() &#123; return ETypeName_StaticEnum(); &#125; static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETypeName(ETypeName_StaticEnum, TEXT(&quot;/Script/TopdownExample&quot;), TEXT(&quot;ETypeName&quot;), false, nullptr, nullptr); uint32 Get_Z_Construct_UEnum_TopdownExample_ETypeName_Hash() &#123; return 2221805252U; &#125; UEnum* Z_Construct_UEnum_TopdownExample_ETypeName() &#123;#if WITH_HOT_RELOAD UPackage* Outer = Z_Construct_UPackage__Script_TopdownExample(); static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT(&quot;ETypeName&quot;), 0, Get_Z_Construct_UEnum_TopdownExample_ETypeName_Hash(), false);#else static UEnum* ReturnEnum = nullptr;#endif // WITH_HOT_RELOAD if (!ReturnEnum) &#123; static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = &#123; &#123; &quot;ETypeName::None&quot;, (int64)ETypeName::None &#125;, &#123; &quot;ETypeName::Int&quot;, (int64)ETypeName::Int &#125;, &#123; &quot;ETypeName::Float&quot;, (int64)ETypeName::Float &#125;, &#125;;#if WITH_METADATA const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = &#123; &#123; &quot;BlueprintType&quot;, &quot;true&quot; &#125;, &#123; &quot;ModuleRelativePath&quot;, &quot;MyK2Node.h&quot; &#125;, &#125;;#endif static const UE4CodeGen_Private::FEnumParams EnumParams = &#123; (UObject*(*)())Z_Construct_UPackage__Script_TopdownExample, nullptr, &quot;ETypeName&quot;, &quot;ETypeName&quot;, Enumerators, ARRAY_COUNT(Enumerators), RF_Public|RF_Transient|RF_MarkAsNative, UE4CodeGen_Private::EDynamicType::NotDynamic, (uint8)UEnum::ECppForm::EnumClass, METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams)) &#125;; UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams); &#125; return ReturnEnum; &#125; UEnum 的构造思路和 UClass 差不多，通过 UHT 生成 Enum 的反射代码，记录枚举类型的名字、枚举值的名字、元数据等等，通过 UE4CodeGen_Private::ConstructUEnum 把这些反射数据构造出 UEnum。 同样也是通过 延迟注册 的方式把 UEnum 构造出来。 运行时访问 UEnum如果要获取一个 UENMU 的 UEnum* 可以通过 StaticEnum&lt;ETypeName&gt;() 或者通过 UEnum* const MethodEnum = FindObjectChecked&lt;UEnum&gt;(ANY_PACKAGE, TEXT(&quot;ETypeName&quot;), true); 来拿。 在 UE4.22+ 的版本中可以使用下列方法： 1const UEnum* TypeEnum = StaticEnum&lt;EnumType&gt;(); 在 4.21 及之前的版本就要麻烦一点： 1const UEnum* TypeEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, TEXT(&quot;EnumType&quot;), true); 注意上面的 TEXT(&quot;EnumType&quot;) 其中要填想要获取的枚举类型名字。 根据枚举名字获取枚举值123456789101112131415// get enum value by name&#123; FString EnumTypeName = TEXT(&quot;ETargetPlatform&quot;); FString EnumName = FString::Printf(TEXT(&quot;%s::%s&quot;),*EnumTypeName,TEXT(&quot;Int&quot;)) UEnum* ETargetPlatformEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *EnumTypeName, true); int32 EnumIndex = ETargetPlatformEnum-&gt;GetIndexByName(FName(*EnumName)); if (EnumIndex != INDEX_NONE) &#123; UE_LOG(LogTemp, Log, TEXT(&quot;FOUND ENUM INDEX SUCCESS&quot;)); int32 EnumValue = ETargetPlatformEnum-&gt;GetValueByIndex(EnumIndex); ETargetPlatform CurrentEnum = (ETargetPlatform)EnumValue; &#125;&#125; 如果也想再封装一层模板类，让枚举名字也可以自动获取，则需要用得到 C++ 的 RTTI 特性： 12345678910template&lt;typename T&gt;static std::string GetCPPTypeName()&#123; std::string result; std::string type_name = typeid(T).name(); std::for_each(type_name.begin(),type_name.end(),[&amp;result](const char&amp; character)&#123;if(!std::isdigit(character)) result.push_back(character);&#125;); return result;&#125; 枚举值与字符串的互相转换 有些需要序列化枚举值的需要，虽然我们可以通过 FindObject&lt;UEnum&gt; 传入枚举名字拿到 UEnum*，再通过GetNameByValue 拿到名字，但是这样需要针对每个枚举都要单独写，我写了模板函数来做这个事情： 123456789101112131415161718192021222324252627282930313233343536373839404142// 同时支持 4.21- 和 4.21+ 版本引擎#include &lt;typeinfo&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;template&lt;typename T&gt;static std::string GetCPPTypeName()&#123; std::string result; std::string type_name = typeid(T).name(); std::for_each(type_name.begin(),type_name.end(),[&amp;result](const char&amp; character)&#123;if(!std::isdigit(character)) result.push_back(character);&#125;); return result;&#125;template&lt;typename ENUM_TYPE&gt;static FString GetEnumNameByValue(ENUM_TYPE InEnumValue, bool bFullName = false)&#123; FString result; &#123; FString TypeName; FString ValueName;#if ENGINE_MINOR_VERSION &gt; 21 UEnum* FoundEnum = StaticEnum&lt;ENUM_TYPE&gt;();#else FString EnumTypeName = ANSI_TO_TCHAR(GetCPPTypeName&lt;ENUM_TYPE&gt;().c_str()); UEnum* FoundEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *EnumTypeName, true); #endif if (FoundEnum) &#123; result = FoundEnum-&gt;GetNameByValue((int64)InEnumValue).ToString(); result.Split(TEXT(&quot;::&quot;), &amp;TypeName, &amp;ValueName, ESearchCase::CaseSensitive, ESearchDir::FromEnd); if (!bFullName) &#123; result = ValueName; &#125; &#125; &#125; return result;&#125; 以及从字符串获取枚举值： 123456789101112131415161718192021222324252627template&lt;typename ENUM_TYPE&gt;static bool GetEnumValueByName(const FString&amp; InEnumValueName, ENUM_TYPE&amp; OutEnumValue)&#123; bool bStatus = false;#if ENGINE_MINOR_VERSION &gt;22 UEnum* FoundEnum = StaticEnum&lt;ENUM_TYPE&gt;(); FString EnumTypeName = FoundEnum-&gt;CppType;#else FString EnumTypeName = *GetCPPTypeName&lt;ENUM_TYPE&gt;(); UEnum* FoundEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *EnumTypeName, true); #endif if (FoundEnum) &#123; FString EnumValueFullName = EnumTypeName + TEXT(&quot;::&quot;) + InEnumValueName; int32 EnumIndex = FoundEnum-&gt;GetIndexByName(FName(*EnumValueFullName)); if (EnumIndex != INDEX_NONE) &#123; int32 EnumValue = FoundEnum-&gt;GetValueByIndex(EnumIndex); ENUM_TYPE ResultEnumValue = (ENUM_TYPE)EnumValue; OutEnumValue = ResultEnumValue; bStatus = false; &#125; &#125; return bStatus;&#125;","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UEnum","slug":"UEnum","permalink":"https://ue5wiki.com/tags/UEnum/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"开启多核心编译","date":"2021-07-03T22:29:04.000Z","path":"wiki/32770/","text":"UBT 会从下面三个文件中读取配置： 123* Engine/Saved/UnrealBuildTool/BuildConfiguration.xml* *User Folder/AppData*/Roaming/Unreal Engine/UnrealBuildTool/BuildConfiguration.xml* *My Documents*/Unreal Engine/UnrealBuildTool/BuildConfiguration.xml 我们只需要修改其中的任意一个就可以。 默认具有以下内容： 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt;&lt;/Configuration&gt; 更多的 BuildConfigutation 的参数可以看引擎文档 Configuring Unreal Build System。在文档中ProcessorCountMultiplier 元素的数字就是允许使用的处理器数，但是 ，UE 的文档和实际的代码有出入，按照上面的文档，设置ProcessorCountMultiplier 是在 BuildConfigutation 下的，但是这么写会与错误： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt; &lt;BuildConfiguration&gt; &lt;ProcessorCountMultiplier&gt;7&lt;/ProcessorCountMultiplier&gt; &lt;/BuildConfiguration&gt;&lt;/Configuration&gt; 错误信息： 1BuildConfiguration.xml(4): [] 元素 命名空间“https://www.unrealengine.com/BuildConfiguration”中的“BuildConfiguration”。 的子元素 命名空间“https://www.unrealengine.com/BuildConfiguration”中的“ProcessorCountMultiplier”。 无效。应为可能元素的列表: 命名空间“https://www.unrealengine.com/BuildConfiguration”中的“bPGOProfile, bAllowHybridExecutor, DMUCSDistProp, bAllowXGE, bGeneratedSYMFile, bAllowSNDBS, bIgnoreOutdatedImportLibraries, bUseFastSemanticsRenderContexts, bDisableDebugInfo, bParseTimingInfoForTracing, CppStandard, bPrintDebugInfo, bUseSharedPCHs, bDisableDebugInfoForGeneratedCode, bForcePrecompiledHeaderForGameModules, bUseShippingPhysXLibraries, bUseAdaptiveUnityBuild, bXGENoWatchdogThread, MinGameModuleSourceFilesForUnityBuild, bAdaptiveUnityDisablesOptimizations, bCheckLicenseViolations, bAllowParallelExecutor, bOmitFramePointers, bUseCheckedPhysXLibraries, bSupportEditAndContinue, bAllowASLRInShipping, bStripSymbols, bAllowDistcc, bVerboseDistccOutput, bUseInlining, bAllowDistccLocalFallback, bAdaptiveUnityEnablesEditAndContinue, bEnableMemorySanitizer, bCheckSystemHeadersForModification, bUseFastPDBLinking, bAdaptiveUnityDisablesProjectPCHForProjectPrivate, BaseLogFileName, bUsePerFileIntellisense, bCreateMapFile, bUsePCHFiles, DMUCSCoordinat...。 查阅代码之后发现，这些配置选项要去看 BuildConfigProperties.INT.udn 里的参数，ProcessorCountMultiplier 是在 ParallelExecutor 下的，所以改成以下配置： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt; &lt;ParallelExecutor&gt; &lt;ProcessorCountMultiplier&gt;7&lt;/ProcessorCountMultiplier&gt; &lt;MaxProcessorCount&gt;7&lt;/MaxProcessorCount&gt; &lt;bStopCompilationAfterErrors&gt;true&lt;/bStopCompilationAfterErrors&gt; &lt;/ParallelExecutor&gt;&lt;/Configuration&gt; 目前我使用的完整配置： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration xmlns=&quot;https://www.unrealengine.com/BuildConfiguration&quot;&gt; &lt;BuildConfiguration&gt; &lt;ProcessorCountMultiplier&gt;7&lt;/ProcessorCountMultiplier&gt; &lt;MaxParallelActions&gt;7&lt;/MaxParallelActions&gt; &lt;bAllowParallelExecutor&gt;true&lt;/bAllowParallelExecutor&gt; &lt;/BuildConfiguration&gt; &lt;SNDBS&gt; &lt;ProcessorCountMultiplier&gt;4&lt;/ProcessorCountMultiplier&gt; &lt;MaxProcessorCount&gt;4&lt;/MaxProcessorCount&gt; &lt;/SNDBS&gt; &lt;ParallelExecutor&gt; &lt;ProcessorCountMultiplier&gt;7&lt;/ProcessorCountMultiplier&gt; &lt;MaxProcessorCount&gt;7&lt;/MaxProcessorCount&gt; &lt;bStopCompilationAfterErrors&gt;true&lt;/bStopCompilationAfterErrors&gt; &lt;/ParallelExecutor&gt;&lt;/Configuration&gt; 相关连接： How to use multiple processors for compiling?","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"命令行导入证书和 Provision","date":"2021-07-03T22:27:38.000Z","path":"wiki/32489/","text":"在部署构建机的时候，需要给每台构建机都导入 iOS 的 provision 和p12证书，如果每个都要打开一遍编辑器，纯粹是重复劳动，翻了下代码，UE 编辑器中导入证书是通过调用 IPhonePackager.exe 来实现的，而且是以命令行的方式执行，这样就好办了，按照它的参数自己实现脚本即可。具体看引擎中的相关代码：IOSTargetSettingsCustomization.cpp#L1312 Certificate导入证书的命令为： 1Engine\\Binaries\\DotNET\\IOS\\IPhonePackager.exe Install Engine -project &quot;D:\\Client\\FGame.uproject&quot; -certificate &quot;D:\\IOS_DEVELOPMENT.p12&quot; -bundlename &quot;com.tencent.xxxx.xx&quot; 证书是导入到系统中的，可以在 certmgr.msc 中查看导入的证书： 注意：因为 iPhonePackager.exe 在导入证书时会让弹框输入证书的密码： 这导致不能用在自动化流程里，但是我怎么可能会老老实实每台电脑都输一次密码呢，看了一下 iPhonePackager 的代码，找到了弹窗让输入密码的地方Programs/IOS/iPhonePackager/ToolsHub.cs#L263，我给它加了个从命令行参数读取密码的选项，如果有该参数就不会弹框： 12345678910111213141516171819202122232425262728293031// Load the certificatestring CertificatePassword = &quot;&quot;;string[] arguments = Environment.GetCommandLineArgs();for (int index = 0;index&lt;arguments.Length;++index)&#123; if (arguments[index] == &quot;-cerpassword&quot; &amp;&amp; index != (arguments.Length-1)) &#123; CertificatePassword = arguments[index + 1]; Console.WriteLine(&quot;Usage -cerpasseord argument&quot;); &#125;&#125;X509Certificate2 Cert = null;try&#123; Cert = new X509Certificate2(CertificateFilename, CertificatePassword, X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable | X509KeyStorageFlags.MachineKeySet);&#125;catch (System.Security.Cryptography.CryptographicException ex)&#123; // Try once with a password if (CertificatePassword.Length &gt; 0 || PasswordDialog.RequestPassword(out CertificatePassword)) &#123; Cert = new X509Certificate2(CertificateFilename, CertificatePassword, X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable | X509KeyStorageFlags.MachineKeySet); &#125; else &#123; // User cancelled dialog, rethrow throw ex; &#125;&#125; 把上面的代码替换掉 Programs/IOS/iPhonePackager/ToolsHub.cs#L263 这里的部分，重新编译 iPhonePackager 即可。 Provision导入 Provision 的命令为： 1Engine\\Binaries\\DotNET\\IOS\\IPhonePackager.exe Install Engine -project &quot;D:\\Client\\FGame.uproject&quot; -provision &quot;D:\\com.tencent.xxxx.xx_Development_SignProvision.mobileprovision&quot; -bundlename &quot;com.tencent.xxxx.xx&quot; Provision 文件导入后会放在用户目录下： 12345678910111213/// &lt;summary&gt;/// The shared provision library directory (on PC)/// &lt;/summary&gt;public static string ProvisionDirectory&#123; get &#123; if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix) &#123; return Environment.GetEnvironmentVariable(&quot;HOME&quot;) + &quot;/Library/MobileDevice/Provisioning Profiles/&quot;; &#125; else &#123; return Environment.GetFolderPath (Environment.SpecialFolder.LocalApplicationData) + &quot;/Apple Computer/MobileDevice/Provisioning Profiles/&quot;; &#125; &#125;&#125; Win 上就为：C:\\Users\\USER_NAME\\AppData\\Local\\Apple Computer\\MobileDevice\\Provisioning Profiles.","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"移动端息屏控制","date":"2021-07-03T20:54:42.000Z","path":"wiki/14280/","text":"息屏控制UE 中封装了通用的接口来控制，可以使用以下函数： 1UKismetSystemLibrary::ControlScreensaver(false); 它会调用到对应平台的 F*ApplicationMisc 中的同名函数： 123456789101112131415161718192021222324252627282930// for Androidbool FAndroidApplicationMisc::ControlScreensaver(EScreenSaverAction Action)&#123;#if USE_ANDROID_JNI extern void AndroidThunkCpp_KeepScreenOn(bool Enable); switch (Action) &#123; case EScreenSaverAction::Disable: // Prevent display sleep. AndroidThunkCpp_KeepScreenOn(true); break; case EScreenSaverAction::Enable: // Stop preventing display sleep now that we are done. AndroidThunkCpp_KeepScreenOn(false); break; &#125; return true;#else return false;#endif&#125;// for IOSbool FIOSPlatformApplicationMisc::ControlScreensaver(EScreenSaverAction Action)&#123; IOSAppDelegate* AppDelegate = [IOSAppDelegate GetDelegate]; [AppDelegate EnableIdleTimer : (Action == FGenericPlatformApplicationMisc::Enable)]; return true;&#125; Android在 UE 的 GameActivity.java.template 文件中有以下函数： 12345678910111213141516171819202122232425262728public void AndroidThunkJava_KeepScreenOn(boolean Enable)&#123; bKeepScreenOn = Enable; if (Enable) &#123; _activity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.debug(&quot;==============&gt; [JAVA] AndroidThunkJava_KeepScreenOn(true) - Disabled screen saver&quot;); _activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125; else &#123; _activity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.debug(&quot;==============&gt; [JAVA] AndroidThunkJava_KeepScreenOn(false) - Enabled screen saver&quot;); _activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125;&#125; 在 GameActivity 的 OnResume 函数中会调用，是否开启的值为bKeepScreenOn。 可以通过 UPL、或者运行时的 JNI 调用来控制 Android 是否息屏。 12345&lt;gameActivityOnCreateFinalAdditions&gt; &lt;insert&gt; AndroidThunkJava_KeepScreenOn(true); &lt;/insert&gt;&lt;/gameActivityOnCreateFinalAdditions&gt; IOS在引擎中有由下代码控制： Runtime/ApplicationCore/Private/IOS/IOSAppDelegate.cpp12345678910-(void)InitIdleTimerSettings&#123; float TimerDuration = 0.0F; GConfig-&gt;GetFloat(TEXT(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;), TEXT(&quot;IdleTimerEnablePeriod&quot;), TimerDuration, GEngineIni); IdleTimerEnablePeriod = TimerDuration; self.IdleTimerEnableTimer = nil; bool bEnableTimer = YES; GConfig-&gt;GetBool(TEXT(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;), TEXT(&quot;bEnableIdleTimer&quot;), bEnableTimer, GEngineIni); [self EnableIdleTimer : bEnableTimer];&#125; 可以从 GEngineIni 中读取两个配置： 123[/Script/IOSRuntimeSettings.IOSRuntimeSettings]IdleTimerEnablePeriod=0.0bEnableIdleTimer=true 当bEnableIdleTimer=false，在游戏运行时就不会息屏。 运行时设置需要调用 OC 的代码： Runtime\\ApplicationCore\\Private\\IOS\\IOSAppDelegate.cpp1234567891011121314151617181920212223242526-(void)EnableIdleTimer:(bool)bEnabled&#123; dispatch_async(dispatch_get_main_queue(),^ &#123; if (bEnabled) &#123; // Nothing needs to be done, if the enable timer is already running. if (self.IdleTimerEnableTimer == nil) &#123; self.IdleTimerEnableTimer = [NSTimer scheduledTimerWithTimeInterval:IdleTimerEnablePeriod target:self selector:@selector(DeferredEnableIdleTimer) userInfo:nil repeats:NO]; &#125; &#125; else &#123; // Ensure pending attempts to enable the idle timer are cancelled. if (self.IdleTimerEnableTimer != nil) &#123; [self.IdleTimerEnableTimer invalidate]; self.IdleTimerEnableTimer = nil; &#125; [UIApplication sharedApplication].idleTimerDisabled = NO; [UIApplication sharedApplication].idleTimerDisabled = YES; &#125; &#125;);&#125; 调用 EnableIdleTimer 传入 false 会关闭游戏运行时息屏。","tags":[],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"}]},{"title":"修改 DDC 的路径","date":"2021-07-03T20:51:43.000Z","path":"wiki/13695/","text":"源码版与安装版引擎的路径有区别： BaseEngine.ini1234567891011121314151617181920212223[DerivedDataBackendGraph_Fill_Seattle]MinimumDaysToKeepFile=7Root=(Type=KeyLength, Length=120, Inner=AsyncPut)AsyncPut=(Type=AsyncPut, Inner=Hierarchy)Hierarchy=(Type=Hierarchical, Inner=Boot, Inner=Pak, Inner=EnginePak, Inner=Local, Inner=Seattle)Boot=(Type=Boot, Filename=&quot;%GAMEDIR%DerivedDataCache/Boot.ddc&quot;, MaxCacheSize=512)Local=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true, UnusedFileAge=34, FoldersToClean=-1, Path=%ENGINEDIR%DerivedDataCache)Seattle=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, DeleteUnused=true, UnusedFileAge=23, FoldersToClean=10, MaxFileChecksPerSec=1, Path=?EpicSeaDDC, EnvPathOverride=UE-SharedDataCachePath_Seattle)Pak=(Type=ReadPak, Filename=&quot;%GAMEDIR%DerivedDataCache/DDC.ddp&quot;)EnginePak=(Type=ReadPak, Filename=%ENGINEDIR%DerivedDataCache/DDC.ddp)[InstalledDerivedDataBackendGraph]MinimumDaysToKeepFile=7Root=(Type=KeyLength, Length=120, Inner=AsyncPut)AsyncPut=(Type=AsyncPut, Inner=Hierarchy)Hierarchy=(Type=Hierarchical, Inner=Boot, Inner=Pak, Inner=CompressedPak, Inner=EnginePak, Inner=EnterprisePak, Inner=Local, Inner=Shared)Boot=(Type=Boot, Filename=&quot;%ENGINEUSERDIR%DerivedDataCache/Boot.ddc&quot;, MaxCacheSize=512)Local=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, PurgeTransient=true, DeleteUnused=true, UnusedFileAge=34, FoldersToClean=-1, Path=&quot;%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache&quot;, EditorOverrideSetting=LocalDerivedDataCache)Shared=(Type=FileSystem, ReadOnly=false, Clean=false, Flush=false, DeleteUnused=true, UnusedFileAge=10, FoldersToClean=10, MaxFileChecksPerSec=1, Path=?EpicDDC, EnvPathOverride=UE-SharedDataCachePath, EditorOverrideSetting=SharedDerivedDataCache)Pak=(Type=ReadPak, Filename=&quot;%GAMEDIR%DerivedDataCache/DDC.ddp&quot;)CompressedPak=(Type=ReadPak, Filename=&quot;%GAMEDIR%DerivedDataCache/Compressed.ddp&quot;, Compressed=true)EnginePak=(Type=ReadPak, Filename=../../../Engine/DerivedDataCache/Compressed.ddp, Compressed=true)EnterprisePak=(Type=ReadPak, Filename=../../../Enterprise/DerivedDataCache/Compressed.ddp, Compressed=true) 源码版的引擎存在于 Engine/DerivedDataCache 与项目的 DerivedDataCache 目录下。安装版引擎的则位于以下几个路径中： %ENGINEUSERDIR%DerivedDataCache/Boot.ddc %ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache %GAMEDIR%DerivedDataCache/DDC.ddp ../../../Engine/DerivedDataCache/Compressed.ddp ../../../Enterprise/DerivedDataCache/Compressed.ddp 这几个路径规则的真实路径： Runtime/Core/Private/Misc/ConfigCacheIni.cpp1234567891011121314static const FConfigExpansion* MatchExpansions(const TCHAR* PotentialVariable)&#123; // Allocate replacement value strings once static const FConfigExpansion Expansions[] = &#123; FConfigExpansion(TEXT(&quot;%GAME%&quot;), FString(FApp::GetProjectName())), FConfigExpansion(TEXT(&quot;%GAMEDIR%&quot;), FPaths::ProjectDir()), FConfigExpansion(TEXT(&quot;%ENGINEDIR%&quot;), FPaths::EngineDir()), FConfigExpansion(TEXT(&quot;%ENGINEUSERDIR%&quot;), FPaths::EngineUserDir()), FConfigExpansion(TEXT(&quot;%ENGINEVERSIONAGNOSTICUSERDIR%&quot;), FPaths::EngineVersionAgnosticUserDir()), FConfigExpansion(TEXT(&quot;%APPSETTINGSDIR%&quot;), GetApplicationSettingsDirNormalized()), &#125;; // ...&#125; 可以在 BaseEngine.ini 中修改 DDC 的路径占位符，替换为上面的可选路径。 注意：EngineUserDir与 EngineVersionAgnosticUserDir 在安装版与源码版上也有区分： Runtime/Core/Private/Misc/Paths.cpp1234567891011121314151617181920212223FString FPaths::EngineUserDir()&#123; if (ShouldSaveToUserDir() || FApp::IsEngineInstalled()) &#123; return FPaths::Combine(FPlatformProcess::UserSettingsDir(), *FApp::GetEpicProductIdentifier(), *FEngineue_version::Current().ToString(EVersionComponent::Minor)) + TEXT(&quot;/&quot;); &#125; else &#123; return FPaths::EngineDir(); &#125;&#125;FString FPaths::EngineVersionAgnosticUserDir()&#123; if (ShouldSaveToUserDir() || FApp::IsEngineInstalled()) &#123; return FPaths::Combine(FPlatformProcess::UserSettingsDir(), *FApp::GetEpicProductIdentifier(), TEXT(&quot;Common&quot;)) + TEXT(&quot;/&quot;); &#125; else &#123; return FPaths::EngineDir(); &#125;&#125; 默认情况下，如果要完全清理系统中的 DDC 缓存，需要清理以下路径： 123Engine\\Engine\\DerivedDataCache\\*ProjectName\\DerivedDataCache\\*C:\\Users\\username\\AppData\\Local\\UnrealEngine\\* 可以使用以下 cmd 命令： 123echo y|del Engine\\DerivedDataCacheecho y|del ProjectName\\DerivedDataCacheecho y|del C:\\Users\\username\\AppData\\Local\\UnrealEngine 类似问题： [HOW TO] Change local data cache location","tags":[],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"DDC","slug":"Engine/DDC","permalink":"https://ue5wiki.com/categories/Engine/DDC/"}]},{"title":"Navmesh bounds are too large","date":"2021-07-03T20:47:03.000Z","path":"wiki/12781/","text":"当地图相当大，在生成导航时会有以下提示： 1LogNavigation: Error: Navmesh bounds are too large! Limiting requested tiles count (5472000) to: (1048576) for RecastNavMesh /Game/Level/Map.Map:PersistentLevel.RecastNavMesh-Default 这是因为地图太大，超出了 Tile 的数量限制。引擎中默认 Tile 的最大数量为 1&lt;&lt;20 也就是 1048576，这个值可以修改配置，但不能大于1&lt;&lt;30(因为它用 int32 存储)。 Source/Runtime/NavigationSystem/Public/NavMesh/RecastNavMesh.h123456789101112UCLASS(config=Engine, defaultconfig, hidecategories=(Input,Rendering,Tags,&quot;Utilities|Transformation&quot;,Actor,Layers,Replication), notplaceable)class NAVIGATIONSYSTEM_API ARecastNavMesh : public ANavigationData&#123; // ... /** Absolute hard limit to number of navmesh tiles. Be very, very careful while modifying it while * having big maps with navmesh. A single, empty tile takes 176 bytes and empty tiles are * allocated up front (subject to change, but that&#x27;s where it&#x27;s at now) * @note TileNumberHardLimit is always rounded up to the closest power of 2 */ UPROPERTY(EditAnywhere, Category = Generation, config, meta = (ClampMin = &quot;1&quot;, UIMin = &quot;1&quot;), AdvancedDisplay) int32 TileNumberHardLimit; // ...&#125;; 以及使用： Runtime/NavigationSystem/Private/NavMesh/RecastNavMesh.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112FRecastNavMeshGenerationProperties::FRecastNavMeshGenerationProperties()&#123; TilePoolSize = 1024; TileSizeUU = 988.f; CellSize = 19; CellHeight = 10; AgentRadius = 34.f; AgentHeight = 144.f; AgentMaxSlope = 44.f; AgentMaxStepHeight = 35.f; MinRegionArea = 0.f; MergeRegionSize = 400.f; MaxSimplificationError = 1.3f; // from RecastDemo TileNumberHardLimit = 1 &lt;&lt; 20; RegionPartitioning = ERecastPartitioning::Watershed; LayerPartitioning = ERecastPartitioning::Watershed; RegionChunkSplits = 2; LayerChunkSplits = 2; bSortNavigationAreasByCost = false; bPerformVoxelFiltering = true; bMarkLowHeightAreas = false; bUseExtraTopCellWhenMarkingAreas = true; bFilterLowSpanSequences = false; bFilterLowSpanFromTileCache = false; bFixedTilePoolSize = false;&#125;FRecastNavMeshGenerationProperties::FRecastNavMeshGenerationProperties(const ARecastNavMesh&amp; RecastNavMesh)&#123; TilePoolSize = RecastNavMesh.TilePoolSize; TileSizeUU = RecastNavMesh.TileSizeUU; CellSize = RecastNavMesh.CellSize; CellHeight = RecastNavMesh.CellHeight; AgentRadius = RecastNavMesh.AgentRadius; AgentHeight = RecastNavMesh.AgentHeight; AgentMaxSlope = RecastNavMesh.AgentMaxSlope; AgentMaxStepHeight = RecastNavMesh.AgentMaxStepHeight; MinRegionArea = RecastNavMesh.MinRegionArea; MergeRegionSize = RecastNavMesh.MergeRegionSize; MaxSimplificationError = RecastNavMesh.MaxSimplificationError; TileNumberHardLimit = RecastNavMesh.TileNumberHardLimit; RegionPartitioning = RecastNavMesh.RegionPartitioning; LayerPartitioning = RecastNavMesh.LayerPartitioning; RegionChunkSplits = RecastNavMesh.RegionChunkSplits; LayerChunkSplits = RecastNavMesh.LayerChunkSplits; bSortNavigationAreasByCost = RecastNavMesh.bSortNavigationAreasByCost; bPerformVoxelFiltering = RecastNavMesh.bPerformVoxelFiltering; bMarkLowHeightAreas = RecastNavMesh.bMarkLowHeightAreas; bUseExtraTopCellWhenMarkingAreas = RecastNavMesh.bUseExtraTopCellWhenMarkingAreas; bFilterLowSpanSequences = RecastNavMesh.bFilterLowSpanSequences; bFilterLowSpanFromTileCache = RecastNavMesh.bFilterLowSpanFromTileCache; bFixedTilePoolSize = RecastNavMesh.bFixedTilePoolSize;&#125;ARecastNavMesh::ARecastNavMesh(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) , bDrawFilledPolys(true) , bDrawNavMeshEdges(true) , bDrawNavLinks(true) , bDrawOctreeDetails(true) , bDrawMarkedForbiddenPolys(false) , bDistinctlyDrawTilesBeingBuilt(true) , DrawOffset(10.f) , TilePoolSize(1024) , MaxSimplificationError(1.3f) // from RecastDemo , DefaultMaxSearchNodes(RECAST_MAX_SEARCH_NODES) , DefaultMaxHierarchicalSearchNodes(RECAST_MAX_SEARCH_NODES) , bPerformVoxelFiltering(true) , bMarkLowHeightAreas(false) , bUseExtraTopCellWhenMarkingAreas(true) , bFilterLowSpanSequences(false) , bFilterLowSpanFromTileCache(false) , bStoreEmptyTileLayers(false) , bUseVirtualFilters(true) , bAllowNavLinkAsPathEnd(false) , TileSetUpdateInterval(1.0f) , NavMeshVersion(NAVMESHVER_LATEST) , RecastNavMeshImpl(NULL)&#123; HeuristicScale = 0.999f; RegionPartitioning = ERecastPartitioning::Watershed; LayerPartitioning = ERecastPartitioning::Watershed; RegionChunkSplits = 2; LayerChunkSplits = 2; MaxSimultaneousTileGenerationJobsCount = 1024; bDoFullyAsyncNavDataGathering = false; TileNumberHardLimit = 1 &lt;&lt; 20;#if RECAST_ASYNC_REBUILDING BatchQueryCounter = 0;#endif // RECAST_ASYNC_REBUILDING if (HasAnyFlags(RF_ClassDefaultObject) == false) &#123; INC_DWORD_STAT_BY(STAT_NavigationMemory, sizeof(*this) ); FindPathImplementation = FindPath; FindHierarchicalPathImplementation = FindPath; TestPathImplementation = TestPath; TestHierarchicalPathImplementation = TestHierarchicalPath; RaycastImplementation = NavMeshRaycast; RecastNavMeshImpl = new FPImplRecastNavMesh(this); // add predefined areas up front SupportedAreas.Add(FSupportedAreaData(UNavArea_Null::StaticClass(), RECAST_NULL_AREA)); SupportedAreas.Add(FSupportedAreaData(UNavArea_LowHeight::StaticClass(), RECAST_LOW_AREA)); SupportedAreas.Add(FSupportedAreaData(UNavArea_Default::StaticClass(), RECAST_DEFAULT_AREA)); &#125;&#125; TileNumberHardLimit的值可以通过配置文件进行设置： DefaultEngine.ini12345678910111213141516171819202122232425262728293031323334353637[/Script/NavigationSystem.RecastNavMesh]bDrawPolyEdges=FalsebDistinctlyDrawTilesBeingBuilt=TrueDrawOffset=10.000000bFixedTilePoolSize=FalseTilePoolSize=1024TileSizeUU=1000.000000CellSize=19.000000CellHeight=10.000000AgentRadius=34.000000AgentHeight=144.000000AgentMaxHeight=160.000000AgentMaxSlope=44.000000AgentMaxStepHeight=35.000000MinRegionArea=0.000000MergeRegionSize=400.000000MaxSimplificationError=1.300000MaxSimultaneousTileGenerationJobsCount=1024TileNumberHardLimit=1048576DefaultDrawDistance=5000.000000DefaultMaxSearchNodes=2048.000000DefaultMaxHierarchicalSearchNodes=2048.000000RegionPartitioning=WatershedLayerPartitioning=WatershedRegionChunkSplits=2LayerChunkSplits=2bSortNavigationAreasByCost=FalsebPerformVoxelFiltering=TruebMarkLowHeightAreas=FalsebDoFullyAsyncNavDataGathering=FalsebUseBetterOffsetsFromCorners=TruebUseVirtualFilters=TruebUseVoxelCache=FalseTileSetUpdateInterval=1.000000HeuristicScale=0.999000VerticalDeviationFromGroundCompensation=0.000000bForceRebuildOnLoad=True","tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://ue5wiki.com/tags/Navigation/"}],"categories":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/categories/NavMesh/"}]},{"title":"打包 iOS 导出 dSYM","date":"2021-07-03T20:44:19.000Z","path":"wiki/12245/","text":"像 Bugly 之类的 crash 上报平台都需要上传符号表才能看到具体的堆栈信息，而 iOS 上的符号和调试信息都是在 dSYM 文件中的。UE 提供了 dSYM 的生成选项，在Project Settings-Platforms-iOS-Build： Generate dSYM file for code debugging and profiling：只开启这个会在 Binaries/IOS 下生成 PROJECT_NAME.dSYM 文件 Generate dSYM bundle for third party crash tools：依赖上面的选项，如果开启会在 Binaries/IOS 下生成 PROJECT_NAME.dSYM.zip，并且不会再生成PROJECT_NAME.dSYM 文件。 但是，在使用源码版打包 iOS 项目的时候生成的 dSYM 特别大，超过 2G，而同样的工程用 Luncher 引擎打包就只有 100+M，而且 bugly 之类的上传还有大小限制。 经过对比之后发现，大小的差距主要是在 _DWARF_debug_* 这些上（左侧为 Launcher 版，右侧为 DebugGame 源码版）： 本来以为是源码版会把所有参与编译的代码都导出到 dSYM 文件中，但是经过翻阅引擎代码发现，其实 TargetRules 中有控制调试信息的选项，就是来控制产生这些 _DWARF_debug_* 的： 1234567891011121314151617181920// TargetRules.cs/// &lt;summary&gt;/// Whether to globally disable debug info generation; see DebugInfoHeuristics.cs for per-config and per-platform options./// &lt;/summary&gt;[CommandLine(&quot;-NoDebugInfo&quot;)][XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bDisableDebugInfo = false;/// &lt;summary&gt;/// Whether to disable debug info generation for generated files. This improves link times for modules that have a lot of generated glue code./// &lt;/summary&gt;[XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bDisableDebugInfoForGeneratedCode = false;/// &lt;summary&gt;/// Whether to disable debug info on PC in development builds (for faster developer iteration, as link times are extremely fast with debug info disabled)./// &lt;/summary&gt;[XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bOmitPCDebugInfoInDevelopment = false; 在项目的 Target.cs 中控制这些变量即可，如 bDisableDebugInfo=true，在源码版引擎中也不会生很大的_DWARF_debug 文件了（左侧为 Lunch 版引擎，右侧为 DebugGame 源码版控制bDisableDebugInfo=true）： 而且，还发现 UE 在打包 IOS 平台的时候处理有问题，本来以为打 Shipping 生成的 dSYM 会没有调试信息了，但是测试发现还是非常大。 经过分析后发现，在 UE 的构建系统中是通过两个值来控制是否创建调试信息的： 123456// UEBuildPlatforms.cs// Create debug info based on the heuristics specified by the user.GlobalCompileEnvironment.bCreateDebugInfo = !Target.bDisableDebugInfo &amp;&amp; ShouldCreateDebugInfo(Target);GlobalLinkEnvironment.bCreateDebugInfo = GlobalCompileEnvironment.bCreateDebugInfo; 可以看到是通过 Target.bDisableDebugInfo 和ShouldCreateDebugInfo(Target)两个值来控制的，而 ShouldCreateDebugInfo 函数则是每个平台的有自己的重写实现。 如在 Windows 上： 123456789101112131415161718192021// UnrealBuildTool/Platform/Windows/UEBuildWindows.cs/// &lt;summary&gt;/// Whether this platform should create debug information or not/// &lt;/summary&gt;/// &lt;param name=&quot;Target&quot;&gt;The target being built&lt;/param&gt;/// &lt;returns&gt;bool true if debug info should be generated, false if not&lt;/returns&gt;public override bool ShouldCreateDebugInfo(ReadOnlyTargetRules Target)&#123; switch (Target.Configuration) &#123; case UnrealTargetConfiguration.Development: case UnrealTargetConfiguration.Shipping: case UnrealTargetConfiguration.Test: return !Target.bOmitPCDebugInfoInDevelopment; case UnrealTargetConfiguration.DebugGame: case UnrealTargetConfiguration.Debug: default: return true; &#125;;&#125; 但是，在 IOS 和 Mac 上完全没有判断！ 123456// UnrealBuildTool/Platform/IOS/UEBuildIOS.cspublic override bool ShouldCreateDebugInfo(ReadOnlyTargetRules Target)&#123; return true;&#125; 这导致只能自己用 bDisableDebugInfo=true 来控制，太坑爹了。翻了代码才发现 bOmitPCDebugInfoInDevelopment 这个选项只在 PC 上有效：BuildConfigProperties.INT.udn#L85。 坑点 根据上面的介绍，可以通过控制 bDisableDebugInfo=true 来生成体积较小的 dSYM，但这样有牵扯出来一个坑的问题：使用远程构建时dSYM 无法通过 UE 的构建系统传回本地。查了下代码，没有什么比较方便的办法来控制从远程拷贝的文件，目前我使用 pscp 从远程拉取 dSYM 文件回本地。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"dSYM","slug":"dSYM","permalink":"https://ue5wiki.com/tags/dSYM/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"移动端指定启动参数","date":"2021-07-03T19:08:37.000Z","path":"wiki/26262/","text":"UE4 打出来的 Windows 包可以使用 XXXX.exe -Params 等方式来传递给游戏参数，但是移动平台 (IOS/Android) 打包出来的怎么传递参数呢？ Android 启动参数 看了一下引擎里的代码，在 Launch 模块下 Launch\\Private\\Android\\LaunchAndroid.cpp 中有 InitCommandLine 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Launch\\Private\\Android\\LaunchAndroid.cppstatic void InitCommandLine()&#123; static const uint32 CMD_LINE_MAX = 16384u; // initialize the command line to an empty string FCommandLine::Set(TEXT(&quot;&quot;)); AAssetManager* AssetMgr = AndroidThunkCpp_GetAssetManager(); AAsset* asset = AAssetManager_open(AssetMgr, TCHAR_TO_UTF8(TEXT(&quot;UE4CommandLine.txt&quot;)), AASSET_MODE_BUFFER); if (nullptr != asset) &#123; const void* FileContents = AAsset_getBuffer(asset); int32 FileLength = AAsset_getLength(asset); char CommandLine[CMD_LINE_MAX]; FileLength = (FileLength &lt; CMD_LINE_MAX - 1) ? FileLength : CMD_LINE_MAX - 1; memcpy(CommandLine, FileContents, FileLength); CommandLine[FileLength] = &#x27;\\0&#x27;; AAsset_close(asset); // chop off trailing spaces while (*CommandLine &amp;&amp; isspace(CommandLine[strlen(CommandLine) - 1])) &#123; CommandLine[strlen(CommandLine) - 1] = 0; &#125; FCommandLine::Append(UTF8_TO_TCHAR(CommandLine)); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;APK Commandline: %s&quot;), FCommandLine::Get()); &#125; // read in the command line text file from the sdcard if it exists FString CommandLineFilePath = GFilePathBase + FString(&quot;/UE4Game/&quot;) + (!FApp::IsProjectNameEmpty() ? FApp::GetProjectName() : FPlatformProcess::ExecutableName()) + FString(&quot;/UE4CommandLine.txt&quot;); FILE* CommandLineFile = fopen(TCHAR_TO_UTF8(*CommandLineFilePath), &quot;r&quot;); if(CommandLineFile == NULL) &#123; // if that failed, try the lowercase version CommandLineFilePath = CommandLineFilePath.Replace(TEXT(&quot;UE4CommandLine.txt&quot;), TEXT(&quot;ue4commandline.txt&quot;)); CommandLineFile = fopen(TCHAR_TO_UTF8(*CommandLineFilePath), &quot;r&quot;); &#125; if(CommandLineFile) &#123; char CommandLine[CMD_LINE_MAX]; fgets(CommandLine, ARRAY_COUNT(CommandLine) - 1, CommandLineFile); fclose(CommandLineFile); // chop off trailing spaces while (*CommandLine &amp;&amp; isspace(CommandLine[strlen(CommandLine) - 1])) &#123; CommandLine[strlen(CommandLine) - 1] = 0; &#125; // initialize the command line to an empty string FCommandLine::Set(TEXT(&quot;&quot;)); FCommandLine::Append(UTF8_TO_TCHAR(CommandLine)); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Override Commandline: %s&quot;), FCommandLine::Get()); &#125;#if !UE_BUILD_SHIPPING if (FString* ConfigRulesCmdLineAppend = FAndroidMisc::GetConfigRulesVariable(TEXT(&quot;cmdline&quot;))) &#123; FCommandLine::Append(**ConfigRulesCmdLineAppend); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;ConfigRules appended: %s&quot;), **ConfigRulesCmdLineAppend); &#125;#endif&#125; 简单来说就是在 UE4Game/ProjectName/ue4commandline.txt 中把启动参数写到里面，引擎启动的时候会从这个文件去读，然后添加到 FCommandLine 中。 IOS 启动参数 与 Android 的做法相同，IOS 的参数传递是在 main 函数中调用FIOSCommandLineHelper::InitCommandArgs(FString());，不过路径和 Android 不一样： 123456789101112131415161718192021222324252627282930313233343536373839404142static void InitCommandArgs(FString AdditionalCommandArgs)&#123; // initialize the commandline FCommandLine::Set(TEXT(&quot;&quot;)); FString CommandLineFilePath = FString([[NSBundle mainBundle] bundlePath]) + TEXT(&quot;/ue4commandline.txt&quot;); // read in the command line text file (coming from UnrealFrontend) if it exists FILE* CommandLineFile = fopen(TCHAR_TO_UTF8(*CommandLineFilePath), &quot;r&quot;); if(CommandLineFile) &#123; FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Found ue4commandline.txt file&quot;) LINE_TERMINATOR); char CommandLine[CMD_LINE_MAX] = &#123;0&#125;; char* DataExists = fgets(CommandLine, ARRAY_COUNT(CommandLine) - 1, CommandLineFile); if (DataExists) &#123; // chop off trailing spaces while (*CommandLine &amp;&amp; isspace(CommandLine[strlen(CommandLine) - 1])) &#123; CommandLine[strlen(CommandLine) - 1] = 0; &#125; FCommandLine::Append(UTF8_TO_TCHAR(CommandLine)); &#125; &#125; else &#123; FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;No ue4commandline.txt [%s] found&quot;) LINE_TERMINATOR, *CommandLineFilePath); &#125; if (!AdditionalCommandArgs.IsEmpty() &amp;&amp; !FChar::IsWhitespace(AdditionalCommandArgs[0])) &#123; FCommandLine::Append(TEXT(&quot; &quot;)); &#125; FCommandLine::Append(*AdditionalCommandArgs); // now merge the GSavedCommandLine with the rest FCommandLine::Append(*GSavedCommandLine); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Combined iOS Commandline: %s&quot;) LINE_TERMINATOR, FCommandLine::Get());&#125; 关键就是 [[NSBundle mainBundle] bundlePath] 这一句，它获取的是 App 的包路径，所以把 UE4CommandLine.txt 放到包路径下就可以了，可以使用 iMaZing 或者爱思助手之类的工具访问 App 的数据目录，放入 ue4commandline.txt 即可。 NSBundle","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"}]},{"title":"引用 windows 头文件的警告 / 错误","date":"2021-07-03T17:04:04.000Z","path":"wiki/34627/","text":"有时候需要包含一些平台相关的代码，如 windows.h 里面包含了很多头文件，其中一些定义了很多宏，如： fileapi.h12345#ifdef UNICODE#define DeleteFile DeleteFileW#else#define DeleteFile DeleteFileA#endif // !UNICODE 如果我们同时在代码中包含了 windows.h 和使用了 IPlatformFile 的接口来调用它的 DeleteFile 函数，因为 DeleteFile 被定义成了宏，所以在预处理阶段就会被替换，导致编译时访问 IPlatformFile 的DeleteFileW成员，但实际上它是不存在的，就产生了以下编译错误： 1error C2039: &#x27;DeleteFileW&#x27;: is not a member of &#x27;IPlatformFile&#x27; 解决办法就是不直接包含 windows.h 而是使用以下封装： 123#include &quot;Windows/AllowWindowsPlatformTypes.h&quot;#include &quot;windows.h&quot;#include &quot;Windows/HideWindowsPlatformTypes.h&quot; 这样可以避免污染 UE 的符号名字。 UE 的文档中也有介绍：第三方库 #故障排除","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"UBT","slug":"BuildSystem/UBT","permalink":"https://ue5wiki.com/categories/BuildSystem/UBT/"}]},{"title":"创建异步 Blueprint 节点","date":"2021-07-03T17:02:38.000Z","path":"wiki/34346/","text":"在工程中有一些异步操作的需求，比如下载文件的行为，一个下载命令等待下载完成之后回调，而且要尽量避免太多的事件绑定和解绑操作。在蓝图的节点中有一些异步的操作，比如 PlayMontage/DownloadImage 等，都是异步操作中有多个输出节点的:我们能不能自己写一个这样的异步操作的节点呢？那必然是可以的。可以在 Engine\\Source\\Runtime\\UMG\\Public\\Blueprint\\AsyncTaskDownloadImage.h 中查看 DownloadImage 节点的实现 (C++API)。 可以自己仿照这自己写一个出来： 关键就是要继承UBlueprintAsyncActionBase，这个是必须的。 然后写一个 static 的函数，返回类的指针，并用 UFUNCTION 的mate标记为BlueprintInternalUseOnly=&quot;true&quot; 声明并定义几个派发器成员，这些派发器成员就是异步的节点，也就是蓝图节点右侧的 exec 节点。 我们先来看一下 DownloadImage 的声明: 123456789101112131415161718192021222324class UTexture2DDynamic;DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FDownloadImageDelegate, UTexture2DDynamic*, Texture);UCLASS()class UMG_API UAsyncTaskDownloadImage : public UBlueprintAsyncActionBase&#123; GENERATED_UCLASS_BODY()public: UFUNCTION(BlueprintCallable, meta=( BlueprintInternalUseOnly=&quot;true&quot; )) static UAsyncTaskDownloadImage* DownloadImage(FString URL);public: UPROPERTY(BlueprintAssignable) FDownloadImageDelegate OnSuccess; UPROPERTY(BlueprintAssignable) FDownloadImageDelegate OnFail;public: void Start(FString URL);private: /** Handles image requests coming from the web */ void HandleImageRequest(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded);&#125;; 对比上面的 DownloadImage 的节点，可以看到：0. 首先声明了一个动态多播代理FDownloadImageDelegate，并且需要传入一个参数 UAsyncTaskDownloadImage类中声明了两个事件派发器 OnSuccess 和OnFail，这也是蓝图节点右侧的 Exec 和参数Texture，本质都是派发器(动态多播代理) UAsyncTaskDownloadImage的 static 函数 DownloadImage 接收一个 FString 的参数，返回一个UAsyncTaskDownloadImage*，这个返回就是把派发器的执行节点在蓝图中显示出来 即：声明的动态多播的成员和该多播的参数都会显示在蓝图节点的右侧。 我自己实现了一个异步行为的操作，先在蓝图中看操作：行为就是，先创建一个 AsyncActionObject 的对象作为后期触发异步操作的对象，然后执行 CreateAsyncTask 里面对上一步创建的 AsyncActionObject 进行事件绑定。然后我们就可以在那个 ActionObj 调用 OnActionStart 之类的操作就可以调用 CreateAsyncTask 右侧的相关节点。注意：我做的限制是，一个对象对应一个 Task, 如果当前传入的 AsyncActionObject 正在被其他的 task 绑定，则创建 task 会失败。然后就是代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// AsyncTask.h// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.#pragma once#include &quot;AsyncActionObject.h&quot;// unreal header#include &quot;Array.h&quot;#include &quot;Kismet/KismetSystemLibrary.h&quot;#include &quot;CoreMinimal.h&quot;#include &quot;UObject/ObjectMacros.h&quot;#include &quot;Kismet/BlueprintAsyncActionBase.h&quot;#include &quot;AsyncTask.generated.h&quot;#ifndef PRINT_LOG#define PRINT_LOG(lOG_TEXT) UKismetSystemLibrary::PrintString(this,lOG_TEXT,true,true);#endif#ifndef PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO#define PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO 0#endifDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FAsyncTaskDelegate,UAsyncActionObject*,ActionObj);UCLASS(BlueprintType)class UAsyncTask : public UBlueprintAsyncActionBase&#123; GENERATED_UCLASS_BODY()public: UFUNCTION(BlueprintCallable, meta=( BlueprintInternalUseOnly=&quot;true&quot; )) static UAsyncTask* CreateAsyncTask(UAsyncActionObject* ActionObj);public: UPROPERTY(BlueprintAssignable) FAsyncTaskDelegate OnStart; UPROPERTY(BlueprintAssignable) FAsyncTaskDelegate OnAbort; UPROPERTY(BlueprintAssignable) FAsyncTaskDelegate OnUpdate; UPROPERTY(BlueprintAssignable) FAsyncTaskDelegate OnFinishd;protected: void StartTask(UAsyncActionObject* ActionObj); virtual void OnActionStart(UAsyncActionObject* ActionObj); virtual void OnActionAbort(UAsyncActionObject* ActionObj); virtual void OnActionUpdate(UAsyncActionObject* ActionObj); virtual void OnActionFinishd(UAsyncActionObject* ActionObj);&#125;; 然后是实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// AsyncTask.cpp// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.#include &quot;AsyncTask.h&quot;#include &quot;Modules/ModuleManager.h&quot;//----------------------------------------------------------------------//// UAsyncTask//----------------------------------------------------------------------//UAsyncTask::UAsyncTask(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)&#123; if (HasAnyFlags(RF_ClassDefaultObject) == false ) &#123; AddToRoot(); &#125;&#125;UAsyncTask* UAsyncTask::CreateAsyncTask(UAsyncActionObject* ActionObj)&#123; UAsyncTask* AsyncActionTask = NewObject&lt;UAsyncTask&gt;(); AsyncActionTask-&gt;StartTask(ActionObj); return AsyncActionTask;&#125;void UAsyncTask::StartTask(UAsyncActionObject* ActionObj)&#123; if(ActionObj &amp;&amp; !ActionObj-&gt;Action_IsRunning()) &#123;#if PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncTask::StartTask Bind Event&quot;));#endif (ActionObj-&gt;OnStart).BindUObject(this,&amp;UAsyncTask::OnActionStart); (ActionObj-&gt;OnAbort).BindUObject(this,&amp;UAsyncTask::OnActionAbort); (ActionObj-&gt;OnUpdate).BindUObject(this,&amp;UAsyncTask::OnActionUpdate); (ActionObj-&gt;OnFinishd).BindUObject(this,&amp;UAsyncTask::OnActionFinishd); &#125;&#125;void UAsyncTask::OnActionStart(UAsyncActionObject* ActionObj)&#123;#if PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncTask::OnStart&quot;));#endif OnStart.Broadcast(ActionObj);&#125;void UAsyncTask::OnActionAbort(UAsyncActionObject* ActionObj)&#123;#if PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncTask::OnActionAbort&quot;));#endif OnAbort.Broadcast(ActionObj);&#125;void UAsyncTask::OnActionUpdate(UAsyncActionObject* ActionObj)&#123;#if PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncTask::OnActionUpdate&quot;));#endif OnUpdate.Broadcast(ActionObj);&#125;void UAsyncTask::OnActionFinishd(UAsyncActionObject* ActionObj)&#123;#if PRINT_ASYNC_ACTION_TOOLS_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncTask::OnActionFinishd&quot;));#endif OnFinishd.Broadcast(ActionObj);&#125; AsyncActionObject 类的声明: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// AsyncActionObject.h// Fill out your copyright notice in the Description page of Project Settings.// Fill out your copyright notice in the Description page of Project Settings.#pragma once// unreal header#include &quot;Array.h&quot;#include &quot;Kismet/KismetSystemLibrary.h&quot;#include &quot;CoreMinimal.h&quot;#include &quot;UObject/NoExportTypes.h&quot;#include &quot;AsyncActionObject.generated.h&quot;#ifndef PRINT_LOG#define PRINT_LOG(lOG_TEXT) UKismetSystemLibrary::PrintString(this,lOG_TEXT,true,true);#endif#ifndef PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO#define PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO 0#endifclass UAsyncActionObject;DECLARE_DELEGATE_OneParam(FAsyncActionDelegate,UAsyncActionObject*);UCLASS(BlueprintType,Blueprintable)class UAsyncActionObject : public UObject&#123; GENERATED_BODY()public: UAsyncActionObject(const FObjectInitializer&amp; objectInitializer); FAsyncActionDelegate OnStart; FAsyncActionDelegate OnAbort; FAsyncActionDelegate OnUpdate; FAsyncActionDelegate OnFinishd;public: UFUNCTION(BlueprintCallable) virtual bool OnActionStart(FString&amp; rReason); UFUNCTION(BlueprintCallable) virtual void OnActionAbort(); UFUNCTION(BlueprintCallable) virtual void OnActionUpdate(); UFUNCTION(BlueprintCallable) virtual void OnActionFinishd();public: // Action status (BP Executable function) UFUNCTION(BlueprintCallable) virtual bool Action_IsRunning()const; UFUNCTION(BlueprintCallable) virtual bool Action_ExecutableStart()const;protected: // End Action virtual void EndAction(); virtual void UnBindAll(); virtual void InitDelegateList(); virtual bool Action_IsStarted()const; virtual bool Action_EventIsBinded()const;protected: bool mActionStarted=false; TArray&lt;FAsyncActionDelegate*&gt; DelegateList;&#125;; 以及它的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// AsyncActionObject.cpp// Fill out your copyright notice in the Description page of Project Settings.// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.// Fill out your copyright notice in the Description page of Project Settings.#include &quot;AsyncActionObject.h&quot;UAsyncActionObject::UAsyncActionObject(const FObjectInitializer&amp; objectInitializer)&#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::UAsyncActionObject&quot;));#endif InitDelegateList();&#125;bool UAsyncActionObject::OnActionStart(FString&amp; rReason)&#123; rReason.Reset(); bool local_bResault=false; if(Action_ExecutableStart()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::OnActionStart&quot;));#endif mActionStarted=true; OnStart.ExecuteIfBound(this); local_bResault=true; &#125;else&#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;call UAsyncActionObject::OnActionStart Faild.&quot;));#endif local_bResault=false; if(Action_IsStarted()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;StartFaild: Action is Started.&quot;));#endif rReason.Append(FString(TEXT(&quot;Action is Started.\\n&quot;))); &#125; if(!Action_EventIsBinded()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;StartFaild: Action is not bind anything event.&quot;));#endif rReason.Append(FString(TEXT(&quot;Action is not bind to anything Task&quot;))); &#125; &#125; return local_bResault;&#125;void UAsyncActionObject::OnActionAbort()&#123; if(Action_IsRunning()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::OnActionAbort&quot;));#endif OnAbort.ExecuteIfBound(this); EndAction(); &#125;&#125;void UAsyncActionObject::OnActionUpdate()&#123; if(Action_IsRunning()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::OnActionUpdate&quot;));#endif OnUpdate.ExecuteIfBound(this); &#125;&#125;void UAsyncActionObject::OnActionFinishd()&#123; if(Action_IsRunning()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::OnActionFinishd&quot;));#endif OnFinishd.ExecuteIfBound(this); EndAction(); &#125;&#125;void UAsyncActionObject::EndAction()&#123; if(Action_IsRunning()) &#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::EndAction&quot;));#endif UnBindAll(); mActionStarted=false; &#125;&#125;void UAsyncActionObject::UnBindAll()&#123;#if PRINT_ASYNC_ACTION_OBJ_DEBUG_INFO PRINT_LOG(TEXT(&quot;UAsyncActionObject::UnBindAll&quot;));#endif for(auto&amp; DeleIndex:DelegateList) &#123; if(DeleIndex-&gt;IsBound()) &#123; DeleIndex-&gt;Unbind(); &#125; &#125;&#125;void UAsyncActionObject::InitDelegateList()&#123; if(!Action_IsStarted()) &#123; DelegateList.AddUnique(&amp;OnStart); DelegateList.AddUnique(&amp;OnAbort); DelegateList.AddUnique(&amp;OnUpdate); DelegateList.AddUnique(&amp;OnFinishd); &#125;&#125;bool UAsyncActionObject::Action_EventIsBinded()const&#123; bool EventIsBinded=true; for(auto&amp; DeleIndex:DelegateList) &#123; if(!DeleIndex-&gt;IsBound()) EventIsBinded=false; &#125; return EventIsBinded;&#125;bool UAsyncActionObject::Action_IsStarted()const&#123; return mActionStarted;&#125;bool UAsyncActionObject::Action_IsRunning()const&#123; return Action_IsStarted() &amp;&amp; Action_EventIsBinded();&#125;bool UAsyncActionObject::Action_ExecutableStart()const&#123; return !Action_IsStarted() &amp;&amp; Action_EventIsBinded();&#125; 其实就是本质上裹了两层派发器而已…举个例子的用途：可以在行为树里监听某个动画被终止或者结束了之后然后再执行其他的行为，可以解决不同模块之间之间的耦合。","tags":[{"name":"Blueprint","slug":"Blueprint","permalink":"https://ue5wiki.com/tags/Blueprint/"},{"name":"异步","slug":"异步","permalink":"https://ue5wiki.com/tags/%E5%BC%82%E6%AD%A5/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"Blueprint","slug":"Programming/Blueprint","permalink":"https://ue5wiki.com/categories/Programming/Blueprint/"}]},{"title":"Profiling Commands","date":"2021-07-03T17:01:07.000Z","path":"wiki/34049/","text":"显示 FPS 1stat FPS 显示统计单元(每帧的总时间，逻辑线程 / 渲染线程和 GPU 的时间消耗)： 1stat Unit 显示渲染线程中的各种参数值 1Stat SceneRendering 显示渲染线程命令的消耗 1stat RenderThreadCommands 显示游戏线程上的参数(AI/ 物理 / 动画 / 蓝图 / 内存分配等) 1stat game 显示剔除所需的时间和效率数据 1Stat InitViews 显示照明和着色所需的渲染时间 1Stat LightRendering 抓取当前帧的 GPU 信息 1ProfileGPU 会弹出 GPU Data Bisualizer 的GPU Visualizer显示抓取帧的数据。 抓取 Profiling 信息(CPU/GPU) 12stat StartFilestat StopFile 会在项目的 Saved/Profiling/UnrealStats 下产生 *.ue4stats 文件，可以使用 UnrealFornted 打开。 UE 网络分析 123456# 打开和关闭录制netprofile# 如果尚未录制则开始录制netprofile enable# 如果当前正在录制，则停止录制netprofile disable 捕获的数据保存在 Saved/Profiling 下，后缀名为 *.nprof。UE 网络分析(Network Profiler) 工具的文档Network Profiler. 链接： Performance and Profiling GPU Profiling Stat Commands VR Developer Tutorial: Testing and Profiling the Premium VR Game Network Profiler","tags":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"Actor Replication Config","date":"2021-07-03T16:58:59.000Z","path":"wiki/33631/","text":"ReplicationOnlyRelecantToServer(default false)if true,this actor is only relevant its owner,if this flag is changed during play,all non-owner channels would need to be explicitly close. Always Relevant(default false)Always relevant for network(overrides bOnlyRelevantToOwner) ReplicateMovement(default true)if true,replicate movement/location related properties.Actor must also be set to replicate. see SetReplicates() see https://doc.unrealengine.com/latest/INT/Gameplay/Networking/Replication/ NetLoadOnClient(default true)This actor will be loaded on network clients during map load. NetUseOwnerReplovancy(default false)If actor has valid Owner, call Owner’s IsNetRelevantFor and GetNetPriovity Replicates(default true)if true,this actor will replicate to remote machinessee SetReplicates() NetDormancy(default DORM_Awake)Dormancy setting for actor ro take itself off the replication list without being destory on clients. 12345678910111213141516// This actor can go dormant,but is not currently dormant,Game code will tell it when it go dormant.enum ENetDormancy&#123; DORM_Never, DORM_Awake, DORM_DormantAll, DORM_DormantPartial, DORM_Initial, DORM_MAX,&#125;DORM_Never: This actor can never go network dormant.DORM_Awake: This actor can go dormant, but is not currently dormant. Game code will tell it when it go dormant.DORM_DormantAll: This actor wants to go fully dormant for all connections.DORM_DormantPartial: This actor may want to go dormant for some connections, GetNetDormancy() will be called to find out which.DORM_Initial: This actor is initially dormant for all connection if it was placed in map.DORM_MAX NeuCullDistanceSquared(default 225000000.0)Suqare of the max distance from the client’s viewpoint that this actor is relevant and will be replicated. NetUpdateFrequency(default 100.0)how often(per second) this actor will be considered for replication,used to determine NetUpdateTime. MinNetUpdateFrequency(default 2.0)Used to determine what rate to throttle down to when replicated properties are changing infrequently. NetPriority: (default 3.0)Priority for this actor when checking for replication in a low bandwidth or saturated siuation,higher priority means it is more likely to replicate. Replicated MovementLocationQuantization Level: (default EVectorQuantization::RoundTwoDecimals) 123456789enum EVectorQuantization&#123; RoundWholeNumber, RoundOneDecimal, RoundTwoDecimals,&#125;RoundWholeNumber: Each vector component will be rounded to the nearest whole number.RoundOneDecimal: Each vector component will be rounded, preserving one decimal place.RoundTwoDecimals: Each vector component will be rounded, preserving two decimal places. VelocityQuantization Level: (default ERotatorQuantization::RoundWholeNumber) 1234567enum ERotatorQuantization&#123; ByteComponents, ShortComponents,&#125;ByteComponents: The rotator will be compressed to 8 bits per component.ShortComponents: The rotator will be compressed to 16 bits per component. RotationQuantization Level(default ByteComponents)Allow turing the compression level for replicated rotation.You should only need to change this from the default if you see visual artfacts. 1234567enum ERotatorQuantization&#123; ByteComponents, ShortComponents,&#125;ByteComponents: The rotator will be compressed to 8 bits per component.ShortComponents: The rotator will be compressed to 16 bits per component.","tags":[],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"}]},{"title":"检测是否为安装版引擎的方法","date":"2021-07-03T16:56:06.000Z","path":"wiki/33066/","text":"在 EpicGameLauncher 安装的引擎版本是不能通过 UnrealBuildTool.exe -ProjectFiles &quot;ProgramProjectName&quot; 来创建 TargetProgram的项目的，会提示下列错误： 1ERROR: UnrealBuildTool Exception: A game project path was not specified, which is required when generating project files using an installed build or passing -game on the command line 这个异常在 UBT 里的相关代码在ProjectFileGenreator.cs： 12345678910111213141516171819202122232425262728293031323334353637383940// ProjectFileGenreator.csprotected virtual void ConfigureProjectFileGeneration( String[] Arguments, ref bool IncludeAllPlatforms )&#123; // ... else switch(CurArgument.ToUpperInvariant() ) &#123; // ... case &quot;-GAME&quot;: // Generates project files for a single game bGeneratingGameProjectFiles = true; break; // ... &#125; // ... if(bGeneratingGameProjectFiles || UnrealBuildTool.IsEngineInstalled() ) &#123; if (OnlyGameProject == null) &#123; throw new BuildException(&quot;A game project path was not specified, which is required when generating project files using an installed build or passing -game on the command line&quot;); &#125; GameProjectName = OnlyGameProject.GetFileNameWithoutExtension(); if (String.IsNullOrEmpty(GameProjectName)) &#123; throw new BuildException(&quot;A valid game project was not found in the specified location (&quot; + OnlyGameProject.Directory.FullName + &quot;)&quot;); &#125; bool bInstalledEngineWithSource = UnrealBuildTool.IsEngineInstalled() &amp;&amp; DirectoryReference.Exists(UnrealBuildTool.EngineSourceDirectory); bIncludeEngineSource = bAlwaysIncludeEngineModules || bInstalledEngineWithSource; bIncludeDocumentation = false; bIncludeBuildSystemFiles = false; bIncludeShaderSource = true; bIncludeTemplateFiles = false; bIncludeConfigFiles = true; IncludeEnginePrograms = bAlwaysIncludeEngineModules; &#125;&#125; 可以看到，if这里如果传递给 UBT-game参数并且是引擎是安装版本 (EpicGameLauncher) 时会检测有没有传入 project 参数，如果没有就会抛异常。正常的 UBT 调用命令： 1UnrelBuildTool.exe -ProjectFiles -project=&quot;D:\\UnrealProjects\\UEProject.uproject&quot; -game 这种普通的 Game 参数在 UBT 里面是不会抛异常的。但是用生成 Program 的命令来调用 UBT，安装版引擎就会抛异常： 1UnrelBuildTool.exe -ProjectFiles ProgramName 根据上面 ProjectFileGenreator.cs 的检测代码，我们要做到的是把 UnrealBuildTool.IsEngineInstalled() 获取的结果变为 false.继续跟代码：UnrealBuildTool.IsEngineInstalled()获得的是 UnrealBuildTool 中的一个 bool 变量bIsEngineInstalled： 123456789// UnrealBuildTool.csstatic public bool IsEngineInstalled()&#123; if (!bIsEngineInstalled.HasValue) &#123; throw new BuildException(&quot;IsEngineInstalled() called before being initialized.&quot;); &#125; return bIsEngineInstalled.Value;&#125; 查找引用发现在 GuardedMain 里有设置 bIsEngineInstalled 这个变量的地方： 12345678910111213141516171819202122232425// UnrealBuildTool.csprivate static int GuardedMain(string[] Arguments)&#123; // ... try&#123; // ... foreach (string Argument in Arguments) &#123; string LowercaseArg = Argument.ToLowerInvariant(); if (LowercaseArg == &quot;-installed&quot; || LowercaseArg == &quot;-installedengine&quot;) &#123; bIsEngineInstalled = true; &#125; else if (LowercaseArg == &quot;-notinstalledengine&quot;) &#123; bIsEngineInstalled = false; &#125; &#125; if (!bIsEngineInstalled.HasValue) &#123; bIsEngineInstalled = FileReference.Exists(FileReference.Combine(RootDirectory, &quot;Engine&quot;, &quot;Build&quot;, &quot;InstalledBuild.txt&quot;)); &#125; // ... &#125;&#125; 从代码可以看到，UBT 对是不是安装版引擎的检测有三种方法： 传入参数是否有 -installled 和-installedengine 传入参数是否有-notinstallengine 判断引擎路径 Engine\\Build 下是否具有 InstalledBuild.txt 文件 (说是三种其实也就是两种，就算指定了 -notinstallengine 也是要判断存不存在 Engine\\Build\\InstalledBuild.txt 这个文件)而且检测的顺序是这样的: 1-installled &gt; -installedengine &gt; -notinstalledengine &gt; Engine\\Build\\InstalledBuild.txt 所以，当我想要让 UBT 认为我的引擎版本不是安装版，有两种办法： 对 UBT 的调用传入 -notinstalledengine 参数，并且删掉 Engine\\Build 目录下的 InstalledBuild.txt 文件 对 UBT 的调用不传入 -installled 和-installedengine参数，并且删掉 Engine\\Build 目录下的 InstalledBuild.txt 文件 注：UBT 里还有下面两种检测： 1234567891011121314151617// UnrealBuildTools.csstatic public bool IsEnterpriseInstalled()&#123; if(!bIsEnterpriseInstalled.HasValue) &#123; bIsEnterpriseInstalled = FileReference.Exists(FileReference.Combine(EnterpriseDirectory, &quot;Build&quot;, &quot;InstalledBuild.txt&quot;)); &#125; return bIsEnterpriseInstalled.Value;&#125;static public bool IsProjectInstalled()&#123; if (!bIsProjectInstalled.HasValue) &#123; bIsProjectInstalled = FileReference.Exists(FileReference.Combine(RootDirectory, &quot;Engine&quot;, &quot;Build&quot;, &quot;InstalledProjectBuild.txt&quot;)); &#125; return bIsProjectInstalled.Value;&#125;","tags":[{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"},{"name":"Build System","slug":"Build-System","permalink":"https://ue5wiki.com/tags/Build-System/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"Insight Profiling in lua","date":"2021-07-03T15:00:13.000Z","path":"wiki/351387851/","text":"想要是用 Unreal Insight Profile lua 端的调用，可以把 SCOPED_NAMED_EVENT 封装到 Lua 端，但是因为 Lua 没有 C++ 的 RAII 机制，无法实时地检测离开作用域时机，所以只能通过在起始和结尾位置添加标记： 12345function TimerMgr:UpdateTimer(DeltaTime) local profile_tag = UE4.FProfileTag(&quot;TimerMgr_UpdateTimer&quot;) -- dosomething... profile_tag:End()end 在 C++ 端的实现： ProfileTag.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ProfileTag.generated.h&quot;USTRUCT()struct FProfileTag&#123; GENERATED_BODY() FProfileTag()&#123;&#125; void Begin(const FString&amp; Name) &#123; if(bInit) return; StaticBegin(Name); bInit = true; &#125; void End() &#123; if(bInit) &#123; StaticEnd(); bInit = false; &#125; &#125; ~FProfileTag() &#123; End(); &#125; static void StaticBegin(const FString&amp; Name) &#123;#if PLATFORM_IMPLEMENTS_BeginNamedEventStatic FPlatformMisc::BeginNamedEventStatic(FColor::Yellow, *Name);#else FPlatformMisc::BeginNamedEvent(FColor::Yellow, *Name);#endif &#125; static void StaticEnd() &#123; FPlatformMisc::EndNamedEvent(); &#125; bool bInit = false;&#125;; 暴露给 Lua 端： Lualib_ProfileTag.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &quot;UnLuaEx.h&quot;#include &quot;LuaCore.h&quot;#include &quot;ProfileTag.h&quot;static int32 FProfileTag_New(lua_State *L)&#123; int32 NumParams = lua_gettop(L); if (NumParams &lt; 1) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid parameters!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; void *Userdata = NewTypedUserdata(L, FProfileTag); FProfileTag *V = new(Userdata) FProfileTag(); if (NumParams &gt; 1) &#123; FString Name = ANSI_TO_TCHAR((char*)lua_tostring(L,2)); V-&gt;Begin(Name); &#125; return 1;&#125;static int32 FProfileTag_Begin(lua_State *L)&#123; int32 NumParams = lua_gettop(L); if (NumParams &lt; 1) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid parameters!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; FProfileTag *V = (FProfileTag*)GetCppInstanceFast(L, 1); if (!V) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid FProfileTag!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; FString Name = ANSI_TO_TCHAR((char*)lua_tostring(L,2)); V-&gt;Begin(Name); return 0;&#125;static int32 FProfileTag_End(lua_State *L)&#123; int32 NumParams = lua_gettop(L); if (NumParams &lt; 1) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid parameters!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; FProfileTag *V = (FProfileTag*)GetCppInstanceFast(L, 1); if (!V) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid FProfileTag!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; V-&gt;End(); return 0;&#125;static const luaL_Reg FProfileTagLib[] =&#123; &#123;&quot;__call&quot;,FProfileTag_New&#125;, &#123; &quot;Begin&quot;, FProfileTag_Begin &#125;, &#123; &quot;End&quot;, FProfileTag_End &#125;, &#123; nullptr, nullptr &#125;&#125;;BEGIN_EXPORT_REFLECTED_CLASS(FProfileTag) ADD_STATIC_FUNCTION_EX(&quot;StaticBegin&quot;,void,StaticBegin,const FString&amp;) ADD_STATIC_FUNCTION_EX(&quot;StaticEnd&quot;,void,StaticEnd) ADD_LIB(FProfileTagLib)END_EXPORT_CLASS()IMPLEMENT_EXPORTED_CLASS(FProfileTag) 然后即可在 Lua 中使用，并且能够在 Unreal Insight 中查看 Lua 端代码执行的消耗： 提供了三种使用方式： 123456789101112131415161718192021-- using 1function TimerMgr:UpdateTimer(DeltaTime) local profile_tag = UE4.FProfileTag(&quot;TimerMgr_UpdateTimer&quot;) -- dosomething... profile_tag:End()end-- using 2function TimerMgr:UpdateTimer(DeltaTime) local profile_tag = UE4.FProfileTag() profile_tag:Begin((&quot;TimerMgr_UpdateTimer&quot;)) -- dosomething... profile_tag:End()end-- using 3function TimerMgr:UpdateTimer(DeltaTime) UE4.FProfileTag.StaticBegin((&quot;TimerMgr_UpdateTimer&quot;)) -- dosomething... UE4.FProfileTag.StaticEnd()end 建议使用创建对象的方式使用，因为创建的对象，如果漏掉 End，在 lua 对象被销毁时也会调用 End，不会造成 Insight 的数据采集问题，使用 StaticBegin/StaticEnd 则一定要保证所有的代码分支能执行到 StaticEnd。 可以组合 lua 的 debug.getinfo(1).name 获取函数名字在 Insight 中显示： 12345function TimerMgr:UpdateTimer(DeltaTime) local profile_tag = UE4.FProfileTag(debug.getinfo(1).name) -- dosomething... profile_tag:End()end","tags":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"},{"name":"UnLua","slug":"UnLua","permalink":"https://ue5wiki.com/tags/UnLua/"},{"name":"lua","slug":"lua","permalink":"https://ue5wiki.com/tags/lua/"},{"name":"Unreal Insight","slug":"Unreal-Insight","permalink":"https://ue5wiki.com/tags/Unreal-Insight/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"StaticClass 实现分析","date":"2021-07-03T14:38:40.000Z","path":"wiki/40612/","text":"StaticClass 和 GetClass 的区别 StaticClass 是继承自 UObject 类的 static 函数，GetClass是 UObjectBase 的成员函数。 UObjectBase的 GetClass 获取到的 UClass 就是在 NewObject 时传递进来的 UClass.（代码在 UObject\\UObjectGlobal.cpp 中） 用途不一样，StaticClass是在获取具体类型的 UClass，而 GetClass 是获取到当前对象的真实 UClass。 StaticClass 是如何定义的 在 UE 中可以对 UObject 的类执行 UXXX::StaticClass 方法来获取到它的 UClass 对象。 但是它是如何定义的？首先要看我们声明对象的 MyActor.generated.h 中（以 AMyActor 类为例）： 1template&lt;&gt; MICROEND_423_API UClass* StaticClass&lt;class AMyActor&gt;(); 为 AMyActor 类特化了 StaticClass 的版本。再去 MyActor.gen.cpp 中找以下它的实现： 12345IMPLEMENT_CLASS(AMyActor, 31943282);template&lt;&gt; MICROEND_423_API UClass* StaticClass&lt;AMyActor&gt;()&#123; return AMyActor::StaticClass();&#125; 从这里看也就只是转发调用而已，但是关键点隐藏在其他地方。首先 AMyActor::StaticClass 类的定义是在 AMyActor.generated.h 的DECLARE_CLASS宏中（该宏定义在 ObjectMacros.h#L1524），返回的是GetPrivateStaticClass 的调用。 而 GetPrivateStaticClass 则在 AMyAcotr.gen.cpp 中的 IMPLEMENT_CLASS 实现。 1234567891011121314151617181920212223242526272829// Runtime/CoreUObject/Public/UObject/ObjectMacros.h// Register a class at startup time.#define IMPLEMENT_CLASS(TClass, TClassCrc) \\ static TClassCompiledInDefer&lt;TClass&gt; AutoInitialize###TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \\ UClass* TClass::GetPrivateStaticClass() \\ &#123; \\ static UClass* PrivateStaticClass = NULL; \\ if (!PrivateStaticClass) \\ &#123; \\ /* this could be handled with templates, but we want it external to avoid code bloat */ \\ GetPrivateStaticClassBody(\\ StaticPackage(), \\ (TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), \\ PrivateStaticClass, \\ StaticRegisterNatives###TClass, \\ sizeof(TClass), \\ alignof(TClass), \\ (EClassFlags)TClass::StaticClassFlags, \\ TClass::StaticClassCastFlags(), \\ TClass::StaticConfigName(), \\ (UClass::ClassConstructorType)InternalConstructor&lt;TClass&gt;, \\ (UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;TClass&gt;, \\ &amp;TClass::AddReferencedObjects, \\ &amp;TClass::Super::StaticClass, \\ &amp;TClass::WithinClass::StaticClass \\ ); \\ &#125; \\ return PrivateStaticClass; \\ &#125; 可以看到 GetPrivateStaticClass 其实就是通过这些元数据构造出 UClass 的。 如下面的代码： 1234567891011121314151617181920212223242526IMPLEMENT_CLASS(AMyActor, 3240835608);// 宏展开之后static TClassCompiledInDefer &lt; AMyActor &gt; AutoInitializeAMyActor(TEXT(&quot;AMyActor&quot;), sizeof(AMyActor), 3240835608);UClass * AMyActor::GetPrivateStaticClass() &#123; static UClass * PrivateStaticClass = NULL; if (!PrivateStaticClass) &#123; GetPrivateStaticClassBody( StaticPackage(), (TCHAR*)TEXT(&quot;AMyActor&quot;) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), PrivateStaticClass, StaticRegisterNativesAMyActor, sizeof(AMyActor), alignof(AMyActor), (EClassFlags) AMyActor::StaticClassFlags, AMyActor::StaticClassCastFlags(), AMyActor::StaticConfigName(), (UClass::ClassConstructorType) InternalConstructor&lt;AMyActor&gt;, (UClass::ClassVTableHelperCtorCallerType) InternalVTableHelperCtorCaller&lt;AMyActor&gt;, &amp;AMyActor::AddReferencedObjects, &amp;AMyActor::Super::StaticClass, &amp;AMyActor::WithinClass::StaticClass ); &#125; return PrivateStaticClass;&#125;; UClass 中的函数指针 上面代码中比较关键的点为： 12(UClass::ClassConstructorType)InternalConstructor&lt;TClass&gt;, \\(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;TClass&gt;, \\ 这两行是模板实例化出了两个函数并转换成函数指针传递给GetPrivateStaticClassBody： 123456789101112131415// class.h// Helper template to call the default constructor for a classtemplate&lt;class T&gt;void InternalConstructor(const FObjectInitializer&amp; X )&#123; T::__DefaultConstructor(X);&#125;// Helper template to call the vtable ctor caller for a classtemplate&lt;class T&gt;UObject* InternalVTableHelperCtorCaller(FVTableHelper&amp; Helper)&#123; return T::__VTableCtorCaller(Helper);&#125; 就是对 __DefaultConstructor 这样函数的的转发调用。 UClass::ClassConstructorType与 UClass::ClassVTableHelperCtorCallerType 这两个 typedef 为： 12typedef void (*ClassConstructorType) (const FObjectInitializer&amp;);typedef UObject* (*ClassVTableHelperCtorCallerType) (FVTableHelper&amp; Helper); GetPrivateStaticClassBody其中的 GetPrivateStaticClassBody 函数是定义在 Runtime\\CoreUObject\\Private\\UObject\\Class.cpp 中的。 原型为： 1234567891011121314151617void GetPrivateStaticClassBody( const TCHAR* PackageName, const TCHAR* Name, UClass*&amp; ReturnClass, void(*RegisterNativeFunc)(), uint32 InSize, uint32 InAlignment, EClassFlags InClassFlags, EClassCastFlags InClassCastFlags, const TCHAR* InConfigName, UClass::ClassConstructorType InClassConstructor, UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller, UClass::ClassAddReferencedObjectsType InClassAddReferencedObjects, UClass::StaticClassFunctionType InSuperClassFn, UClass::StaticClassFunctionType InWithinClassFn, bool bIsDynamic /*= false*/ ); 其中第四个参数是传入注册 Native 函数的函数指针，该函数在 MyActor.gen.cpp 中生成，也可以通过在 UFUNCTION 中添加 CustomThunk 函数来自己实现，UnLua 的覆写 C++ 函数就是基于替换 thunk 函数做的。 GetPrivateStaticClassBody中通过 (UClass*)GUObjectAllocator.AllocateUObject 来分配出 UClass 的内存，因为所有的 UClass 结构都一致。 12345678910// MyActor.gen.cppvoid AMyActor::StaticRegisterNativesAMyActor()&#123; UClass* Class = AMyActor::StaticClass(); static const FNameNativePtrPair Funcs[] = &#123; &#123; &quot;ReceiveBytes&quot;, &amp;AMyActor::execReceiveBytes &#125;, &#123; &quot;TESTFUNC&quot;, &amp;AMyActor::execTESTFUNC &#125;, &#125;; FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, ARRAY_COUNT(Funcs));&#125; 其实就是把 Native 的函数通过 AddNativeFunction 添加到 UClass 中： 12345678// Runtime\\CoreUObject\\Private\\UObject\\Class.cpp void FNativeFunctionRegistrar::RegisterFunctions(class UClass* Class, const FNameNativePtrPair* InArray, int32 NumFunctions)&#123; for (; NumFunctions; ++InArray, --NumFunctions) &#123; Class-&gt;AddNativeFunction(UTF8_TO_TCHAR(InArray-&gt;NameUTF8), InArray-&gt;Pointer); &#125;&#125;","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UClass","slug":"UClass","permalink":"https://ue5wiki.com/tags/UClass/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"编译系统 PCH 配置","date":"2021-07-03T14:30:01.000Z","path":"wiki/320933567/","text":"修改 PCH Buffer size默认是/Zm1000，就是 750M，如果编译时产生页面文件太小的错误： 1234c1xx: error C3859: Failed to create virtual memory for PCHc1xx: note: the system returned code 1455: 页面文件太小，无法完成操作。c1xx: note: please visit https://aka.ms/pch-help for more detailsc1xx: fatal error C1076: compiler limit: internal heap limit reached 可以在项目的 target.cs 里添加以下代码： 12345if(Target.Platform == UnrealTargetPlatform.Win64)&#123; bOverrideBuildEnvironment = true; AdditionalCompilerArguments = &quot;/Zm2000&quot;;&#125; /Zm (Specify Precompiled Header Memory Allocation Limit) 关闭 PCH在 TargetRules.cs 中有 bUsePCHFiles 和bUseSharedPCHs两个选项，可以控制项目是否开启 PCH： UnrealBuildTool\\Configuration\\TargetRules.cs1234567891011121314/// &lt;summary&gt;/// Whether PCH files should be used./// &lt;/summary&gt;[CommandLine(&quot;-NoPCH&quot;, Value = &quot;false&quot;)][XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bUsePCHFiles = true;/// &lt;summary&gt;/// Enables &quot;Shared PCHs&quot;, a feature which significantly speeds up compile times by attempting to/// share certain PCH files between modules that UBT detects is including those PCH&#x27;s header files./// &lt;/summary&gt;[CommandLine(&quot;-NoSharedPCH&quot;, Value = &quot;false&quot;)][XmlConfigFile(Category = &quot;BuildConfiguration&quot;)]public bool bUseSharedPCHs = true; 但是为了不改动代码，也可以通过 BuildConfiguration.xml 中的设置： 12C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\UnrealBuildTool\\BuildConfiguration.xmlF:\\EngineSource\\UE_4.26\\Engine\\Saved\\UnrealBuildTool\\BuildConfiguration.xml 这两个路径下的均可，在 Configuration 下添加以下配置： 12&lt;bUsePCHFiles&gt;true&lt;/bUsePCHFiles&gt;&lt;bUseSharedPCHs&gt;false&lt;/bUseSharedPCHs&gt;","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"修改 LaunchScreen 视频比例","date":"2021-07-01T14:31:35.000Z","path":"wiki/39224/","text":"当使用 Project Settings-Project-Movies 中来为游戏启动时播放视频时，默认情况下是锁定视频的长宽比的，在全面屏流行的现在，长宽比为 2.x 的比比皆是，锁定视频比例会导致两侧有黑边，所以希望视频能够拉伸来适应屏幕的大小。需要修改引擎的代码： Runtime/MoviePlayer/Private/DefaultGameMoviePlayer.cpp1234567891011121314151617181920FVector2D FDefaultGameMoviePlayer::GetMovieSize() const&#123; const FVector2D ScreenSize = MainWindow.Pin()-&gt;GetClientSizeInScreen(); // if (MovieStreamingIsPrepared() &amp;&amp; ActiveMovieStreamer.IsValid()) // &#123; // const float MovieAspectRatio = ActiveMovieStreamer-&gt;GetAspectRatio(); // const float ScreenAspectRatio = ScreenSize.X / ScreenSize.Y; // if (MovieAspectRatio &lt; ScreenAspectRatio) // &#123; // return FVector2D(ScreenSize.Y * MovieAspectRatio, ScreenSize.Y); // &#125; // else // &#123; // return FVector2D(ScreenSize.X, ScreenSize.X / MovieAspectRatio); // &#125; // &#125; // No movie, so simply return the size of the window return ScreenSize;&#125; 把 FDefaultGameMoviePlayer::GetMovieSize() 修改为上面的代码，其实就是把从视频获取长宽的代码去掉，强制使用窗口的大小。","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"Video","slug":"Video","permalink":"https://ue5wiki.com/tags/Video/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"}]},{"title":"使用 IDetailCustomization 自定义属性面板","date":"2021-07-01T14:29:57.000Z","path":"wiki/38904/","text":"使用 IDetailCustomization 的方式可以给 UE 的属性面板添加特殊的东西，比如按钮。 以给 F 的结构的 Detail 添加按钮的方法如下： 12345678910111213// ReleaseSettingsDetails.h#pragma once#include &quot;IDetailCustomization.h&quot;class FReleaseSettingsDetails : public IDetailCustomization&#123;public: /** Makes a new instance of this detail layout class for a specific detail view requesting it */ static TSharedRef&lt;IDetailCustomization&gt; MakeInstance(); /** IDetailCustomization interface */ virtual void CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder) override;&#125;; .cpp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ReleaseSettingsDetails.cpp#include &quot;CreatePatch/ReleaseSettingsDetails.h&quot;#include &quot;CreatePatch/FExportReleaseSettings.h&quot;// engine header#include &quot;DetailLayoutBuilder.h&quot;#include &quot;DetailCategoryBuilder.h&quot;#include &quot;DetailWidgetRow.h&quot;#include &quot;Widgets/Input/SButton.h&quot;#define LOCTEXT_NAMESPACE &quot;ReleaseSettingsDetails&quot;TSharedRef&lt;IDetailCustomization&gt; FReleaseSettingsDetails::MakeInstance()&#123; return MakeShareable(new FReleaseSettingsDetails());&#125;void FReleaseSettingsDetails::CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder)&#123; TArray&lt; TSharedPtr&lt;FStructOnScope&gt; &gt; StructBeingCustomized; DetailBuilder.GetStructsBeingCustomized(StructBeingCustomized); check(StructBeingCustomized.Num() == 1); FExportReleaseSettings* ReleaseSettingsIns = (FExportReleaseSettings*)StructBeingCustomized[0].Get()-&gt;GetStructMemory(); IDetailCategoryBuilder&amp; VersionCategory = DetailBuilder.EditCategory(&quot;Version&quot;,FText::GetEmpty(),ECategoryPriority::Default); VersionCategory.SetShowAdvanced(true); VersionCategory.AddCustomRow(LOCTEXT(&quot;ImportPakLists&quot;, &quot;Import Pak Lists&quot;),true) .ValueContent() [ SNew(SHorizontalBox) + SHorizontalBox::Slot() .Padding(0) .AutoWidth() [ SNew(SButton) .Text(LOCTEXT(&quot;Import&quot;, &quot;Import&quot;)) .ToolTipText(LOCTEXT(&quot;ImportPakLists_Tooltip&quot;, &quot;Import Pak Lists&quot;)) .IsEnabled_Lambda([this,ReleaseSettingsIns]()-&gt;bool &#123; return ReleaseSettingsIns-&gt;IsByPakList(); &#125;) .OnClicked_Lambda([this, ReleaseSettingsIns]() &#123; if (ReleaseSettingsIns) &#123; ReleaseSettingsIns-&gt;ImportPakLists(); &#125; return(FReply::Handled()); &#125;) ] + SHorizontalBox::Slot() .Padding(5,0,0,0) .AutoWidth() [ SNew(SButton) .Text(LOCTEXT(&quot;Clear&quot;, &quot;Clear&quot;)) .ToolTipText(LOCTEXT(&quot;ClearPakLists_Tooltip&quot;, &quot;Clear Pak Lists&quot;)) .IsEnabled_Lambda([this,ReleaseSettingsIns]()-&gt;bool &#123; return ReleaseSettingsIns-&gt;IsByPakList(); &#125;) .OnClicked_Lambda([this, ReleaseSettingsIns]() &#123; if (ReleaseSettingsIns) &#123; ReleaseSettingsIns-&gt;ClearImportedPakList(); &#125; return(FReply::Handled()); &#125;) ] ];&#125;#undef LOCTEXT_NAMESPACE 这里我们只是定义了一个 IDetailCustomization 的类，其中的 CustomizeDetails 是对 FExportReleaseSettings 添加的细节。 该类在创建 DetailView 时使用： 12345678910111213141516171819202122232425262728293031323334void SHotPatcherExportRelease::CreateExportFilterListView()&#123; // Create a property view FPropertyEditorModule&amp; EditModule = FModuleManager::Get().GetModuleChecked&lt;FPropertyEditorModule&gt;(&quot;PropertyEditor&quot;); FDetailsViewArgs DetailsViewArgs; &#123; DetailsViewArgs.bAllowSearch = true; DetailsViewArgs.bHideSelectionTip = true; DetailsViewArgs.bLockable = false; DetailsViewArgs.bSearchInitialKeyFocus = true; DetailsViewArgs.bUpdatesFromSelection = false; DetailsViewArgs.NotifyHook = nullptr; DetailsViewArgs.bShowOptions = true; DetailsViewArgs.bShowModifiedPropertiesOption = false; DetailsViewArgs.bShowScrollBar = false; DetailsViewArgs.bShowOptions = true; DetailsViewArgs.bUpdatesFromSelection= true; &#125; FStructureDetailsViewArgs StructureViewArgs; &#123; StructureViewArgs.bShowObjects = true; StructureViewArgs.bShowAssets = true; StructureViewArgs.bShowClasses = true; StructureViewArgs.bShowInterfaces = true; &#125; SettingsView = EditModule.CreateStructureDetailView(DetailsViewArgs, StructureViewArgs, nullptr); FStructOnScope* Struct = new FStructOnScope(FExportReleaseSettings::StaticStruct(), (uint8*)ExportReleaseSettings.Get()); SettingsView-&gt;GetOnFinishedChangingPropertiesDelegate().AddRaw(ExportReleaseSettings.Get(),&amp;FExportReleaseSettings::OnFinishedChangingProperties); SettingsView-&gt;GetDetailsView()-&gt;RegisterInstancedCustomPropertyLayout(FExportReleaseSettings::StaticStruct(),FOnGetDetailCustomizationInstance::CreateStatic(&amp;FReleaseSettingsDetails::MakeInstance)); SettingsView-&gt;SetStructureData(MakeShareable(Struct));&#125; 使用 RegisterInstancedCustomPropertyLayout 把所写的 FReleaseSettingsDetails 实例注册到 DetailView 中。注意调用时机要在 SetStructureData 之前。然后就可以看到添加的两个按钮了：","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"IDetailCustomization","slug":"IDetailCustomization","permalink":"https://ue5wiki.com/tags/IDetailCustomization/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}]},{"title":"监听资源创建 / 操作事件","date":"2021-07-01T14:26:27.000Z","path":"wiki/38218/","text":"资源创建 在 Editor 中创建资源，并没有直接保存到磁盘上，所以要监听OnInMemoryAssetCreated： 123FAssetRegistryModule&amp; AssetRegistryModule = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;( TEXT(&quot;AssetRegistry&quot;)); AssetRegistryModule.Get().OnInMemoryAssetCreated().AddRaw(this, &amp;FTestEditorModule::OnInMemoryAssetCreated); 回调过来的就是一个UObject*，实际上是一个UBlueprint*： 12345678void FTestEditorModule::OnInMemoryAssetCreated(UObject* Object)&#123; if (nullptr == Object) return; UBlueprint* Blueprint = Cast&lt;UBlueprint&gt;(Object); if (nullptr == Blueprint) return; // ...&#125; 可以实现监听 uasset 创建事件，对该 uasset 执行一些操作（如默认添加接口等）。 拿到 UBlueprint 后就可以通过 FBlueprintEditorUtils 等辅助类来实现对蓝图资源的操作了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool FTestEditor::AddInterface(UBlueprint* Blueprint)&#123; if (nullptr == Blueprint) return false; UClass* Class = Blueprint ? *Blueprint-&gt;GeneratedClass : Blueprint ? Blueprint-&gt;GetClass() : NULL; if (nullptr == Class) return false; if (!Class-&gt;IsChildOf&lt;UUserWidget&gt;()) return false; static UClass* InterfaceClass = UUnLuaInterface::StaticClass(); UFunction* Func = FBlueprintEditorUtils::GetInterfaceFunction(Blueprint, FName(&quot;GetModuleName&quot;)); if (nullptr == Func) &#123; FBlueprintEditorUtils::ImplementNewInterface(Blueprint, InterfaceClass-&gt;GetFName()); &#125; Func = FBlueprintEditorUtils::GetInterfaceFunction(Blueprint, FName(&quot;GetModuleName&quot;)); if (nullptr == Func) return false; auto ImplementedInterfaces = Blueprint-&gt;ImplementedInterfaces; if (ImplementedInterfaces.Num() &lt;= 0) return false; auto InterfacesDesc = ImplementedInterfaces[0]; auto Graphs = InterfacesDesc.Graphs; if (Graphs.Num() &lt;= 0) return false; auto Graph = Graphs[0]; //UEdGraph if (nullptr == Graph) return false; auto Nodes = Graph-&gt;Nodes; if (Nodes.Num() &lt;= 0) return false; auto Node = Nodes[1]; //UEdGraphNode if (nullptr == Node) return false; auto Pins = Node-&gt;Pins; if (Pins.Num() &lt;= 0) return false; auto Pin = Pins[1]; //UEdGraphPin if (nullptr == Pin) return false; FString moduleName; UnLuaExtensionUtils::GetLuaModuleName(Class-&gt;GetName(), Class-&gt;GetPathName(), moduleName); Pin-&gt;DefaultValue = moduleName; return true;&#125; 监听资源操作事件 可以通过 IAssetRegistry 获取到下列事件的 delegate 并监听： 1234567891011121314151617181920212223DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FAssetAddedEvent, FAssetAddedEvent);virtual FAssetAddedEvent&amp; OnAssetAdded() override &#123; return AssetAddedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FAssetRemovedEvent, FAssetRemovedEvent);virtual FAssetRemovedEvent&amp; OnAssetRemoved() override &#123; return AssetRemovedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FAssetRenamedEvent, FAssetRenamedEvent);virtual FAssetRenamedEvent&amp; OnAssetRenamed() override &#123; return AssetRenamedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FAssetUpdatedEvent, FAssetUpdatedEvent);virtual FAssetUpdatedEvent&amp; OnAssetUpdated() override &#123; return AssetUpdatedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FInMemoryAssetCreatedEvent, FInMemoryAssetCreatedEvent);virtual FInMemoryAssetCreatedEvent&amp; OnInMemoryAssetCreated() override &#123; return InMemoryAssetCreatedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FInMemoryAssetDeletedEvent, FInMemoryAssetDeletedEvent);virtual FInMemoryAssetDeletedEvent&amp; OnInMemoryAssetDeleted() override &#123; return InMemoryAssetDeletedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FFilesLoadedEvent, FFilesLoadedEvent);virtual FFilesLoadedEvent&amp; OnFilesLoaded() override &#123; return FileLoadedEvent; &#125;DECLARE_DERIVED_EVENT(UAssetRegistryImpl, IAssetRegistry::FFileLoadProgressUpdatedEvent, FFileLoadProgressUpdatedEvent);virtual FFileLoadProgressUpdatedEvent&amp; OnFileLoadProgressUpdated() override &#123; return FileLoadProgressUpdatedEvent; &#125; 监听资源保存的事件12345678void PackageSaved(const FString&amp; PacStr,UObject* PackageSaved)&#123; UE_LOG(LogTemp,Log,TEXT(&quot;Package %s Saved.&quot;),*PacStr);&#125;void FEmptyProjectModule::StartupModule()&#123; UPackage::PackageSavedEvent.AddStatic(&amp;PackageSaved);&#125;","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"Asset","slug":"Asset","permalink":"https://ue5wiki.com/tags/Asset/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}]},{"title":"EpicVerse：UE5 新的脚本语言","date":"2021-06-30T15:30:31.000Z","path":"wiki/21436/","text":"UE5 可能的脚本语言简介 在 Epic 的 Inside Unreal:2020 Year In Review 中介绍了一个全新的脚本语言，有可能被称作Epic Verse。 reddit 上关于该脚本语言的讨论：Epic showed off their new Unreal Verse scripting language that will probably end up in UE5 UE4 的蓝图极大地降低了非专业开发者的上手门槛，图形化编程的方式从线性角度很容易理解，但是也会造成混乱。上了一定规模的项目还是需要文本化的脚本语言的，主要解决以下几个问题： 文本化方便协同开发，不会造成资源的冲突（BP 是资源） 方便直观地进行 diff 方便迁移引擎版本，而没有资源的升 / 降级问题 而且我认为，脚本语言最好是强类型语言，写惯了 C++ 这种静态强类型语言，其实对 Lua 这种弱类型语言还是挺不习惯的，之前有一种语言叫做 AngelScript 的静态强类型脚本语言，和 C++ 非常像，被第三方集成到了 UE 中，但是目前只支持 PC 和主机平台，不支持移动端。 对于 UE4 中目前在手游开发中主流的脚本语言支持，为腾讯开源的 UnLua 和SLua两款插件，都是以反射形式集成的，有一些实现上的缺点和社区支持不够，希望 Epic 能出一款官方支持的脚本工具，原本以为 Python 有比较大的可能，因为 UE 在编辑器下对 Python 的支持已经挺好了，而且 Python 有比较大的用户群体，上手难度也不高。 如果引入一门新的脚本语言，在 UE 中可以使用的编程方式： C++ 蓝图 Python（编辑器） Epic Verse 处理不同的需求有不同的语言，有些过于复杂了。 目前还不知道 UE 出的这个新脚本具体表现和语法形式怎么样，其实新增一门语言大大增加了用户的学习成本，也不知道 UE 是如何设计 BP 和新脚本语言的关联的，等最新的消息再看。 两年前 Tim 在 Reddit 上有一些相关的回复和讨论：It seems people at Epic are considering adding some intermediate script language between C++ and Blueprints Epic Verse 语法介绍 认真看了一下 Inside Unreal:2020 Year In Review 里展示的 Epic Verse 代码，看起来新的脚本语言很像 pascal 和Python的结合体，而且还有点 ruby 味，Verse 具有静态类型，某些语法与 SkookumScript 非常像。 2019 年初 Epic 收购了Agog Labs (and SkookumScript)，应该是要来打造 UE5 的脚本语言，所以 UE5 的语法结构和 SkookumScript 比较像应该是比较合理的，根据视频里的展示情况，我认为 UE5 的脚本语言应该就是 Agog Labs 做的。 但是这场展示中并没有展示该脚本语言如何与引擎进行交互，也没有展示引擎中的符号信息，与 C++ 的交互方式目前只能观望。目前介绍一下视频里有展示的语言内容。 视频展示的代码如下： 手敲了遍文本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# This is a BoxFight prototype game.BoxFight=class(FortGameScriptBase): GameStarted^: bool=false GameEnded^: bool=false CurrentRound^: int=0 RunGame() # Pause until all players in the matchmaking session # have connected to the server. MaitForPlayersToJoin() # Start the game. GameStarted := true for(i = 1..NumberofRounds): # Perform round setup. currentRound := i EnableBarriers() SetBuildingDisallowed() if(!SetupPlayersAndSpawnPoints()?): # We hit an error and are unable to start the round. ShutdownGame() return else: # Begin the round start countdown. Players.PutAllInStasisAllowEmotes() Players.SetAllInvulnerable(true) SimpleUI.ShowcountDown(7) Wait(2) # Enable building at the end of the countdown. SimpleUI.ShowMessage(&quot;Building Enabled&quot;) SetBuildingAllowed() Players.RemoveAllFromStasis() Players.SetAllInRound() # Wait for the start countdown to complete. Wait(4.7) SimpleUI.HideMessage() # Begin combat and initialize the storm. Players.SetAllInvulnerable(false) DisableBarriers() # Hide the round start after it&#x27;s had a second to display. Wait(1.3) simpleUI.HideCountDown() Storm.Startstorm(60.0, CurrentRound^) #Wait for the round end conditions if(IsSoloGame()?): race: #Setup Solo specific end conditions for testing WaitForZeroRemaining() WaitForRoundTimeout() else: race: # Setup Solo specific end conditions for testing WaitForOneRemaining() WaitForZeroRemaining() WaitForRoundTimeout() # Handle round complete. # Give everyone a quick completion message. SimpleUI.ShowMessage(&quot;Round Complete&quot;) Wait(2.0) # Disable combat and the storm. SimpleUI.HideMessage() Players.PutAllInstasisAllowEmotes() Players.SetAllInvulnerable(true) SetBuildingDisallowed() Storm.stopstorm() Players.SetAllEndRound() # Display the scoreboard. class 定义 首先是 class 定义（暂且标记为继承形式）： 1BoxFight = class(FortGameScriptBase): 变量声明 具有静态类型，并且无需; 12GameStarted^: bool = falseCurrentRound^: int = 0 变量赋值 类似与 pascal 语言（SkookumScript 也是如此） 1GameStarted := 1 代码块 类似于 Python 的缩进，需要使用 : 标识： 12345678if(!SetupPlayerAndSpwanPoints()?): ShutdownGame() returnelse: Players.PutAllInStasisAllowEmotes() Players.SetAllInvulnerable(true) SimpleUI.ShowcountDown(7) Wait(2) ?在 SkookumScript 是谓词，只能够应用到 boolean 的对象。在 SkookumScript 的文档中介绍是可选的，用于标识返回值为布尔类型： Optional ‘?’ used as convention to indicate predicate variable or method of return type Boolean (true or false). 循环语句 整型迭代： 1for(i = 1..NumberOfRounds): 这个形式有点类似于 ruby 语言里的 for： 1for i in 0..100 do 函数调用 使用 . 来调用成员函数： 1Players.SetAllInRound() 具有类似协程的形式123456789if(IsSoloGame()?): race: WaitForZeroRemaining() WairForRoundTimeout()else: race: WaitForOntRemaining() WaitForZeroRemaining() WaitForRoundTimeout() 这里代码的含义上类似于 UE 的行为树中的 Sequences 的节点，只有当它的所有子节点都执行成功（完毕）了，它才执行成功。 这门脚本语言看起来更像是以 SkookumScript 为基础，糅合了数种编程语言的集合体，目前展示的代码还太少，不好说具体的上手表现怎么样，持续关注。","tags":[{"name":"EpicVerse","slug":"EpicVerse","permalink":"https://ue5wiki.com/tags/EpicVerse/"},{"name":"Script Language","slug":"Script-Language","permalink":"https://ue5wiki.com/tags/Script-Language/"},{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/tags/UE5/"}],"categories":[{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/categories/UE5/"}]},{"title":"Oodle 压缩算法","date":"2021-06-30T15:28:31.000Z","path":"wiki/21435/","text":"和我当初预想的一样，2021.04.01 的 Feeds：Epic 把 Oodle 集成到 UE4.27 和 UE5 中了。 Oodle now free to use in Unreal Engine via GitHub RAD Game Tools’ Oodle—cross-platform data compression solutions 他们会提供四种 Oodle 系列的压缩算法： Oodle Data Compression：最快和最高压缩比的压缩算法，可以用于数据压缩、打包压缩等。 Oodle Texture：用来压缩 Texture，可以压缩 BC1-BC7Texture，能够减少 50% 的 Texture 大小（官方数据）。 Oodle Network Compression：压缩 TCP/UDP 数据，降低与服务器传输占用的带宽。 Oodle Lossless Image Compression：无损图像压缩算法，比 png 小很多且具有非常高的解压速度。 目前（2021.04.05）可以拉取 UE 的 master 分支，下载依赖之后在以下目录下： 12E:\\UnrealEngine\\Source\\UnrealEngine\\Engine\\Plugins\\CompressionE:\\UnrealEngine\\Source\\UnrealEngine\\Engine\\Plugins\\Developer\\TextureFormatOodle 具有 OodleData 和OodleNetwork、TextureFormatOodle三个插件，注意必须要下载依赖。不然代码中只有 .h 接口，并没有各个平台的链接库。 比较遗憾的是在更早的引擎版本中不支持，我从 UE 的开发分支把这部分代码抽离了出来，放到了单独的仓库中：oodle-compression，看了代码并没有依赖新版本引擎相关的东西，但是直接在低版本引擎启用会有编译错误，我已修复。插件中的实现也是通过 SDK 把 Oodle 添加到了 UE 的 Compression 的 Modular Feature 中，同样可以按照我之前这篇文章的介绍中的方法使用：ModularFeature：为 UE4 集成 ZSTD 压缩算法。 当使用 IOS 远程构建时还需要加上 Sdks 的 Rsync 的上传规则： Build/Rsync/RsyncProject.txt1234+ /Plugins/Compression/oodle-compression/OodleData/Sdks/2.9.0/include/**+ /Plugins/Compression/oodle-compression/OodleData/Sdks/2.9.0/lib/IOS/**+ /Plugins/Compression/oodle-compression/OodleNetwork/Sdks/2.9.0/include/**+ /Plugins/Compression/oodle-compression/OodleNetwork/Sdks/2.9.0/lib/IOS/** 注意：如果默认打包时想要启用 Oodle 需要将插件放入 Engine/Plugins/Runtime 下，并给 Oodle 插件的 uplugin 添加 &quot;SupportedPrograms&quot; : [&quot;UnrealPak&quot;]，在 UnrealPak 启动时会加载Oodle 插件。 通过在项目设置中配置 Oodle，会传递给 UnrealPak 命令行参数 -compressionformats=Oodle 来指定使用 Oodle，以及 -compresslevel=fast 来指定压缩级别。 12345678910111213141516171819UATHelper: Packaging (iOS): Output from: &quot;D:\\UE4\\Blank\\Blank.uproject&quot; &quot;D:\\UE4\\Blank\\Saved\\StagedBuilds\\IOS\\cookeddata\\Blank\\content\\paks\\Blank-ios.pak&quot; -create=C:\\build_agent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\PakList_Blank-ios.txt -cryptokeys=&quot;D:\\UE4\\Blank\\Saved\\Cooked\\IOS\\Blank\\Metadata\\Crypto.json&quot; -order=&quot;D:\\UE4\\Blank\\Build\\IOS\\FileOpenOrder\\CookerOpenOrder.log&quot; -platform=IOS -AlignForMemoryMapping=16384 -compressionformats=Oodle,Zlib -multiprocess -abslog=C:\\build_agent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\UnrealPak-Blank-ios-2021.07.13-18.43.29.txt -compressmethod=Kraken -compresslevel=fastUATHelper: Packaging (iOS): OodleCompression: Display: Oodle v2.9.0 initializing with method=Kraken, level=3=FastUATHelper: Packaging (iOS): LogPakFile: Display: Parsing crypto keys from a crypto key cache fileUATHelper: Packaging (iOS): LogPakFile: Display: Loading response file C:\\build_agent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\PakList_Blank-ios.txtUATHelper: Packaging (iOS): LogPakFile: Display: Added 2255 entries to add to pak file.UATHelper: Packaging (iOS): LogPakFile: Display: Loading pak order file D:\\UE4\\Blank\\Build\\IOS\\FileOpenOrder\\CookerOpenOrder.log...UATHelper: Packaging (iOS): LogPakFile: Display: Finished loading pak order file D:\\UE4\\Blank\\Build\\IOS\\FileOpenOrder\\CookerOpenOrder.log.UATHelper: Packaging (iOS): LogPakFile: Display: Collecting files to add to pak file...UATHelper: Packaging (iOS): LogPakFile: Display: Collected 2255 files in 0.01s.UATHelper: Packaging (iOS): LogPakFile: Display: Creating pak D:\\UE4\\Blank\\Saved\\StagedBuilds\\IOS\\cookeddata\\Blank\\content\\paks\\Blank-ios.pak.UATHelper: Packaging (iOS): LogPakFile: Display: ENABLING pak file index freezingUATHelper: Packaging (iOS): LogPakFile: Display: Added 2255 files, 123452947 bytes total, time 2.17s.UATHelper: Packaging (iOS): LogPakFile: Display: Compression summary: 43.30% of original size. Compressed Size 69209450 bytes, Original Size 159833025 bytes.UATHelper: Packaging (iOS): LogPakFile: Display: Used compression formats (in priority order) &#x27;Oodle, Zlib, &#x27;UATHelper: Packaging (iOS): LogPakFile: Display: Encryption - DISABLEDUATHelper: Packaging (iOS): LogPakFile: Display: Unreal pak executed in 2.233311 secondsUATHelper: Packaging (iOS): UnrealPak terminated with exit code 0 经过测试，一个使用 zlib 压缩之后有 295M 的 pak 文件使用 Oodle 压缩降低到了 282M，但是 Oodle 的解压速度完胜 zlib。Oodle 的压缩性能在 RAD 网站上有对比数据：Oodle Compression 其他的对比数据： PS4 Battle : LZ4 vs LZSSE vs Oodle 压缩算法的选择就是要在压缩率 / 解压速度上来做一个权衡，就是压缩率最低的 Selkie 也比 zlib 要强一点点，但是 decompress 速度比 zlib 高了十几倍，对于游戏而言解压速度非常直观地影响到游戏性能，这应该也是 UE 选择收购 RAD 的原因吧。 其他资料： How Oodle Kraken and Oodle Texture supercharge the IO system of the Sony PS5 cbloom rants Oodle Texture compression PS5 IO System to Be ‘Supercharged’ by Oodle Texture, Bandwidth Goes Up to 17.38GB/s","tags":[{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/tags/UE5/"},{"name":"Oodle","slug":"Oodle","permalink":"https://ue5wiki.com/tags/Oodle/"}],"categories":[{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/categories/UE5/"}]},{"title":"Profiling for UE","date":"2021-06-29T22:32:01.000Z","path":"wiki/24066/","text":"Editor在 UE4Editor.exe 启动项目时添加 -Trace=CPU -tracehost=127.0.0.1 参数： 1UE4Editor.exe Client.uproject -Trace=CPU -tracehost=127.0.0.1 Insight 中就会自动捕获： Unreal Insights 实时分析 Oculus Quest Performance Tools in Unreal Engine Unreal Insights Overview 上一节提到了使用 SessionFrontEnd 实时分析 Android 的方法，在实际的测试当中发现不太稳定，会造成游戏的 Crash，UE 在新的引擎版本中也提供了新的性能分析工具 Unreal Insights，可以更方便和直观地进行 Profile。文档： Unreal Insights Unreal Insights Reference 同样也需要端口映射，需要把 PC 的 1980 端口映射到设备上： 1adb reverse tcp:1980 tcp:1980 然后需要给 Android 设备添加启动命令： 1../../../FGame/FGame.uproject -Messaging -SessionOwner=&quot;lipengzha&quot; -SessionName=&quot;Launch On Android Device&quot; -iterative -tracehost=127.0.0.1 -Trace=CPU 在 PC 上开启 Unreal Insights，在手机上启动游戏，即可实时捕获： Unreal Insights 也可以实时捕获 PIE 的数据，需要在 Editor 启动时添加 -trace 参数： 1UE4Editor.exe PROJECT_NAME.uproject -trace=counters,cpu,frame,bookmark,gpu 在启动游戏后在 Unreal Insights 里通过 New Connection 监听 127.0.0.1 即可。 SessionFrontEnd 实时分析 有几个条件： 需要 USB 连接 PC 和手机 需要安装 adb 首先需要映射端口，因为 SessionFrontEnd 是通过监听端口的方式来与游戏内通信的，手机和 PC 并不在同一个网段，所以需要以 adb 的形式把 PC 的监听端口转发给手机的端口。 SessionFrontEnd 的监听端口可以通过对 UE4Editor.exe 的端口分析获取： 123456789C:\\Users\\lipengzha&gt;netstat -ano | findstr &quot;231096&quot; TCP 0.0.0.0:1985 0.0.0.0:0 LISTENING 231096 TCP 0.0.0.0:3961 0.0.0.0:0 LISTENING 231096 TCP 0.0.0.0:3963 0.0.0.0:0 LISTENING 231096 TCP 127.0.0.1:4014 127.0.0.1:12639 ESTABLISHED 231096 TCP 127.0.0.1:4199 127.0.0.1:12639 ESTABLISHED 231096 UDP 0.0.0.0:6666 *:* 231096 UDP 0.0.0.0:24024 *:* 231096 UDP 0.0.0.0:58101 *:* 231096 需要把 PC 的 1985 端口映射到 Android 的 1985 端口，这样手机上 APP 启动时，连接 0.0.0.0 的1985端口就可以连接到 PC 上的端口。 通过 adb 命令来执行： 1adb reverse tcp:1985 tcp:1985 然后需要给手机上 App 指定启动参数： 1../../../FGame/FGame.uproject -Messaging -SessionOwner=&quot;lipengzha&quot; -SessionName=&quot;Launch On Android Device&quot; 把这些文本保存为 UE4Commandline.txt 文件，放到项目的数据目录下即可，具体路径为： 1/sdcard/UE4Game/PROJECT_NAME/ 之后直接启动 App，在 PC 上的 SessionFrontEnd 中就可以看到设备的数据了。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"},{"name":"Unreal Insight","slug":"Unreal-Insight","permalink":"https://ue5wiki.com/tags/Unreal-Insight/"},{"name":"UnrealFrontEnd","slug":"UnrealFrontEnd","permalink":"https://ue5wiki.com/tags/UnrealFrontEnd/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"UE 工具集：我的开源项目介绍","date":"2021-06-29T22:32:01.000Z","path":"wiki/c735df6d/","text":"工欲善其事必先利其器，本文主要介绍在我在使用 UE 的过程中开发的一些开源的工具和插件，能够方便地在项目中使用，提高开发效率。之前简单罗列在 资源 页面里，今天做一个详细的整理，对各个工具、插件做一些介绍。 Tools本节主要介绍我开发和部署的 UE 的外部工具，可以方便开发流程。 UE4PROGRAMue4program是一个命令行工具，用于方便地创建 UE 的 Standalone Application 的工具（官方没有提供它的创建方法），可以使用 UE 来写一些独立程序而不依赖引擎启动的流程，也可以方便地测试引擎的功能而不用创建一个游戏项目。 详细介绍见我之前的文章：Create A Standalone Application in UE4 UE4LauncherUE4Launcher是一个使用 UE 的 Standalone Application 的方式开发的独立程序，用来方便地切换引擎、启动项目、添加启动参数、保存配置，使用命令行通过配置启动，支持关联 uproject 文件。 主界面： uproject 的文件关联： 详细的用法和介绍可以看Create A Standalone Application in UE4 UE4_API_FOR_DASHUE4_API_FOR_DASH是我制作的 UE4 API 的 Dash 文档源。可以方便地使用 Dash 或者 Zeal 来查询 UE 的 C++ API，目前最新的文档源是生成 UE4.25.3 引擎版本，如果后续有新的引擎版本发布，我也会不定期更新。 文档源的下载和更新，见我之前的文章：抓取 UE4 API 并生成带索引的 Dash 文档 UE4 Console HelpUE 提供了 Console 命令的帮助文档，我把它部署到了公网，可以方便在线查看和搜索。 地址：consolehelp.imzlp.com UE4 Wiki ArchiveUE4 的官方 wiki 经历了很大改版，之前老 Wiki 中的内容都没了，很可惜，老 wiki 中有很多很棒的内容，所以我部署了 UE4 老 wiki 的站点，作为备份。地址：ue4wiki.imzlp.com Plugins本节介绍我业余开发的 UE 中的一些插件，简单介绍一下它们的功能和解决了什么问题。 HotPatcherHotPatcher是我开发的用于 UE4 热更新资源的打包工具，用来管理热更新版本，进行资源的差异分析并打出 pak，支持全平台。 详细的介绍见我之前的文章：UE4 资源热更打包工具 HotPatcher，Github 地址：hxhb/HotPatcher以及 UE4 热更新的思路：UE4 热更新：需求分析与方案设计 ExportNavue4-export-nav-data是我开发的用于从 UE4 导出 Recast Navigation 寻路数据的插件，可以用在非 DS 架构的服务器中用作地图同步以及寻路计算使用。该插件上架了 虚幻商城 ，但是依然在 Github 上开源。 详细的文档介绍见我之前的文章：Export Recast Navigation Data from UE4 另外，针对外部服务器使用导出的 Recast 数据，我也抽出了 UE 所使用的 recast-detour 版本，可以用在外部服务器的寻路：ue4-recast-detour ue4-zstdue4-zstd是我集成到 UE 的 ZSTD 压缩算法，使用 ModularFeature 的方式集成，可以替换引擎中默认的 ZLib 算法，也可以配合 HotPatcher 使用，替换 pak 的压缩算法。详细的文档见我之前的文章：ModularFeature：为 UE4 集成 ZSTD 压缩算法 ue4-dtkitue4-dtkit是我基于 HTTP 封装了一个下载库，支持 边下边存 / 边下边计算 MD5，这样当文件下载完也已经存到本地了，并且还计算出了 MD5 值可以供校验用。还支持暂停 / 继续 / 分片下载，自己改一下也可以改成断点续传的。开源在 Github 上：ue4-dtkit，支持 IOS/Android/Windows/Mac 四个平台。在这个插件中我还封装了一个 MD5Wrapper.hpp 可以用来在其他地方的 MD5 计算，使用的是 OpenSSL 的库。 PlatformUtilsPlatformUtils是一个跨平台插件，用于在四个平台（Win/Mac/Android/iOS）获取硬件信息，主要是用作展示 UE 的跨平台写法，如何集成 iOS 的 framework 并使用、Android 添加 Java 代码、使用 JNI 调用等特定平台的原生操作。 unreal-pbunlua-pb是集成 lua-ptorobuf 到UnLua的 Module，之前没有 UnLua 的版本，我做了集成。 debugable-unluadebugable-unlua是 Fork 自 Tencent 的 UnLua，我在其基础上修改，基础版本为106fa9c，目的是打造一个开箱即用的 UnLua， 可调试 和一些基础 lua 库、编辑器优化。 ue4-git-controllerue4-git-controller可以在 UE 中操作 Git 仓库，可以用来拓展 UE 的版本控制功能。 ue4-protobufue4-protobuf是以源码方式集成的 protobuf，版本为 3.5.1。 ue4-jwtue4-jwt在 UE 中集成 JWT 的插件，可以用来跨域认证。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"插件","slug":"插件","permalink":"https://ue5wiki.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"开源","slug":"开源","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E6%BA%90/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Setup 多线程数加速下载","date":"2021-06-29T22:32:01.000Z","path":"wiki/67d284ec/","text":"在下载 UE4 的源码之后，需要先执行 Setup.bat 下载依赖才可以开始生成 VS 项目文件以及编译。但是国内的网络环境又极差，默认的 Setup.bat 是没有指定线程数量的（Setup.bat只给 GitDenpencies 传递了 --prompt 参数）。 123456789101112131415161718192021222324252627282930313233343536373839@echo offsetlocalpushd %~dp0rem Figure out if we should append the -prompt argumentset PROMPT_ARGUMENT=for %%P in (%*) do if /I &quot;%%P&quot; == &quot;--prompt&quot; goto no_prompt_argumentfor %%P in (%*) do if /I &quot;%%P&quot; == &quot;--force&quot; goto no_prompt_argumentset PROMPT_ARGUMENT=--prompt:no_prompt_argumentrem Sync the dependencies....\\Engine\\Binaries\\DotNET\\GitDependencies.exe %PROMPT_ARGUMENT% %*if ERRORLEVEL 1 goto errorrem Setup the git hooks...if not exist .git\\hooks goto no_git_hooks_directoryecho Registering git hooks...echo #!/bin/sh &gt;.git\\hooks\\post-checkoutecho Engine/Binaries/DotNET/GitDependencies.exe %* &gt;&gt;.git\\hooks\\post-checkoutecho #!/bin/sh &gt;.git\\hooks\\post-mergeecho Engine/Binaries/DotNET/GitDependencies.exe %* &gt;&gt;.git\\hooks\\post-merge:no_git_hooks_directoryrem Install prerequisites...echo Installing prerequisites...start /wait Engine\\Extras\\Redist\\en-us\\UE4PrereqSetup_x64.exe /quietrem Register the engine installation...if not exist .\\Engine\\Binaries\\Win64\\UnrealVersionSelector-Win64-Shipping.exe goto :no_unreal_version_selector.\\Engine\\Binaries\\Win64\\UnrealVersionSelector-Win64-Shipping.exe /register:no_unreal_version_selectorrem Done!goto :EOFrem Error happened. Wait for a keypress before quitting.:errorpause GitDependencies.exe支持的参数为： 12345678910111213141516171819202122232425Usage: GitDependencies [options]Options: --all Sync all folders --include=&lt;X&gt; Include binaries in folders called &lt;X&gt; --exclude=&lt;X&gt; Exclude binaries in folders called &lt;X&gt; --prompt Prompt before overwriting modified files --force Always overwrite modified files --root=&lt;PATH&gt; Set the repository directory to be sync --threads=&lt;N&gt; Use N threads when downloading new files --dry-run Print a list of outdated files and exit --max-retries Override maximum number of retries per file --proxy=&lt;user:password@url&gt; Sets the HTTP proxy address and credentials --cache=&lt;PATH&gt; Specifies a custom path for the download cache --cache-size-multiplier=&lt;N&gt; Cache size as multiplier of current download --cache-days=&lt;N&gt; Number of days to keep entries in the cache --no-cache Disable caching of downloaded filesDetected settings: Excluded folders: Mac, Android, Linux Proxy server: none Download cache: E:\\UnrealEngine\\EngineSource\\UE_4.21_Source\\.git\\ue4-gitdepsDefault arguments can be set through the UE4_GITDEPS_ARGS environment variable. 所以我们可以将 Setup.bat 中的变量 PROMPT_ARGUMENT 增加上指定的线程数即可（N 替换为数字）： 1set PROMPT_ARGUMENT=--prompt --threads=N 我一般开 8 个线程，基本可以跑 2-3M/s…","tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"categories":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]},{"title":"Unreal Networking Guide","date":"2021-06-29T22:32:01.000Z","path":"wiki/eac348f5/","text":"","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"}]},{"title":"Unreal Engine 4 Network Compendium","date":"2021-06-29T22:32:01.000Z","path":"wiki/2e32e862/","text":"","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"}]},{"title":"PENDING WIKI","date":"2021-06-29T21:40:29.000Z","path":"wiki/3/","text":"等待发布的 Wiki 页面，基于 Gist 可以方便地在线编辑内容。 UE 开发的问题笔记和资料辑录 UE 和 VR 开发技术笔记 UE 工具链配置与开发技巧 我的 Unreal Engine 技术文章归档","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://ue5wiki.com/tags/Wiki/"}],"categories":[]},{"title":"Wiki 内容编写格式与规则","date":"2021-06-29T21:35:01.000Z","path":"wiki/2/","text":"重要：本站不允许非作者的全文转载，每篇内容版权归作者所有，欢迎外部作者将内容投稿到本站。 本站支持两种投稿方式： 内容投稿，直接把内容创建一个 md 文件发布到本站，能够进行全文搜索、贡献统计。 链接投稿，能够把一篇外部链接的内容发布到本站，可以进行分类和添加标签，点击会跳转到指定的链接。 方式均为在 commit_wiki/issues 创建一个 issue，我提供了 链接投稿 和内容投稿 的两个模板，按照格式提交即可。 链接投稿 收录外部平台的文章，需要创建一个外部平台文章的 issues: 并按照以下格式编写 issue，提交即可。 12345678910文章名: 这是一篇新文章 作者: author文章链接: https://ue5wiki.com/发表时间: 2022/10/10分类 (/ 分隔): Category1/Cateogry2 标签(/ 分隔): Tag1/Tag2/Tag3GithubID: hxhbEmail: Website: https://ue5wiki.com/AvatarLink: 同样能够被本站的分类、标签中查看、以及搜索（仅限标题），点击链接会自动跳转到所指定的链接页面。 发布之后就会在分类和标签页面显示： 内容投稿 提交新的 Wiki 词条需要在 UnrealCommunity/commit_wiki 中创建一个 issue，Wiki 格式已创建模版，在 issues 页面选择“创建新的 Wiki 内容”即可，当使用这种方式投稿并被接受一次之后会被添加 Authors 权限，就能够点击页面右上角的 Edit/New 进行在线创建会让编辑。 Unreal Engine Wiki 的文档编写规则与组织方式： 每个 Wiki 页面是一个独立的 md 文档 使用 categories 进行分类 添加合适的 Tag 通过文档所在的文件夹进行自动分类 指定作者名字以及链接 能够指定文章使用的引擎版本 能够指定自定义导流 / 打赏二维码 能够自定义 copyright 以及备份链接信息 能够控制是否开启评论功能 能够添加外部链接引用 可以预览文章效果：Profiling for UE，配置模板（在 github 上创建 issue 时会自动创建）： 12345678910111213141516171819202122232425262728293031---title: # 标题date: 2021-06-29 22:32:01 # 创建时间toc: true # 开启目录categories: # 分类，可以指定多个，用于进行目录分类 - 父分类 - 子分类tag: # 标签可以指定多个（每行一个） - comments: true # 开启评论ue_version: UE4.25 # 文章使用的引擎版本author: # 作者信息，会显示在贡献者列表 name: # 名字 site_addr: # 网站链接 avatar_image: # 头像图片链接，如果为空则默认使用 github 头像 github_id: # github 账户 ID zhihu_addr: # 知乎链接 email: # 邮件地址 wechat_image: # 微信二维码图片地址postQR: enable: false # 开启文章末尾二维码 image: # 二维码链接 info: # 显示文字copyright: # 文章末尾的版权信息 enable: true history: true # 是否可查看文章编辑历史、RAW 文本 license: CC BY-NC-SA 4.0 # 文章的授权协议 backupAddr: # 文章的备份链接---&lt;!-- WIKI 内容 --&gt; 注意需要填写贡献者信息（author），如果不指定 avatar_image 图片链接，则会默认获取 github 账户头像。 本站的 Wiki 的文件存储在 source/_posts/ 下，Title 为文件名。 插入 b 站视频md 中可以直接插入 html 代码： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=583305972&amp;bvid=BV1Tz4y197tR&amp;cid=209073526&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 但是推荐使用&#123;% bilibili your_video_id %&#125;，能根据屏幕自适应： 内容要求 需要保证 Wiki 内容在测试环境的准确性，所有内容应该在本地测试通过，不允许提交未被验证的内容。 未完，待补充。","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://ue5wiki.com/tags/Wiki/"}],"categories":[]},{"title":"欢迎访问虚幻社区知识库！","date":"2021-06-29T21:32:01.000Z","path":"wiki/1/","text":"我是查利鹏，循迹研究室 博客作者，过去几年积累了很多 UE 相关的文章和技术笔记，为了方便组织、管理以及检索，创建本站点作为 Unreal Engine Wiki 知识站点，用于发布 UE 相关的技术内容。同时也计划把虚幻社区那些优秀但散落在各个平台的内容整合起来，方便统一地查阅和检索，目标是创建一个由 社区驱动 的公益性 虚幻知识库，期望能发展成为一个全面的 Unreal Engine 的中文 wiki 站点。本站会持续更新，包含 UE 特性、引擎分析、工具教程、开发技巧等内容，希望能对 UE 开发者提供一些帮助，也欢迎投稿支持，共同促进 UE 社区的发展。 我之前开源了一批 UE 的工具和插件并整理了一些文档链接资料，详情可在 Resources 中查看。 我的博客：imzlp.com Github：hxhb / UnrealCommunity 本站被部署在 Github Pages 上，提交和编辑内容，均基于 Github 账号系统。 内容投稿 ，在UnrealCommunity/commit_wiki 仓库中创建一个 issue，按照 Wiki 内容编写格式与提交规则 方式编写并提交即可，当被投稿被接收一次之后会被添加至 Authors 用户组，在页面或右侧分类中点击 New 即可创建新内容，并且可以通过 Edit 跳转到 Github 页面直接编辑。 链接投稿 ，可以把发布于外部网站的内容被本站收录，可以添加分类、标签，能够在本站搜索，通过Google Docs 编辑管理。本站不做任何非原作者内容搬运，链接投稿的内容会直接跳转至原链接。 我会定期整理 issues 方式的投稿并发布。通过 New 创建的会自动发布，并更新贡献者名单，以及为每一位作者创建一个独立的归档页面，如contributor/lipengzha。 Epic Offical Documents Unreal Engine 5 Documentation Unreal Engine 4 Documentation Unreal Engine API Reference Unreal Engine 4 Release Notes Unreal Engine 5 Release Notes Unreal Engine Resource Unreal Engine Feeds Unreal Engine Public Roadmap Programming with C++ Unreal Engine Issues Unreal Engine Community Wiki 虚幻中国 - 虚幻引擎官方社区新闻文章 Unreal Engine C++ API Dash Document Unreal Engine Console Variables and Commands(ue5) Contributor 希望更多的开发者能踊跃投稿，分享自己的开发经验，为虚幻社区添砖加瓦！ 感谢以下组织对开发者的支持： Epic Games Tencent 本站的内容贡献者：","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://ue5wiki.com/tags/Wiki/"}],"categories":[]},{"title":"虚幻周报 20210623| 又有好东西要来了","date":"2021-06-23T00:00:00.000Z","path":"wiki/external1200349813/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210623| 又有好东西要来了 。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/383057008"},{"title":"4.25.2Mac 打包的 metal-ar 错误","date":"2021-06-08T14:11:18.000Z","path":"wiki/35250/","text":"在 4.25.2 引擎版本，使用 Mac 打包时提示 metal-ar 错误，Log 中有执行 metal-ar 的报错： 1234567891011121314151617UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: no valid input for metallib.UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: no valid input for metallib.UATHelper: Packaging (iOS): LogShaders: Error: Archiving failed: no valid input for metallib.UATHelper: Packaging (iOS): LogZipArchiveWriter: Display: Closing zip file with 25491 entries.UATHelper: Packaging (iOS): CookResults: Error: Package Native Shader Library failed for IOS.UATHelper: Packaging (iOS): LogCook: Display: Saved scl.csv /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Saved/Cooked/IOS/FGame/Metadata/PipelineCaches/ShaderStableInfo-Global-SF_METAL.scl.csv for platform IOSUATHelper: Packaging (iOS): LogCook: Display: Saved scl.csv /Users/buildmachine/Documents/BuildWorkspace/workspace/PackageClient/Client/Saved/Cooked/IOS/FGame/Metadata/PipelineCaches/ShaderStableInfo-FGame-SF_METAL.scl.csv for platform IOSPackagingResults: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7PackagingResults: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7PackagingResults: Error: Archiving failed: metal-ar failed with code 2: Couldn&#x27;t posix_spawn: error 7PackagingResults: Error: Archiving failed: no valid input for metallib.PackagingResults: Error: Archiving failed: no valid input for metallib.PackagingResults: Error: Archiving failed: no valid input for metallib.PackagingResults: Error: Package Native Shader Library failed for IOS. 引擎中调用 metal-ar 的代码如下： 感觉错误的问题像是传递给 metal-ar 的参数太长了导致的，把 metal-ar 参数打出来发现确实非常长： 解决办法，把在 Mac 上 GetMaxArgLength 的返回值改成一个较小的值或者从环境变量中获取即可： Developer\\Apple\\MetalShaderFormat\\Private\\MetalShaderCompiler.cpp1234567891011static uint32 GetMaxArgLength()&#123;#if PLATFORM_MAC &amp;&amp; !UNIXLIKE_TO_MAC_REMOTE_BUILDING // 引擎中原始代码为返回 ARG_MAX // return ARG_MAX; return 4096;#else // Ask the remote machine via &quot;getconf ARG_MAX&quot; return 1024;#endif&#125; 在官方版本的 4.25.2 中已经修复：Use runtime evaluation of ARG_MAX instead of the compile-time constant (which in Xcode 12 is now 1m) Developer\\Apple\\MetalShaderFormat\\Private\\MetalShaderCompiler.cpp123456789101112131415161718192021222324252627static uint32 GetMaxArgLength()&#123;#if PLATFORM_MAC &amp;&amp; !UNIXLIKE_TO_MAC_REMOTE_BUILDING static uint32 MaxLength = 0; if (!MaxLength) &#123; // It&#x27;s dangerous to use &quot;ARG_MAX&quot; directly because it&#x27;s a compile time constant and may not be compatible with the running OS. // It&#x27;s safer to get the number from &quot;getconf ARG_MAX&quot; and only use the constant as the fallback FString StdOut, StdError; if (ExecRemoteProcess(TEXT(&quot;/usr/bin/getconf&quot;), TEXT(&quot;ARG_MAX&quot;), nullptr, &amp;StdOut, &amp;StdError)) &#123; MaxLength = FCString::Atoi(*StdOut); check(MaxLength &gt; 0); UE_LOG(LogMetalShaderCompiler, Display, TEXT(&quot;Set MaxArgLength to %d via getconf&quot;), MaxLength); &#125; else &#123; MaxLength = FMath::Min(ARG_MAX, 256 * 1024); UE_LOG(LogMetalShaderCompiler, Warning, TEXT(&quot;Failed to determine MaxArgLength via getconf: %s\\nSet it to %d which is the lesser of MAX_ARG and the value from the 10.15 SDK&quot;), *StdError, MaxLength); &#125; &#125; return MaxLength;#else // Ask the remote machine via &quot;getconf ARG_MAX&quot; return 1024;#endif&#125;","tags":[{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"},{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"},{"name":"Mac","slug":"Mac","permalink":"https://ue5wiki.com/tags/Mac/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"},{"name":"4.25","slug":"Engine/Bug/4-25","permalink":"https://ue5wiki.com/categories/Engine/Bug/4-25/"}]},{"title":"虚幻周报 20210603| 开心地像个孩子！","date":"2021-06-03T00:00:00.000Z","path":"wiki/external1024736214/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 虚幻周报 20210603| 开心地像个孩子！。","tags":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"categories":[{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/377551140"},{"title":"添加编译器参数","date":"2021-05-29T22:32:01.000Z","path":"wiki/b25cab28/","text":"如果想要在编译引擎时自定义加一些编译器参数可以修改 Programs\\UnrealBuildTool\\Platform 下各个平台的 *Toolchain.cs 中的： 123456string GetCompileArguments_Global(CppCompileEnvironment CompileEnvironment)&#123; // ++[RSTUDIO][lipengzha] support xcode12 Result += &quot; -Wno-range-loop-analysis&quot;; // --[RSTUDIO]&#125; 这样是全局配置（包含引擎和 Program 的编译都会使用该参数），如果只是想要给某个 Target 添加编译器参数可以在 target.cs 里通过 AdditionalCompilerArguments 设置： 12bOverrideBuildEnvironment = true;AdditionalCompilerArguments = &quot;-Wno-range-loop-analysis&quot;;","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"UBT","slug":"BuildSystem/UBT","permalink":"https://ue5wiki.com/categories/BuildSystem/UBT/"}]},{"title":"Install IPA 0xE8008029 Error","date":"2021-05-29T22:32:01.000Z","path":"wiki/d2310d51/","text":"使用最新的苹果开发者证书（2021.07.11）打包的 IPA 安装时具有错误： 123456789101112131415[DD] Mobile Device &#x27;iPhone&#x27; connectedTrying to connect to mobile device running iOS ...Transferring IPA to device &#x27;iPhone&#x27; ... ... Transfer is 10% complete at phase &#x27;TransferringPackage&#x27; ... Transfer is 20% complete at phase &#x27;CopyingFile&#x27; ... Transfer is 30% complete at phase &#x27;CopyingFile&#x27; ... Transfer is 40% complete at phase &#x27;CopyingFile&#x27; ... Transfer is 50% complete at phase &#x27;CopyingFile&#x27; ... Transfer is 60% complete at phase &#x27;CopyingFile&#x27; ... Transfer is 80% complete at phase &#x27;CopyingFile&#x27;Installing IPA on device &#x27;iPhone&#x27; ... ... Install is 5% complete at phase &#x27;CreatingStagingDirectory&#x27; ... Install is 20% complete at phase &#x27;InspectingPackage&#x27; ... Install is 40% complete at phase &#x27;VerifyingApplication&#x27;Install \\ Update of &quot;Blank425.ipa&quot; failed with Unknown error 0xE8008029 in 13.65 seconds 或者有 0xE8008019 的错误： 12345Installing IPA on device &#x27;iPhone&#x27; ... ... Install is 5% complete at phase &#x27;CreatingStagingDirectory&#x27; ... Install is 20% complete at phase &#x27;InspectingPackage&#x27; ... Install is 40% complete at phase &#x27;VerifyingApplication&#x27;Install \\ Update of &quot;Blank425.ipa&quot; failed with Missing or invalid code signature (0xE8008019) in 0.27 seconds 这是因为使用了老的代码格式签名导致的。 4.27/Engine/Source/Programs/IOS/iPhonePackager/MachObjects.cs#L2099 Using the Latest Code Signature Format iOS 14.5 - Code Signing Version No Longer Supported 在 UE4.25 中，cVersion2的值： 12345public class CodeDirectoryBlob : AbstractBlob&#123; public const UInt32 cVersion2 = 0x20200; // ...&#125; 在 4.27 中 IPhonePackager 做了修正，使用之前版本的 UE 打包出来的 IPA 使用 4.27 之后的 IPhonePackager 进行 re-signing 即可安装。 re-signing log： 我提取了 UE4.27 的 iPhonePackager 的代码和编译的可执行程序： iPhonePackager.7z iPhonePackager_src_427.7z","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"IPA","slug":"IPA","permalink":"https://ue5wiki.com/tags/IPA/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"UE5：新一代虚幻引擎初探","date":"2021-05-25T12:22:44.000Z","path":"wiki/8724/","text":"终于，在 2021 年的五月底，UE5 终于要推出第一个预览版本了，虚幻引擎 5——将于中国时间 5 月 26 日周三晚 10 点开启抢先体验计划！。对 UE5 期待许久，去年 Nanite 和 lumen 一石激起千层浪，时隔一年，终于能够实际体验到了。过去一年，关于 UE5 的技术消息不多，我做过了一些 Epic 披露的关于 UE5 相关的信息总结和分析，有兴趣的可以移步 notes/ue5 中查看。本篇文章会记录上手 UE5 的一些体验，相较于 UE4 开发方式的变动，为 UE4 到 UE5 的过渡，以及将 UE5 应用到生产环境做一个技术预研，近期会持续更新。 UE5 官方资料： 虚幻引擎 5 抢鲜体验 Unreal Engine 5 Early Access Documentation Unreal Engine 5 Early Access Release Notes Unreal Engine C++ API Reference 发布的演示视频： 最值得关注的点当然是 Lumin/Nanite，并且引擎集成了 Quixel Bridge，可以直接导入资源，场景编辑流程变化很大。增加强大的动画支持，在引擎中直接编辑和复用动画资源更方便了，能够根据场景自适应动画，非常 Amazing 啊！GamePlay 方面增加了一种叫做 Game Feature 的机制，支持使用模块化的方式创建和发布游戏内容，对于资产管理和打包的流程相较于 UE4 也有变动，从热更新的角度来看，估计需要增加支持 Game Feature 作为资产包的功能支持，准备近期有时间先把 HotPatcher 目前的版本升级到 UE5。准备近期有时间对 UE5 中的新机制做个功能预研然后写几篇文章。 可以在 EpicLauncher 里安装二进制版本： UE5 预览版源码 github 地址：ue5-main，需要下载的依赖 ue4-gitdeps 与 UE4 的版本有相同的部分，可以拷贝到 UE5 代码的 .git/ue4-gitdeps 目录下，在 Setup.bat 时可以减少下载的内容。并且，Epic 随 UE5 一起放出了 古代山谷 项目，可以点击连接从 Epic Launcher 下载，文档：Valley of the Ancient Sample。 我的博客中在发布之前关于 UE5 的分析笔记（notes/ue5）： Oodle Compression Epic Verse 语法介绍 Epic 收购 RAD Game Tools UE5 可能的脚本语言 UE5 的 PS5 真机视频 附 Epic 中国直播的 UE 开发路线图视频： [中文直播]第 29 期｜解析虚幻引擎开发路线图(上集) | Epic 王祢 马骥 孙丹璐 [中文直播]第 29 期｜解析虚幻引擎开发路线图(下集) | Epic 王祢 马骥 孙丹璐 注意：本次发布的预览版并不包含新的脚本语言 Epic Verse，估计还需要挺长一段时间的更新才会支持。 Platform SupportUE5 已经抛弃支持 32 位平台，并已支持 Apple Silicon 设备（M1），但 Editor 非 Arm 原生，仍需要 Rosetta 转译执行。Lumen 和 Nanite 不支持移动平台、上一代主机平台。建议设备：GTX 1080+。 引擎中增加了Unreal Trunkey，相较于 UE4，可以非常方便地在团队之间统一配置平台 SDK。UE5 集成的各 SDK 版本： New: Platform SDK Upgrades。Windows 编译器版本最低支持 VS2019 v16.4 及以上的版本 ，不再支持 VS2015 和 VS2017。 Engine CodeGithub 上提供了两个 UE5 的代码分支：ue5-main和ue5-early-access。 两者的区别是： ue5-early-access：与 Epic Lacunher 相同的源码分支 ue5-main：Epic 的开发分支 引擎代码的组织方式相较于 UE4 没有变动，目前看到 Module 的代码基本与 UE4 保持一致，所以 UE4 代码升级到 UE5 应该问题不大，需要解决的应该是以下几点： 原先依赖的模块代码组织变动 BuildSettingsVersion被设置为 Latest 带来的警告等级的变化 CppStandardVersion默认为 Cpp17（Latst 为 Cpp20） 检测引擎版本的代码，如 ENGINE_MAJOR_VERSION 变为 5，ENGINE_MINOR_VERSION 变为 0 在 TargetRules 中增加了一些新的编译选项： DefaultWarningLevel DeprecationWarningLevel bWarningsAsErrors bEnableCppModules Nvdia 的组件则从 UE4 的默认开启变成了默认关闭（不确定是否为了兼容 UE4 项目升级保留，有可能后面会移除，这一点 UE5 的文档中也有写），物理系统在 UE5 中默认使用 Chaos： 123bCompilePhysX = false;bCompileAPEX = false;bCompileNvCloth = false; 引擎中 ModuleRules 的几乎没有变动，没有新加的参数，只是针对 bEnableCppModules 做了检测。UE5 的编译系统可以看作是 UE4 的常规升级，有时间我会先把我开源的插件升级到 UE5 进行测试。 同时，UE5 相较于 UE4.25，引擎中增加了几个新的 Programs： BaseTextureBuildWorker ChaosVisualDebugger DerivedDataBuildWorker EpicWebHelper HeadlessChaosPerf Horde InterchangeWorker EpicGames.Core/Jupiter/MongoDB/Perforce/Perforce.Managed SwitchboardListener TextureShare UnrealBuildToolTests UnrealObjectPtrTool VirtualProduction 有时间再来具体分析作用。 EditorUE5 新 Editor 的文档介绍：Navigating the New Unreal Editor Interface 启动界面 个人觉得相对于 UE4 的拟物化 UI 风格更耐看一些。 可以在 Launcher 界面选择启动 UE4 项目： 项目设置与编辑器设置，与 UE4 的分类保持一致，也可以使用 Rider 作为开发 IDE 并刷新工程。 具有比 UE4 更好的本地化语言支持： ProjectUE5 创建项目组织基本与 UE4 保持一致，代码开发流程与 UE4 没有区别。 对开发硬件要求更高了，我的机器位 10606G，在 ThirdPersion 项目 Editor 只能跑到 80fps：估计在我的机器上打包之后最多只能跑 30fps。 Data Drived CVarsUE5 中还增加了 Data Driven CVars 的支持，可以在项目设置中配置 Console Variables： 可以在 IConsoleManager::Get() 获取，相较于 UE4，无需在代码中创建 TAutoConsoleVariable 对象，更为方便，它被存储在 DefaultEngine.ini 中： DefaultEngine.ini12[/Script/Engine.DataDrivenConsoleVariableSettings]+CVarsArray=(Type=CVarInt,Name=&quot;t.testvar&quot;,ToolTip=&quot;&quot;,DefaultValueFloat=0.000000,DefaultValueInt=123,DefaultValueBool=False) Cook for PlatformUE5 终于支持在编辑器中 Cook 非本地平台了（其实就是为平台默认增加了 Cook 按钮，在 UE4 中 HotPatcher 中也已支持同时 Cook 多个平台）。 GamePlayUE5 带来的 Game Play 的变动较多，如 Game Feature 等，准备有时间再进行详细的分析和使用。 PluginsUE5 创建插件和 UE4 的组织方式和 Build.cs 代码也没有变动，我把我之前开源的 ue4-export-nav-data 插件放到 UE5 工程里，出现的错误也只是符号找不到，是引擎内实现有变动，通过简单的修改可以直接编译通过，但 UE4 的代码模块是直接可以拿到 UE5 编译的，需要处理对应的符号查找错误。 我已经把 ue4-export-nav-data 插件升级支持 UE5 了，并且在 UE5 上导出数据与 detour 验证通过，详情请看之前的文章：Export Recast Navigation Data from UE4，仓库地址为：ue4-export-nav-data。 AssetsUE5 资源管理的变动，新特性支持了 Game Feature 机制，能够模块化构建游戏内容，开启之后可以在项目设置的 Asset Manager 中看到 GameFeatureData 的选项，说明 GameFeature 是已经兼容了打包的方式的，有时间做个详细的分析。 UE5 同样支持 PrimaryAssetLable 机制来标记资产，与 UE4 中没有区别，同时编辑器选项中增加了 允许 ChunkID 指定 功能，开启之后可以在资源右键中看到以下菜单： Package 蓝图项目对 Apple Silicon 的支持位仅限通过 Rosetta2 运行，C++ 项目支持本地 Apple Silicon 打包。 UE5 中的打包选项移动到了以下位置： 打包时同样使用 UAT 执行，命令如下： 12345678910111213141516171819202122232425262728293031cmd.exe /c &quot;&quot;C:/Program Files/Epic Games/UE_5.0ea/Engine/Build/BatchFiles/RunUAT.bat&quot; -ScriptsForProject=&quot;C:/Users/lipengzha/Documents/Unreal Projects/ThirdPerson_UE5/ThirdPerson_UE5.uproject&quot; Turnkey -command=VerifySdk -platform=Win64 -UpdateIfNeeded -EditorIO -project=&quot;C:/Users/lipengzha/Documents/Unreal Projects/ThirdPerson_UE5/ThirdPerson_UE5.uproject&quot; BuildCookRun -nop4 -utf8output -nocompileeditor -cook-project=&quot;C:/Users/lipengzha/Documents/Unreal Projects/ThirdPerson_UE5/ThirdPerson_UE5.uproject&quot; -ue4exe=&quot;C:\\Program Files\\Epic Games\\UE_5.0ea\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe&quot; -platform=Win64 -ddc=InstalledDerivedDataBackendGraph -installed -stage -archive -package -build -iostore -pak -prereqs -archivedirectory=&quot;C:/Users/lipengzha/Documents/Unreal Projects/ThirdPerson_UE5/Package&quot; -nodebuginfo -clientconfig=Development-nocompil&quot; 代码的编译命令与 UE4 也没有区别： 12345678910C:\\Program Files\\Epic Games\\UE_5.0ea\\Engine\\Binaries\\DotNET\\UnrealBuildTool\\UnrealBuildTool.exe ThirdPerson_UE5 Win64 Development -Project=&quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson_UE5\\ThirdPerson_UE5.uproject&quot; &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson_UE5\\ThirdPerson_UE5.uproject&quot; -NoUBTMakefiles -remoteini=&quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson_UE5&quot; -skipdeploy -Manifest=&quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson_UE5\\Intermediate\\Build\\Manifest.xml&quot; -NoHotReload -log=&quot;C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_5.0ea\\UBT-ThirdPerson_UE5-Win64-Development.txt&quot; Cook 命令也相同： 12345678910C:\\Program Files\\Epic Games\\UE_5.0ea\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\ThirdPerson_UE5\\ThirdPerson_UE5.uproject&quot; -run=Cook -TargetPlatform=Windows -fileopenlog -ddc=InstalledDerivedDataBackendGraph -unversioned -abslog=&quot;C:\\Program Files\\Epic Games\\UE_5.0ea\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2021.05.27-12.04.09.txt&quot; -stdout -CrashForUA 测试打包 ThirdPerson 非常慢。打包之后的目录结构与 UE4 相同： 1234567891011121314151617181920C:.| Manifest_NonUFSFiles_Win64.txt| ThirdPerson_UE5.exe|+---Engine| +---Binaries| | \\---ThirdParty\\---ThirdPerson_UE5 +---Binaries | \\---Win64 | ThirdPerson_UE5.exe | turbojpeg.dll | \\---Content \\---Paks global.ucas global.utoc ThirdPerson_UE5-Windows.pak ThirdPerson_UE5-Windows.ucas ThirdPerson_UE5-Windows.utoc 但是除了 pak 之外多了两种类型的文件 ucas 与utoc两种文件，在运行时 Mount pak 时也会 mount 它们，看了下代码在 UE4.25/26 就中存在，有时间详细地分析下它们的作用和加载流程。 Open UE4 ProjectUE5 的文档中写道：支持 UE4.26 及之前的引擎版本项目升级到 UE5，UE5 会和 UE4.27 并行存在，不会保证与 4.26 之后的版本保持兼容。并且，UE5 项目无法降级到 UE4。 但是就目前的情况而言，把 4.26 的工程升级到 UE5 还是有不少的错误，但这些错误基本都是上面介绍的那几点中的情况，花些心思适配即可。 其他兼容性问题补充UE5 的其他的兼容性问题补充： UE4Editor*.exe更名为 UnrealEngine*.exe，原先依赖UE4Editor*.exe 路径的需要修改； UnrealBuildTool从 UE4 中 Binaries/DoNET 移动到 Binaries/DoNET/AutomationTool 目录下，会导致 UE4 的 UnrealVersionSelector 生成 sln 失败； 平台名的变化： 去掉了一些资源平台，新加了一些 如 WindowsNoEditor/MacNoEditor 等统一去掉了 NoEditor 后缀 总结 总的来说，UE5 的核心更新在 Lumen 和 Nanite 带来的美术资源与场景编辑流程的革新，以及对引擎内对数据驱动动画的强大支持。UE5 相较于 UE4 在编程方面没有非常大的变化，较新版本的 UE4 工程代码和插件能够比较轻松地升级到 UE5，之前有消息的新脚本语言 Epic Verse 没有同步发布，对这个还是非常期待的。编辑器的整体操作习惯还是遵循了 UE4，不过主界面布局和 UI 风格变化比较大，熟悉之后倒也没有什么障碍，UE5 提供了更方便的平台 SDK 支持。基本上 UE4 资源管理和工程实践的积累也能在 UE5 中直接用，打包流程与 UE4 也基本相同，不过目前打包速度相较于 UE4 变慢了很多。作为下一个世代的游戏引擎，非常期待 UE5 在主机平台上的效果，但是目前 Lumen 和 Nanite 并不支持 Mobile 平台，短期内无法作为生产环境，期待正式版本在移动端上的表现。","tags":[{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/tags/UE5/"}],"categories":[{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/categories/UE5/"}]},{"title":"UE4VirtualTexture 源码解析","date":"2021-05-20T00:00:00.000Z","path":"wiki/external1165613716/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4VirtualTexture 源码解析 。","tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/tags/Rendering/"},{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"VirtualTexture","slug":"VirtualTexture","permalink":"https://ue5wiki.com/tags/VirtualTexture/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"VirtualTexture","slug":"Rendering/VirtualTexture","permalink":"https://ue5wiki.com/categories/Rendering/VirtualTexture/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/373969159"},{"title":"UE 项目优化：PSO Caching","date":"2021-04-22T19:40:55.000Z","path":"wiki/24336/","text":"UE 中具有 PSO Caching 机制，全称 Pipeline State Object Caching，用于预先记录和构建出运行时所使用的材质依赖的 Shader 信息，当项目首次使用这些 Shader 时，该列表可以加速 Shader 的加载 / 编译过程。PSO Caching 会把渲染状态、顶点声明、Primitive 类型、RenderTarget 像素格式等数据保存到文件中，提升 Shader 的加载效率。本篇文章主要介绍 PSO Caching 的启用及构建流程，并会分析 PSO Cache 在引擎中的加载流程以及实现热更 PSO 方式、错误处理等，PSO Caching 的原理有时间再进行详细分析。 PSO Caching 的官方文档：PSO Caching。 PSO Cache 构建流程概览： PSO Caching 的部署和使用大致分为以下几个步骤： 为项目开启 PSO Cahche 和 ShaderStableKeys，打包后可以从 Metadata/PipelineCaches 目录下获得ShaderStableInfo*.scl.csv 添加 logPSO 参数启动游戏，用于在运行时记录 PSO 数据（*.scl.upipelinecache） 通过 ShaderStableInfo*.scl.csv 和*.scl.upipelinecache生成*.stablepc.csv 再次执行 Cook，通过 *.stablepc.csv 生成 upipelinecache 文件，打至包内； 启动游戏，引擎自动加载*.stable.upipelinecache，编译 Shader 时使用 PSO Caching 本篇文章的内容顺序也遵循着几个步骤。 启用 ShaderStableKeys首先需要为项目开启ShaderStableKeys，在执行 Cook 时生成稳定的 ShaderKey，作为记录 Shader 的凭据。 在DefaultEngine.ini（或平台相关如 AndroidEngine.ini）中添加以下值： 12[DevOptions.Shaders]NeedsShaderStableKeys=true 添加之后再执行打包（Cook），会创建以下目录： 1Saved/Cooked/PLATFORM_NAME/PROJECT_NAME/Metadata/PipelineCaches 并且会在该目录下生成两个文件（分别对应项目、引擎）： 12ShaderStableInfo-PROJECT_NAME-GLSL_ES3_1_ANDROID.scl.csvShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv Cook 过程中会有以下 log，表明生成了这两个文件： 12LogCook: Display: Saved scl.csv D:/PSOExample/Saved/Cooked/Android_ASTC/PSOExample/Metadata/PipelineCaches/ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv for platform Android_ASTCLogCook: Display: Saved scl.csv D:/PSOExample/Saved/Cooked/Android_ASTC/PSOExample/Metadata/PipelineCaches/ShaderStableInfo-PSOExample-GLSL_ES3_1_ANDROID.scl.csv for platform Android_ASTC 可以使用它们通过 -run=ShaderPipelineCacheTools 这个 Commandlet 来生成*.stablepc.csv。 *.scl.csv文件的内容： 运行时捕获 PSO 数据 启动游戏时加入 -logPSO 参数或者在 DefaultEngine.ini 中加入以下配置： Config/DefaultEngine.ini1234[ConsoleVariables]r.ShaderPipelineCache.Enabled=1r.ShaderPipelineCache.LogPSO=1r.ShaderPipelineCache.SaveBoundPSOLog=1 也可以在 Devices Profile 中设置： 这两个参数在以下代码中使用： Runtime/RHI/Private/PipelineFileCache.cpp12345678910111213141516171819202122232425bool FPipelineFileCache::IsPipelineFileCacheEnabled()&#123; static bool bOnce = false; static bool bCmdLineForce = false; if (!bOnce) &#123; bOnce = true; bCmdLineForce = FParse::Param(FCommandLine::Get(), TEXT(&quot;psocache&quot;)); UE_CLOG(bCmdLineForce, LogRHI, Warning, TEXT(&quot;****************************** Forcing PSO cache from command line&quot;)); &#125; return FileCacheEnabled &amp;&amp; (bCmdLineForce || CVarPSOFileCacheEnabled.GetValueOnAnyThread() == 1);&#125;bool FPipelineFileCache::LogPSOtoFileCache()&#123; static bool bOnce = false; static bool bCmdLineForce = false; if (!bOnce) &#123; bOnce = true; bCmdLineForce = FParse::Param(FCommandLine::Get(), TEXT(&quot;logpso&quot;)); UE_CLOG(bCmdLineForce, LogRHI, Warning, TEXT(&quot;****************************** Forcing logging of PSOs from command line&quot;)); &#125; return (bCmdLineForce || CVarPSOFileCacheLogPSO.GetValueOnAnyThread() == 1);&#125; 运行游戏时会有 log: 123456789101112LogConfig: Applying CVar settings from Section [ConsoleVariables] File [../../../FGame/Saved/Config/Android/Engine.ini]LogConfig: Setting CVar [[r.ShaderPipelineCache.Enabled:1]]LogConfig: Setting CVar [[r.ShaderPipelineCache.LogPSO:1]]LogConfig: Setting CVar [[r.ShaderPipelineCache.SaveBoundPSOLog:1]]...LogRHI: Base name for record PSOs is ../../../FGame/Saved/CollectedPSOs/++UE4+Release-4.25-CL-0-FGame_GLSL_ES3_1_ANDROID_00084A4308D90436AC0F652223AA8D4F.rec.upipelinecacheLogRHI: Could not open FPipelineCacheFile: ../../../FGame/Content/PipelineCaches/Android/FGame_GLSL_ES3_1_ANDROID.upipelinecache...LogRHI: Display: Encountered a new graphics PSO: 3478445130LogRHI: Display: New Graphics PSO (3478445130) Description: 416F798F22743F626513A16205A15ECB135C3791,0000000000000000000000000000000000000000,0000000000000000000000000000000000000000,0000000000000000000000000000000000000000,0000000000000000000000000000000000000000,&lt;0 1 0 0 1 0 0 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0&gt;,&lt;0.000000 0.000000 2 1 0 0&gt;,&lt;0 3 0 7 0 0 0 0 7 0 0 0 255 255&gt;,1,11,1051148,2,2,0,0,0,4,10,1114633,0,0,18,2569,0,0,37,1051145,0,0,37,2585,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15360,15391,1055,1027,1025,0,0,0,0,1,&lt;0 0 3 0 12 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;LogRHI: Display: Encountered a new graphics PSO: 898510125LogRHI: Display: New Graphics PSO (898510125) Description: 432A3E5557E9ED8328AC7E6CDA5AA6FC2F0B2439,0FED48EC019CFDD251488DE33D563DCFFD7E69DA,0000000000000000000000000000000000000000,0000000000000000000000000000000000000000,0000000000000000000000000000000000000000,&lt;0 1 0 0 1 0 7 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0 1 0 0 1 0 15 0&gt;,&lt;0.000000 0.000000 2 0 0 0&gt;,&lt;0 7 0 7 0 0 0 0 7 0 0 0 255 255&gt;,1,11,1051148,2,2,0,0,0,4,10,1114633,0,0,18,2569,0,0,37,1051145,0,0,37,2585,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15360,15391,1055,1027,1025,0,0,0,2,2,&lt;0 0 4 0 32 0&gt;,&lt;0 16 2 1 32 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt;,&lt;0 0 0 0 0 0&gt; 并会在 Saved/CoolectedPSOs 中创建以下文件： 生成 *.stablepc.csv使用以下 commandlet： 123456Engine/Binaries/Win64/UE4Editor-Cmd.exeD:/Client/Client.uproject-run=ShaderPipelineCacheTools expandD:/PSOCache/*.rec.upipelinecacheD:/PSOCache/*.scl.csvD:/PSOCache/Client_GLSL_ES3_1_ANDROID.stablepc.csv 以上命令会在引擎的 Binaries/Win64 下生成 Client_GLSL_ES3_1_ANDROID.stablepc.csv 文件，注意一定要匹配 &#123;PROJECTNAME&#125;_&#123;SHADER_FORMART_NAME&#125;.stablepc.csv 这个命名规则。 Android 的命名为：Client_GLSL_ES3_1_ANDROID.stablepc.csvIOS 的命名为：Client_SF_METAL.stablepc.csv 生成时具有以下 Log： 12345678910111213141516171819202122232425D:\\PSOCache&gt;&quot;C:\\Program Files\\Epic Games\\UE_4.25\\Engine\\Binaries\\Win64\\UE4Editor-Cmd.exe&quot; &quot;D:\\PSOExample\\PSOExample.uproject&quot; -run=ShaderPipelineCacheTools expand D:/PSOCache/*.rec.upipelinecache D:/PSOCache/*.scl.csv D:/PSOCache/PSOExample_GLSL_ES3_1_ANDROID.stablepc.csv[2021.04.22-08.57.39:623][0]LogTargetPlatformManager: Display: Building Assets For Windows[2021.04.22-08.57.39:648][0]LogAudioDebug: Display: Lib vorbis DLL was dynamically loaded.[2021.04.22-08.57.39:841][0]LogShaderCompilers: Display: Using Local Shader Compiler.[2021.04.22-08.57.40:492][0]LogDerivedDataCache: Display: Max Cache Size: 512 MB[2021.04.22-08.57.40:523][0]LogDerivedDataCache: Display: Loaded Boot cache: C:/Users/lipengzha/AppData/Local/UnrealEngine/4.25/DerivedDataCache/Boot.ddc[2021.04.22-08.57.40:533][0]LogDerivedDataCache: Display: Pak cache opened for reading ../../../Engine/DerivedDataCache/Compressed.ddp.[2021.04.22-08.57.44:616][0]LogAudioCaptureCore: Display: No Audio Capture implementations found. Audio input will be silent.[2021.04.22-08.57.44:616][0]LogAudioCaptureCore: Display: No Audio Capture implementations found. Audio input will be silent.[2021.04.22-08.57.45:274][0]LogShaderPipelineCacheTools: Display: Loading D:/PSOCache/ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv...[2021.04.22-08.57.45:275][0]LogShaderPipelineCacheTools: Display: Loading D:/PSOCache/ShaderStableInfo-PSOExample-GLSL_ES3_1_ANDROID.scl.csv...[2021.04.22-08.57.45:280][0]LogShaderPipelineCacheTools: Display: Loaded 548 shader info lines from D:/PSOCache/ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv.[2021.04.22-08.57.45:287][0]LogShaderPipelineCacheTools: Display: Loaded 5707 shader info lines from D:/PSOCache/ShaderStableInfo-PSOExample-GLSL_ES3_1_ANDROID.scl.csv.[2021.04.22-08.57.45:287][0]LogShaderPipelineCacheTools: Display: Loaded 6255 unique shader info lines total.[2021.04.22-08.57.45:289][0]LogShaderPipelineCacheTools: Display: Loading D:/PSOCache/++UE4+Release-4.25-CL-13942748-PSOExample_GLSL_ES3_1_ANDROID_000843BC08D905AF09E24614C6A6086F.rec.upipelinecache....[2021.04.22-08.57.45:293][0]LogShaderPipelineCacheTools: Display: Loaded 105 PSOs[2021.04.22-08.57.45:297][0]LogShaderPipelineCacheTools: Display: Loaded 105 PSOs total [Usage Mask Merged = 0].[2021.04.22-08.57.45:325][0]LogShaderPipelineCacheTools: Display: Generated 478 stable PSOs total[2021.04.22-08.57.45:344][0]LogShaderPipelineCacheTools: Display: Wrote stable PSOs, 479 lines (541.8 KB) to D:/PSOCache/PSOExample_GLSL_ES3_1_ANDROID.stablepc.csv[2021.04.22-08.57.45:346][0]LogInit: Display:[2021.04.22-08.57.45:349][0]LogInit: Display: Success - 0 error(s), 0 warning(s)[2021.04.22-08.57.45:353][0]LogInit: Display:Execution of commandlet took: 0.08 seconds[2021.04.22-08.57.45:408][0]LogShaderCompilers: Display: Shaders left to compile 0[2021.04.22-08.57.45:621][0]LogContentStreaming: Display: There are 1 unreleased StreamingManagers 最终 PSO 所需要的所有文件： 12345678D:\\PSOCache&gt;tree /a /f卷 Data 的文件夹 PATH 列表 卷序列号为 004B-E876D:. ++UE4+Release-4.25-CL-13942748-PSOExample_GLSL_ES3_1_ANDROID_000843BC08D905AF09E24614C6A6086F.rec.upipelinecache PSOExample_GLSL_ES3_1_ANDROID.stablepc.csv ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv ShaderStableInfo-PSOExample-GLSL_ES3_1_ANDROID.scl.csv 我把测试工程生成的文件备份了一份：PSOCache.7z，可以查看每个文件中的内容。 生成 *.stable.upipelinecache把生成的 *stablepc.csv 放到 Build/Android/PipelineCaches 目录下，注意 Build/PLATFORM 这个 Platform 是编译平台，不是 Cook 的资源平台，Android 的包就是 Android 而不是 Android_ASTC 等。之后重新打包即可。 引擎在 Cook 时通过 stavlepc.csv 创建 PipelineCache 的代码： Editor\\UnrealEd\\Private\\CookOnTheFlyServer.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void UCookOnTheFlyServer::CreatePipelineCache(const ITargetPlatform* TargetPlatform, const FString&amp; LibraryName)&#123; // make sure we have a registry generated for all the platforms const FString TargetPlatformName = TargetPlatform-&gt;PlatformName(); TArray&lt;FString&gt;* SCLCSVPaths = OutSCLCSVPaths.Find(FName(TargetPlatformName)); if (SCLCSVPaths &amp;&amp; SCLCSVPaths-&gt;Num()) &#123; TArray&lt;FName&gt; ShaderFormats; TargetPlatform-&gt;GetAllTargetedShaderFormats(ShaderFormats); for (FName ShaderFormat : ShaderFormats) &#123; // *stablepc.csv or *stablepc.csv.compressed const FString Filename = FString::Printf(TEXT(&quot;*%s_%s.stablepc.csv&quot;), *LibraryName, *ShaderFormat.ToString()); const FString StablePCPath = FPaths::ProjectDir() / TEXT(&quot;Build&quot;) / TargetPlatform-&gt;IniPlatformName() / TEXT(&quot;PipelineCaches&quot;) / Filename; const FString StablePCPathCompressed = StablePCPath + TEXT(&quot;.compressed&quot;); TArray&lt;FString&gt; ExpandedFiles; IFileManager::Get().FindFilesRecursive(ExpandedFiles, *FPaths::GetPath(StablePCPath), *FPaths::GetCleanFilename(StablePCPath), true, false, false); IFileManager::Get().FindFilesRecursive(ExpandedFiles, *FPaths::GetPath(StablePCPathCompressed), *FPaths::GetCleanFilename(StablePCPathCompressed), true, false, false); if (!ExpandedFiles.Num()) &#123; UE_LOG(LogCook, Display, TEXT(&quot;---- NOT Running UShaderPipelineCacheToolsCommandlet for platform %s shader format %s, no files found at %s&quot;), *TargetPlatformName, *ShaderFormat.ToString(), *StablePCPath); &#125; else &#123; UE_LOG(LogCook, Display, TEXT(&quot;---- Running UShaderPipelineCacheToolsCommandlet for platform %s shader format %s&quot;), *TargetPlatformName, *ShaderFormat.ToString()); const FString OutFilename = FString::Printf(TEXT(&quot;%s_%s.stable.upipelinecache&quot;), *LibraryName, *ShaderFormat.ToString()); const FString PCUncookedPath = FPaths::ProjectDir() / TEXT(&quot;Content&quot;) / TEXT(&quot;PipelineCaches&quot;) / TargetPlatform-&gt;IniPlatformName() / OutFilename; if (IFileManager::Get().FileExists(*PCUncookedPath)) &#123; UE_LOG(LogCook, Warning, TEXT(&quot;Deleting %s, cooked data doesn&#x27;t belong here.&quot;), *PCUncookedPath); IFileManager::Get().Delete(*PCUncookedPath, false, true); &#125; const FString PCCookedPath = ConvertToFullSandboxPath(*PCUncookedPath, true); const FString PCPath = PCCookedPath.Replace(TEXT(&quot;[Platform]&quot;), *TargetPlatformName); FString Args(TEXT(&quot;build &quot;)); Args += TEXT(&quot;\\&quot;&quot;); Args += StablePCPath; Args += TEXT(&quot;\\&quot;&quot;); int32 NumMatched = 0; for (int32 Index = 0; Index &lt; SCLCSVPaths-&gt;Num(); Index++) &#123; if (!(*SCLCSVPaths)[Index].Contains(ShaderFormat.ToString())) &#123; continue; &#125; NumMatched++; Args += TEXT(&quot; &quot;); Args += TEXT(&quot;\\&quot;&quot;); Args += (*SCLCSVPaths)[Index]; Args += TEXT(&quot;\\&quot;&quot;); &#125; if (!NumMatched) &#123; UE_LOG(LogCook, Warning, TEXT(&quot;Shader format %s for platform %s had this file %s, but no .scl.csv files.&quot;), *ShaderFormat.ToString(), *TargetPlatformName, *StablePCPath); for (int32 Index = 0; Index &lt; SCLCSVPaths-&gt;Num(); Index++) &#123; UE_LOG(LogCook, Warning, TEXT(&quot; .scl.csv file: %s&quot;), *((*SCLCSVPaths)[Index])); &#125; continue; &#125; Args += TEXT(&quot; &quot;); Args += TEXT(&quot;\\&quot;&quot;); Args += PCPath; Args += TEXT(&quot;\\&quot;&quot;); UE_LOG(LogCook, Display, TEXT(&quot; With Args: %s&quot;), *Args); int32 Result = UShaderPipelineCacheToolsCommandlet::StaticMain(Args); if (Result) &#123; LogCookerMessage(FString::Printf(TEXT(&quot;UShaderPipelineCacheToolsCommandlet failed %d&quot;), Result), EMessageSeverity::Error); &#125; else &#123; UE_LOG(LogCook, Display, TEXT(&quot;---- Done running UShaderPipelineCacheToolsCommandlet for platform %s&quot;), *TargetPlatformName); &#125; &#125; &#125; &#125;&#125; 实际使用 stablepc.csv 的地方就是用它来执行 ShaderPipelineCacheTools 这个 commandlet 生成 upipelinecache 文件并打至包内。 ShaderPipelineCacheToolsCommandlet 的执行命令为： 1234567Engine\\Binaries\\Win64\\UE4Editor-Cmd.exeD:\\PSOExample\\PSOExample.uproject-run=ShaderPipelineCacheTools build&quot;D:\\PSOExample/Build/Android/PipelineCaches/*PSOExample_GLSL_ES3_1_ANDROID.stablepc.csv&quot;&quot;D:\\PSOExample/Saved/Cooked/Android_ASTC/PSOExample/Metadata/PipelineCaches/ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv&quot;&quot;D:\\PSOExample/Saved/Cooked/Android_ASTC/PSOExample/Metadata/PipelineCaches/ShaderStableInfo-PSOExample-GLSL_ES3_1_ANDROID.scl.csv&quot;&quot;D:\\PSOExample/Saved/Cooked/Android_ASTC/PSOExample/Content/PipelineCaches/Android/PSOExample_GLSL_ES3_1_ANDROID.stable.upipelinecache&quot; 生成 *.stable.upipelinecache 文件的包内路径为Content\\PipelineCaches\\Android： 123456D:\\PSOExample\\Saved\\Cooked\\Android_ASTC\\PSOExample\\Content\\PipelineCaches&gt;tree /a /f卷 Windows 的文件夹 PATH 列表 卷序列号为 0C49-9EA3C:.\\---Android PSOExample_GLSL_ES3_1_ANDROID.stable.upipelinecache 因为它是位于 Content 下并会打包进 pak 的文件，我们也可以对其进行热更。 当安装了包含 upipelinecache 的包，在运行时就会有以下 log： 1234567891011LogShaderLibrary: Display: Using ../../../PSOExample/Content/ShaderArchive-PSOExample-GLSL_ES3_1_ANDROID.ushaderbytecode for material shader code. Total 3053 unique shaders.LogShaderLibrary: Display: Cooked Context: Using Shared Shader Library PSOExampleLogRHI: Display: Opened pipeline cache after state change and enqueued 0 of 0 tasks for precompile.LogRHI: Base name for record PSOs is ../../../PSOExample/Saved/CollectedPSOs/++UE4+Release-4.25-CL-13942748-PSOExample_GLSL_ES3_1_ANDROID_00087B4B08D905BBC5A827F40CA03A0C.rec.upipelinecacheLogRHI: FPipelineCacheFile Header Game ue_version: 13942748LogRHI: FPipelineCacheFile Header Engine Data ue_version: 17LogRHI: FPipelineCacheFile Header TOC Offset: 38155LogRHI: FPipelineCacheFile File Size: 51011 BytesLogRHI: Opened FPipelineCacheFile: ../../../PSOExample/Content/PipelineCaches/Android/PSOExample_GLSL_ES3_1_ANDROID.stable.upipelinecache (GUID: 00000000000000000000000000000000) with 102 entries.LogRHI: Scanning Binary program cache, using Shader Pipeline Cache version 6988202F47BA858F3F0DE483D7DB0606LogRHI: AndroidEGL:SwapBuffers eglGetCompositorTimingANDROID EGL_COMPOSITE_DEADLINE_ANDROID=2718926192606265, EGL_COMPOSITE_INTERVAL_ANDROID=16559027, EGL_COMPOSITE_TO_PRESENT_LATENCY_ANDROID=14559027 PSO Cache 的加载与热更 与ShaderCode类似，引擎在启动时也是会自动加载 PSO Cache 的，在 FEngineLoop 中通过调用 FPipelineCacheFile::OpenPipelineFileCache 读取 *.stable.upipelinecache 的。 在 PreInitPreStartupScreen 中加载 PSO 的代码： Runtime/Launch/Private/LaunchEngineLoop.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344int32 FEngineLoop::PreInitPreStartupScreen(const TCHAR* CmdLine)&#123; // ... &#123; bool bUseCodeLibrary = FPlatformProperties::RequiresCookedData() || GAllowCookedDataInEditorBuilds; if (bUseCodeLibrary) &#123; &#123; SCOPED_BOOT_TIMING(&quot;FShaderCodeLibrary::InitForRuntime&quot;); // Will open material shader code storage if project was packaged with it // This only opens the Global shader library, which is always in the content dir. FShaderCodeLibrary::InitForRuntime(GMaxRHIShaderPlatform); &#125; #if !UE_EDITOR // Cooked data only - but also requires the code library - game only if (FPlatformProperties::RequiresCookedData()) &#123; SCOPED_BOOT_TIMING(&quot;FShaderPipelineCache::Initialize&quot;); // Initialize the pipeline cache system. Opening is deferred until the manual call to // OpenPipelineFileCache below, after content pak&#x27;s ShaderCodeLibraries are loaded. FShaderPipelineCache::Initialize(GMaxRHIShaderPlatform); &#125; #endif //!UE_EDITOR &#125; &#125; // ... //Handle opening shader library after our EarlyLoadScreen &#123; LLM_SCOPE(ELLMTag::Shaders); SCOPED_BOOT_TIMING(&quot;FShaderCodeLibrary::OpenLibrary&quot;); // Open the game library which contains the material shaders. FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::ProjectContentDir()); for (const FString&amp; RootDir : FPlatformMisc::GetAdditionalRootDirectories()) &#123; FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::Combine(RootDir, FApp::GetProjectName(), TEXT(&quot;Content&quot;))); &#125; // Now our shader code main library is opened, kick off the precompile, if already initialized FShaderPipelineCache::OpenPipelineFileCache(GMaxRHIShaderPlatform); &#125; // ...&#125; FShaderPipelineCache::OpenPipelineFileCache有两个重载版本： Runtime\\RenderCore\\Private\\ShaderPipelineCache.cpp123456789101112131415161718192021222324252627bool FShaderPipelineCache::OpenPipelineFileCache(EShaderPlatform Platform)&#123; bool bFileOpen = false; if (GConfig) &#123; FString LastOpenedName; if ((GConfig-&gt;GetString(FShaderPipelineCacheConstants::SectionHeading, FShaderPipelineCacheConstants::LastOpenedKey, LastOpenedName, *GGameUserSettingsIni) || GConfig-&gt;GetString(FShaderPipelineCacheConstants::SectionHeading, FShaderPipelineCacheConstants::LastOpenedKey, LastOpenedName, *GGameIni)) &amp;&amp; LastOpenedName.Len()) &#123; bFileOpen = OpenPipelineFileCache(LastOpenedName, Platform); &#125; &#125; if (!bFileOpen) &#123; bFileOpen = OpenPipelineFileCache(FApp::GetProjectName(), Platform); &#125; return bFileOpen;&#125;bool FShaderPipelineCache::OpenPipelineFileCache(FString const&amp; Name, EShaderPlatform Platform)&#123; if (ShaderPipelineCache) return ShaderPipelineCache-&gt;Open(Name, Platform); else return false;&#125; 引擎启动的时候默认读取的就是 OpenPipelineFileCache(FApp::GetProjectName(), Platform)，也就是PSOExample_GLSL_ES3_1_ANDROID.stable.upipelinecache，Platform 参数可以通过传递全局对象GMaxRHIShaderPlatform 来获取当前运行的平台。 UE 也提供了一个 console 命令可以指定加载stable.upipelinecache：r.ShaderPipelineCache.Open，还有几个其他控制 PSO 的 console 命令： Runtime/RenderCore/Private/ShaderPipelineCache.cpp1234567891011121314151617181920212223static FAutoConsoleCommand LoadPipelineCacheCmd( TEXT(&quot;r.ShaderPipelineCache.Open&quot;), TEXT(&quot;Takes the desired filename to open and then loads the pipeline file cache.&quot;), FConsoleCommandWithArgsDelegate::CreateStatic(ConsoleCommandLoadPipelineFileCache) );static FAutoConsoleCommand SavePipelineCacheCmd( TEXT(&quot;r.ShaderPipelineCache.Save&quot;), TEXT(&quot;Save the current pipeline file cache.&quot;), FConsoleCommandDelegate::CreateStatic(ConsoleCommandSavePipelineFileCache) );static FAutoConsoleCommand ClosePipelineCacheCmd( TEXT(&quot;r.ShaderPipelineCache.Close&quot;), TEXT(&quot;Close the current pipeline file cache.&quot;), FConsoleCommandDelegate::CreateStatic(ConsoleCommandClosePipelineFileCache) );static FAutoConsoleCommand SwitchModePipelineCacheCmd( TEXT(&quot;r.ShaderPipelineCache.SetBatchMode&quot;), TEXT(&quot;Sets the compilation batch mode, which should be one of:\\n\\tPause: Suspend precompilation.\\n\\tBackground: Low priority precompilation.\\n\\tFast: High priority precompilation.&quot;), FConsoleCommandWithArgsDelegate::CreateStatic(ConsoleCommandSwitchModePipelineCacheCmd) ); 这样只需要在热更包中包含最新的 *.stable.upipelinecache，之后调用OpenPipelineFileCache 加载最新的 PSO Cache 即可，可以与 ShaderCode 的热更流程保持一致。 生成新的 PSO Cache 需要关键的两种数据： 运行时捕获的 PSO 数据（upipelinecache） ShaderStableInfo（位于 Metadata 目录下） 因为 ShaderCode 是可以热更的，而 ShaderStableInfo 可以通过 Cook 最新的工程获得，所以 PSO Cache 也是可以通过热更 Shader 并不断地捕获最新的 PSO 数据进行迭代更新的。准备有时间给 HotPacther 中增加 PSO Caching 的热更功能，这样也可以把 PSO Caching 的部署和打包集成至自动化地热更流程，先挖个坑。 因为当开启了 r.ShaderPipelineCache.Enabled=1，在引擎启动时就会自动加载项目的 PSO Cache，而引擎中做了限制，只能够加载一次，后续调用OpenPipelineFileCache 的都不会被加载： Runtime\\RHI\\Private\\PipelineFileCache.cpp123456789101112131415161718192021222324bool FPipelineFileCache::OpenPipelineFileCache(FString const&amp; Name, EShaderPlatform Platform, FGuid&amp; OutGameFileGuid)&#123; bool bOk = false; OutGameFileGuid = FGuid(); if(IsPipelineFileCacheEnabled()) &#123; FRWScopeLock Lock(FileCacheLock, SLT_Write); if(FileCache == nullptr) &#123; FileCache = new FPipelineCacheFile(); bOk = FileCache-&gt;OpenPipelineFileCache(Name, Platform, OutGameFileGuid); // File Cache now exists - these caches should be empty for this file otherwise will have false positives from any previous file caching - if not something has been caching when it should not be check(NewPSOs.Num() == 0); check(NewPSOHashes.Num() == 0); check(RunTimeToPSOUsage.Num() == 0); &#125; &#125; return bOk;&#125; 当引擎默认加载执行之后 FileCache 就不为 nullptr 了，后续所有的加载调用都会直接返回 false，解决办法就是，让引擎启动时不自动加载 PSO Cache，等到运行时热更之后由我们手动加载，翻了下代码，可以从这个IsPipelineFileCacheEnabled 检测中做： Runtime\\RHI\\Private\\PipelineFileCache.cpp123456789101112bool FPipelineFileCache::IsPipelineFileCacheEnabled()&#123; static bool bOnce = false; static bool bCmdLineForce = false; if (!bOnce) &#123; bOnce = true; bCmdLineForce = FParse::Param(FCommandLine::Get(), TEXT(&quot;psocache&quot;)); UE_CLOG(bCmdLineForce, LogRHI, Warning, TEXT(&quot;****************************** Forcing PSO cache from command line&quot;)); &#125; return FileCacheEnabled &amp;&amp; (bCmdLineForce || CVarPSOFileCacheEnabled.GetValueOnAnyThread() == 1);&#125; 它的返回值依赖了两个值：FileCacheEnabled以及CVarPSOFileCacheEnabled。 FileCacheEnabled在 FPipelineFileCache::Initialize 中被赋值，IOS 之外的平台总是 true，IOS 则依赖于FPipelineFileCache::ShouldEnableFileCache 的结果。 CVarPSOFileCacheEnabled是一个控制台变量，用来控制 r.ShaderPipelineCache.Enabled 的值： Runtime\\RHI\\Private\\PipelineFileCache.cpp123456static TAutoConsoleVariable&lt;int32&gt; CVarPSOFileCacheEnabled( TEXT(&quot;r.ShaderPipelineCache.Enabled&quot;), PIPELINE_CACHE_DEFAULT_ENABLED, TEXT(&quot;1 Enables the PipelineFileCache, 0 disables it.&quot;), ECVF_Default | ECVF_RenderThreadSafe ); 我们需要做的有三步： 引擎默认启动时 CVarPSOFileCacheEnabled 的值为 false 运行时手动修改 CVarPSOFileCacheEnabled 值，开启 PSO Cache 加载 PSO Cache 具体实现流程： 在 DefaultEngine.ini 中将 r.ShaderPipelineCache.Enabled=0 并打包 DefaultEngine.ini12[ConsoleVariables]r.ShaderPipelineCache.Enabled=0 然后写两个函数在运行时开启和加载 PSO： 1234567891011121314151617181920#include &quot;ShaderPipelineCache.h&quot;#include &quot;RHIShaderFormatDefinitions.inl&quot;#include &quot;HAL/IConsoleManager.h&quot;bool UFlibShaderPipelineCacheHelper::EnableShaderPipelineCache(bool bEnable)&#123; UE_LOG(LogHotPatcher,Display,TEXT(&quot;EnableShaderPipelineCache %s&quot;),bEnable?TEXT(&quot;true&quot;):TEXT(&quot;false&quot;)); auto Var = IConsoleManager::Get().FindConsoleVariable(TEXT(&quot;r.ShaderPipelineCache.Enabled&quot;)); if(Var) &#123; Var-&gt;Set(bEnable ? 1 : 0); &#125; return !!Var;&#125;bool UFlibShaderPipelineCacheHelper::LoadShaderPipelineCache(const FString&amp; Name)&#123; UE_LOG(LogHotPatcher,Display,TEXT(&quot;Load Shader pipeline cache %s for platform %d&quot;),*Name,*ShaderPlatformToShaderFormatName(GMaxRHIShaderPlatform).ToString()); return FShaderPipelineCache::OpenPipelineFileCache(Name,GMaxRHIShaderPlatform);&#125; 这样即可实现 PSO Cache 的延迟加载，手动加载时机在热更之后加载即可。 延迟采集和存储 因为采集和存储 PSO Cache 具有额外的性能消耗，所以可以把采集和存储 PSO 数据关闭，根据需求在运行时再开启。在 DefaultEngine.ini 中关闭 LogPSO 和SaveBoundPSOLog，打基础包时就不会自动采集和自动存储了： DefaultEngine.ini123[ConsoleVariables]r.ShaderPipelineCache.LogPSO=0r.ShaderPipelineCache.SaveBoundPSOLog=0 然后在运行时开启： 12345678910111213141516171819202122232425262728293031323334UENUM(BlueprintType)enum class EPSOSaveMode : uint8&#123; Incremental = 0, // Fast(er) approach which saves new entries incrementally at the end of the file, replacing the table-of-contents, but leaves everything else alone. BoundPSOsOnly = 1, // Slower approach which consolidates and saves all PSOs used in this run of the program, removing any entry that wasn&#x27;t seen, and sorted by the desired sort-mode. SortedBoundPSOs = 2 // Slow save consolidates all PSOs used on this device that were never part of a cache file delivered in game-content, sorts entries into the desired order and will thus read-back from disk.&#125;;bool UFlibShaderPipelineCacheHelper::SavePipelineFileCache(EPSOSaveMode Mode)&#123; return FShaderPipelineCache::SavePipelineFileCache((FPipelineFileCache::SaveMode)Mode);&#125;bool UFlibShaderPipelineCacheHelper::EnableLogPSO(bool bEnable)&#123; UE_LOG(LogHotPatcher,Display,TEXT(&quot;EnableLogPSO %s&quot;),bEnable?TEXT(&quot;true&quot;):TEXT(&quot;false&quot;)); auto Var = IConsoleManager::Get().FindConsoleVariable(TEXT(&quot;r.ShaderPipelineCache.LogPSO&quot;)); if(Var) &#123; Var-&gt;Set(bEnable ? 1 : 0); &#125; return !!Var;&#125;bool UFlibShaderPipelineCacheHelper::EnableSaveBoundPSOLog(bool bEnable)&#123; UE_LOG(LogHotPatcher,Display,TEXT(&quot;EnableSaveBoundPSOLog %s&quot;),bEnable?TEXT(&quot;true&quot;):TEXT(&quot;false&quot;)); auto Var = IConsoleManager::Get().FindConsoleVariable(TEXT(&quot;r.ShaderPipelineCache.SaveBoundPSOLog&quot;)); if(Var) &#123; Var-&gt;Set(bEnable ? 1 : 0); &#125; return !!Var;&#125; 开启 SaveBoundPSOLog 后会自动存储采集的 PSO 数据，可以不开启自动存储，在运行时通过调用 FShaderPipelineCache::SavePipelineFileCache 手动存储。 错误处理 Cook 没有生成.scl.csv 注意，一定要为项目开启ShaderStableKeys，不然不会生成.scl.csv 文件。 运行时没有生成 upipelinecache 文件 请严格按照 运行时捕获 PSO 数据 中的步骤执行。 确认是否开启r.ShaderPipelineCache.Enabled（DefaultEngine.ini 或 DeviceProfile）。 在 ue4commandline.txt 中添加 -logPSO 参数。 Bad PSO如果使用公版引擎，上述流程就是完整的流程，但是有时项目需要修改引擎支持一些渲染特性，如添加 Multi-subpasshint 支持： Runtime\\RHI\\Public\\PipelineFileCache.h123456789101112struct RHI_API FPipelineCacheFileFormatPSO&#123; // ... struct RHI_API GraphicsDescriptor &#123; // uint8 SubpassHint; to SubpassHint[8]; uint8 SubpassHint[8]; uint8 SubpassIndex; // ... &#125;; // ...&#125;; 这处变动需要同时修改 GraphicsDescriptor::StateToString() 与GraphicsDescriptor::StateFromString()两个函数，加入 multi-subpasshint 的序列化支持。 但是，修改之后使用 -run=ShaderPipelineCacheTools 生成 *.stablepc.csv 时有以下报错的 Log： 12345678910111213141516171819202122LogShaderPipelineCacheTools: Expanding matched 1 files: D:\\PipelineCaches\\*.rec.upipelinecacheLogShaderPipelineCacheTools: : D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecacheLogShaderPipelineCacheTools: Expanding matched 2 files: D:\\PipelineCaches\\*.scl.csvLogShaderPipelineCacheTools: : D:\\PipelineCaches\\ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csvLogShaderPipelineCacheTools: : D:\\PipelineCaches\\ShaderStableInfo-PSOCaching-GLSL_ES3_1_ANDROID.scl.csvLogShaderPipelineCacheTools: Display: Loading D:\\PipelineCaches\\ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv...LogShaderPipelineCacheTools: Display: Loading D:\\PipelineCaches\\ShaderStableInfo-PSOCaching-GLSL_ES3_1_ANDROID.scl.csv...LogShaderPipelineCacheTools: Display: Loaded 926 shader info lines from D:\\PipelineCaches\\ShaderStableInfo-Global-GLSL_ES3_1_ANDROID.scl.csv.LogShaderPipelineCacheTools: Display: Loaded 9266 shader info lines from D:\\PipelineCaches\\ShaderStableInfo-PSOCaching-GLSL_ES3_1_ANDROID.scl.csv.LogShaderPipelineCacheTools: Display: Loaded 10192 unique shader info lines total.LogShaderPipelineCacheTools: Display: Loading D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache....LogShaderPipelineCacheTools: Display: Loaded 115 PSOsLogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache]LogShaderPipelineCacheTools: Warning: Bad PSO found discarding [Invertibility=FAIL Verify=PASS in: D:\\PipelineCaches\\++UE4+Release-4.25-CL-0-PSOCaching_GLSL_ES3_1_ANDROID_0008BF4D08D9069169A7B6820601243D.rec.upipelinecache] 这是因为 PSO 数据从 String 的可逆性验证失败了： Editor\\UnrealEd\\Private\\Commandlets\\ShaderPipelineCacheToolsCommandlet.cpp123456789101112131415161718192021222324252627282930bool CheckPSOStringInveribility(const FPipelineCacheFileFormatPSO&amp; Item)&#123; FPipelineCacheFileFormatPSO TempItem(Item); TempItem.Hash = 0; FString StringRep; if (Item.Type == FPipelineCacheFileFormatPSO::DescriptorType::Compute) &#123; StringRep = TempItem.ComputeDesc.ToString(); &#125; else &#123; StringRep = TempItem.GraphicsDesc.ToString(); &#125; FPipelineCacheFileFormatPSO DupItem; FMemory::Memzero(DupItem.GraphicsDesc); DupItem.Type = Item.Type; DupItem.UsageMask = Item.UsageMask; if (Item.Type == FPipelineCacheFileFormatPSO::DescriptorType::Compute) &#123; DupItem.ComputeDesc.FromString(StringRep); &#125; else &#123; DupItem.GraphicsDesc.FromString(StringRep); &#125; UE_LOG(LogShaderPipelineCacheTools, Verbose, TEXT(&quot;CheckPSOStringInveribility: %s&quot;), *StringRep); return (DupItem == TempItem) &amp;&amp; (GetTypeHash(DupItem) == GetTypeHash(TempItem));&#125; 关键部分在于 DupItem.GraphicsDesc.FromString(StringRep); 这行代码中 GraphicsDesc 的数据没有恢复成功。 经过调试发现，引擎中具有记录 PipelineCacheGraphicsDesc 的字符串中可被解析元素的数量，也就是生成的 *.stablepc.csv 中第二列中数据的数量，公版引擎中默认是 63 个，使用 FPipelineCacheGraphicsDescPartsNum 记录： Runtime\\RHI\\Private\\PipelineFileCache.cpp1const int32 FPipelineCacheGraphicsDescPartsNum = 63; // parser will expect this number of parts in a description string 生成的 *.stablepc.csv 中各项状态和数据如下： 刚好是 63 个。需要注意的是，在 GraphicsDescriptor::StateFromString 对数据的数量做了检测，FromString 的数据数量要与 FPipelineCacheGraphicsDescPartsNum 的值一致： Runtime\\RHI\\Private\\PipelineFileCache.cpp123456789101112131415bool FPipelineCacheFileFormatPSO::GraphicsDescriptor::StateFromString(const FStringView&amp; Src)&#123; constexpr int32 PartCount = FPipelineCacheGraphicsDescPartsNum; TArray&lt;FStringView, TInlineAllocator&lt;PartCount&gt;&gt; Parts; UE::String::ParseTokens(Src.TrimStartAndEnd(), TEXT(&#x27;,&#x27;), [&amp;Parts](FStringView Part) &#123; Parts.Add(Part); &#125;); // check if we have expected number of parts if (Parts.Num() != PartCount) &#123; // instead of crashing let caller handle this case return false; &#125; // ...&#125; 因为我们增加了 multi-subpasshint 支持，把 SubpassHint 从uint8改成了 uint8[8]，增加了 7 个数据，所以与之对应的FPipelineCacheGraphicsDescPartsNum 也要加 7，改为 70，上面 StateFromString 验证才能够通过。 修改之后再通过 -run=ShaderPipelineCacheTools 生成 *.stablepc.csv 就没有 Bas PSO 的错误了。 使用与配置 Compiling &amp; Using PSO Caching Data 可以通过 FShaderPipelineCache 的函数在运行时控制构建 PSO 数据： Runtime\\RenderCore\\Public\\ShaderPipelineCache.h12345678910/** Pauses precompilation. */static void PauseBatching();/** Resumes precompilation batching. */static void ResumeBatching();/** Returns the number of pipelines waiting for precompilation. */static uint32 NumPrecompilesRemaining();/** Returns the number of pipelines actively being precompiled this frame. */static uint32 NumPrecompilesActive();/** Sets the precompilation batching mode. */static void SetBatchMode(BatchMode Mode); 官方建议的做法是在加载屏幕时等待 PSO 构建完毕，再把 LoadingScreen 隐藏： 12345678if(FShaderPipelineCache::NumPrecompilesRemaining() &gt; 0)&#123; if (OutDebugReason != nullptr) &#123; *OutDebugReason = FString(TEXT(&quot;PC: PSO cache still compiling&quot;)); &#125; return true;&#125; 也可以在打开 UI、过场动画、暂停菜单时构建，通过以下三个函数组合处理： 123456789101112// 暂停 PSO 缓存编译FShaderPipelineCache::PauseBatching();// 设置 PSO 的处理模式// enum class BatchMode// &#123; // Background, // The maximum batch size is defined by r.ShaderPipelineCache.BackgroundBatchSize// Fast, // The maximum batch size is defined by r.ShaderPipelineCache.BatchSize// Precompile // The maximum batch size is defined by r.ShaderPipelineCache.PrecompileBatchSize// &#125;;FShaderPipelineCache::SetBatchMode(FShaderPipelineCache::BatchMode::Background);// 恢复编译 PSOstatic void ResumeBatching(); 也可以使用配置在游戏启动时自动构建，修改 DefaultEngine.ini 中[ConsoleVariables]的配置，它们否时定义在 Runtime\\RenderCore\\Private\\ShaderPipelineCache.cpp 中的ConsoleVariable，可以根据自己的需要在运行时或配置文件中进行修改： PSO 引擎默认配置: DefaultEngine.ini123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[ConsoleVariables];Sets the startup mode for the PSO cache, determining what the cache does after initialisation:;0: Precompilation is paused and nothing will compile until a call to ResumeBatching().;1: Precompilation is enabled in the &#x27;Fast&#x27; mode.;2: Precompilation is enabled in the &#x27;Background&#x27; mode.;Default is 1.r.ShaderPipelineCache.StartupMode=1;Set the number of PipelineStateObjects to compile in a single batch operation when compiling takes priority. Defaults to a maximum of 50 per frame, due to async. file IO it is less in practice.r.ShaderPipelineCache.BackgroundBatchSize=1;Set the number of PipelineStateObjects to compile in a single batch operation when pre-optimizing the cache. Defaults to a maximum of 50 per frame, due to async. file IO it is less in practice.r.ShaderPipelineCache.PrecompileBatchSize=50;The target time (in ms) to spend precompiling each frame when in the background or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 0.0 (off).r.ShaderPipelineCache.BackgroundBatchTime=0.0;The target time (in ms) to spend precompiling each frame when compiling takes priority or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 16.0 (max. ms per-frame of precompilation).r.ShaderPipelineCache.BatchTime=16.0;The target time (in ms) to spend precompiling each frame when cpre-optimizing or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 10.0 (off).r.ShaderPipelineCache.PrecompileBatchTime=0.0;Set the number of PipelineStateObjects to log before automatically saving. 0 will disable automatic saving. Shipping defaults to 0, otherwise default is 100.r.ShaderPipelineCache.SaveAfterPSOsLogged=100;Set the time where any logged PSO&#x27;s will be saved if the number is &lt; r.ShaderPipelineCache.SaveAfterPSOsLogged. Disabled when r.ShaderPipelineCache.SaveAfterPSOsLogged is 0;Set the time where any logged PSO&#x27;s will be saved if the number is &lt; r.ShaderPipelineCache.SaveAfterPSOsLogged. Disabled when r.ShaderPipelineCache.SaveAfterPSOsLogged is 0r.ShaderPipelineCache.AutoSaveTime=30;Mask used to precompile the cache. Defaults to all PSOs (-1)r.ShaderPipelineCache.PreCompileMask=-1;Set the time where any logged PSO&#x27;s will be saved when -logpso is on the command line.r.ShaderPipelineCache.AutoSaveTimeBoundPSO=10;If &gt; 0 then a log of all bound PSOs for this run of the program will be saved to a writable user cache file. Defaults to 0 but is forced on with -logpso.r.ShaderPipelineCache.SaveBoundPSOLog=0;Set non zero to use GameFileMask during PSO precompile - recording should always save out the usage masks to make that data availble when needed.r.ShaderPipelineCache.GameFileMaskEnabled=0;Set non zero to PreOptimize PSOs - this allows some PSOs to be compiled in the foreground before going in to gamer.ShaderPipelineCache.PreOptimizeEnabled=0;The minimum bind count to allow a PSO to be precompiled. Changes to this value will not affect PSOs that have already been removed from consideration.r.ShaderPipelineCache.MinBindCount=0;The maximum time to allow a PSO to be precompiled. if greather than 0, the amount of wall time we will allow pre-compile of PSOs and then switch to background processing.r.ShaderPipelineCache.MaxPrecompileTime=0.0 我修改的配置: DefaultEngine.ini123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[ConsoleVariables];Sets the startup mode for the PSO cache, determining what the cache does after initialisation:;0: Precompilation is paused and nothing will compile until a call to ResumeBatching().;1: Precompilation is enabled in the &#x27;Fast&#x27; mode.;2: Precompilation is enabled in the &#x27;Background&#x27; mode.;Default is 1.r.ShaderPipelineCache.StartupMode=1;Set the number of PipelineStateObjects to compile in a single batch operation when compiling takes priority. Defaults to a maximum of 50 per frame, due to async. file IO it is less in practice.r.ShaderPipelineCache.BatchSize=50;The target time (in ms) to spend precompiling each frame when compiling takes priority or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 16.0 (max. ms per-frame of precompilation).r.ShaderPipelineCache.BatchTime=16.0;Set the number of PipelineStateObjects to compile in a single batch operation when compiling takes priority. Defaults to a maximum of 50 per frame, due to async. file IO it is less in practice.r.ShaderPipelineCache.BackgroundBatchSize=1;Set the number of PipelineStateObjects to compile in a single batch operation when pre-optimizing the cache. Defaults to a maximum of 50 per frame, due to async. file IO it is less in practice.r.ShaderPipelineCache.PrecompileBatchSize=50;The target time (in ms) to spend precompiling each frame when in the background or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 0.0 (off).r.ShaderPipelineCache.BackgroundBatchTime=11.0;The target time (in ms) to spend precompiling each frame when cpre-optimizing or 0.0 to disable. When precompiling is faster the batch size will grow and when slower will shrink to attempt to occupy the full amount. Defaults to 10.0 (off).r.ShaderPipelineCache.PrecompileBatchTime=10.0;Set the number of PipelineStateObjects to log before automatically saving. 0 will disable automatic saving. Shipping defaults to 0, otherwise default is 100.r.ShaderPipelineCache.SaveAfterPSOsLogged=100;Set the time where any logged PSO&#x27;s will be saved if the number is &lt; r.ShaderPipelineCache.SaveAfterPSOsLogged. Disabled when r.ShaderPipelineCache.SaveAfterPSOsLogged is 0;Set the time where any logged PSO&#x27;s will be saved if the number is &lt; r.ShaderPipelineCache.SaveAfterPSOsLogged. Disabled when r.ShaderPipelineCache.SaveAfterPSOsLogged is 0r.ShaderPipelineCache.AutoSaveTime=30;Mask used to precompile the cache. Defaults to all PSOs (-1)r.ShaderPipelineCache.PreCompileMask=-1;Set the time where any logged PSO&#x27;s will be saved when -logpso is on the command line.r.ShaderPipelineCache.AutoSaveTimeBoundPSO=10;Set non zero to use GameFileMask during PSO precompile - recording should always save out the usage masks to make that data availble when needed.r.ShaderPipelineCache.GameFileMaskEnabled=0;Set non zero to PreOptimize PSOs - this allows some PSOs to be compiled in the foreground before going in to gamer.ShaderPipelineCache.PreOptimizeEnabled=1;The minimum bind count to allow a PSO to be precompiled. Changes to this value will not affect PSOs that have already been removed from consideration.r.ShaderPipelineCache.MinBindCount=30;The maximum time to allow a PSO to be precompiled. if greather than 0, the amount of wall time we will allow pre-compile of PSOs and then switch to background processing.r.ShaderPipelineCache.MaxPrecompileTime=33 开启了启动时自动构建 PSO 数据，会有以下 log： 1234567LogRHI: Base name for record PSOs is ../../../FGame/Saved/CollectedPSOs/++UE4+Release-4.25-CL-0-FGame_SF_METAL_8F3222B7964FE2A89C849E90E0000736.rec.upipelinecacheLogRHI: FPipelineCacheFile Header Game ue_version: 0LogRHI: FPipelineCacheFile Header Engine Data ue_version: 17LogRHI: FPipelineCacheFile Header TOC Offset: 293853LogRHI: FPipelineCacheFile File Size: 380497 BytesLogRHI: Opened FPipelineCacheFile: ../../../FGame/Content/PipelineCaches/IOS/FGame_SF_METAL.stable.upipelinecache (GUID: 00000000000000000000000000000000) with 690 entries.LogRHI: Display: Opened pipeline cache and enqueued 441 of 441 tasks for precompile with BatchSize 50 and BatchTime 10.000000. 也可以在 DefaultGameUserSettings.ini 中设置 PSO 的SortOrder： DefaultGameUserSettings.ini123456[ShaderPipelineCache.CacheFile];default is 0;Default = 0, // Whatever order they are already in.;FirstToLatestUsed = 1, // Start with the PSOs with the lowest first-frame used and work toward those with the highest.;MostToLeastUsed = 2 // Start with the most often used PSOs working toward the least.SortOrder=1 参考资料 PSO Caching。 Unreal Engine 4: PSO Caching (Pipeline State Object) to Reduce Load Times/Hitches UE4 渲染引擎模块简介(2)","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"PSO Caching","slug":"PSO-Caching","permalink":"https://ue5wiki.com/tags/PSO-Caching/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"}]},{"title":"UE4 从 UProperty 到 FProperty","date":"2021-04-10T00:00:00.000Z","path":"wiki/external1774438800/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 从 UProperty 到 FProperty。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}],"is_external":true,"jump_to":"https://papalqi.cn/%E8%93%9D%E5%9B%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"},{"title":"蓝图的一些细节","date":"2021-04-10T00:00:00.000Z","path":"wiki/external1995684526/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 蓝图的一些细节 。","tags":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"},{"name":"蓝图","slug":"蓝图","permalink":"https://ue5wiki.com/tags/%E8%93%9D%E5%9B%BE/"}],"categories":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/categories/Tip/"},{"name":"蓝图","slug":"Tip/蓝图","permalink":"https://ue5wiki.com/categories/Tip/%E8%93%9D%E5%9B%BE/"}],"is_external":true,"jump_to":"https://papalqi.cn/%E8%93%9D%E5%9B%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"},{"title":"UE4Chaos 框架解析","date":"2021-04-07T00:00:00.000Z","path":"wiki/external1797451917/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4Chaos 框架解析 。","tags":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"Chaos","permalink":"https://ue5wiki.com/tags/Chaos/"},{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"categories":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"物理系统/Chaos","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/Chaos/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/342638827"},{"title":"UE4Niagara 源码解析","date":"2021-04-07T00:00:00.000Z","path":"wiki/external1145587240/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4Niagara 源码解析 。","tags":[{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"特效粒子","slug":"特效粒子","permalink":"https://ue5wiki.com/tags/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/"},{"name":"Niagara","slug":"Niagara","permalink":"https://ue5wiki.com/tags/Niagara/"}],"categories":[{"name":"特效粒子","slug":"特效粒子","permalink":"https://ue5wiki.com/categories/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/"},{"name":"Niagara","slug":"特效粒子/Niagara","permalink":"https://ue5wiki.com/categories/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/Niagara/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/362638250"},{"title":"UE 性能分析：内存优化","date":"2021-03-30T10:59:16.000Z","path":"wiki/19135/","text":"在开发游戏时，程序性能是需要着重考虑的问题，因为要尽可能覆盖最多的用户群体，就要考虑那些中低端设备的运行效果，兼容非常多配置差异的硬件，在这种情况下，怎么样分析和优化游戏的性能瓶颈是关键。 在运行时把更多的资源加载至内存中，本质上是一种空间换时间的思路。因为频繁从磁盘进行 IO 是非常耗时的，把资源预先加载到内存就可以实现高速读取，但是内存资源也是有限的，并不能不加限制地使用，尤其是对某些中低端移动设备而言，4G 甚至更小的内存的设备目前还具有不少的占有率，所以在内存方面不能浪费，而且过高的内存占用也有可能导致被系统查杀。 内存优化本质上就是在加载效率和内存占用之间寻求一个平衡，怎么样在能满足兼容更多低配设备正常运行不触发 OOM 的同时尽可能地把可利用的内存使用起来，提高程序的运行效率。 准备写几篇性能优化相关的文章，本篇文章先从 UE 内存分析入手，介绍常用的内存分析工具和方法，以及对 UE 项目中能够进行的内存优化手段做一个整理，这部分内容之前以笔记的形式记录在 notes/ue 中，后续内存相关的内容都会补充到本篇文章。 内存优化其实主要就是从以下四个方面着手： 排查内存泄漏 裁剪多余模块 优化现有模块的内存占用 有损优化：砍内容（素材质量等） 三步走：查 bug、挤水分、砍需求。 内存分析工具 所以，在进行内存优化之前，首先要能够对 UE 项目的内存分布有一个大概的了解，可以使用 UE 提供的内存分析工具以及一些 Native 平台的分析工具。 内存分析资料： LLM UE4 内存 Profiler Android 平台上的 Native 内存分析 一些常用的 console command: 1234stat memory # 显示引擎中各个子系统的内存占用stat MemoryAllocator # 显示内存分配信息stat MemoryPlatform # 显示平台内存信息stat MemoryStaticMesh # 显示静态模型的内存信息 以及开启 LLM，在启动时加上 -LLM 参数 1234-LLM # 启用 LLM-LLMCSV # 连续将所有值写入 CSV 文件。自动启用 -LLM。-llmtagsets=Assets # 实验性功能。显示每个资源分配的内存总计。-llmtagsets=AssetClasses # 实验性功能。显示每个 UObject 类类型的总计。 然后就可以在运行时使用以下 console 命令： 1234stat llm # 显示 LLM 摘要。所有较低级别的引擎统计信息都归入单个引擎统计信息。stat llmfull # 显示 LLM 所有统计信息stat LLMPlatform # 显示从 OS 分配的所有内存信息 stat LLMOverhead # 显示 LLM 内部使用的内存 内存分析还可以使用以下工具： memreport MemoryProfiler Heapprofd(Android) Instrument(IOS) 在游戏的 console 中输入 memreport(-full) 会在 Saved/Profiling/Memreports 中创建地图目录以及 .memreport 文件，可以使用文本编辑器打开，能够看到游戏中各个部分的内存占用情况。 具体的内存分析工具的使用和对 UE 引擎中内存分配的分析流程有时间再详细补充，关于 LLM 的内容可以详情参考 UE 的文档。 内存优化方案 以下列举的优化方式，其实都是可选的，并不是一定要把所有的都做了就最好，因为内存优化要兼顾效率，所以可以根据项目需求在不同的设备上控制要优化的功能，尽可能再保证功能一致地情况下对低端机进行适配。 这里主要列举 UE 中哪些部分可以被优化以及如果做，具体的优化数据有时间慢慢分析和补充。 关闭不必要的功能支持 根据需求可以裁剪以下的引擎模块支持： APEX：如果不使用 Nvidia 的 APEX 破碎系统，可以在编译引擎时去掉 APEX 的支持。可以在 BuildSetting 或者 TargetRules 设置bCompileAPEX=true。 Recast(NavMesh)：如果客户端在运行时不需要 Recast 的支持，并且不需要客户端本地进行 NavMesh 寻路操作，可以运行时裁剪掉 NavMesh 的支持。可以在 BuildSetting 或者 TargetRules 设置bCompileRecast=true。 FreeType：是否需要 FreeType 字库支持，可以在 BuildSetting 或者 TargetRules 设置bCompileFreeType=true。 ICU(unicode/i18n)：引擎 Core 模块中对 unicode/i18n 的支持，可以在 BuildSetting 或者 TargetRules 设置bCompileICU=true。 CompileForSize：UE 提供的优化选项，可以控制编译时严格控制大小，但是会牺牲性能。可以在 BuildSetting 或者 TargetRules 设置bCompileForSize=true。 CEF3：可选是否支持Chromium Embedded Framework，Google 的嵌入式浏览器支持。可以在 BuildSetting 或者 TargetRules 设置bCompileCEF3=true。 bUsesSteam：是否使用 Steam，手游可以关闭，在 TargetRules 中通过 bUsesSteam 控制。 SpeedTree：如果游戏中不需要使用 SpeedTree 进行植被建模，可以关闭编译 SpeedTree，通过 TargetRules 中的 bOverrideCompileSpeedTree 控制。 Audio 模块：如果项目使用 WWise 等作为音频播放接口，如果完全不需要引擎中内置的 Audio 模块，该部分功能是冗余的，可以裁剪掉。 国际化模块：如果游戏的多语言支持不依赖 UE 的文本采集和翻译功能，可以裁剪掉该模块。 可以减少编译之后静态程序的大小以及减少不必要的执行逻辑。 控制 AssetRegistry 的序列化AssetRegistry 其实主要是在 Editor 下用来方便进行资源的查找和过滤操作，它的主要使用者是 ContentBrowser，这一点在 UE 的文档中也有描述：Asset Registry。 对于项目而言在 Runtime 可能没有需求来使用它，但是在 AssetRegistry 模块一启动就会把 AssetRegistry.bin 加载到内存中，如果对它没有需求其实这部分内存是浪费的。 好在 UE 提供了不序列化或者部分序列化 AssetRegistry 数据的方法，在 UAssetRegistryImpl 的构造函数中会调用 InitializeSerializationOptionsFromIni 函数来读取 DefaultEngine.ini 中的配置，并会构造出一个 FAssetRegistrySerializationOptions 结构来存储，它会在后续的 Serialize 函数中使用，用来控制把哪部分的数据序列化到 AssetRegistry 中。 Runtime/AssetRegistry/Private/AssetRegistry.cpp123456789101112131415161718192021222324void UAssetRegistryImpl::InitializeSerializationOptionsFromIni(FAssetRegistrySerializationOptions&amp; Options, const FString&amp; PlatformIniName) const&#123; FConfigFile* EngineIni = nullptr;#if WITH_EDITOR // Use passed in platform, or current platform if empty FConfigFile PlatformEngineIni; FConfigCacheIni::LoadLocalIniFile(PlatformEngineIni, TEXT(&quot;Engine&quot;), true, (!PlatformIniName.IsEmpty() ? *PlatformIniName : ANSI_TO_TCHAR(FPlatformProperties::IniPlatformName()))); EngineIni = &amp;PlatformEngineIni;#else // In cooked builds, always use the normal engine INI EngineIni = GConfig-&gt;FindConfigFile(GEngineIni);#endif EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeAssetRegistry&quot;), Options.bSerializeAssetRegistry); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeDependencies&quot;), Options.bSerializeDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeNameDependencies&quot;), Options.bSerializeSearchableNameDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeManageDependencies&quot;), Options.bSerializeManageDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializePackageData&quot;), Options.bSerializePackageData); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bUseAssetRegistryTagsWhitelistInsteadOfBlacklist&quot;), Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterAssetDataWithNoTags&quot;), Options.bFilterAssetDataWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterDependenciesWithNoTags&quot;), Options.bFilterDependenciesWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterSearchableNames&quot;), Options.bFilterSearchableNames); // ...&#125; 这个控制方式可以在打包时控制是否生成 AssetRegistry.bin，以及控制在运行时反序列化哪些 AssetRegistry 的数据（但是不会对 DevelopmentAssetRegistry.bin 造成影响，可以用它来进行资产审计）。 它的反序列化流程为： 检测 bSerializeAssetRegistry，如果为true 则把 AssetRegistry.bin 以二进制形式加载到内存中 通过 Serialize 函数来把二进制数据反序列化 释放加载 AssetRegistry.bin 所占用的内存 所以，AssetRegistry 的内存占用是在序列化之后的数据，而 FAssetRegistrySerializationOptions 就是控制把哪些数据序列化的。 Runtime/AssetRegistry/Public/AssetRegistryState.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** Load/Save options used to modify how the cache is serialized. These are read out of the AssetRegistry section of Engine.ini and can be changed per platform. */struct FAssetRegistrySerializationOptions&#123; /** True rather to load/save registry at all */ bool bSerializeAssetRegistry; /** True rather to load/save dependency info. If true this will handle hard and soft package references */ bool bSerializeDependencies; /** True rather to load/save dependency info for Name references, */ bool bSerializeSearchableNameDependencies; /** True rather to load/save dependency info for Manage references, */ bool bSerializeManageDependencies; /** If true will read/write FAssetPackageData */ bool bSerializePackageData; /** True if CookFilterlistTagsByClass is a whitelist. False if it is a blacklist. */ bool bUseAssetRegistryTagsWhitelistInsteadOfBlacklist; /** True if we want to only write out asset data if it has valid tags. This saves memory by not saving data for things like textures */ bool bFilterAssetDataWithNoTags; /** True if we also want to filter out dependency data for assets that have no tags. Only filters if bFilterAssetDataWithNoTags is also true */ bool bFilterDependenciesWithNoTags; /** Filter out searchable names from dependency data */ bool bFilterSearchableNames; /** The map of classname to tag set of tags that are allowed in cooked builds. This is either a whitelist or blacklist depending on bUseAssetRegistryTagsWhitelistInsteadOfBlacklist */ TMap&lt;FName, TSet&lt;FName&gt;&gt; CookFilterlistTagsByClass; FAssetRegistrySerializationOptions() : bSerializeAssetRegistry(false) , bSerializeDependencies(false) , bSerializeSearchableNameDependencies(false) , bSerializeManageDependencies(false) , bSerializePackageData(false) , bUseAssetRegistryTagsWhitelistInsteadOfBlacklist(false) , bFilterAssetDataWithNoTags(false) , bFilterDependenciesWithNoTags(false) , bFilterSearchableNames(false) &#123;&#125; /** Options used to read/write the DevelopmentAssetRegistry, which includes all data */ void ModifyForDevelopment() &#123; bSerializeAssetRegistry = bSerializeDependencies = bSerializeSearchableNameDependencies = bSerializeManageDependencies = bSerializePackageData = true; DisableFilters(); &#125; /** Disable all filters */ void DisableFilters() &#123; bFilterAssetDataWithNoTags = false; bFilterDependenciesWithNoTags = false; bFilterSearchableNames = false; &#125;&#125;; 配置的读取在以下代码中： Runtime/AssetRegistry/Private/AssetRegistry.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546void UAssetRegistryImpl::InitializeSerializationOptionsFromIni(FAssetRegistrySerializationOptions&amp; Options, const FString&amp; PlatformIniName) const&#123; FConfigFile* EngineIni = nullptr;#if WITH_EDITOR // Use passed in platform, or current platform if empty FConfigFile PlatformEngineIni; FConfigCacheIni::LoadLocalIniFile(PlatformEngineIni, TEXT(&quot;Engine&quot;), true, (!PlatformIniName.IsEmpty() ? *PlatformIniName : ANSI_TO_TCHAR(FPlatformProperties::IniPlatformName()))); EngineIni = &amp;PlatformEngineIni;#else // In cooked builds, always use the normal engine INI EngineIni = GConfig-&gt;FindConfigFile(GEngineIni);#endif EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeAssetRegistry&quot;), Options.bSerializeAssetRegistry); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeDependencies&quot;), Options.bSerializeDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeNameDependencies&quot;), Options.bSerializeSearchableNameDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializeManageDependencies&quot;), Options.bSerializeManageDependencies); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bSerializePackageData&quot;), Options.bSerializePackageData); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bUseAssetRegistryTagsWhitelistInsteadOfBlacklist&quot;), Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterAssetDataWithNoTags&quot;), Options.bFilterAssetDataWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterDependenciesWithNoTags&quot;), Options.bFilterDependenciesWithNoTags); EngineIni-&gt;GetBool(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;bFilterSearchableNames&quot;), Options.bFilterSearchableNames); TArray&lt;FString&gt; FilterlistItems; if (Options.bUseAssetRegistryTagsWhitelistInsteadOfBlacklist) &#123; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsWhitelist&quot;), FilterlistItems); &#125; else &#123; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsBlacklist&quot;), FilterlistItems); &#125; &#123; // this only needs to be done once, and only on builds using USE_COMPACT_ASSET_REGISTRY TArray&lt;FString&gt; AsFName; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsFName&quot;), AsFName); TArray&lt;FString&gt; AsPathName; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsPathName&quot;), AsPathName); TArray&lt;FString&gt; AsLocText; EngineIni-&gt;GetArray(TEXT(&quot;AssetRegistry&quot;), TEXT(&quot;CookedTagsAsLocText&quot;), AsLocText); FAssetRegistryState::IngestIniSettingsForCompact(AsFName, AsPathName, AsLocText); &#125; // ... &#125; 在 Config/DefaultEngine.ini 中创建AssetRegistrySection 使用上面的名字就可以控制 AssetRegistry 的序列化，减少打包时的包体大小以及内存占用（AssetRegistry 在引擎启动时会加载到内存中） DefaultEngine.ini123456[AssetRegistry]bSerializeAssetRegistry=falsebSerializeDependencies=falsebSerializeNameDependencies=falsebSerializeManageDependencies=falsebSerializePackageData=false 也可以对某个平台来单独指定，只需要修改平台相关的 Ini 文件： 123Config/Windows/WindowsEngine.iniConfig/Android/AndroidEngine.iniConfig/IOS/IOSEngine.ini 只加载所使用质量级别的 Shader默认情况下，引擎会把所有质量级别的 Shader 加载到内存中，在不需要实施切换画质的情况下，可以不加载未使用的质量级别，降低 Shader 的内存占用。 在Project Settings-Engine-Rendering-Materials-Game Discards Unused Material Quality Levels： 或者在 DefaultEngine.ini 中添加以下配置： DefaultEngine.ini12[/Script/Engine.RendererSettings]r.DiscardUnusedQuality=True When running in game mode, whether to keep shaders for all quality levels in memory or only those needed for the current quality level. Unchecked: Keep all quality levels in memory allowing a runtime quality level change.(default) Checked: Discard unused quality levels when loading content for the game, saving some memory. 减少 Shader 变体 可以通过减少母材制的数量以及在 Project Settings-Engine-Rendering 中开启下列选项： ShareMaterialShaderCode在打包时可以在 Project Settings-Packaging 中设置 Share Material Shader Code 和Shadred Material Native Libraries可以减小包体的大小，并且会减少内存占用（增加加载时间）。 123456789101112131415/** * By default shader code gets saved inline inside material assets, * enabling this option will store only shader code once as individual files * This will reduce overall package size but might increase loading time */UPROPERTY(config, EditAnywhere, Category=Packaging)bool bShareMaterialShaderCode;/** * By default shader shader code gets saved into individual platform agnostic files, * enabling this option will use the platform-specific library format if and only if one is available * This will reduce overall package size but might increase loading time */UPROPERTY(config, EditAnywhere, Category=Packaging, meta = (EditCondition = &quot;bShareMaterialShaderCode&quot;, ConfigRestartRequired = true))bool bSharedMaterialNativeLibraries; 开启了之后打出的包中会生成下列文件： 12ShaderArchive-Blank425-PCD3D_SM5.ushaderbytecodeShaderCode-Global-PCD3D_SM5.ushaderbytecode 但是，如果开启之后如果后续的 Cook 资源 Shader 发生了变动，而基础包内还是旧的 ShaderBytecode 信息，会导致材质丢失。 有三个办法： 后续的打包时可以把 Shaderbytecode 文件打包在 pak 中，挂载时加载； Cook 热更资源时把 Shaderbytecode 打包在资源内； 创建 ShaderPatch，在热更后加载； 热更 Shaderbytecode 更具体地实践流程可以在我之前对我文章 UE4 热更新：Create Shader Patch 中查看。 关闭 UMG 的模板化创建 引擎中有缓存蓝图控件加速创建的功能，但是会造成内存的浪费，可以配置关闭： 也可以直接修改引擎中的代码使用类内初始化给予默认值： Source\\Editor\\UMGEditor\\Public\\WidgetBlueprint.h12UPROPERTY(EditAnywhere, AdvancedDisplay, Category=WidgetBlueprintOptions, AssetRegistrySearchable)bool bForceSlowConstructionPath; 该变量在以下代码中被检测使用： Source\\Editor\\UMGEditor\\Private\\WidgetBlueprintCompiler.cpp123456789101112131415161718bool FWidgetBlueprintCompilerContext::CanAllowTemplate(FCompilerResultsLog&amp; MessageLog, UWidgetBlueprintGeneratedClass* InClass)&#123; // ... // If this widget forces the slow construction path, we can&#x27;t template it. if (WidgetBP-&gt;bForceSlowConstructionPath) &#123; if (GetDefault&lt;UUMGEditorProjectSettings&gt;()-&gt;CompilerOption_CookSlowConstructionWidgetTree(WidgetBP)) &#123; MessageLog.Note(*LOCTEXT(&quot;ForceSlowConstruction&quot;, &quot;Fast Templating Disabled By User.&quot;).ToString()); return false; &#125; else &#123; MessageLog.Error(*LOCTEXT(&quot;UnableToForceSlowConstruction&quot;, &quot;This project has [Cook Slow Construction Widget Tree] disabled, so [Force Slow Construction Path] is no longer allowed.&quot;).ToString()); &#125; &#125; // ...&#125; 关闭 pakcache引擎中默认启用了 PakCache 机制，在从 Pak 中读取文件时，会多读一段内存用作缓存，内存占用还是十分可观的（通过 stat memory 查看）： 游戏启动时会有 PakCache 的 Log： 1234[2021.03.23-10.49.21:354][445]LogPakFile: Precache HighWater 16MB[2021.03.23-10.49.21:382][447]LogPakFile: Precache HighWater 32MB[2021.03.23-10.49.21:442][450]LogPakFile: Precache HighWater 48MB[2021.03.23-10.49.21:470][452]LogPakFile: Precache HighWater 64MB 可以通过以下方式配置关闭： 12[ConsoleVariables]pakcache.Enable=0 关闭 PakCache 会带来频繁 IO 的问题，但是具体的性能影响细节要等有时间再来分析。 Unload pakentry filenames从 UE4.23 开始，引擎中提供了 Mount PakFile 的内存优化配置： DefaultEngine.ini12345[Pak]UnloadPakEntryFilenamesIfPossible=trueDirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Config/Tags/&quot;+DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Content/Localization/*&quot;ShrinkPakEntriesMemoryUsage=true 在 FPakPlatformFile 执行 Initialize 的时候会绑定FCoreDelegates::OnOptimizeMemoryUsageForMountedPaks，可以调用该 Delegate 来通知 PakPlatformFile 来优化已 mount 的 Pak 的内存。 Runtime\\PakFile\\Private\\IPlatformFilePak.cpp123456789101112131415161718192021222324252627282930313233void FPakPlatformFile::OptimizeMemoryUsageForMountedPaks()&#123;#if !(IS_PROGRAM || WITH_EDITOR) FSlowHeartBeatScope SuspendHeartBeat; bool bUnloadPakEntryFilenamesIfPossible = FParse::Param(FCommandLine::Get(), TEXT(&quot;unloadpakentryfilenames&quot;)); GConfig-&gt;GetBool(TEXT(&quot;Pak&quot;), TEXT(&quot;UnloadPakEntryFilenamesIfPossible&quot;), bUnloadPakEntryFilenamesIfPossible, GEngineIni); if ((bUnloadPakEntryFilenamesIfPossible &amp;&amp; !FParse::Param(FCommandLine::Get(), TEXT(&quot;nounloadpakentries&quot;))) || FParse::Param(FCommandLine::Get(), TEXT(&quot;unloadpakentries&quot;))) &#123; // With [Pak] UnloadPakEntryFilenamesIfPossible enabled, [Pak] DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames // can contain pak entry directory wildcards of which the entire recursive directory structure of filenames underneath a // matching wildcard will be kept. // // Example: // [Pak] // DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Config/Tags/&quot; // +DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Content/Localization/*&quot; TArray&lt;FString&gt; DirectoryRootsToKeep; GConfig-&gt;GetArray(TEXT(&quot;Pak&quot;), TEXT(&quot;DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames&quot;), DirectoryRootsToKeep, GEngineIni); FPakPlatformFile* PakPlatformFile = (FPakPlatformFile*)(FPlatformFileManager::Get().FindPlatformFile(FPakPlatformFile::GetTypeName())); PakPlatformFile-&gt;UnloadPakEntryFilenames(&amp;DirectoryRootsToKeep); &#125; bool bShrinkPakEntriesMemoryUsage = FParse::Param(FCommandLine::Get(), TEXT(&quot;shrinkpakentries&quot;)); GConfig-&gt;GetBool(TEXT(&quot;Pak&quot;), TEXT(&quot;ShrinkPakEntriesMemoryUsage&quot;), bShrinkPakEntriesMemoryUsage, GEngineIni); if (bShrinkPakEntriesMemoryUsage) &#123; FPakPlatformFile* PakPlatformFile = (FPakPlatformFile*)(FPlatformFileManager::Get().FindPlatformFile(FPakPlatformFile::GetTypeName())); PakPlatformFile-&gt;ShrinkPakEntriesMemoryUsage(); &#125;#endif&#125; UnloadPakEntryFilenamesIfPossible：允许卸载 PakEntry filenames 占用的内存 DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames：卸载 PakEntry filename 时要保留的目录 bShrinkPakEntriesMemoryUsage：缩小 PakEntry 的内存占用 当调用之后，如果开启 UnloadPakEntryFilenamesIfPossible 了，会通过计算 Pak 中文件名列表的 Hash 来节省内存，但是卸载 PakEntry filenames 之后无法再使用路径的通配符匹配。 Runtime\\PakFile\\Public\\IPlatformFilePak.h123456789101112131415/** Iterator class used to iterate over all files in pak. */class FFileIterator&#123; // ... /** * Saves memory by hashing the filenames, if possible. After this process, * wildcard scanning of pak entries can no longer be performed. Returns TRUE * if the process successfully unloaded filenames from this pak * * @param CrossPakCollisionChecker A map of hash-&gt;fileentry records encountered during filename unloading on other pak files. Used to detect collisions with entries in other pak files. * @param DirectoryRootsToKeep An array of strings in wildcard format that specify whole directory structures of filenames to keep in memory for directory iteration to work. * @param bAllowRetries If a collision is encountered, change the intial seed and try again a fixed number of times before failing */ bool UnloadPakEntryFilenames(TMap&lt;uint64, FPakEntry&gt;&amp; CrossPakCollisionChecker, TArray&lt;FString&gt;* DirectoryRootsToKeep = nullptr, bool bAllowRetries = true);&#125;; 压缩 TextureTexture 的压缩是有损压缩，能够减小包体大小以及加载到内存中的大小，虽然是有损压缩，但是在移动端质量降低的效果并不明显，可以根据项目情况进行设置。 之前的笔记中，提到过可以在 Project Settings-Cooker-Texture-ASTC Compression vs Size 可以设置默认的资源质量和大小的级别： 123450=12x12 1=10x10 2=8x8 3=6x6 4=4x4 在 Texture 的资源编辑中也可以针对某个 Texture 单独设置： Lowest-&gt;Hightest 对应着 0-4 的值，使用 Default 则使用项目设置中的配置。 并且，设置 Compression Settings 的类型也会对资源压缩的类型有差别，Default 则是项目设置中的参数，如果设置成 NormalMap 的类型会是 ASTC_4x4 的。 Using ASTC Texture Compression for Game Assets Texture Compression Settings UPDATE使用 Github Gist 管理的动态更新内容，在国内网络可能会无法查看。","tags":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"},{"name":"Memory","slug":"Memory","permalink":"https://ue5wiki.com/tags/Memory/"},{"name":"内存优化","slug":"内存优化","permalink":"https://ue5wiki.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"},{"name":"Memory","slug":"Optimization/Memory","permalink":"https://ue5wiki.com/categories/Optimization/Memory/"}]},{"title":"UE 热更新：Questions & Answers","date":"2021-03-12T10:45:44.000Z","path":"wiki/16895/","text":"HotPatcher项目开源这一年多以来，经过了不少的更新和优化，也被越来越多的开发者选择作为自己项目的热更新方案，期间有不少人陆陆续续询问 UE4 热更新相关遇到的问题，很多问题比较常见，重复询问的频率也比较多，所以我准备把一些常见的问题进行整理，方便初步上手 UE4 热更新方案的人能够尽快地排查问题。 本篇文章会持续更新 UE4 热更新和 HotPatcher 相关的 Q&amp;A 内容，有疑问的地方也可以直接在本篇文章中评论，我会定期统一回答和整理，也可以加入我的 UE4 热更新群讨论遇到的问题(QQ 群 958363331)。 HotPatcher 相关问题 是否可以用在商业项目中？可以，使用的是 MIT 开源协议。 是否可以热更 C++？不能，只能用来更新 uasset 和 Non-Asset（lua/db/json 等等）。 支持移动端热更吗？支持，本身 HotPatcher 是没有平台限制的，可以打包和管理 UE 支持的任意平台。 注意：使用 HotPatcher 打包时，需要避免一个目录既包含 uasset 又包含 non-asset 的情况，不然会导致未被 cook 的 uasset 打包。 热更新系列文章 我写的 UE4 热更新的系列文章，可以作为工程实践的参考： UE4 热更新：需求分析与方案设计 UE4 资源热更打包工具 HotPatcher UE4 热更新：基于 HotPatcher 的自动化流程 2020 Unreal Open Day UE4 热更新：拆分基础包 UE4 热更新：资产管理与审计工具 UE4 热更新：Create Shader Patch UE4 热更新：Questions &amp; Answers pak 的自动挂载目录 以下三个路径中的 Pak 会在引擎启动时自动挂载： Engine/Content/Paks GAME_DIR/Content/Paks GAME_DIR/Saved/Paks Runtime\\PakFile\\Private\\IPlatformFilePak.cpp12345678910111213141516171819void FPakPlatformFile::GetPakFolders(const TCHAR* CmdLine, TArray&lt;FString&gt;&amp; OutPakFolders)&#123;#if !UE_BUILD_SHIPPING // Command line folders FString PakDirs; if (FParse::Value(CmdLine, TEXT(&quot;-pakdir=&quot;), PakDirs)) &#123; TArray&lt;FString&gt; CmdLineFolders; PakDirs.ParseIntoArray(CmdLineFolders, TEXT(&quot;*&quot;), true); OutPakFolders.Append(CmdLineFolders); &#125;#endif // @todo plugin urgent: Needs to handle plugin Pak directories, too // Hardcoded locations OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::ProjectContentDir())); OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::ProjectSavedDir())); OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::EngineContentDir()));&#125; 这三个路径下的 pak 的默认优先级不同（除非通过_1_P.pak 这种形式命名）： Runtime\\PakFile\\Private\\IPlatformFilePak.cpp123456789101112131415161718192021int32 FPakPlatformFile::GetPakOrderFromPakFilePath(const FString&amp; PakFilePath)&#123; if (PakFilePath.StartsWith(FString::Printf(TEXT(&quot;%sPaks/%s-&quot;), *FPaths::ProjectContentDir(), FApp::GetProjectName()))) &#123; return 4; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectContentDir())) &#123; return 3; &#125; else if (PakFilePath.StartsWith(FPaths::EngineContentDir())) &#123; return 2; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectSavedDir())) &#123; return 1; &#125; return 0;&#125; Mount Point 的作用 在 Mount Pak 的时候，有一个参数可以指定 MountPoint: 1234567/*** Mounts a pak file at the specified path.** @param InPakFilename Pak filename.* @param InPath Path to mount the pak at.*/bool Mount(const TCHAR* InPakFilename, uint32 PakOrder, const TCHAR* InPath = NULL, bool bLoadIndex = true); 那么它是干什么的呢？首先从 Mount 函数开始： 1234if (InPath != NULL)&#123; Pak-&gt;SetMountPoint(InPath);&#125; 如果在调用 Mount 时传递了 InPath，则通过加载 Pak 的 FPakFile 实例调用SetMountPoint，把 InPath 设置给它。 其实在 FPakFile 中，MountPath 是有默认值的（从 Pak 文件中读取），在 FPakFile 的构造函数中调用了 Initialize(Reader, bLoadIndex);，Initialize 中又调用了LoadIndex，在LoadIndex 中从 Pak 中读取 Pak 的 Mount Point 的逻辑： 123456789101112131415161718192021222324252627282930313233// Runtime/PakFile/Private/IPlatformFilePak.cppvoid FPakFile::LoadIndex(FArchive* Reader)&#123; if (CachedTotalSize &lt; (Info.IndexOffset + Info.IndexSize)) &#123; UE_LOG(LogPakFile, Fatal, TEXT(&quot;Corrupted index offset in pak file.&quot;)); &#125; else &#123; if (Info.Version &gt;= FPakInfo::PakFile_Version_FrozenIndex &amp;&amp; Info.bIndexIsFrozen) &#123; SCOPED_BOOT_TIMING(&quot;PakFile_LoadFrozen&quot;); // read frozen data Reader-&gt;Seek(Info.IndexOffset); int32 FrozenSize = Info.IndexSize; // read in the index, etc data in one lump void* DataMemory = FMemory::Malloc(FrozenSize); Reader-&gt;Serialize(DataMemory, FrozenSize); Data = TUniquePtr&lt;FPakFileData&gt;((FPakFileData*)DataMemory); // cache the number of entries NumEntries = Data-&gt;Files.Num(); // @todo loadtime: it is nice to serialize the mountpoint right into the Data so that IndexSize is right here // but it takes this to copy it out, because it&#x27;s too painful for the string manipulation when dealing with // MemoryImageString everywhere MountPoint is used MountPoint = Data-&gt;MountPoint; &#125; // ... &#125; // ...&#125; 简单的可以理解为：如果 Mount 时不传递 Mount Point 就会从 Pak 文件中读取，如果有传入就设置为传入的值（Pak 文件中的 MountPoint 是 Pak 中所有文件的公共路径）。 那么，给 Pak 设置 MountPoint 的作用是什么呢？真实目的是，检测要加载的文件是否存在于当前 Pak 中！因为 Pak 的 Mount Point 的默认含义是当前 Pak 中所有文件的公共路径，所以只需要检测要读取的文件是否以这个路径开头，就可以首先排除掉基础路径不对的文件（基础路径都不对，意味着这个文件在 Pak 中也不存在）。 具体逻辑可以看这个函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Runtime/PakFile/Public/IPlatformFilePak.h/*** Finds a file in the specified pak files.** @param Paks Pak files to find the file in.* @param Filename File to find in pak files.* @param OutPakFile Optional pointer to a pak file where the filename was found.* @return Pointer to pak entry if the file was found, NULL otherwise.*/static bool FindFileInPakFiles(TArray&lt;FPakListEntry&gt;&amp; Paks,const TCHAR* Filename,FPakFile** OutPakFile,FPakEntry* OutEntry = nullptr)&#123; FString StandardFilename(Filename); FPaths::MakeStandardFilename(StandardFilename); int32 DeletedReadOrder = -1; for (int32 PakIndex = 0; PakIndex &lt; Paks.Num(); PakIndex++) &#123; int32 PakReadOrder = Paks[PakIndex].ReadOrder; if (DeletedReadOrder != -1 &amp;&amp; DeletedReadOrder &gt; PakReadOrder) &#123; //found a delete record in a higher priority patch level, but now we&#x27;re at a lower priority set - don&#x27;t search further back or we&#x27;ll find the original, old file. UE_LOG(LogPakFile, Verbose, TEXT(&quot;Delete Record: Accepted a delete record for %s&quot;), Filename ); return false; &#125; FPakFile::EFindResult FindResult = Paks[PakIndex].PakFile-&gt;Find(*StandardFilename, OutEntry); if (FindResult == FPakFile::EFindResult::Found) &#123; if (OutPakFile != NULL) &#123; *OutPakFile = Paks[PakIndex].PakFile; &#125; UE_CLOG(DeletedReadOrder != -1, LogPakFile, Verbose, TEXT(&quot;Delete Record: Ignored delete record for %s - found it in %s instead (asset was moved between chunks)&quot;), Filename, *Paks[PakIndex].PakFile-&gt;GetFilename()); return true; &#125; else if (FindResult == FPakFile::EFindResult::FoundDeleted) &#123; DeletedReadOrder = PakReadOrder; UE_LOG(LogPakFile, Verbose, TEXT(&quot;Delete Record: Found a delete record for %s in %s&quot;), Filename, *Paks[PakIndex].PakFile-&gt;GetFilename()); &#125; &#125; UE_CLOG(DeletedReadOrder != -1, LogPakFile, Warning, TEXT(&quot;Delete Record: No lower priority pak files looking for %s. (maybe not downloaded?)&quot;), Filename ); return false;&#125; 当我们从 Pak 中读取文件时，通过对游戏中所有 Mount 的 Pak 调用 Find 函数，而 FPakFile::Find 的函数就实现了上述我说的逻辑： 1234567891011// Runtime/PakFile/Private/IPlatformFilePak.cppFPakFile::EFindResult FPakFile::Find(const FString&amp; Filename, FPakEntry* OutEntry) const&#123; QUICK_SCOPE_CYCLE_COUNTER(PakFileFind); if (Filename.StartsWith(MountPoint)) &#123; FString Path(FPaths::GetPath(Filename)); // ... &#125; // ...&#125; 所以，MountPoint 的作用就是在从 Pak 中查找文件时，首先判断文件的路径是否与 Pak 中所有文件的 基础路径 相匹配（StartWith），如果不存在也就不会进入后续的流程了。 Pak 无法被挂载 在本体包中开启 signature 后，打包出来的 Pak 无法被挂载 同样是 pak 的 signature 的错误，是因为没有为 pak 生成对应的.sig 文件。Log 中的内容如下: 123LogPakFile: Warning: Couldn&#x27;t find pak signature file &#x27;../../../Pak/Content/Paks/1.0.3_WindowsNoEditor_P.pak&#x27;LogPakFile: Warning: Unable to create pak &quot;../../../Pak/Content/Paks/1.0.3_WindowsNoEditor_P.pak&quot; handleLogPakFile: Warning: Failed to mount pak &quot;../../../Pak/Content/Paks/1.0.3_WindowsNoEditor_P.pak&quot;, pak is invalid 这是因为打出本体包时 Project Setting-Crypto 中的 bEnablePakSigning 被设置成了 true，这样对打出来的包里的所有 pak 都会执行校验，目的就是为了确保 只有自己打包的 pak 才可以被加载。 相关的代码处理在： 123456789101112131415161718192021222324252627// Runtime/PakFile/Private/SignedArchiveReader.cppFChunkCacheWorker::FChunkCacheWorker(FArchive* InReader, const TCHAR* Filename) : Thread(nullptr) , Reader(InReader) , QueuedRequestsEvent(nullptr) , ChunkRequestAvailable(nullptr)&#123; FString SigFileFilename = FPaths::ChangeExtension(Filename, TEXT(&quot;sig&quot;)); FArchive* SigFileReader = IFileManager::Get().CreateFileReader(*SigFileFilename); if (SigFileReader == nullptr) &#123; UE_LOG(LogPakFile, Fatal, TEXT(&quot;Couldn&#x27;t find pak signature file &#x27;%s&#x27;&quot;), *SigFileFilename); &#125; Signatures.Serialize(*SigFileReader); delete SigFileReader; Signatures.DecryptSignatureAndValidate(Filename); const bool bEnableMultithreading = FPlatformProcess::SupportsMultithreading(); if (bEnableMultithreading) &#123; QueuedRequestsEvent = FPlatformProcess::GetSynchEventFromPool(); ChunkRequestAvailable = FPlatformProcess::GetSynchEventFromPool(); Thread = FRunnableThread::Create(this, TEXT(&quot;FChunkCacheWorker&quot;), 0, TPri_BelowNormal); &#125;&#125; 所以，如果在用 HotPatcher 打包 pak 时没有与项目指定相同的加密参数，则导致放入包内的 pak 会加载失败（因为验证失败了）。解决的办法就是，在使用 HotPatcher 时指定与项目相同的加密信息，当直接使用 UE 打出本体包时，会默认在下列路径中生成一个 Crypto.json 文件： 1PROJECT_DIRECTORY\\Saved\\Cooked\\WindowsNoEditor\\PROJECT_NAME\\Metadata\\Crypto.json 它里面的内容是根据 Project Setting-Crypto 中的选项生产的。使用方法为：在 HotPatcher 的 UnrealPak 参数项添加参数：-cryptokeys=&quot;Crypto.json&quot;(在 UE4.23+ 中还需要添加 -sign 参数): 重新生成 Pak 就会在 Pak 的目录里生成与 Pak 同名的 .sig 文件了，把 pak 和sig文件一同拷贝到挂载目录里就可以了。 UnrealPak 的参数可以看我之前的一篇文章：UE4 工具链配置与开发技巧 #UnrealPak 的参数 Pak master signature table check failed for pak 使用 HotPatcher 打包出来的 pak 在挂载时 Crash 并具有 Pak master signature table check failed for pak 提示 这是由于打出本体包的时候在项目设置中设置了 Signing 加密，需要在 HotPatcher 中的 UnrealPak 参数中添加相同的加密参数。 在 IPlatformFilePak.cpp 中的 RegisterPakFile 中，同样做了判断： 12345678910111213141516171819202122232425262728293031323334353637// Runtime/PakFile/Private/uint16* RegisterPakFile(FName File, int64 PakFileSize)&#123; uint16* PakIndexPtr = CachedPaks.Find(File); if (!PakIndexPtr) &#123; FString PakFilename = File.ToString(); check(CachedPakData.Num() &lt; MAX_uint16); IAsyncReadFileHandle* Handle = LowerLevel-&gt;OpenAsyncRead(*PakFilename); if (!Handle) &#123; return nullptr; &#125; CachedPakData.Add(FPakData(Handle, File, PakFileSize)); PakIndexPtr = &amp;CachedPaks.Add(File, CachedPakData.Num() - 1); UE_LOG(LogPakFile, Log, TEXT(&quot;New pak file %s added to pak precacher.&quot;), *PakFilename); FPakData&amp; Pak = CachedPakData[*PakIndexPtr]; if (SigningKey.IsValid()) &#123; // Load signature data FString SignaturesFilename = FPaths::ChangeExtension(*PakFilename, TEXT(&quot;sig&quot;)); IFileHandle* SignaturesFile = LowerLevel-&gt;OpenRead(*SignaturesFilename); ensure(SignaturesFile); FArchiveFileReaderGeneric* Reader = new FArchiveFileReaderGeneric(SignaturesFile, *SignaturesFilename, SignaturesFile-&gt;Size()); Pak.Signatures.Serialize(*Reader); delete Reader; Pak.Signatures.DecryptSignatureAndValidate(SigningKey, PakFilename); // Check that we have the correct match between signature and pre-cache granularity int64 NumPakChunks = Align(PakFileSize, FPakInfo::MaxChunkDataSize) / FPakInfo::MaxChunkDataSize; ensure(NumPakChunks == Pak.Signatures.ChunkHashes.Num()); &#125; &#125; return PakIndexPtr;&#125; iOS 热更 metallib 问题 在 4.25 存在不会重新加载 shaderbytecode 的问题，而且引擎内部对加载 metallib 是单独处理的流程，无法服用 usahderbytecode 的流程，所以出 iOS 包尽量使用远程打包的方式，会生成ushaderbytecode，在 4.25 里 LoadLibrary 没有问题，但是如果去加载 metallib 就有问题。 UE 热更 Shader 相关的内容可以看之前的文章：UE4 热更新：Create Shader Patch UE4.25+ ShaderPatch Crash这是因为在 4.25+ 引擎内部的 bug 导致的，UE4 热更新：Create Shader Patch#4.25+ ShaderPatch Crash](https://imzlp.com/posts/5867/)这篇文章中提供了修改方案。 热更一个不存在的插件中的资源 打包之后引擎是会从 upluginmanifest 中读取当前工程中具有有哪些插件的，加载插件中的资源先判断插件是否存在，从而实现一个粒度较粗的过滤效果。 所以，当需要把一个在基础包中不存在的插件打包至 pak 中，需要在打包资源的同时需要把项目的 upluginmanifest 文件同步打包，挂载点为： 1../../../PROJECT_NAME/Plugins/PROJECT_NAME.upluginmanifest 关于 upluginmanifest 的介绍，可以看我之前的笔记：UE4#upluginmanifest。 热更的资源没有效果 / 材质丢失 如果热更蓝图，逻辑没有变化，需要检查资源是否被 Cook，可以手动在 Content Browser 中通过 HotPatcher 中提供的功能对选中资源执行 Cook，也可以在打包 Patch 时勾选 bCookAsset 选项。 如果时热更了资源 / 材质，没有效果，需要检查是否把 Shaderbytecode 打包，如果新增材质没有打包 shaderbytecode 是会导致 Shader 获取失败使用默认材质的。 Log 中的错误： 如果不使用引擎启动时自动挂载 pak 的方式，而是运行时手动 Mount 包含新 shaderbytecode 的 pak，则需要在 mount 之后手动重新加载一遍 shaderbytecode，这样引擎才能够读取到最新的 shader，插件中提供了一个辅助函数： 1234567#include &quot;ShaderCodeLibrary.h&quot;void UFlibPatchParserHelper::ReloadShaderbytecode()&#123; FShaderCodeLibrary::OpenLibrary(&quot;Global&quot;, FPaths::ProjectContentDir()); FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::ProjectContentDir());&#125; 在 mount 之后调用即可。 AssetRegistry 是否必须热更 看需求，如果 Runtime 的代码中有通过 AssetRegistry 模块获取资源的引用关系、检测资源是否存在，需要热更。但是 AssetRegistry 并不是引擎必要的，如果肯定不会在运行时用到，可以去掉它，会节省一点内存。 具体介绍可以看我之前的笔记：UE4# 控制 AssetRegistry 的序列化 Android 提示 not found uprojectUE 中有一个 BUG，在 4.25.1 引擎版本中可以复现，步骤如下： 安装 apk，第一次启动游戏 打开 UE 的沙盒数据目录 UE4Game/PROJECTNAME，在这个目录下创建Content/Paks 目录 重新启动游戏 Log 中也有 Project file not found: ../../../FGame/FGame.uproject 提示。 在 Android 上自动挂载的 Pak 文件可以放到 Saved/Paks 下，有时间具体分析一下这个问题。 控制资源不打到基础包中 拆分基础包的实践可看我的这两篇文章： UE4 热更新：资产管理与审计工具 UE4 热更新：拆分基础包 分析某个平台的包中的资源 可以使用 UE 提供的 Asset Audit 工具，需要在每次打包时备份好 Cooked/PLATFORM/PROJECT_NAME/Metadata 目录中的 DevelopmentAssetRegistry.bin 文件。 也可以使用 UnrealPakViewer 来直接加载 Pak 文件。 具体可以看这篇文章的资产审计小节：UE4 热更新：资产管理与审计工具 #资产审计 UMG 子控件热更不生效 如果 Instanced 的形式引用的 UMG，子 UMG 的变动需要递归包含所有以子控件形式引用的 UMG 资源。我之前在笔记中记录过这个问题：UE4#UMG 的子控件引用热更问题。 解决方案：HotPatcher 中具有一个递归分析 UMG 父控件的的选项(bRecursiveWidgetTree)，开启即可。 这个问题的具体分析在我 2020 UOD 的演讲中有详细介绍，感兴趣的可以去这里查看视频和 PPT： 2020 Unreal Open Day Pak 是否可以跨引擎版本使用 不行，要保持打包和使用的引擎版本一致。 从 A 项目打包给 B 项目使用的 PakHotPatcher 中做了替换 pakcommand 的功能，可以通过以下参数指定： 注意：From 和 To 都必须要包含 ../../../ 前缀，不然会把文件的绝对路径替换了。 plugin HotPatcher faild打包之后又如下提示： 应该是纯蓝图项目打包导致的，在项目中新建一个 C++ 类，变成一个 C++ 工程重新打包即可。 打包原始 uasset 资源 目前插件并没有能直接选择打包原始 uasset 资源的功能，但是可以使用一个取巧的方法实现。可以设置 ReplacePakCommandTexts 把 Cooked 的目录替换为项目的Content 目录： 虽然 *pakcommand.txt 里依然会有 uexp 等文件的记录，但是在项目的 Content 下没有，也并不会打包到 pak 中去，会忽略不存在的文件，并有以下 log 输出： 1LogPakFile: Warning: Missing file &quot;D:/Client/Content/Assets/Scene/Map/LookDev/DemoAssets/Mesh/FFXV/000.uexp&quot; will not be added to PAK file. 算是取巧的一种实现吧，但是可行。 导出跨机器的通用配置文件Q：HotPatcher 中导出的配置，有些是依赖于本地绝对路径的文件，如 BaseVersion、Non-Asset 文件、SavePath 等，不同的机器这些绝对路径并不能保证一致，能否基于相对路径进行配置？ A：可以。HotPatcher 所有能够指定路径的配置项，都支持标记符替换，可以使用以下标记符来替代绝对路径。 123456[ENGINEDIR][ENGINE_CONTENT_DIR][PROJECTDIR][PROJECT_CONTENT_DIR][PROJECT_SAVED_DIR][PROJECT_CONFIG_DIR] 在打包时会自动替换为当前机器的绝对路径，基于相对路径则是完全通用的配置文件。 依赖分析耗时 当项目资源非常多，插件提供的依赖分析功能的耗时十分可观，其主要目的是分析被依赖的资源，防止依赖了但是没有被打包的情况。如果依赖了引擎、插件中的资源，不进行依赖分析是管理不到的（或者手动指定），而且如果想要剔除没有引用的资源不分析也做不到。不需要的话也是可以关掉的，设置 bAnalysisFilterDependencies 就可以了。这样只会对配置中所指定的目录下的所有资源、单独指定的资源，与基础版本中的进行 Diff 分析，能够减少依赖分析的耗时（如果资源量非常大，并且能保证所有的资源依赖都在 /Game）下的可以不开启依赖分析。 OTHER UPDATE使用 Github Gist 管理的动态更新内容，在国内网络可能会无法查看。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"UE 热更新：Create Shader Patch","date":"2021-03-12T09:49:27.000Z","path":"wiki/5867/","text":"之前的热更新系列文章中介绍了 UE 热更新的流程和打包细节，其实有一些热更补丁优化的工程实践我觉得也可以详细介绍。 本篇文章从生成 Shader 的 Patch 入手，目的减少每次热更新时的 Shader 的大小，并会对引擎内部的实现细节做一些分析，解决引擎中的 Shader Patch 的相关问题，并基于 HotPatcher 的实现自动化的 Shade Patch 流程。 shaderbytecode 的生成与加载 UE 在Project Settings-Packaging 中提供了 Share Material Shader Code 的选项，可以控制 Shader 的共享，存储为单独的文件中，减少包体的大小。 By default shader code gets saved inline inside material assets, enabling this option will store only shader code once as individual files This will reduce overall package size but might increase loading time. 当开启这个选项之后打包项目，包内的 Content 目录下会生成以下两个 ushaderbytecode 文件： 打包的 Pak 中的 Mount Point 为： 1../../../PROJECT_NAME/Content/ 而且 ushaderbytecode 文件的命名根据以下规则： Runtime/RenderCore/Private/ShaderCodeLibrary.cpp12345678static FString ShaderExtension = TEXT(&quot;.ushaderbytecode&quot;);static FString StableExtension = TEXT(&quot;.scl.csv&quot;);static FString PipelineExtension = TEXT(&quot;.ushaderpipelines&quot;);static FString GetCodeArchiveFilename(const FString&amp; BaseDir, const FString&amp; LibraryName, FName Platform)&#123; return BaseDir / FString::Printf(TEXT(&quot;ShaderArchive-%s-&quot;), *LibraryName) + Platform.ToString() + ShaderExtension;&#125; ushaderbytecode 在引擎启动时会自动加载，但是注意 Global 和项目两者加载时机的区别： Runtime/Launch/Private/LaunchEngineLoop.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int32 FEngineLoop::PreInitPreStartupScreen(const TCHAR* CmdLine)&#123; // ... &#123; bool bUseCodeLibrary = FPlatformProperties::RequiresCookedData() || GAllowCookedDataInEditorBuilds; if (bUseCodeLibrary) &#123; &#123; SCOPED_BOOT_TIMING(&quot;FShaderCodeLibrary::InitForRuntime&quot;); // Will open material shader code storage if project was packaged with it // This only opens the Global shader library, which is always in the content dir. FShaderCodeLibrary::InitForRuntime(GMaxRHIShaderPlatform); // 加载 Global 的 ushaderbytecode &#125; #if !UE_EDITOR // Cooked data only - but also requires the code library - game only if (FPlatformProperties::RequiresCookedData()) &#123; SCOPED_BOOT_TIMING(&quot;FShaderPipelineCache::Initialize&quot;); // Initialize the pipeline cache system. Opening is deferred until the manual call to // OpenPipelineFileCache below, after content pak&#x27;s ShaderCodeLibraries are loaded. FShaderPipelineCache::Initialize(GMaxRHIShaderPlatform); &#125; #endif //!UE_EDITOR &#125; &#125; // ...&#125;int32 FEngineLoop::PreInitPostStartupScreen(const TCHAR* CmdLine)&#123; // ... //Handle opening shader library after our EarlyLoadScreen &#123; LLM_SCOPE(ELLMTag::Shaders); SCOPED_BOOT_TIMING(&quot;FShaderCodeLibrary::OpenLibrary&quot;); // Open the game library which contains the material shaders. FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::ProjectContentDir()); // 加载项目的 ushaderbytecode for (const FString&amp; RootDir : FPlatformMisc::GetAdditionalRootDirectories()) &#123; FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::Combine(RootDir, FApp::GetProjectName(), TEXT(&quot;Content&quot;))); &#125; // Now our shader code main library is opened, kick off the precompile, if already initialized FShaderPipelineCache::OpenPipelineFileCache(GMaxRHIShaderPlatform); &#125; // ...&#125; 综上所述，引擎打包对于 Shader 的处理需要注意以下两点： 打包项目是会只把当前打包的资源的 Shader 编译到 ushaderbytecode 中 引擎启动时会自动加载 所以，如果我们进行热更新资源时有 shader 的变动或者新增了，如果不把 shaderbytecode 打包进来，会导致有些资源没有效果，如图： Log 中的错误： 这就需要我们去处理更新 Shader 的情况。 Shader 的热更新 根据前面一小节的介绍，我们知道了打包时会自动把 所打包资源 的 Shader 生成到 ushaderbytecode 文件中，当我们热更时新增了材质，需要把新的 shader 文件给打到 pak 中，在运行时加载，不然会丢失材质效果。 在 HotPatcher 中提供了包含 shaderbytecode 的选项，会把 Cook 之后最新生成的 ushaderbytecode 打包到 pak 中： 并且 Monut Point 与基础包的相同。 当我们挂载热更的 pak 时，需要 pak order 大于基础包中的 pak，这样我们热更的 pak 中的 ushaderbytecode 就是优先级最高的，但是因为前面也已经提到了，引擎启动时就已经自动加载了基础包中的 shaderbytecode，当程序运行起来之后挂载的 pak 中的 shaderbytecode 就不会被自动加载，这需要在挂载 pak 之后自己执行： 12345void UFlibPatchParserHelper::ReloadShaderbytecode()&#123; FShaderCodeLibrary::OpenLibrary(&quot;Global&quot;, FPaths::ProjectContentDir()); FShaderCodeLibrary::OpenLibrary(FApp::GetProjectName(), FPaths::ProjectContentDir());&#125; 调用 FShaderCodeLibrary::OpenLibrary 函数即可。 综上所述，我们热更 shader 时的流程如下： 执行 Cook 生成包含最新资源的 ushaderbytecode 文件 打包 ushaderbytecode 到 pak 中 手动加载 ushaderbytecode 重新生成 ushaderbytecode 可以直接使用以下 cook 命令： 1UE4Editor-cmd.exe PROJECT_NAME.uproject -run=cook -targetplatform=WindowsNoEditor -Iterate -UnVersioned -Compressed 其实它会 rebuild metadata，AssetRegistry 之类的都会重新生成。执行完毕之后 Saved/Cooked 下的 AssetRegistry.bin以及 Metadate 目录 /Content/ShaderArchive-*.ushaderbytecode以及 Ending/GlobalShaderCache*.bin等文件都是生成之后最新的了，可以在之后通过 HotPatcher 来打包他们了。 Shader Patch 的生成 但是，上一节的介绍其实是每次热更都需要完整地把 shaderbytecode 更新，其实是有点浪费的，因为基础包中的 shader 已经存在了，没必要我们每次更新还要把已有的包含进来，而且到项目后期 Shader 的占用会很大，甚至有的能达到几百 M，如果每次资源变动的热更都要包含几百 M 这肯定是不行的，所以也需要对 Shader 进行 Patch，实现增量更新的目的。 UE 中在 4.23+ 中开始提供了创建 ShaderPatch 的方法，需要提供 Old Metadata 和 New Metadata 的目录，Metadata必须要具有以下目录结构： 1234567891011D:\\Unreal Projects\\Blank425\\Saved\\Cooked\\WindowsNoEditor\\Blank425\\Metadata&gt;tree /a /f卷 Windows 的文件夹 PATH 列表 卷序列号为 0C49-9EA3C:.| BulkDataInfo.ubulkmanifest| CookedIniVersion.txt| DevelopmentAssetRegistry.bin|\\---ShaderLibrarySource ShaderArchive-Global-PCD3D_SM5.ushaderbytecode ShaderArchive-Blank425-PCD3D_SM5.ushaderbytecode 需要在打基础包时备份好当时的 Metadata 目录，把最新的工程在执行 Cook 之后的 Metadata 目录作为 New Metadata，基础包的作为 Old Metadata，调用引擎中的 FShaderCodeLibrary::CreatePatchLibrary 函数，但是这个函数在不同的引擎版本中原型有差异，可以实现一层封装： 123456789101112bool UFlibShaderPatchHelper::CreateShaderCodePatch(TArray&lt;FString&gt; const&amp; OldMetaDataDirs, FString const&amp; NewMetaDataDir, FString const&amp; OutDir, bool bNativeFormat)&#123;#if ENGINE_MINOR_VERSION &gt; 25 return FShaderCodeLibrary::CreatePatchLibrary(OldMetaDataDirs,NewMetaDataDir,OutDir,bNativeFormat,true);#else #if ENGINE_MINOR_VERSION &gt; 23 return FShaderCodeLibrary::CreatePatchLibrary(OldMetaDataDirs,NewMetaDataDir,OutDir,bNativeFormat); #else return false; #endif#endif&#125; FShaderCodeLibrary::CreatePatchLibrary内部的实现原理是，从 Old Metadata 序列化出旧的 Shader 数据，与 New Metadata 的做比对，有差异的部分作为 Patch 中的 Shader。 HotPatcher 中提供了 Shader Patch 的配置和管理方法： 可以同时指定多个平台以及 Metadata 的目录参数，并且支持 commandlet。 4.25+ ShaderPatch Crash注意 ，引擎中提供的FShaderCodeLibrary::CreatePatchLibrary 在 4.25 中有 bug，会导致生成 Patch 时的 Crash，下面写一下解决方案。 在 4.25 引擎版本中调用 FShaderCodeLibrary::CreatePatchLibrary 来创建 ShaderCode Patch 会触发 check 抛异常： 这是因为 FEditorShaderCodeArchive 的构造函数中调用了 ShaderHashTable 的 Initialize，并给了默认值0x1000： 12345678910FEditorShaderCodeArchive(FName InFormat) : FormatName(InFormat) , Format(nullptr)&#123; Format = GetTargetPlatformManagerRef().FindShaderFormat(InFormat); check(Format); SerializedShaders.ShaderHashTable.Initialize(0x10000); SerializedShaders.ShaderMapHashTable.Initialize(0x10000);&#125; 导致在后续的流程中 (FSerializedShaderArchive::Serialize) 调用 Initialize 的时候 check 失败了(因为 HaseSize 已经有值了，并不是 0，对其再调用 Initialize 就触发了 check)： 查了下 FEditorShaderCodeArchive 构造函数中调用 Initialize 的代码是在 4.25 之后的引擎版本才有的，所以影响到的之后 4.25+ 的版本。代码对比： 4.24.3-release/Engine/Source/Runtime/RenderCore/Private/ShaderCodeLibrary.cpp#L922 4.25.0-release/Engine/Source/Runtime/RenderCore/Private/ShaderCodeLibrary.cpp#L801 解决方案：把 FSerializedShaderArchive::Serialize 中ShaderMapHashTable的 Initialize 和ShaderHashTable的 Initialize 在 Editor 下注释掉，因为 FEditorShaderCodeArchive 的代码只在 Editor 下有效，并且是只在生成 ShaderPatch 时有用。 这就造成了以下几个问题： FEditorShaderCodeArchive的构造只有 Eidotor 并且 ShaderPatch 是才有用，也就意味着这里写的 ShaderMapHashTable 的Initialize和 ShaderHashTable 的Initialize只有在创建 ShaderPatch 时才会执行 在打基础包时执行 Cook 会编译 shader，但是不会执行 FEditorShaderCodeArchive 的构造，ShaderMapHashTable的 Initialize 和ShaderHashTable的 Initialize 也就不会执行，就需要在使用的地方来调用它们的初始化 这也是 UE 中没有管理好这两个状态的地方：在 FEditorShaderCodeArchive 和FSerializedShaderArchive::Serialize中都做了 Initialize 的操作，在打基础包时造成了 ShaderMapHashTable 和ShaderHashTable的 Initialize 已经被 FEditorShaderCodeArchive 初始化的情况下又被 FSerializedShaderArchive::Serialize 执行了一遍，导致 Crash，但是我们又不能粗暴地把任何一处的初始化操作去掉，只能通过检测 ShaderMapHashTable 和ShaderHashTable的 Initialize 是否已经被执行，来选择性的跳过。 阅读代码可以知道 ShaderMapHashTable 和ShaderHashTable的 Initialize 只应该执行一次，并且初始化之后 HashSize 和 IndexSize 应该具有非 0 值： Runtime/Core/Public/Containers/HashTable.h123456789101112131415161718192021FORCEINLINE void FHashTable::Initialize(uint32 InHashSize, uint32 InIndexSize)&#123; check(HashSize == 0u); check(IndexSize == 0u); HashSize = InHashSize; IndexSize = InIndexSize; check(HashSize &lt;= 0x10000); check(FMath::IsPowerOfTwo(HashSize)); if (IndexSize) &#123; HashMask = (uint16)(HashSize - 1); Hash = new uint32[HashSize]; NextIndex = new uint32[IndexSize]; FMemory::Memset(Hash, 0xff, HashSize * 4); &#125;&#125; 在 Initialize 时会检测当前的 HashSize 和IndexSize是否为 0，并在之后进行赋值。所以，我们只要获取 FHashTable 的HashSize和 IndexSize 检测它们是否为 0 即可判断当前的 HashTable 对象是否已经被 Initialize 过，但是，UE 里的 FHashTable 里这两个成员都是 protected 的，只能修改引擎来实现了： 添加获取 FHashTable 的HashSize和 IndexSize 属性的成员函数： 12345678class FHashTable&#123;public: // ... FORCEINLINE uint32 GetHashSize()const&#123;return HashSize;&#125;; FORCEINLINE uint32 GetIndexSize()const&#123;return IndexSize;&#125;; // ...&#125;; 然后在 FSerializedShaderArchive::Serialize 进行检测，如果已被初始化则跳过 Initialize 逻辑： Runtime/RenderCore/Private/ShaderCodeArchive.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void FSerializedShaderArchive::Serialize(FArchive&amp; Ar)&#123; Ar &lt;&lt; ShaderMapHashes; Ar &lt;&lt; ShaderHashes; Ar &lt;&lt; ShaderMapEntries; Ar &lt;&lt; ShaderEntries; Ar &lt;&lt; PreloadEntries; Ar &lt;&lt; ShaderIndices; check(ShaderHashes.Num() == ShaderEntries.Num()); check(ShaderMapHashes.Num() == ShaderMapEntries.Num()); if (Ar.IsLoading()) &#123; // ++[SHADER_PATCH][lipengzha] auto ShaderHashInitialized = [](const FHashTable&amp; HashTable)-&gt;bool &#123; return HashTable.GetHashSize() || HashTable.GetIndexSize(); &#125;; // ++[SHADER_PATCH][lipengzha] &#123; const uint32 HashSize = FMath::Min&lt;uint32&gt;(0x10000, 1u &lt;&lt; FMath::CeilLogTwo(ShaderMapHashes.Num())); // ++[SHADER_PATCH][lipengzha] if(!ShaderHashInitialized(ShaderMapHashTable)) &#123; ShaderMapHashTable.Initialize(HashSize, ShaderMapHashes.Num()); &#125; // ++[SHADER_PATCH][lipengzha] for (int32 Index = 0; Index &lt; ShaderMapHashes.Num(); ++Index) &#123; const uint32 Key = GetTypeHash(ShaderMapHashes[Index]); ShaderMapHashTable.Add(Key, Index); &#125; &#125; &#123; const uint32 HashSize = FMath::Min&lt;uint32&gt;(0x10000, 1u &lt;&lt; FMath::CeilLogTwo(ShaderHashes.Num())); // ++[SHADER_PATCH][lipengzha] if(!ShaderHashInitialized(ShaderHashTable)) &#123; ShaderHashTable.Initialize(HashSize, ShaderHashes.Num()); &#125; // ++[SHADER_PATCH][lipengzha] for (int32 Index = 0; Index &lt; ShaderHashes.Num(); ++Index) &#123; const uint32 Key = GetTypeHash(ShaderHashes[Index]); ShaderHashTable.Add(Key, Index); &#125; &#125; &#125;&#125; 这样可以统一 ShaderPatch 和 Runtime 的 HashTable 的 Initialize 流程。 Shader Patch 的自动化流程HotPatcher 中支持了 Shade Patch 的配置化 Commandlet 功能，可以通过配置文件执行： 1UE4Editor.exe PROJECT.uproject -run=HotShaderPatch -config=&quot;export-shaderpatch-config.json&quot; -config 参数所接收的文件都可以从编辑器中通过插件导出。 并且也支持在命令行上的参数替换，与 HotRelease 和 HotPatcher 的 Commandlet 功能类似，这里不再赘述，可以直接去看 HotPatcher 的文档介绍： UE4 资源热更打包工具 HotPatcher#Commandlet 只需要管理好项目每次版本的 Metadata 目录，就可以编辑一份通用的配置文件导出，在每次 HotPatcher 的 Patch 任务前执行生成 Shader 的 Patch 文件，以外部文件的形式添加至 HotPatcher 的配置中即可。剩下的事情就是运行时加载 Shader Patch 的文件了，插件中同样做了函数库的支持： 1bool UFlibPatchParserHelper::LoadShaderbytecode(const FString&amp; LibraryName, const FString&amp; LibraryDir); 注意事项 在 Shader Patch 的使用中需要注意的是：生成出来的 ShaderPatch 的 ushaderbytecode 文件是与基础包内的文件名一致的，所以不能使用引擎启动时的默认挂载（会导致基础包内的 ushaderbytecode 文件无法被加载，从而 crash）。 应该按照前文的介绍在挂载之后自己处理 ShaderPatch 的 ushaderbytecode 文件的加载。 并且 ：ShaderPatch 的更新不 直接支持Patch 的迭代，如：1.0 Metadata + 1.1 的 ShaderPatch，并不能生成 1.2 的 ShaderPatch，必须要基于 1.1 的完整 Metadata 才可以，即每次 Patch 必须要基于上一次完整的 Metadate 数据（Project 和 Global 的 ushaderbytecode 文件），在工程管理上每次打包都需要把完整的 Metadata 收集起来。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Shader Patch","slug":"Shader-Patch","permalink":"https://ue5wiki.com/tags/Shader-Patch/"},{"name":"ushaderbytecode","slug":"ushaderbytecode","permalink":"https://ue5wiki.com/tags/ushaderbytecode/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"同时支持 armv7 和 arm64 的链接库","date":"2021-03-11T22:32:01.000Z","path":"wiki/97154335/","text":"在开发 Android 的时候，有需求需要同时支持 arm64 和 armv7，需要在 Build.cs 中同时把 armv7 和 arm64 的链接库都添加到 PublicAdditionalLibraries 中： 12345PublicAdditionalLibraries.AddRange(new string[]&#123; Path.Combine(ThirdPartyFolder, &quot;Android_armeabi-v7a&quot;, AkConfigurationDir), Path.Combine(ThirdPartyFolder, &quot;Android_arm64-v8a&quot;, AkConfigurationDir),&#125;); 但是，在 UE 的 ModuleRules 里没有能判断当前编译的架构的方法（ModuleRules 的构造在编译时只会执行一次），导致编译 arm64 的时候找到了 armv7 的链接库，导致链接错误： 123456789101112131415161718192021222314&gt;ld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSoundEngine.a(AkAudioLib.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSoundEngine.a(AkLEngine.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSoundEngine.a(AkAudioLib.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSoundEngine.a(AkLEngine.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMemoryMgr.a(AkMemoryMgr.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMemoryMgr.a(AkMemoryMgrBase.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMemoryMgr.a(AkMemoryMgr.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMemoryMgr.a(AkMemoryMgrBase.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkStreamMgr.a(AkStreamMgr.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkStreamMgr.a(AkStreamMgr.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMusicEngine.a(AkMusicRenderer.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMusicEngine.a(AkMusicRenderer.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSpatialAudio.a(AkSpatialAudio.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkSpatialAudio.a(AkSpatialAudio.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkAudioInputSource.a(AkFXSrcAudioInput.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkAudioInputSource.a(AkFXSrcAudioInput.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkVorbisDecoder.a(AkVorbisLib.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkVorbisDecoder.a(AkVorbisLib.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMeterFX.a(InitAkMeterFX.o) is incompatible with aarch64linuxld.lld: error: D:/Client/Plugins/WWise/ThirdParty/Android_armeabi-v7a/Profile/lib\\libAkMeterFX.a(InitAkMeterFX.o) is incompatible with aarch64linuxld.lld: error: too many errors emitted, stopping now (use -error-limit=0 to see all errors)clang++: error: linker command failed with exit code 1 (use -v to see invocation)14&gt;Execution failed. Error: 1 (0x01) Target: &#x27;C:\\BuildAgent\\workspace\\FGameClientBuild\\Client\\Binaries\\Android\\FGame-arm64.so&#x27; 所以，需要找到一种方法，能够在使用 PublicAdditionalLibraries 同时添加了 arm64 和 armv7 链接库的情况下让编译器能够自动地匹配到应该去什么路径来执行链接。 翻了一下 UBT 的代码，发现 UE 中对在 Android 上对链接库的路径做了模式匹配： Engine\\Source\\Programs\\UnrealBuildTool\\Platform\\Android\\AndroidToolChain.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static private Dictionary&lt;string, string[]&gt; AllArchNames = new Dictionary&lt;string, string[]&gt; &#123; &#123; &quot;-armv7&quot;, new string[] &#123; &quot;armv7&quot;, &quot;armeabi-v7a&quot;, &#125; &#125;, &#123; &quot;-arm64&quot;, new string[] &#123; &quot;arm64&quot;, &quot;arm64-v8a&quot;, &#125; &#125;, &#123; &quot;-x86&quot;, new string[] &#123; &quot;x86&quot;, &#125; &#125;, &#123; &quot;-x64&quot;, new string[] &#123; &quot;x64&quot;, &quot;x86_64&quot;, &#125; &#125;,&#125;; static bool IsDirectoryForArch(string Dir, string Arch)&#123; // make sure paths use one particular slash Dir = Dir.Replace(&quot;\\\\&quot;, &quot;/&quot;).ToLowerInvariant(); // look for other architectures in the Dir path, and fail if it finds it foreach (KeyValuePair&lt;string, string[]&gt; Pair in AllArchNames) &#123; if (Pair.Key != Arch) &#123; foreach (string ArchName in Pair.Value) &#123; // if there&#x27;s a directory in the path with a bad architecture name, reject it if (Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;$&quot;) || Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;/&quot;) || Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;_API[0-9]+_NDK[0-9]+&quot;, RegexOptions.IgnoreCase)) &#123; return false; &#125; &#125; &#125; &#125; // if nothing was found, we are okay return true;&#125;public override FileItem[] LinkAllFiles(LinkEnvironment LinkEnvironment, bool bBuildImportLibraryOnly, IActionGraphBuilder Graph)&#123; // ... // Add the library paths to the additional path list foreach (DirectoryReference LibraryPath in LinkEnvironment.LibraryPaths) &#123; // LinkerPaths could be relative or absolute string AbsoluteLibraryPath = Utils.ExpandVariables(LibraryPath.FullName); if (IsDirectoryForArch(AbsoluteLibraryPath, Arch)) &#123; // environment variables aren&#x27;t expanded when using the $(style if (Path.IsPathRooted(AbsoluteLibraryPath) == false) &#123; AbsoluteLibraryPath = Path.Combine(LinkerPath.FullName, AbsoluteLibraryPath); &#125; AbsoluteLibraryPath = Utils.CollapseRelativeDirectories(AbsoluteLibraryPath); if (!AdditionalLibraryPaths.Contains(AbsoluteLibraryPath)) &#123; AdditionalLibraryPaths.Add(AbsoluteLibraryPath); &#125; &#125; &#125; // ...&#125; 最关键的就是这这一行： 1if (Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;$&quot;) || Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;/&quot;) || Regex.IsMatch(Dir, &quot;/&quot; + ArchName + &quot;_API[0-9]+_NDK[0-9]+&quot;, RegexOptions.IgnoreCase)) 根据上面正则的规则，可以把链接库的路径改为： 12XXXX/armeabi-v7a/XXXX/armeabi-v8a/ 只要我们为 Android 添加的链接库路径匹配这个规则，使用 UE 编译时就会自动使用对应架构的链接库（.a 和.so 都是可以使用这个规则的）。 UE 这也太坑了，这个要求文档没写，完全是一个潜规则。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"链接库","slug":"链接库","permalink":"https://ue5wiki.com/tags/%E9%93%BE%E6%8E%A5%E5%BA%93/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"UE 反射实现分析：反射代码生成（一）","date":"2021-03-10T15:14:19.000Z","path":"wiki/9780/","text":"之前写了两篇 UE 中实现反射的文章分析，介绍了 UE 的反射基础概念和依赖的一些 C++ 特性，本篇文章开始分析 UE 反射实现的具体流程。 C++ 标准中并没有反射的特性，UE 使用的反射是基于 标记语法 和UHT 扫描生成辅助代码 来实现的一套机制，正如 David Wheeler 的那句名言一样：“All problems in computer science can be solved by another level of indirection”，UHT 做的就是这样的事情，在真正执行编译之前分析标记代码并产生真正的 C++ 代码，收集反射类型的元数据，供运行时之用。 UHT 生成的代码内容很多，为了避免文章组织上的混乱，本篇文章主要讲 GENERATED_BODY/UFUNCTION 等反射标记通过 UHT 之后生成到 generated.h 中的 真正的 C++ 代码。 UHT 生成的代码分别在 generated.h 和gen.cpp中，generated.h中的代码大多是定义了一些宏，用在所声明的类内通过编译器预处理来添加通用成员，gen.cpp中的代码则是 UHT 基于反射标记生成的用来描述类反射信息的具体代码，genrated.h和 gen.cpp 也是为了声明和定义分离。 UE 的 Feeds 中写过一篇关于 UE Property System 的文章：Unreal Property System(Reflection) UE 与反射相关的 UHT 宏标记 大多定义在下列几个头文件中： Runtime/CoreUObject/Public/Object/ObjectMacros.h （UHT 标记） Runtime/CoreUObject/Public/Object/ScriptMacros.h（大多是 P_* 的宏，可以利用反射从 Stack 中获取数据） Runtime/CoreUObject/Public/UObject/Class.h （反射基类的定义 UField/UEnum/UStruct/UClass 等） 注意：不同的引擎版本，有些代码变更幅度很大，要结合具体的引擎版本做参考，重点是分析方法。 GENERATED_BODY每一个在 UE 中继承自 UObject 的 C++ 类或者声明的 USTRUCT 类，在类声明中都会有一个 GENERATED_XXXX 的系列宏： 12345678910111213// This pair of macros is used to help implement GENERATED_BODY() and GENERATED_USTRUCT_BODY()#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)// Include a redundant semicolon at the end of the generated code block, so that intellisense parsers can start parsing// a new declaration if the line number/generated code is out of date.#define GENERATED_BODY_LEGACY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY_LEGACY);#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);#define GENERATED_USTRUCT_BODY(...) GENERATED_BODY()#define GENERATED_UCLASS_BODY(...) GENERATED_BODY_LEGACY()#define GENERATED_UINTERFACE_BODY(...) GENERATED_BODY_LEGACY()#define GENERATED_IINTERFACE_BODY(...) GENERATED_BODY_LEGACY() 直接看起来并没什么用！就是拼接了一个字符串而已。但是真相却往往另有玄机，搞清楚它可以顺便厘清在工作中写代码遇到的一系列会造成疑惑的问题，本节来分析一下 GENERATED_ 宏的作用。 考虑下列类代码： 123456789101112131415161718192021222324252627282930313233// NetActor.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;NetActor.generated.h&quot;UCLASS()class ANetActor :public AActor&#123; GENERATED_BODY() // 注意这个宏在 NetActor.h 的第八行public: UFUNCTION() int32 GetHp()const; UFUNCTION() void SetHp(int32 pNewHp);private: UPROPERTY() int32 mHP;&#125;;// NetActor.cpp#include &quot;NetActor.h&quot;int32 ANetActor::GetHp()const&#123; return mHP;&#125;void ANetActor::SetHp(int32 pNewHp)&#123; mHP = pNewHp;&#125; 当我们在编译时，UBT 会驱动 UHT 为我们写的这个类生成 NetActor.generated.h 和NetActor.gen.cpp文件。*.generated.h与 *.gen.cpp 文件存放与下列路径(相对于项目根目录)： 1Intermediate\\Build\\Win64\\UE4Editor\\Inc\\&#123;PROJECT_NAME&#125; 其中在 NetActor.generated.h 中的代码，是 UHT 分析我们写的 NetActor.h 生成的代码 (都是宏定义，供后面使用)。 在分析 generated.h 之前需要先来说一下 GENERATED_BODY 与GENERATED_UCLASS_BODY宏。根据本节开头列出的 UE 所支持的一系列 GENERATED_ 宏，单纯从宏展开的角度看，GENERATED_BODY与 GENERATED_UCLASS_BODY 的区别就是： 1234# GENERATED_BODY 最终生成了这样的一串字符：&#123;CURRENT_FILE_ID&#125;_&#123;__LINE__&#125;_GENERATED_BODY# GENERATED_UCLASS_BODY 最终生成的是这样的一串字符串：&#123;CURRENT_FILE_ID&#125;_&#123;__LINE__&#125;_GENERATED_BODY_LEGACY 注意：这里用 &#123;&#125; 括着的是其他的宏组成的，这里只是列出来两个宏的不同形式。 CURRENT_FILE_ID为 项目所在的文件夹的名字_源文件相对路径_h 123# e.g# ReflectionExample\\Source\\ReflectionExample\\NetActor.hReflectionExample_Source_ReflectionExample_NetActor_h __LINE__为这条宏所在的文件的行数，也就是上面代码中备注说的第八行。 那么 GENERATED_BODY 与GENERATED_UCLASS_BODY所拼接的实际字符串就是： 1234// GENERATED_BODYReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY// GENERATED_UCLASS_BODYReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY_LEGACY 说了这么一大堆，那么就算拼接出来了两个这么长的字符，又是干什么用的呢？ 此时，打开我们的 NetActor.generated.h 文件，可以看到其中定义了一大堆宏的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved./*=========================================================================== Generated code exported from UnrealHeaderTool. DO NOT modify this manually! Edit the corresponding .h files instead!===========================================================================*/#include &quot;UObject/ObjectMacros.h&quot;#include &quot;UObject/ScriptMacros.h&quot;PRAGMA_DISABLE_DEPRECATION_WARNINGS#ifdef REFLECTIONEXAMPLE_NetActor_generated_h#error &quot;NetActor.generated.h already included, missing &#x27;#pragma once&#x27; in NetActor.h&quot;#endif#define REFLECTIONEXAMPLE_NetActor_generated_h#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_RPC_WRAPPERS \\ \\ DECLARE_FUNCTION(execSetHp) \\ &#123; \\ P_GET_PROPERTY(UIntProperty,Z_Param_pNewHp); \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ P_THIS-&gt;SetHp(Z_Param_pNewHp); \\ P_NATIVE_END; \\ &#125; \\ \\ DECLARE_FUNCTION(execGetHp) \\ &#123; \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ *(int32*)Z_Param__Result=P_THIS-&gt;GetHp(); \\ P_NATIVE_END; \\ &#125;#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_RPC_WRAPPERS_NO_PURE_DECLS \\ \\ DECLARE_FUNCTION(execSetHp) \\ &#123; \\ P_GET_PROPERTY(UIntProperty,Z_Param_pNewHp); \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ P_THIS-&gt;SetHp(Z_Param_pNewHp); \\ P_NATIVE_END; \\ &#125; \\ \\ DECLARE_FUNCTION(execGetHp) \\ &#123; \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ *(int32*)Z_Param__Result=P_THIS-&gt;GetHp(); \\ P_NATIVE_END; \\ &#125;#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_INCLASS_NO_PURE_DECLS \\private: \\ static void StaticRegisterNativesANetActor(); \\ friend struct Z_Construct_UClass_ANetActor_Statics; \\public: \\ DECLARE_CLASS(ANetActor, AActor, COMPILED_IN_FLAGS(CLASS_Abstract), CASTCLASS_None, TEXT(&quot;/Script/ReflectionExample&quot;), NO_API) \\ DECLARE_SERIALIZER(ANetActor)#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_INCLASS \\private: \\ static void StaticRegisterNativesANetActor(); \\ friend struct Z_Construct_UClass_ANetActor_Statics; \\public: \\ DECLARE_CLASS(ANetActor, AActor, COMPILED_IN_FLAGS(CLASS_Abstract), CASTCLASS_None, TEXT(&quot;/Script/ReflectionExample&quot;), NO_API) \\ DECLARE_SERIALIZER(ANetActor)#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_STANDARD_CONSTRUCTORS \\ /** Standard constructor, called after all reflected properties have been initialized */ \\ NO_API ANetActor(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()); \\ DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(ANetActor) \\ DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, ANetActor); \\DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(ANetActor); \\private: \\ /** Private move- and copy-constructors, should never be used */ \\ NO_API ANetActor(ANetActor&amp;&amp;); \\ NO_API ANetActor(const ANetActor&amp;); \\public:#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_ENHANCED_CONSTRUCTORS \\ /** Standard constructor, called after all reflected properties have been initialized */ \\ NO_API ANetActor(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) &#123; &#125;; \\private: \\ /** Private move- and copy-constructors, should never be used */ \\ NO_API ANetActor(ANetActor&amp;&amp;); \\ NO_API ANetActor(const ANetActor&amp;); \\public: \\ DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, ANetActor); \\DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(ANetActor); \\ DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(ANetActor)#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_PRIVATE_PROPERTY_OFFSET \\ FORCEINLINE static uint32 __PPO__mHP() &#123; return STRUCT_OFFSET(ANetActor, mHP); &#125;#define ReflectionExample_Source_ReflectionExample_NetActor_h_5_PROLOG#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY_LEGACY \\PRAGMA_DISABLE_DEPRECATION_WARNINGS \\public: \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_PRIVATE_PROPERTY_OFFSET \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_RPC_WRAPPERS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_INCLASS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_STANDARD_CONSTRUCTORS \\public: \\PRAGMA_ENABLE_DEPRECATION_WARNINGS#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY \\PRAGMA_DISABLE_DEPRECATION_WARNINGS \\public: \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_PRIVATE_PROPERTY_OFFSET \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_RPC_WRAPPERS_NO_PURE_DECLS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_INCLASS_NO_PURE_DECLS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_ENHANCED_CONSTRUCTORS \\private: \\PRAGMA_ENABLE_DEPRECATION_WARNINGStemplate&lt;&gt; REFLECTIONEXAMPLE_API UClass* StaticClass&lt;class ANetActor&gt;();#undef CURRENT_FILE_ID#define CURRENT_FILE_ID ReflectionExample_Source_ReflectionExample_NetActor_hPRAGMA_ENABLE_DEPRECATION_WARNINGS 看到了嘛！这个生成的 generated.h 里定义了上面我们写的那些宏： 12345CURRENT_FILE_ID// GENERATED_BODYReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY// GENERATED_UCLASS_BODYReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY_LEGACY 因为我们的 NetActor.h 中包含了 NetActo.generated.h 这个头文件，所以在真正进行编译的时候会将 GENERATED_BODY 进行宏展开，展开的内容就是 NetActor.generated.h 中的宏 ReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY 展开之后的代码。 因为我在 NetActor.h 中使用的是GENERATED_BODY，我就先分析这个宏展开之后的真实代码。 其实 GENERATED_BODY 与GENERATED_UCLASS_BODY的区别在于：GENERATED_BODY声明并定义 了一个接收 const FObjectInitializer&amp; 的构造函数，GENERATED_UCLASS_BODY只声明 了该构造函数，需要用户自己提供一个定义。 1ANetActor(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()); GENERATED_BODY的真实宏名字又包裹了一层其他的宏： 123456789#define ReflectionExample_Source_ReflectionExample_NetActor_h_8_GENERATED_BODY \\PRAGMA_DISABLE_DEPRECATION_WARNINGS \\public: \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_PRIVATE_PROPERTY_OFFSET \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_RPC_WRAPPERS_NO_PURE_DECLS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_INCLASS_NO_PURE_DECLS \\ ReflectionExample_Source_ReflectionExample_NetActor_h_8_ENHANCED_CONSTRUCTORS \\private: \\PRAGMA_ENABLE_DEPRECATION_WARNINGS 展开之后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ANetActor:public AActor&#123; DECLARE_FUNCTION(execSetHp) &#123; P_GET_PROPERTY(UIntProperty,Z_Param_pNewHp); P_FINISH; P_NATIVE_BEGIN; P_THIS-&gt;SetHp(Z_Param_pNewHp); P_NATIVE_END; &#125; DECLARE_FUNCTION(execGetHp) &#123; P_FINISH; P_NATIVE_BEGIN; *(int32*)Z_Param__Result=P_THIS-&gt;GetHp(); P_NATIVE_END; &#125;private: static void StaticRegisterNativesANetActor(); friend struct Z_Construct_UClass_ANetActor_Statics; public: DECLARE_CLASS(ANetActor, AActor, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(&quot;/Script/ReflectionExample&quot;), NO_API) DECLARE_SERIALIZER(ANetActor)/** Standard constructor, called after all reflected properties have been initialized */ NO_API ANetActor(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) &#123; &#125;; private: /** Private move- and copy-constructors, should never be used */ NO_API ANetActor(ANetActor&amp;&amp;); NO_API ANetActor(const ANetActor&amp;); public: DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, ANetActor); DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(ANetActor); DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(ANetActor)public: UFUNCTION() // 注意这里的都是空宏了 int32 GetHp()const; UFUNCTION() // 注意这里的都是空宏了 void SetHp(int32 pNewHp);private: UPROPERTY() // 注意这里的都是空宏了 int32 mHP;&#125;; 可以看到其中使用了： DECLARE_CLASS：声明定义当前类的几个关键信息：Super和 ThisClass 等typedef在此处被定义，以及 StaticClass/StaticPackage/StaticClassCastFlags 和重载的 new 也被定义； DECLARE_FUNCTION为使用 UFUNCIONT 标记的函数创建中间函数； DECLARE_SERIALIZER：重载 &lt;&lt; 使可以被 FArchive 序列化； DECLARE_VTABLE_PTR_HELPER_CTOR：声明一个接收 FVTableHelper&amp; 参数的构造函数； DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER_DUMMY：用于 HotReload，唯一调用的地方是在Class.h 中的模板函数InternalVTableHelperCtorCaller； DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL：定义一个名为 __DefaultConstructor 的静态函数，其中是调用 placement-new 创建类对象（用于统一的内存分配），引擎中唯一调用的位置是在 Class.h 的模板函数InternalConstructor； 因为我们没有在 ANetActor 这个类上标记 XXXX_API，所以它不会被导出，UHT 生成的类ANetActor 的构造函数中都使用的是NO_API. 还有，因为 UFUNCTION 之类的宏在 C++ 的定义里都是 空宏 ，其实严格来说他们并不能称之为 宏，它们 只是对 UHT 的标记 ，用于通过 UHT 来解析生成.generated.h 和.gen.cpp的代码，所以在执行完 UHT 之后，对于 C++ 和编译器来说它们就是不存在的(在预处理之后就是彻底不存在的了)。 这几个宏 (被 UHT 生成之后就是真正的 C++ 宏了)，可以在CoreUObject/Public/UObject/OBjectMacros.h 中找到定义。 把上面的宏再全部展开： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class ANetActor:public AActor&#123; // DECLARE_FUNCTION 在本节不展开讲，留到下一节，所以我保留了宏。 DECLARE_FUNCTION(execSetHp) &#123; P_GET_PROPERTY(UIntProperty,Z_Param_pNewHp); P_FINISH; P_NATIVE_BEGIN; P_THIS-&gt;SetHp(Z_Param_pNewHp); P_NATIVE_END; &#125; DECLARE_FUNCTION(execGetHp) &#123; P_FINISH; P_NATIVE_BEGIN; *(int32*)Z_Param__Result=P_THIS-&gt;GetHp(); P_NATIVE_END; &#125; private: static void StaticRegisterNativesANetActor(); friend struct Z_Construct_UClass_ANetActor_Statics; private: ANetActor&amp; operator=(ANetActor&amp;&amp;); ANetActor&amp; operator=(const ANetActor&amp;); NO_API static UClass* GetPrivateStaticClass();public:// DECLARE_CLASS(ANetActor, AActor, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(&quot;/Script/ReflectionExample&quot;), NO_API) /** Bitwise union of #EClassFlags pertaining to this class.*/ enum &#123;StaticClassFlags=COMPILED_IN_FLAGS(0)&#125;; /** Typedef for the base class (&#123;&#123; typedef-type &#125;&#125;) */ typedef AActor Super /** Typedef for &#123;&#123; typedef-type &#125;&#125;. */ typedef ANetActor ThisClass /** Returns a UClass object representing this class at runtime */ inline static UClass* StaticClass() &#123; return GetPrivateStaticClass(); &#125; /** Returns the package this class belongs in */ inline static const TCHAR* StaticPackage() &#123; return TEXT(&quot;/Script/ReflectionExample&quot;); &#125; /** Returns the static cast flags for this class */ inline static EClassCastFlags StaticClassCastFlags() &#123; return CASTCLASS_None; &#125; /** For internal use only; use StaticConstructObject() to create new objects. */ inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) &#123; return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); &#125; /** For internal use only; use StaticConstructObject() to create new objects. */ inline void* operator new(const size_t InSize, EInternal* InMem ) &#123; return (void*)InMem; &#125;// DECLARE_SERIALIZER(ANetActor) friend FArchive &amp;operator&lt;&lt;(FArchive&amp; Ar, ANetActor*&amp; Res) &#123; return Ar &lt;&lt; (UObject*&amp;)Res; &#125; friend void operator&lt;&lt;(FStructuredArchive::FSlot InSlot, ANetActor*&amp; Res) &#123; InSlot &lt;&lt; (UObject*&amp;)Res; &#125; /** Standard constructor, called after all reflected properties have been initialized */ NO_API ANetActor(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) &#123; &#125;; private: /** Private move- and copy-constructors, should never be used */ NO_API ANetActor(ANetActor&amp;&amp;); NO_API ANetActor(const ANetActor&amp;); public: // DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, ANetActor); static UObject* __VTableCtorCaller(FVTableHelper&amp; Helper) &#123; return nullptr; &#125;// DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(ANetActor); /** DO NOT USE. This constructor is for internal usage only for hot-reload purposes. */ \\ API ANetActor(FVTableHelper&amp; Helper);// DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(ANetActor) static void __DefaultConstructor(const FObjectInitializer&amp; X) &#123; new((EInternal*)X.GetObj())ANetActor(X); &#125;public: UFUNCTION() // 注意这里的都是空宏了 int32 GetHp()const; UFUNCTION() // 注意这里的都是空宏了 void SetHp(int32 pNewHp);private: UPROPERTY() // 注意这里的都是空宏了 int32 mHP;&#125;; 这就是经过 UHT 之后的我们的 ANetActtor 类声明，其中定义了一系列的函数、typedef以及序列化、new等等。 还要类似于 C# 中的 Super 其实就是 UHT 给我们的类添加了一个 typedef 的形式，把 Super 定义成了基类，UE 通过这种形式给我们的类添加了通用的访问函数，用于支持 UE 的对象系统。 GetPrivateStaticClass在 StaticClass 中调用的 GetPrivateStaticClass 其实现是在 NetActor.gen.cpp 中的，通过 IMPLEMENT_CLASS 宏来定义 (这个IMPLEMENT_ 系列宏也是被定义在 Class.h 中)： 1IMPLEMENT_CLASS(ANetActor, 2260007263); 展开之后为： 12345678910111213141516171819202122232425262728#define IMPLEMENT_CLASS(ANetActor, 2260007263) static ANetActorCompiledInDefer&lt;ANetActor&gt; AutoInitializeANetActor(TEXT(&quot;ANetActor&quot;), sizeof(ANetActor), 2260007263); UClass* ANetActor::GetPrivateStaticClass() &#123; static UClass* PrivateStaticClass = NULL; if (!PrivateStaticClass) &#123; // GetPrivateStaticClassBody is a Template function, Helper template allocate and construct a UClass /* this could be handled with templates, but we want it external to avoid code bloat */ GetPrivateStaticClassBody( StaticPackage(), (TCHAR*)TEXT(&quot;ANetActor&quot;) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), PrivateStaticClass, StaticRegisterNativesANetActor, sizeof(ANetActor), alignof(ANetActor), (EClassFlags)ANetActor::StaticClassFlags, ANetActor::StaticClassCastFlags(), ANetActor::StaticConfigName(), (UClass::ClassConstructorType)InternalConstructor&lt;ANetActor&gt;, (UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;ANetActor&gt;, &amp;ANetActor::AddReferencedObjects, &amp;ANetActor::Super::StaticClass, &amp;ANetActor::WithinClass::StaticClass ); &#125; return PrivateStaticClass; &#125; GetPrivateStaticClass(定义在 Class.cpp) 其作用是从当前类的信息构造出一个 UClass 对象出来，其是一个单例对象，通过 UXXX::StaticClass() 获取到的就是这个对象。 注意：在 GetPrivateStaticClass 中调用 GetPrivateStaticClassBody 所传递的参数，就是 UHT 根据我们类的声明产生的所有元数据的访问方法，UClass里存储的就是我们定义类的元数据，而且也并非是每一个我们定义的类都生成了一个一个 UClass 类，而是对每一个类产生一个不同的 UClass 对象实例。 UFUNCTION在 UE 中写代码时，所有需要进行反射的函数必须添加 UFUNTION() 标记。 12345678UCLASS()class ANetActor:public Actor&#123; GENERATED_BODY()public: UFUNCTION() void SetHp(int32 pNewHp);&#125;; UHT 通过扫描我们在代码中所有标记了 UFUNCTION 的函数，生成出来的名为 execFUNC_NAME 中间函数定义（被称作 thunk 函数）。它统一了所有的 UFUNCTION 函数调用规则(this/ 调用参数以及返回值)，并且包裹了真正要执行的函数。 之后就可以通过反射来调用该函数： 通过 UObject::FindFunction 获得所指定函数的 UFunction 对象 (如果指定的函数没有添加UFUNCTION 标记，则返回NULL); 通过 ProcessEvent 来调用函数，第一个参数是调用函数UFunction, 第二个是参数列表void*; 1234567891011&#123; UFunction* funcSetHp = pNetActor-&gt;FindFunctionChecked(&quot;SetHp&quot;); if(funcSetHp) &#123; // struct define in scope struct funcSetHpParams&#123;int32 NewHp;&#125;InsParam; InsParam.NewHp=123; // call SetHp ProcessEvent(funcSetHp,(void*)(&amp;InsParam)); &#125;&#125; 注：UFunction对象中的 ParamSize 的大小是所有成员组成的结构大小，并且具有字节对齐，所以可以将所有参数封装为一个结构，再将其转换为void*。 例，一个函数接收 int32/bool/AActor* 三个类型参数，其 ParamSize 的大小等同于： 123456// sizeof(Params) == 16struct Params&#123; int32 pIval; bool pBool; AActor* pPointer;&#125;; 内存对齐相关的内容可以看我之前的一篇文章：结构体成员内存对齐问题 DECLARE_FUNCTIONDECLARE_FUNCTION的宏定义为： 12345// This macro is used to declare a thunk function in autogenerated boilerplate code#define DECLARE_FUNCTION(func) static void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL)// This macro is used to define a thunk function in autogenerated boilerplate code#define DEFINE_FUNCTION(func) void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL) 通过上面我们手动解析之后的代码可以看到，对于使用 UFUNCTION 标记的函数，UHT 解析时给我们生成了一个 DECLARE_FUNCTION 的宏，其宏定义为： 1234// This macro is used to declare a thunk function in autogenerated boilerplate code#define DECLARE_FUNCTION(func) static void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL)// This macro is used to define a thunk function in autogenerated boilerplate code#define DEFINE_FUNCTION(func) void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL) 在我之前的文章中有提到过，C++ 的成员函数和非成员函数本质没有区别，只不过 C++ 的成员函数有一个隐式的 this 指针参数，这个 DECLARE_FUNCTION 处理的思想也一样，可以把成员和非成员函数通过这种形式统一起来，至于 Context 自然就是传统 C++ 的那个 隐式 this 指针 了，代表着当前调用该成员函数的对象。 注意：在老版本的引擎代码中(4.18.3 之前)，是没有这个 Context 参数的，从 4.19 之后才支持。 Now，将上文 NetActor.generated.h 中的 DECLARE_FUNCTION(execSetHp) 展开为： 12345678910111213141516171819// DECLARE_FUNCTION(execSetHp)void execSetHp(UObject* Context, FFrame&amp; Stack, RESULT_DECL)&#123; // P_GET_PROPERTY(UIntProperty,Z_Param_pNewHp); UIntProperty::TCppType Z_Param_pNewHp = UIntProperty::GetDefaultPropertyValue(); Stack.StepCompiledIn&lt;UIntProperty&gt;(&amp;Z_Param_pNewHp); // P_FINISH; Stack.Code += !!Stack.Code; /* increment the code ptr unless it is null */ // P_NATIVE_BEGIN; &#123; SCOPED_SCRIPT_NATIVE_TIMER(ScopedNativeCallTimer); // P_THIS-&gt;SetHp(Z_Param_pNewHp); ((ThisClass*)(Context))-&gt;SetHp(Z_Param_pNewHp); // P_NATIVE_END; &#125;&#125; 以及DECLARE_FUNCTION(execGetHp)： 123456789101112131415// DECLARE_FUNCTION(execGetHp)void execGetHp(UObject* Context, FFrame&amp; Stack, RESULT_DECL)&#123; // P_FINISH; Stack.Code += !!Stack.Code; /* increment the code ptr unless it is null */ // P_NATIVE_BEGIN; &#123; SCOPED_SCRIPT_NATIVE_TIMER(ScopedNativeCallTimer); // *(int32*)Z_Param__Result=P_THIS-&gt;GetHp(); *(int32*)Z_Param__Result=((ThisClass*)(Context))-&gt;GetHp(); // P_NATIVE_END; &#125;&#125; 这些 P_ 开头的宏，是封装了从参数 Context 以及 Stack 中获取真正要执行的函数的参数，它们被定义在 Runtime/CoreUObject/Public/Object/ScriptMacros.h 中。 RESULT_DECL宏是被定义在 Script.h 中的： 123456// Runtime/CoreUObject/Public/Script.h//// Blueprint VM intrinsic return value declaration.//#define RESULT_PARAM Z_Param__Result#define RESULT_DECL void*const RESULT_PARAM 被展开后是： 1void*const Z_Param__Result 它是一个顶层 const(Top-level const)，指针值不能修改，指针所指向的值可以修改，用于处理函数的返回值。 Custom Thunk Function上面写道，当我们对一个函数标记 UFUNCTION 的时候，UHT 就会自动给生成一个 execFunc 的函数，如果不想让 UHT 生成该函数的 Thunk 函数，可以使用 CustomThunk 来标记，不生成，自己提供。 123456789101112131415UCLASS(BlueprintType,Blueprintable)class ANetActor:public AActor&#123; GENERATED_BODY()public: UFUNCTION(CustomThunk) int32 GetHp()const; DECLARE_FUNCTION(execGetHp) &#123; P_FINISH; P_NATIVE_BEGIN; *(int32*)Z_Param__Result = P_THIS-&gt;GetHp(); P_NATIVE_END; &#125;&#125;; 其实就是需要把 DECLARE_FUNCTION 自己写一遍来处理 ProcessEvent 传递过来的逻辑。比如考虑一下实现这样的逻辑：写一个通用的函数，允许传入任何具有反射的的 struct（不管是蓝图的还是 C++ 的），然后将其序列化为 json。想要实现这样的功能就需要我们在 Thunk 函数中自己来写逻辑。 1234567UFUNCTION(BlueprintCallable,CustomThunk, meta = (CustomStructureParam = &quot;StructPack&quot;))FString StructToJson(const FNetActorStruct&amp; StructPack);DECLARE_FUNCTION(execStructToJson)&#123; // ...&#125; meta中 CustomStructureParam 的含义是将参数作为通配符，可以传入任何类型的参数。 UPROPERTY在类内对属性加了 UPROPERTY 的标记，不会在 generated.h 中产生额外的代码，但是它会把它的反射信息代码生成到在 gen.cpp 中，关于生成在 gen.cpp 中的代码细节本篇文章暂时按下不表，留到下一篇文章中详细介绍。 StaticClass/Struct/Enum在 generated.h 中，UHT 会为当前文件中声明的反射类型（UObject class/struct/enum）生成对应的 Static*&lt;&gt; 模板特化： 123template&lt;&gt; REFLECTIONEXAMPLE_API UClass* StaticClass&lt;class ANetActor&gt;();template&lt;&gt; REFLECTIONEXAMPLE_API UEnum* StaticEnum&lt;ENetEnum&gt;();template&lt;&gt; REFLECTIONEXAMPLE_API UScriptStruct* StaticStruct&lt;struct FNetStruct&gt;(); 这是我们在运行时通过 StaticClass&lt;ANetActor&gt; 这种形式获取 UClass/UStruct/UEnum 的方法。 这种形式在 UE4.21 之后才添加，在 4.21 之前要使用以下这种形式： 1UEnum* FoundEnum = FindObject&lt;UEnum&gt;(ANY_PACKAGE, *EnumTypeName, true); Static*&lt;&gt;()的定义是在 gen.cpp 中。 EndUE 反射的实现以一言蔽之：通过 UHT 生成反射的元数据，把这些元数据在运行时构造出来对应的 UClass/UStruct/UEnum，从而提供了反射的支持。本篇文章主要介绍了 UHT 生成的 generated.h 中的代码，其实核心是通过 UHT 给反射类的声明中添加了一堆通用的成员，依赖这些成员支持了 UE 的对象系统的管理。 下一篇文章会着重介绍 UHT 生成的 gen.cpp 中的代码，它们是真正记录了反射类的对象信息的，比如反射成员的名字、函数地址，传递参数、数据成员类内偏移等等，通过分析它们可以知道我们通过反射能够得到类的哪些信息。","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"UHT","slug":"UHT","permalink":"https://ue5wiki.com/tags/UHT/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"UE 热更新：资产管理与审计工具","date":"2021-03-09T18:16:31.000Z","path":"wiki/3675/","text":"在前面的文章中，介绍了基础包的拆分规则和实现，在基础的打包规则稳定之后，日常开发中的关注重点就转向侧重于项目的资产管理和包体资源审计、分析项目中的资产大小和冗余情况等。 本篇文章介绍 UE 中的资源打包配置、常用的资产管理方式以及资产审计工具等工程实践，热更新系列文章的资源管理篇，也是对上一篇文章 UE4 热更新：拆分基础包 的内容补充。 打包配置 UE 中的资源打包选项可以在Project Settings-Packaging 中进行设置，可以在这里设置是否生成 Pak 以及资源进包的规则。 关于 UE4 基础包中包含的具体内容，我在 Unreal Open Day 的热更新方案中有介绍，有兴趣的可以去看这个视频：Unreal Open Day 2020 虚幻引擎 4 全平台热更新方案 | 查利鹏。 UsePakFile：是否使用 Pak 文件，如果启用，会把游戏用到的资源都打包到 pak 文件中，如果不启用，则会把 cook 之后的 uasset/config/shaderbytecode/assetregistry/uplugin/uproject 等文件按照项目内的路径规则每个文件单独存放。 Generate Chunks：是否打包时生成 Chunk，如果项目内具有划分 Chunk 的规则，勾选此选项会生成多个 pak 文件。 Generate No Chunks：不生成 Chunk Chunk Hard Reference Only：只把 Hard 引用的资源打包到 Chunk 中，Soft 的引用不会进包。 PakFile Compression Formats：指定 Pak 的压缩算法，该参数会传递给 UnrealPak，详见：ModularFeature：为 UE4 集成 ZSTD 压缩算法 ShareMaterialShaderCode：是否共享 ShaderCode，会生成 ushaderbytecode 到包内，可以减小包体的大小。 下面这些参数就是具体的控制把资源打到包内的规则： Directories to never cook的目录不会被打到包内。 Additional Non-Asset Directories to Package用来把一些 non-uasset 文件打到包内，比如 Lua 或者其他的一些表格文件等。 Chunk 划分UE 具有划分 Chunk 的功能，每个 Chunk 在打包时会生成一个单独的 pak 文件，可以通过创建一个 PrimaryAssetLable 来进行设置。 UE 关于划分 Chunk 的文档： Preparing Assets for Chunking Cooking and Chunking 创建 PrimaryAssetLable 资源： 注意，在默认情况下，引擎中的资源和在项目设置中配置的 Non-Asset 的资源是强制打包到 Chunk0 中的，如果包含了引擎的资源也不会把它们打包到当前 Chunk 中（设置 Priority 也无用），用 PrimaryAssetLable 只能控制 uasset 的划分。 这部分代码在： Runtime/Engine/Private/AssetManager.cpp123456789101112131415161718192021222324252627bool UAssetManager::GetPackageChunkIds(FName PackageName, const ITargetPlatform* TargetPlatform, const TArray&lt;int32&gt;&amp; ExistingChunkList, TArray&lt;int32&gt;&amp; OutChunkList, TArray&lt;int32&gt;* OutOverrideChunkList) const&#123; // Include preset chunks OutChunkList.Append(ExistingChunkList); if (OutOverrideChunkList) &#123; OutOverrideChunkList-&gt;Append(ExistingChunkList); &#125; if (PackageName.ToString().StartsWith(TEXT(&quot;/Engine/&quot;), ESearchCase::CaseSensitive)) &#123; // Some engine content is only referenced by string, make sure it&#x27;s all in chunk 0 to avoid issues OutChunkList.AddUnique(0); if (OutOverrideChunkList) &#123; OutOverrideChunkList-&gt;AddUnique(0); &#125; &#125; // Add all chunk ids from the asset rules of managers. By default priority will not override other chunks TSet&lt;FPrimaryAssetId&gt; Managers; Managers.Reserve(128); GetPackageManagers(PackageName, true, Managers); return GetPrimaryAssetSetChunkIds(Managers, TargetPlatform, ExistingChunkList, OutChunkList);&#125; 通过编辑创建的 PrimaryAssetLable 资源的参数来控制它所管理的 Chunk 的资源： Priority：指定当前 Chunk 的优先级，因为可能有几个 Chunk 中都会包含同一个资源，如何决定这个资源打包到哪个 chunk 中去？通过指定优先级可以控制资产的冗余，如果优先级相同则每个 Chunk 中都会包含一份。 ChunkID：指定生成 Chunk 的 ID 值，生成的 pak 文件命名规则为：pakchunk0-WindowsNoEditor.pak，pakchunk后的数字就是 ChunkID 值。 ApplyRecursively：对所管理的资源进行递归依赖分析，但不包含优先级更高的 Chunk 管理的资产。 CookRule：当前 Chunk 的 Cook 规则，可以实现控制该 PrimaryAssetLable 管理的资源都不打包（NeverCook） UnKnown：如果有引用则进行 Cook NeverCook：从不进行 Cook，该部分资源不会被打包 DevelopmentCook：如果有引用则在 Development 模式中 Cook，Production 时不 Cook DevelopmentAlwaysCook：在 Development 模式中均进行 Cook，Production 不 Cook AlwayCook：在任何情况下都执行 Cook Lable Assets in My Directory：当前 PrimaryAssetLable 所在目录（以及子目录）下的资源都归它管理。 IsRuntimeLabel：设置 PrimaryAssetLable 资源本身在运行时可用，并且会打到包内，该选项不会对它标记的资产有影响。 Explicit Assets：指定所管理的资源文件，与 HotPatcher 中的 IncludeSpecifyAsset 类似。 ExplicitBlueprints：指定管理某种类型的蓝图资产。 AssetCollection：指定 Collection 名字。 可以看到通过上述的参数能够实现以下的资产管理功能： 指定目录 指定资源和其依赖 反向控制上述参数不打到包内(Never Cook) chunk 优先级控制资产冗余 在工程的资产管理中可以组合这几种模式来实现项目的需求： 如果地图副本较多，可以把副本及其资源作为一个 Chunk 管理，如果有一些资源被其他 chunk 中重复引用，可以把这部分资源单独作为 chunk 管理并设置成较高优先级。 可以在资源预览（Reference Viewer）中看到 Chunk直接 引用的资源，需要勾选Show Management References，被 Chunk 引用的类型是EAssetRegistryDependencyType::Manage，并不是普通的 Hard/Soft 资源引用关系。 但是 PrimaryAssetLable 也有个缺点，不能指定 non-uasset 文件，如果我们有更新 lua 或者 db、表格之类的需求，无法通过 PrimaryAssetLable 机制来进行打包和划分，这个需求可以通过 HotPatcher 实现，HotPatcher 也实现了类似 PrimaryAssetLable 的 Chunk 的功能用于拆分 Patch，详情见之前的文章：UE4 资源热更打包工具 HotPatcher。 当我们使用了 PrimaryAssetLable 并且在 Project Settings-Packaging 中开启了Generate Chunks，在打包时就会按照配置的规则生成多个 pak 文件了： 12345678910111213141516171819D:\\PCVersion\\WindowsNoEditor&gt;tree /a /f| ClientGame.exe| Manifest_DebugFiles_Win64.txt| Manifest_NonUFSFiles_Win64.txt| +---Engine\\---ClientGame +---Binaries | \\---Win64 | ClientGame.exe | ClientGame.pdb | +---Content | \\---Paks | pakchunk0-WindowsNoEditor.pak | pakchunk1-WindowsNoEditor.pak | pakchunk2-WindowsNoEditor.pak | \\---Plugins 这里生成的多个 chunks 的 pak 文件可以设置在上一篇拆分基础包的规则文件中，实现基础包拆分的功能。 资产审计 Asset Audit 在上面的两节中分别介绍了 UE 中打包的项目配置和为资产划分 Chunk 的方式，本节会介绍在日常开发中进行资产审计的方式和工具。 通过Chunk 划分，这一节的介绍，我们可以标记一些资源打包到 pak 中去，但是我们无法很直观地知道被这个 chunk 所管理的资源有多少，在每个平台的大小，因为 UE 打包时需要执行 cook，每个资源的最终大小都是平台相关的，所以需要一种方法能够直观地看到基础包内 Chunk 的资源划分。 UE 提供了资产审计工具：Asset Audit，可以在 Editor 中通过 Windows-Developer Tools-Asset Audit 打开。 可以看到资源路径、大小、位于哪些 Chunk 中等一系列的信息，便于排查资源大小和 Chunk 中的资源冗余。 前面已经提到了 Editor 里的看到的资源大小和最终打到包内的大小是不一样的，在 Asset Audit 窗口的右上角会列出已经打包的平台（Saved/Cooked）下的平台。 Asset Audit是需要读取 DevelopmentAssetRegistry.bin 文件来得到某个平台的资源信息的，当打包某个平台之后，存储在以下路径中： 1Client\\Saved\\Cooked\\WindowsNoEditor\\Client\\Metadata\\DevelopmentAssetRegistry.bin 这个文件记录着某个平台执行完 Cook 之后资源的大小以及引用关系等信息，注意 Cook 之后的资源如 Texture2D 等设置的压缩均以执行，但是打包成 pak 时也会执行压缩，这里列出来的大小是没有经过打包 pak 压缩的 Cook 资源之后的原始大小。 可以在打包时自动提取 Cooked 目录下的 Metadata 目录，在 AssetAudit 窗口的右上角选择 Custom，选择 DevelopmentAssetRegistry.bin 文件即可。 UnrealPakViewerUnrealPakViewer是一个可以查看 Pak 文件的工具，可以方便地查看 Pak 中的文件信息以及从 Pak 中解压文件。 作者还支持了指定加载 AssetRegistry 文件，因为默认情况下 AssetRistry.bin 只在 Chunk0 中包含，打开不包含 AssetRegistry.bin 的 pak 是无法预览出资源类型的，可以通过指定外部文件的 AssetRegistry.bin 来使用，UnrealPakViewer 可以与 AssetAudit 结合起来用作为日常工程的资产审计工具。","tags":[{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"},{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"给 UE4 项目改名","date":"2021-02-10T00:00:00.000Z","path":"wiki/external1469810194/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 给 UE4 项目改名 。","tags":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"}],"categories":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/categories/Tip/"}],"is_external":true,"jump_to":"https://papalqi.cn/rename/"},{"title":"UE4 一些实践建议","date":"2021-02-09T00:00:00.000Z","path":"wiki/external1122176667/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 一些实践建议 。","tags":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"}],"categories":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/categories/Tip/"}],"is_external":true,"jump_to":"https://papalqi.cn/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"UE4 100 Tip For Unreal","date":"2021-02-07T00:00:00.000Z","path":"wiki/external1441096196/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 100 Tip For Unreal。","tags":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"}],"categories":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/categories/Tip/"}],"is_external":true,"jump_to":"https://papalqi.cn/100tipforunreal/"},{"title":"UE4 大世界场景工作流","date":"2021-01-28T00:00:00.000Z","path":"wiki/external1309222633/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 大世界场景工作流 。","tags":[{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"},{"name":"大世界","slug":"大世界","permalink":"https://ue5wiki.com/tags/%E5%A4%A7%E4%B8%96%E7%95%8C/"}],"categories":[{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"},{"name":"大世界","slug":"Optimization/大世界","permalink":"https://ue5wiki.com/categories/Optimization/%E5%A4%A7%E4%B8%96%E7%95%8C/"}],"is_external":true,"jump_to":"https://papalqi.cn/%E7%BE%8E%E6%9C%AF%E5%A4%A7%E4%B8%96%E7%95%8C/"},{"title":"UE 热更新：拆分基础包","date":"2021-01-27T21:51:56.000Z","path":"wiki/13765/","text":"在之前的几篇文章中，分别介绍了 UE 热更新的实现机制，以及热更的自动化流程，近期打算继续写几篇文章介绍下 UE 里热更新中资源包管理的流程和规则。 当然，不同类型的项目会有不同的打包策略，资源管理也没有通用的最佳策略。本篇文章主要介绍热更新流程中基础包的拆分的工程实践，涉及修改引擎实现 Android/IOS 通用拆分方式的方法，希望对不同业务的项目能提供一些有用的思路。 当项目发展到中后期的时候，会有大量的地图和美术资源，对于手游而言，包体的大小也是比较敏感的，而且 Android 还是 2G 的包体大小限制，所以当项目进行到一定阶段，拆分包体就是需要考虑的事情了，并且巨型的安装包也不利于推广。 在具有热更的情况下拆分基础包需要兼顾两个因素： 减小包体的同时不能影响玩法 要减少玩家的下载等待时间 这两个因素的取舍和实现或多或少都是需要与具体的游戏业务相关的，这里仅从实现层面来拆分基础包，不同的业务根据适合自己的业务规则来拆分就好。 UE 本身的资源管理，是可以在打包时进行拆分资源的，就是通过 Asset Manager 或者 AssetPrimaryLable 对资源按照类型、目录、地图、依赖分析等粒度进行资源的划分，也就是所谓的 Chunk 机制。Chunk 划分的操作方法可以看 UE 的文档： Preparing Assets for Chunking。 Cooking and Chunking UE 的 Chunk 机制，可以把默认情况下打出来一个单独的巨型 pak 根据设置的拆分粒度打包成数个小的 pak（在 Priority 相同的情况下会具有一份资源在多个 chunk 中存在的情况），如果以地图和其依赖的资源作为 chunk 的划分机制，就可以让基础包内包含初始的关键地图，在热更或者运行时把其余的资源动态下载下来。 其实拆分基础包的关键就两点： 能够按照自定义分类拆分资源（chunk） 能够自己控制资源打包到基础包内的规则 第一点可以通过 Asset Manager 的 Chunk 机制实现，那么第二点如何实现呢？ Android对于 Android 平台，因为有超过 2G 就会出包失败的问题，所以 UE 对 Android 默认提供了 ObbFilter 的功能，可以指定哪些文件要被添加到 Obb 中（pak/mp4）等。 控制方法只需要添加配置即可。 12345# Config/DefaultEngine.ini[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]+ObbFilters=-pakchunk1-*+ObbFilters=-pakchunk2-*+ObbFilters=-pakchunk3-* ObbFilters 的规则以 - 开头就是排除规则，会把基础包中的 chunk1-3 的 pak 给过滤掉，可以用于后续的下载流程。 也可以指定 Exclute 和Include规则组合来用： 12+ObbFilters=-*.pak+ObbFilters=pakchunk0-* 第一步忽略掉所有的 pak 文件，然后把 pakchunk0-*.pak 显式添加至 obb 中。 IOS但是 ，IOS 并没有提供这个功能，为了实现 IOS 与 Android 一样的过滤机制，我翻了下 UE 中打包 IOS 的代码，可以通过以下方式实现（需要修改iPhonePackager 的代码），思考和实现过程记录如下。 注意：我使用的 IPA 打包方式是远程构建，详见之前的文章：UE4 开发笔记：Mac/iOS 篇。 在前面提到了 UE 为 Android 提供了打包到 obb 中的文件过滤规则： 123# Config/DefaultEngine.ini[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]+ObbFilters=-pakchunk1-* 但是 UE 并没有为 IOS 提供相应的操作，默认情况下会把 IOS 的所有的 pak 文件都打包至 IPA 中。 为了统一 Android 和 IOS 的基础包规则，我自己实现了 IOS 上类似 Android 那种指定过滤规则的功能，做个简单的介绍。 我使用的是 Mac 远程打包，流程是在 Mac 上编译代码生成 IPA，拉回 Win，在 Win 上进行 Cook，生成 Pak 文件，最后把原始 IPA 解包，再添加 Pak 等文件组合成最终 IPA。 我的需求是，自定义指定过滤规则，可以把某些文件忽略，不打包到 IPA 中。那么这一步的操作其实就位于把 IPA 解包再打包的流程里，经过翻阅 UE 的代码，发现这个操作是通过 iPhonePackager 这个独立程序来实现的，那么就需要对这个程序的代码进行改造了。 经过调试分析，发现真正实现重新打包 IPA 的操作是在以下函数中执行的： Programs/IOS/iPhonePackager/CookTime.cs1234/** * Using the stub IPA previously compiled on the Mac, create a new IPA with assets*/static public void RepackageIPAFromStub(); 该函数位于 iPhonePackager-CookTime 类中。 123456789101112static public void RepackageIPAFromStub()&#123; // ... string SourceDir = Path.GetFullPath(ZipSourceDir); string[] PayloadFiles = Directory.GetFiles(SourceDir, &quot;*.*&quot;, Config.bIterate ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories); foreach (string Filename in PayloadFiles) &#123; // read file to memory,add to ZipFileSystem // generate stub and ipa &#125; //...&#125; 需要做的操作就是介入这个过程，把 PayloadFiles 中的文件列表通过我们自定义的规则来执行过滤。 从流程上分为以下几个步骤： 从项目中读取 Filter 的配置 创建出真正的过滤器 在 RepackageIPAFromStub 遍历文件的流程里使用过滤器进行检测是否需要被打入 ipa 只需要几十行代码就可以实现，首先需要添加一个 IniReader 的类： 123456789101112131415161718192021222324252627using Tools.DotNETCommon;using System.Runtime.InteropServices;using Ini;namespace Ini&#123; public class IniReader &#123; private string path; [DllImport(&quot;kernel32&quot;)] private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath); public IniReader(string INIPath) &#123; path = INIPath; &#125; public string ReadValue(string Section, string Key) &#123; StringBuilder ReaderBuffer = new StringBuilder(255); int ret = GetPrivateProfileString(Section, Key, &quot;&quot;, ReaderBuffer, 255, this.path); return ReaderBuffer.ToString(); &#125; &#125;&#125; 然后在 RepackageIPAFromStub 函数中创建过滤器： 123456789101112131415161718FileFilter IpaPakFileFilter = new FileFilter(FileFilterType.Include);&#123; string ProjectDir = Directory.GetParent(Path.GetFullPath(Config.ProjectFile)).FullName; // Program.Log(&quot;ProjectDir path &#123;0&#125;&quot;, ProjectDir); string EngineIni = Path.Combine(ProjectDir,&quot;Config&quot;,&quot;DefaultEngine.ini&quot;); // Program.Log(&quot;EngineIni path &#123;0&#125;&quot;, EngineIni); IniReader EngineIniReader = new IniReader(EngineIni); string RawPakFilterRules = EngineIniReader.ReadValue(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;, &quot;IPAFilters&quot;); Program.Log(&quot;RawPakFilterRules &#123;0&#125;&quot;, RawPakFilterRules); string[] PakRules = RawPakFilterRules.Split(&#x27;,&#x27;); // foreach(string Rule in PakRules) &#123;Program.Log(&quot;PakRules &#123;0&#125;&quot;, Rule);&#125; List&lt;string&gt; PakFilters = new List&lt;string&gt;(PakRules); if (PakFilters != null) &#123; IpaPakFileFilter.AddRules(PakFilters); &#125;&#125; 这里从项目的 Config/DefaultEngine.ini 的[/Script/IOSRuntimeSettings.IOSRuntimeSettings]项读取 IPAFilters 的值，规则与 Android 相同，也可以指定 Exclute 和Include规则，但是要把规则都写在一行，多个规则以逗号分隔。 12[/Script/IOSRuntimeSettings.IOSRuntimeSettings]IPAFilters=-*.pak,pakchunk0-* 最终，还需要在 RepackageIPAFromStub 遍历 Payload 文件的循环中进行检测是否匹配我们指定的过滤规则： 12345678910111213141516static public void RepackageIPAFromStub()&#123; // ... string SourceDir = Path.GetFullPath(ZipSourceDir); string[] PayloadFiles = Directory.GetFiles(SourceDir, &quot;*.*&quot;, Config.bIterate ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories); foreach (string Filename in PayloadFiles) &#123; if (!IpaPakFileFilter.Matches(Filename)) &#123; Program.Log(&quot;IpaPakFileFilter not match file &#123;0&#125;&quot;, Filename); continue; &#125; // Program.Log(&quot;IpaPakFileFilter match file &#123;0&#125;&quot;, Filename); &#125; //...&#125; 这样再执行打包 IOS，就会按照指定的过滤规则来添加文件了，实现了与 Android 上一致的行为。 打包过程中的 Log 如下（上文代码已注释）： 12345678910111213141516171819Saving IPA ...ProjectDir path C:\\BuildAgent\\workspace\\PackageWindows\\ClientEngineIni path C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Config\\DefaultEngine.iniRawPakFilterRules -*.pak,pakchunk0-*PakRules -*.pakPakRules pakchunk0-*IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Assets.carIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Info.plistIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\LaunchScreenIOS.webpIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Manifest_DebugFiles_IOS.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\Manifest_NonUFSFiles_IOS.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\mute.cafIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\ue4commandline.txtIpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\movies\\logo.mp4IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\movies\\sparkmore.mp4IpaPakFileFilter match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk0-ios.pakIpaPakFileFilter not match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk1-ios.pakIpaPakFileFilter not match file C:\\BuildAgent\\workspace\\PackageWindows\\Client\\Saved\\StagedBuilds\\IOS\\cookeddata\\fgame\\content\\paks\\pakchunk2-ios.pak... 可以看到，过滤规则已经生效了，除此之外不会对打出来的包有任何其他影响（当然这种默认情况下是丢失了资源的，还要实现一套下载机制，可以参考我之前热更系列的文章）。 注意：因为 iPhonePackager 是个 Program 类型的程序，并不依赖引擎，所以将其编译完之后是可以拷贝到非源码版引擎使用的。 注意 ，在非远程构建，直接在 Mac 中打 IOS 包的并不能修改 IphonePackager 的代码，因为非远程构建不会用到它。实现相同的效果需要修改IOSPlatform.Automation.cs 中的流程，把上面的代码加到 Package 函数中，实现过滤行为。 而且，默认 UE 在 mac 上应该也不会编译 csharp 的 program 的工程，可以在 Win 上修改了 AutomationTool 后拷贝到 Mac 上。 End通过上面的操作，可以实现 Android/IOS 相同的基础包过滤规则，把工程内最关键的资源打包到基础包中，其余的 pak 可以在打完基础包之后从 Saved/StagedBuilds 中提取出来，放到热更平台启动时下载或者根据项目的类型和需求设计运行时下载的方案。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"UE 热更新：基于 HotPatcher 的自动化流程","date":"2021-01-24T12:47:34.000Z","path":"wiki/10938/","text":"HotPatcher是我之前开源的一个 UE4 热更新版本管理和资源打包工具，可以方便地进行版本间的差异分析和 pak 打包。之前的文章为了直观地介绍都是基于手动地在编辑器中进行配置和打包的，在真正的工程实践中，可以自动化的重复操作就要避免手动的参与，较早之前我就在插件中添加了 commandlet 的支持，近期修复了一些问题以及增加了很多针对 commandlet 的优化，本篇文章是基于 HotPatcher 的自动化热更新流程的工程实践。 在之前的文章中，介绍了 HotPatcher 的工作机制，可以从以下几篇文章中获取更详细的信息： UE4 资源热更打包工具 HotPatcher UE4 热更新：需求分析与方案设计 2020 Unreal Open Day 从流程上简单的划分为以下几个步骤： 使用 UE 的方式打基础包； 提取基础包的 paklist 文件，导入 HotPatcher 中进行分析； 生成基础包的 Release 信息（多平台使用一份 Release）； 热更版本基于 Release 信息进行比对； 生成 Patch； 所以本篇文章的目的就是实现这几个关键步骤的可配置自动化流程，并且这个流程和所有的配置文件不应该受到引擎、项目路径在不同机器的差异等非关键因素的影响，实现真正通用的配置和流程。 自动化出基础包 当需要集成到 ci/cd 进行自动化构建出包，可以使用 UE 的 BuildGraph 来指导 UBT 和 UAT 工作。 可以直接使用下面的命令（引擎、项目、平台根据自己实际情况修改）： 1E:\\UnrealEngine\\Launcher\\UE_4.25\\Engine\\Build\\BatchFiles\\RunUAT.bat BuildCookRun -nocompileeditor -installed -nop4 -project=&quot;E:/Examples/Blank425/Blank425.uproject&quot; -cook -stage -archive -archivedirectory=&quot;E:/Examples/Blank425/Package&quot; -package -pak -prereqs -nodebuginfo -targetplatform=Android -cookflavor=ASTC -build -target=Blank425 -clientconfig=Development -utf8output 支持的平台名字为： 1Win32,Win64,HoloLens,Mac,XboxOne,PS4,IOS,Android,HTML5,Linux,LinuxAArch64,AllDesktop,TVOS,Switch,Lumin 也可以通过自己写 BuildGraph 的脚本来更精准地控制打包的阶段，这里不再赘述，推荐看这篇文章：UE4 基础：一键出包脚本。 通过上面的命令可以通过命令行的方式将 UE 的项目打包，可以自己封装一层脚本集成到 ci/cd 平台上。 打包不是本节的重点，重点是在打包后的第一时间提取当前打包时 UE 产生的 paklist*.txt 文件。 UE 打基础包时会把项目中配置的资源打包成 pak 文件，UE 的打包流程中也是通过创建了一个 paklist*.txt 文件来记录哪些资源需要被打成 pak，所以，只要提取了 paklist*.txt 文件就能知道当前基础包中包含了哪些 文件（注意不仅仅是 uasset）。 HotPatcher提供了两种方式来生成基础包的 Release 信息（用于记录基础包中的所有资源信息）： 通过导入打基础包时生成的 paklist 文件 通过自己指定打包的目录、添加外部文件 我建议的方式是使用第一种，因为更精准，可以精确地分析出基础包的任何一个文件（uasset/non-uasset），而且可以分析出不同平台的基础包中的差异文件，实现完全精确地基础包信息导出。 UE 打基础包时默认会把 paklist 文件存放在以下路径中（源码版与安装版的路径不同）： 安装版引擎： 1%AppData%\\Unreal Engine\\AutomationTool\\Logs\\ 引擎路径拼接 \\PakList_*.txt 其中 引擎路径拼接 的规则为： 1234# 引擎路径E:\\UnrealEngine\\Launcher\\UE_4.25# 拼接之后E+UnrealEngine+Launcher+UE_4.25 源码版引擎： 1Engine\\Programs\\AutomationTool\\Saved\\Logs\\BuildCookRun\\PakList_*.txt 所以，当打完基础包之后就按照上面的路径规则提取 paklist_*.txt 文件即可，以安装版为例，Win 上可以使用以下文件拷贝命令： 1echo f|xcopy /y/i/s/e &quot;%AppData%\\Unreal Engine\\AutomationTool\\Logs\\E+UnrealEngine+Launcher+UE_4.25\\PakList_*.txt&quot; &quot;E:\\ClientVersion\\0.0.1.0&quot; 就会把当前该目录下所有符合 paklist_*.txt 规则的文件拷贝到指定目录了。 为了统一获取源码版和安装版 paklist 的路径差异，可以使用 Python 写个脚本： 1234567891011121314151617181920def GetPakListFileRules(target_platform,engine_root_dir): b_installed_engine = False installedbuild_txt_path = &quot;%s\\\\Engine\\\\Build\\\\InstalledBuild.txt&quot; % engine_root_dir if os.path.exists(InstalledBuild_txt_path): b_installed_engine = True ue_paklist_dir = &quot;&quot; if b_installed_engine: sys_appdata_dir = os.getenv(&quot;APPDATA&quot;) ue_aut_log_dir = &quot;Unreal Engine\\\\AutomationTool\\\\Logs&quot; engine_log_dir = engine_root_dir engine_log_dir = engine_log_dir.replace(&#x27;:&#x27;,&#x27;&#x27;) engine_log_dir = engine_log_dir.replace(&#x27;\\\\&#x27;,&#x27;+&#x27;) engine_log_dir = engine_log_dir.replace(&#x27;/&#x27;,&#x27;+&#x27;) ue_paklist_dir = &quot;%s\\\\%s\\\\%s\\\\BuildCookRun&quot; % (sys_appdata_dir,ue_aut_log_dir,engine_log_dir) else: ue_paklist_dir = &quot;%s\\\\Engine\\\\Programs\\\\AutomationTool\\\\Saved\\\\Logs\\\\BuildCookRun&quot; % engine_root_dir print(ue_paklist_dir) ue_pak_list_rule = &quot;%s\\\\PakList_pakchunk*-%s.txt&quot; % (ue_paklist_dir,GetRealPlatformName(target_platform)) return ue_pak_list_rule 调用方法： 1ue_paklist_rules = GetPakListFileRules(&quot;Android_ASTC&quot;,&quot;C:\\\\Program Files\\\\Epic Games\\\\UE_4.26&quot;) 根据自己项目的需要简单修改即可。 注意：每打包一个平台都 必须要立即提取 该平台基础包的 paklist 文件，因为当执行下一个打包任务的时候，该目录下的文件会被清理。 自动化提取基础包信息 在上一步自动化出基础包中，实现了两个关键点的自动化： UE 的打包 提取当前平台的基础包的 paklist 这一节的重点，则是当我们打包了 0.0.1.0 版本数个平台的基础包和提取了相应的 paklist 文件之后，如何生成多平台的 release 的流程。 提取到的几个平台的 Paklist 目录结构如下： 123456789101112131415161718E:\\ClientVersion\\0.0.1.0&gt;tree /a /f卷 Document 的文件夹 PATH 列表 卷序列号为 0003-AEBBE:.+---Android_ASTC| PakList_pakchunk0-Android_ASTC.txt| PakList_pakchunk1-Android_ASTC.txt| PakList_pakchunk2-Android_ASTC.txt|+---IOS| PakList_pakchunk0-ios.txt| PakList_pakchunk1-ios.txt| PakList_pakchunk2-ios.txt|\\---WindowsNoEditor PakList_pakchunk0-WindowsNoEditor.txt PakList_pakchunk1-WindowsNoEditor.txt PakList_pakchunk2-WindowsNoEditor.txt 几个平台的 paklist 的存放结构和文件名是有相同规则的，只要有规则就可以自动化处理。 HotPatcher提供了 HotRelease 的 Commandlet，用于命令行的方式来导出 Release，可以指定配置文件： 1UE4Editor.exe PROJECT.uproject -run=HotRelease -config=&quot;release-config.json&quot; 但是，简单地指定配置文件其实对命令行是不那么友好的，因为首先需要构造出 config 文件才能指定，所以我近期对 HotRelease 的 Commandlet 做了增强，可以完全通过命令行来控制 config 的参数，并且可以不指定 config 文件。 因为前面已经提到 HotPather 支持两种模式导出 Release 的信息，所以如果当使用导入 paklist 时，只需要指定以下几个关键参数即可： VersionId 当前 Release 的版本号 ByPakList 开启 Paklist 模式 PlatformsPakListFiles 指定各个平台的对应的 paklist*.txt 文件 SavePath 生成 Release 的存储路径 我使用 UE 的反射机制实现了可以在命令行指定参数结构中定义的名字来构造出真实的配置信息（暂不支持指定数组），可以在执行 commandlet 时直接指定上面的参数。 所以，需要使用的 HotRelease 的 Commandlet 命令为（方便观看我对参数换行拆分）： 1234567E:\\UnrealEngine\\Launcher\\UE_4.25\\Engine\\Binaries\\UE4Editor-cmd.exeE:\\Examples\\Blank425\\Blank425.uproject-run=HotRelease-versionid=&quot;0.0.1.0&quot;-ByPakList=true-AddPlatformPakList=WindowsNoEditor+E:\\ClientVersion\\0.0.1.0\\WindowsNoEditor\\PakList_pakchunk0-WindowsNoEditor.txt+E:\\ClientVersion\\0.0.1.0\\WindowsNoEditor\\PakList_pakchunk1-WindowsNoEditor.txt+E:\\ClientVersion\\0.0.1.0\\WindowsNoEditor\\PakList_pakchunk2-WindowsNoEditor.txtsavepath.path=&quot;E:\\ClientVersion\\&quot; AddPlatformPakList是通过命令行指定 Platform-PaklistFiles 的参数，要求为： 1PLATFORM_NAME+Paklist_0.txt+PakList_1.txt,PLATFORM_NAME+Paklist_0.txt+PakList_1.txt 可以指定多个平台，以逗号 (,) 分割，每个平台的节第一个为平台名通过 + 号分割，后面可以指定任意数量的 Paklist 文件。 以指定 WindowsNoEditor/Android_ASTC/IOS 三个平台为例： 1-AddPlatformPakList=WindowsNoEditor+E:\\Paklist_chunk01_WindowsNoEditor.txt+E:\\Paklist_chunk02_WindowsNoEditor.txt,Android_ASTC+E:\\Paklist_chunk01_Android_ASTC.txt+E:\\Paklist_chunk02_Android_ASTC.txt,IOS+E:\\Paklist_chunk01_IOS.txt+E:\\Paklist_chunk02_IOS.txt 指定平台和文件路径都是有规则的，可以使用 Python 等脚本来针对项目的管理风格进行封装，最后直接使用 os.system 来执行 commandlet 即可，就会与在 Editor 中在 HotPatcher 编辑器中手动执行 ByRelease 一样的行为。 注意：虽然 Release.json 中记录了 Non-uasset 文件的绝对路径，但是实际上进行版本比对时，是不检查文件的绝对路径的，所以 Release.json 文件是跨机器通用的信息（以资源路径、mount 路径进行比对）。 自动化生成 Patch上一节也已经介绍了如何自动化地生成 Release 信息，生成 Release 需要配置的选项不多，但是 Patch 就有非常多的配置了，所以完全地抛弃 config 文件是更麻烦的行为，所以我想了一个折衷方案——指定通用配置文件和命令行指定特殊的参数。 那么，哪些是通用的配置文件呢？ Patch 要扫描的资源目录 要添加的文件（ini/shaderbytecode/assetregistry） Non-uasset 的文件、目录 Chunk 的划分 哪些是可以通过命令行指定的呢？ VersionID 基础版本的 Release 文件 是否 Cook 当前 Patch 中的资源 要生成 Patch 的平台 Pak 文件的命名规则 保存目录 在老版本的 HotPatcher 中，配置文件是依赖各种参数的绝对路径的（添加的 Non-uasset）文件，近期我做了优化，可以支持相对于工程目录的相对路径。 以添加 Content/Script 目录为例，在之前的版本中只能通过选择绝对路径的文件夹： 现在可以通过 [PROJECT_CONTENT_DIR] 来替代： 在执行 Path 的过程中会扫描替换为当前工程的绝对路径。 支持 [] 标记的相对路径有以下几个： 123456[ENGINEDIR][ENGINE_CONTENT_DIR][PROJECTDIR][PROJECT_CONTENT_DIR][PROJECT_SAVED_DIR][PROJECT_CONFIG_DIR] 可以根据自己的需要使用，使用这种方式，就可以导出一份通用的配置。 PatchTemplate.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123; &quot;bByBaseVersion&quot;: true, &quot;baseVersion&quot;: &#123; &quot;filePath&quot;: &quot;&quot; &#125;, &quot;versionId&quot;: &quot;&quot;, &quot;assetIncludeFilters&quot;: [ &#123; &quot;path&quot;: &quot;/Game&quot; &#125; ], &quot;assetIgnoreFilters&quot;: [], &quot;bForceSkipContent&quot;: true, &quot;forceSkipContentRules&quot;: [ &#123; &quot;path&quot;: &quot;/Engine/Editor&quot; &#125;, &#123; &quot;path&quot;: &quot;/Engine/VREditor&quot; &#125; ], &quot;forceSkipAssets&quot;: [], &quot;bIncludeHasRefAssetsOnly&quot;: false, &quot;bAnalysisFilterDependencies&quot;: true, &quot;bRecursiveWidgetTree&quot;: true, &quot;assetRegistryDependencyTypes&quot;: [ &quot;Packages&quot; ], &quot;includeSpecifyAssets&quot;: [], &quot;bIncludeAssetRegistry&quot;: true, &quot;bIncludeGlobalShaderCache&quot;: false, &quot;bIncludeShaderBytecode&quot;: false, &quot;bIncludeEngineIni&quot;: false, &quot;bIncludePluginIni&quot;: false, &quot;bIncludeProjectIni&quot;: false, &quot;bEnableExternFilesDiff&quot;: true, &quot;ignoreDeletionModulesAsset&quot;: [], &quot;addExternAssetsToPlatform&quot;: [ &#123; &quot;targetPlatform&quot;: &quot;AllPlatforms&quot;, &quot;addExternFileToPak&quot;: [], &quot;addExternDirectoryToPak&quot;: [ &#123; &quot;directoryPath&quot;: &#123; &quot;path&quot;: &quot;[PROJECT_CONTENT_DIR]/Script&quot; &#125;, &quot;mountPoint&quot;: &quot;../../../Blank425/Content/Script&quot; &#125; ] &#125; ], &quot;bIncludePakVersionFile&quot;: false, &quot;pakVersionFileMountPoint&quot;: &quot;../../../Blank425/Versions/version.json&quot;, &quot;bEnableChunk&quot;: false, &quot;chunkInfos&quot;: [], &quot;bCookPatchAssets&quot;: true, &quot;pakCommandOptions&quot;: [], &quot;replacePakCommandTexts&quot;: [], &quot;unrealPakOptions&quot;: [ &quot;-compress&quot;, &quot;-compressionformats=Zlib&quot; ], &quot;pakTargetPlatforms&quot;: [], &quot;bCustomPakNameRegular&quot;: false, &quot;pakNameRegular&quot;: &quot;&#123;VERSION&#125;_&#123;CHUNKNAME&#125;_&#123;PLATFORM&#125;_001_P&quot;, &quot;bIgnoreDeleatedAssetsInfo&quot;: false, &quot;bSaveDeletedAssetsToNewReleaseJson&quot;: true, &quot;bSavePakList&quot;: true, &quot;bSaveDiffAnalysis&quot;: true, &quot;bSaveAssetRelatedInfo&quot;: false, &quot;bSavePatchConfig&quot;: true, &quot;savePath&quot;: &#123; &quot;path&quot;: &quot;&quot; &#125;&#125; 这个配置就可以作为生成 Path 时 资源相关 的通用配置文件，当我们想要修改打包的配置时只需要修改这个文件即可。 其他的版本相关的参数都可以通过 HotPatcher 的 commandlet 命令行来指定了： 12345678E:\\UnrealEngine\\Launcher\\UE_4.25\\Engine\\Binaries\\UE4Editor-cmd.exeE:\\Examples\\Blank425\\Blank425.uproject-run=HotPatcher-config=&quot;E:\\ClientVersion\\PatchTemplate.json&quot;-versionid=&quot;0.0.1.1&quot;-baseVersion.filePath=&quot;E:\\ClientVersion\\0.0.1.0\\0.0.1.0_Release.json&quot;-AddPatchPlatforms=&quot;WindowsNoEditor,Android_ASTC,IOS&quot;-savePath.path=&quot;E:\\ClientVersion\\&quot; 同样，这个命令的参数也是有规律可循的，当目录结构组织比较好的情况下，只要指定当前 Patch 的基础版本和当前的版本号就可以完全自动化的出包了。 同样，生成 Path 的流程也可以通过 Python 等脚本进行封装，可以在 ci/cd 平台上指定引擎目录、项目目录、基线版本、当前版本、以及生成哪些平台的 patch 等参数，方便控制。 结语 本篇文章介绍了使用 HotPatcher 来自动化执行热更新的流程，包括 UE 自动化出基础包、paklsit 的提取，Release 的生成、通用的 Patch 生成规则等，可以方便地集成至 ci/cd 平台，避免手动参与的过程。 后续有时间我会写一份用于 HotPatcher 自动化导出 Release/Patch 的 Python 脚本，方便直接使用。","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"UE 反射实现分析：C++ 特性","date":"2020-12-13T19:39:37.000Z","path":"wiki/23694/","text":"在前一篇文章中，介绍了 UE 的反射的基础概念，这篇文章开始研究 UE 的反射机制的具体实现。 在介绍 UE 的代码之前，需要先要介绍一些 C++ 特性，虽然 UE 的反射实现是大量依赖 UHT 的代码生成的，但是也需要 C++ 的语法特性支持，只有把这些特性还有它们背后的含义了解清楚，才能够更好地理解 UE 的反射机制。 本篇文章中介绍的 C++ 的特性和标准描述均基于ISO/IEC 14882:2014，也就是 C++14 标准。 要介绍的实现反射依赖的 C++ 特性，就是把 C++ 中类型的信息通过什么样的方式存储下来供运行时访问。 class/struct对于 C++ 的类而言，需要着重关注的是内存布局，因为类实例本质就是一块内存，而如何解释这块内存，需要通过类的类型信息来确定。在 C++ 中 struct 和class来定义类，只有默认的访问控制权限有差别，在 UE 中则不同，USTRUCT 和 UCLASS 则进行了严格的区分，USTRUCT 不能具有反射函数。 数据成员 因为兼容 C 的以及语言特性的实现，C++ 还有 POD 的概念。而介绍 POD 则又先要介绍 C++ 标准中的standard-layout class（[ISO/IEC 14882:2014 9.1.7]）：A standard-layout class is a class that: has no non-static data members of type non-standard-layout class (or array of such types) or reference, has no virtual functions (10.3) and no virtual base classes (10.1), has the same access control (Clause 11) for all non-static data members, has no non-standard-layout base classes, either has no non-static data members in the most derived class and at most one base class withnon-static data members, or has no base classes with non-static data members, and has no base classes of the same type as the ﬁrst non-static data member. 因为 C++ 在实现特性的时候会往原始的内存布局中插入或调整成员顺序，所以 C++ 标准中对 standard-layout class 做了上述限定。 可以把 POD 理解为只有数据的类，并且数据成员的排列顺序是固定的（不能包含多个不同的访问控制权限，因为编译器 有可能 会混排，标准中没有做保证），除了内存对齐外，不会被插入额外的内存。 在我之前的一篇文章：结构体成员内存对齐问题 里介绍了内存对齐。因为内存对其的存在，类内数据成员并不是严格的一个挨着一个存放的，内存布局中会有一些空隙，这样会有两个问题： 数据成员在类内的偏移地址是依赖于内存对齐的 不同的声明顺序会导致类布局的变化（编译器也有可能对不同的访问控制权限进行重排） 为了获取数据成员在类内的偏移值，而不用考虑上面一堆的东西，C++ 引入了一个特性：Pointers to members，翻译过来就叫做 指向成员的指针 ，这部分内容的详细描述在ISO/IEC 14882:2014 §8.3.3 中。 在我之前的一篇文章中，也对指向成员的指针做过比较详细的介绍：C++ 中指向类成员的指针并非指针。 指向类成员的指针，重点就是来获取数据成员、函数相对于类型的描述信息，比如数据成员在类布局中的偏移，成员函数的 this 偏移值、成员函数的原始函数指针，得到了这些信息才能通过类实例访问到具体的成员。 如以下类： 12345678class ClassExample&#123;public: bool bBoolean; int ival; double dval; void func(int)&#123;&#125;&#125;; 来获取它三个成员的内部偏移值： 123bool ClassExample::*bBoolean = &amp;ClassExample::bBoolean;int ClassExample::*ival = &amp;ClassExample::ival;double ClassExample::*dval = &amp;ClassExample::dval; 通过 LLVM-IR 翻译之后可以更直观地看到： 123store i64 0, i64* %1, align 8store i64 4, i64* %2, align 8store i64 8, i64* %3, align 8 如果把类定义中的 func 改成 virtual 呢？ 123store i64 8, i64* %1, align 8store i64 12, i64* %2, align 8store i64 16, i64* %3, align 8 可以看到内存布局的变化，这是因为类中有了虚函数，往类布局中插入了虚表指针，占用了 8 个字节。 小结一下：通过成员函数指针等特性，可以在编译时就确定数据成员在类布局中的偏移，通过 该偏移 + 数据成员的类型大小（sizeof），就可以正确地访问到指定的成员所在的内存了。 但是，C++ 中也有一个限制，就是不能对位域取地址： The address-of operator &amp; shall not be applied to a bit-ﬁeld, so there are no pointers to bit-ﬁelds. 位域在 UE 中被广泛地应用于 bool 值，C++ 中对该用法有保证： A bool value can successfully be stored in a bit-ﬁeld of any nonzero size. 并且，位域的分配和对齐是实现定义的： [ISO/IEC 14882:2014 9.6 Bit-ﬁelds]Allocation of bit-ﬁelds within a class object is implementation-deﬁned. Alignment of bit-ﬁelds is implementation-deﬁned. 因为不能对位域进行取地址，所以在反射实现中需要对 uint8 bEnable:1; 做一些特殊处理，要能得到位域中的位。 以 FBoolProperty 中获取 bool 值的实现为例： 123456FORCEINLINE bool GetPropertyValue(void const* A) const&#123; check(FieldSize != 0); uint8* ByteValue = (uint8*)A + ByteOffset; return !!(*ByteValue &amp; FieldMask);&#125; 同时兼容了 NativeBool 和bit-field。 对于 uint8 bit_field:1; 和bool native_bool;两种反射信息的生成，以反射信息中的 UE4CodeGen_Private::EPropertyGenFlags::NativeBool 来区别，具有该 flag 的是bool native_bool;。 成员函数UE 的反射函数都是成员函数，并且需要继承自 UObject。 UE 中成员函数实现反射，并没有依赖 C++ 的指向成员函数的指针，它完全依赖 UHT 生成了一个统一原型的 Thunk 函数，在 Thunk 函数中调用真正执行的函数（包括从栈上取数据等操作）。 并且会为反射的函数生成用于传递给 ProcessEvent 函数的参数结构，以及每个参数、返回值生成属性的反射信息（它们的内存偏移都是相对于 UHT 生成的参数结构的）。 如以下函数： 12UFUNCTION()bool func(int32 InIval); UHT 生成的 Thunk 函数为： 12345678DEFINE_FUNCTION(URefObject::execfunc)&#123; P_GET_PROPERTY(FIntProperty,Z_Param_InIval); P_FINISH; P_NATIVE_BEGIN; *(bool*)Z_Param__Result=P_THIS-&gt;func(Z_Param_InIval); P_NATIVE_END;&#125; 用这种方式，统一了所有的反射函数的调用原型为： 1void execfunc(UObject* Context, FFrame&amp; Stack, RESULT_DECL) 每个反射的函数都可以从这个原型中获取自己的参数，从而执行真正的函数调用行为（或者执行蓝图字节码）。 enum枚举值不是整数，但是它可以被提升为整数类型。 [ISO/IEC 14882:2014]Therefore, enumerations (7.2) are not integral; however, enumerations can be promoted to integral types as speciﬁed in 4.5. 在 UE 的 UEnum 中枚举值使用 int64 来存储，所以，只要我们知道了枚举的名字，还有它名字所对应的整数值，就可以在名字和整数值以及枚举之间进行相互转换了。 UHT 会给添加了 UENUM 的枚举生成这些信息，并在运行时构造出 UEnum 实例存储这些信息。 UE 中的 Enum 写法： 12345678UENUM()enum class EClassEnum: uint8&#123; A =0, B, C = 11, D&#125;; UHT 生成的部分反射代码： 123456static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = &#123; &#123; &quot;EClassEnum::A&quot;, (int64)EClassEnum::A &#125;, &#123; &quot;EClassEnum::B&quot;, (int64)EClassEnum::B &#125;, &#123; &quot;EClassEnum::C&quot;, (int64)EClassEnum::C &#125;, &#123; &quot;EClassEnum::D&quot;, (int64)EClassEnum::D &#125;,&#125;; 基于反射 UEnum 进行字符串、枚举值的转换： 1234567891011121314151617181920template&lt;typename ENUM_TYPE&gt;static bool GetEnumValueByName(const FString&amp; InEnumValueName, ENUM_TYPE&amp; OutEnumValue)&#123; bool bStatus = false; UEnum* FoundEnum = StaticEnum&lt;ENUM_TYPE&gt;(); FString EnumTypeName = FoundEnum-&gt;CppType; if (FoundEnum) &#123; FString EnumValueFullName = EnumTypeName + TEXT(&quot;::&quot;) + InEnumValueName; int32 EnumIndex = FoundEnum-&gt;GetIndexByName(FName(*EnumValueFullName)); if (EnumIndex != INDEX_NONE) &#123; int32 EnumValue = FoundEnum-&gt;GetValueByIndex(EnumIndex); ENUM_TYPE ResultEnumValue = (ENUM_TYPE)EnumValue; OutEnumValue = ResultEnumValue; bStatus = true; &#125; &#125; return bStatus;&#125; 而且也可以访问蓝图中的 Enum： 12345678910FString UFlibAppHelper::GetEnumNameByValue(TSoftObjectPtr&lt;UUserDefinedEnum&gt; EnumPath, int32 value)&#123; FString result; UUserDefinedEnum* Enumer = LoadObject&lt;UUserDefinedEnum&gt;(nullptr, *EnumPath.ToString()); if (Enumer) &#123; result = Enumer-&gt;GetDisplayNameTextByValue(value).ToString(); &#125; return result;&#125; scoped enum随便写一点点番外，C++ 的 scoped enum。 C++11 引入了 scoped enum： 12345enum class EClassEnum&#123; A = 0, B, C&#125;; 为什么要引入这么语法呢？因为 C++11 之前的 enum，其枚举值得定义是位于整个所属名字空间的。C++ 标准中的描述： [ISO/IEC 14882:2014 §7.2]The enumeration type declared with an enum-key of only enum is an unscoped enumeration, and its enumerators are unscoped enumerators. 下面代码就会出现重定义错误： 123456enum ENormalEnum&#123; A = 0&#125;;enum EOtherEnum&#123; A = 0&#125;; 所以在一般写代码时会加上 namespace 来人为地区分枚举的名字空间： 123456789namespace ENamespaceEnum&#123; enum Type &#123; A = 0, B, C &#125;;&#125;; 因为上面 Type 的枚举值是位于当前 namespace 的，所以就可以以下面这种形式来使用： 123ENamespaceEnum::A;ENamespaceEnum::B;ENamespaceEnum::C; 这其实是一种弱类型枚举，枚举本身并不是一个类型。所以 C++11 引入了 Scoped Enum，可以理解为强类型枚举： 12345enum class EScopedEnum&#123; A = 0, B, C&#125;; 使用它可以具有与上面 namespace 形式一样的效果。 Scoped Enumeration 的值也是可以显式转换为数值类型的： [ISO/IEC 14882:2014 §5.2.9]A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. 而且，如果 scoped enum 的基础类型没有被显式指定的话，它的默认基础类型是 int: [ISO/IEC 14882:2014 §7.2]Each enumeration also has an underlying type. The underlying type can be explicitly speciﬁed using enum-base; if not explicitly speciﬁed, the underlying type of a scoped enumeration type is int. 在 LLVM 中，对 Scoped enum 的处理是在编译器前端做的，下列代码生成的 IR 代码： 12345678910111213141516enum ENormalEnum&#123; A = 0, B, C&#125;;enum class EScopedEnum&#123; A = 0, B, C&#125;;int main()&#123; printf(&quot;A:%d,B:%d,C:%d\\n&quot;,A,B,C); printf(&quot;A:%d,B:%d,C:%d\\n&quot;,EScopedEnum::A,EScopedEnum::B,EScopedEnum::C);&#125; main 函数的 LLVM-IR： 1234567; Function Attrs: uwtabledefine i32 @main() #3 &#123;entry: %call = call i32 (i8*, ...) @_Z6printfPKcz(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i32 0, i32 0), i32 0, i32 1, i32 2) %call1 = call i32 (i8*, ...) @_Z6printfPKcz(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i32 0, i32 0), i32 0, i32 1, i32 2) ret i32 0&#125; 在生成 IR 时就没有符号信息，只剩常量了。 static 的构造时机 UE 里的反射技术也依赖了 C++ 的 static 构造时机，如gen.cpp 中的： 1static FCompiledInDefer Z_CompiledInDefer_UClass_URefObject(Z_Construct_UClass_URefObject, &amp;URefObject::StaticClass, TEXT(&quot;/Script/RefExample&quot;), TEXT(&quot;URefObject&quot;), false, nullptr, nullptr, nullptr); C++ 标准中对 static 的构造时机介绍： It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main. 虽然标准里写的 implementation-defined 行为，但是几乎用到的编译器都是这么干的。","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"UE 反射实现分析：基础概念","date":"2020-12-12T23:56:24.000Z","path":"wiki/12624/","text":"反射，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC 等方面非常有用。但是 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 在之前的文章中，有一些涉及到 UE 的构建系统和反射相关的内容。 涉及了 UE 的构建系统文章： Build flow of the Unreal Engine4 project UE4 Build System: Target and Module UEC++ 与标准 C++ 的区别与联系 基于 UE 的反射机制来做一些奇淫巧技的文章： UE4：Hook UObject UE 的反射实现是依赖于构建系统中 UHT 来执行代码生成的，本篇文章对 UE 的反射做一个基础概念介绍，后续会花几篇文章完整地介绍 UE 里反射的实现机制。 UE 的反射可以实现 Enum 的反射 (UEnum)、类反射(UClass)、结构反射(UStruct)、数据成员反射(UProperty/FProperty)、成员函数反射(UFunction)，可以在运行时访问到它们，其实反射被称作 属性系统 应该更合适。 可以根据这些反射信息来获取它们的类型信息，本篇文章以类反射为例子介绍一下 UE 的反射。 如以下纯 C++ 代码： 123456class ClassRef&#123;public: int32 ival = 666; bool func(int32 InIval)&#123; return false;&#125;&#125;; 想要在运行时获取 ClassRef 类有哪些数据成员、函数，要如何操作？ C++ 原生并没有提供这样的能力，相同的需求在 UE 中创建的类是以下形式： 12345678910111213141516171819#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;RefObject.generated.h&quot;UCLASS()class REF_API URefObject : public UObject&#123; GENERATED_BODY()public: UPROPERTY() int32 ival = 666; UFUNCTION() bool func(int32 InIval) &#123; UE_LOG(LogTemp,Log,TEXT(&quot;Function func: %d&quot;),InIval); return true; &#125;&#125;; 其中关键需要注意的点： RefObject.generated.h文件 UCLASS 标记 GENERATED_BODY 标记 UPROPERTY 标记 UFUNCTION 标记 本文不对它们的具体含义做过多的介绍，后续的文章会做详细的分析。 UCLASS/USTRUCT/UFUNCTION/UPROPERTY等可以在 () 中添加很多的标记值以及 meta 参数，用于指导 UHT 来生成对应的反射代码，它们支持的参数可以在 UE 的文档中查看： Class Specifiers Struct Specifiers Function Specifiers Property Specifiers Metadata Specifiers 这种通过添加的 代码标记 来告诉 UE 的构建系统，由 UHT 来生成反射的代码，反射的代码保存在 gen.cpp 中，注意这些反射标记 只是 用来告诉 UHT 来生成代码的，在经过 C++ 的预处理阶段后它们大多都是空宏（有些是真的 C++ 宏），这也导致 UE 的反射标记有一个缺点：无法使用 C++ 的宏来包裹 UE 的反射标记，因为它们先于 预处理 执行。 而且，UHT 只是简单粗暴的关键字匹配硬扫描，限制很大。 对于继承自 UObject 的类而言，它的反射信息被创建出了一个 UClass 对象，可以通过这个对象在运行时获取对象类型的信息。并且，类内部的 反射数据成员 和反射成员函数 ，都会给生成对应的FProperty 和UFunction对象，用来运行时访问到它们。 UClass 的继承关系： UObjectBase UObjectBaseUtility UObject UField UStruct UClass 针对继承自 UObject 的类，可以通过 GetClass() 来获取 UClass 实例，但是如果想直接获取某个类型的 UClass，则可以通过 StaticClass&lt;UObject&gt; 或者 UObject::StaticClass() 来获取。 UClass 中记录这类的继承关系、实现的接口、各种 Flag 等等，具体可以直接查阅 UClass 的类定义，通过它可以访问到该 UObject 的 C++ 类型中的信息。 而且，在运行时可以通过 TFieldIterator 来遍历 UClass 中的反射属性： 12345678910111213URefObject::URefObject(const FObjectInitializer&amp; Initializer):Super(Initializer)&#123; for(TFieldIterator&lt;FProperty&gt; PropertyIter(GetClass());PropertyIter;++PropertyIter) &#123; FProperty* PropertyIns = *PropertyIter; UE_LOG(LogTemp,Log,TEXT(&quot;Property Name: %s&quot;),*PropertyIns-&gt;GetName()); &#125; for(TFieldIterator&lt;UFunction&gt; PropertyIter(GetClass());PropertyIter;++PropertyIter) &#123; UFunction* PropertyIns = *PropertyIter; UE_LOG(LogTemp,Log,TEXT(&quot;Function Name: %s&quot;),*PropertyIns-&gt;GetName()); &#125;&#125; 执行结果： 123LogTemp: Property Name: ivalLogTemp: Function Name: funcLogTemp: Function Name: ExecuteUbergraph 那么如何通过属性和成员函数的反射信息来访问到它们呢？ 访问数据成员 首先，在 C++ 中类内存布局中是编译时固定的，所以一个数据成员在类中的位置是固定的，C++ 有一个特性叫做 指向类成员的指针，本质上就是描述了当前数据成员在类布局内的偏移值。这部分内容在我之前的文章中有介绍：C++ 中指向类成员的指针并非指针。 FProperty 做的就是类似的事情，记录反射数据成员的类内偏移信息，UE 中的实现也是通过 指向成员的指针 来实现的，这部分后面的文章会着重介绍，这里只介绍使用方法。 通过 FProperty 获取对象中值的方式，需要通过调用 FProperty 的ContainerPtrToValuePtr来实现： 123456789for(TFieldIterator&lt;FProperty&gt; PropertyIter(GetClass());PropertyIter;++PropertyIter)&#123; FProperty* PropertyIns = *PropertyIter; if(PropertyIns-&gt;GetName().Equals(TEXT(&quot;ival&quot;))) &#123; int32* i32 = PropertyIns-&gt;ContainerPtrToValuePtr&lt;int32&gt;(this); UE_LOG(LogTemp,Log,TEXT(&quot;Property %s value is %d&quot;),*PropertyIns-&gt;GetName(),*i32); &#125;&#125; 这样就实现了通过 FProperty 来访问数据成员的目的，因为获取到的是数据成员的指针，所以修改它也是没问题的。 访问成员函数 通过反射访问函数则要复杂一些，因为要处理参数传递和返回值的接收问题。 前面已经提到了，UE 的反射成员函数会生成 UFunction 对象，函数的反射信息就在它里面，因为 UFUNCTION 是只能标记在继承自 UObject 的类中，所以 UE 封装了一套基于 UObject 的反射函数调用方式： 123456// defined in UObjectvirtual void ProcessEvent( UFunction * Function, void * Parms) 只有两个参数，第一个是传入 UFunction 的指针，第二个是 void* 指针，作为通用的方式来传递参数和接收返回值。对于标记为 UFUNCTION 的函数，UHT 会为该函数生成一个 Thunk 函数，形如以下形式： 12345678DEFINE_FUNCTION(URefObject::execfunc)&#123; P_GET_PROPERTY(FIntProperty,Z_Param_InIval); P_FINISH; P_NATIVE_BEGIN; *(bool*)Z_Param__Result=P_THIS-&gt;func(Z_Param_InIval); P_NATIVE_END;&#125; 把 DEFINE_FUNCTION 宏展开之后就是固定的原型了： 12#define DEFINE_FUNCTION(func) void func(UObject* Context, FFrame&amp; Stack, RESULT_DECL)void URefObject::execfunc(UObject* Context, FFrame&amp; Stack, RESULT_DECL) 在 ProcessEvent 会按照这个统一的原型去调用反射函数的 Thunk 函数，在从 Thunk 函数转发给真正的 C++ 函数，实现基于反射调用到真正 C++ 函数的目的，当然也可以通过在 UFUNCTION 中添加 CustomThunk 标记，不让 UHT 生成函数的 Thunk 函数，自己手动提供，可以用来解决特殊的需求（如 unlua 中的覆写）。 现在回到ProcessEvent，它的函数原型中有三个关键点： ProcessEvent是 UObject 的成员函数 ProcessEvent的第一个参数要是当前类中的 UFunction void* Parms必须要是连续内存结构 着重要讲的就是 void* Parms 怎么用。 首先，对于示例函数： 1bool func(int32 InIval); 它接收一个参数，并返回一个 bool 值，如何通过一个参数来同时做这两件事情呢？ 把他们封装为一个结构！如同下面这种形式： 12345struct RefObject_eventFunc_Parms&#123; int32 ival; bool ReturnValue;&#125;; 要传递给函数的参数排在前面，返回值为最后一个数据成员（如果有的话）。而且，也是可以通过 UFunction::ParmsSize 得到当前函数所有参数 + 返回值结构的大小，在运行时动态分配，并且可以通过 UFunction 的各个参数 FProperty 来访问到每个参数的内存，这部分内容暂时按下不表，后面的文章会详细的介绍。 所以，当我们通过 UClass 拿到指定的 UFunction 之后就可以做这个事情了： 12345678910111213141516for(TFieldIterator&lt;UFunction&gt; PropertyIter(GetClass());PropertyIter;++PropertyIter)&#123; UFunction* FuncIns = *PropertyIter; if(FuncIns-&gt;GetName().Equals(TEXT(&quot;func&quot;))) &#123; struct RefObject_eventFunc_Parms &#123; int32 ival; bool ReturnValue; &#125;func_params; func_params.ival = 111; this-&gt;ProcessEvent(FuncIns,&amp;func_params); UE_LOG(LogTemp,Log,TEXT(&quot;call func return: %s&quot;),func_params.ReturnValue?TEXT(&quot;true&quot;):TEXT(&quot;false&quot;)); &#125; UE_LOG(LogTemp,Log,TEXT(&quot;Function Name: %s&quot;),*FuncIns-&gt;GetName());&#125; 但是这样基于反射机制的函数调用有一个问题：无法处理参数和返回值为引用的情况。如： 1234UFUNCTION() int32&amp; Add(int32 R, int32&amp; L);UFUNCTION() int32 Add(int32 R, int32 L); 这两个函数生成的反射信息一摸一样！（对 L 参数生成的 FProperty 的 Flag 会多一个 CPF_OutParm，返回值的 FProperty 还具有 CPF_ReturnParm）。 因为 C++ 的引用必须要在初始化时进行绑定的： 123456789class ClassRef&#123;public: ClassRef(int&amp; InIval):ival(InIval)&#123;&#125; int&amp; ival;&#125;;// instanceint ival =666;ClassRef obj(ival); 这就对 UHT 的参数结构造成了限制，因为默认情况下 UHT 给每个反射函数生成了参数结构，是通过先实例化，再把真正的参数赋值给该实例中成员的，就跟上面的例子一样，做了一次值拷贝。而引用无法修改，只能在初始化时设置。在调用 ProcessEvent 时，真正调用到 C++ 函数的时候，如果参数有引用则是绑定到的该 UHT 生成的结构中数据成员，而不是我们真实传递的参数。 基于反射的函数调用实际上进行了两步操作： 把参数赋值给 ProcessEvent 的函数参数结构 ProcessEvent 再把参数结构传递给真正的 C++ 函数 这会造成通过 UFunction* 调用 ProcessEvent 传递的参数和想要获取的返回值也都只是原始参数的一份拷贝，而不是真正绑定的引用关系（因为本来调用时的参数传递到 ProcessEvent 之前都会被赋值到 UHT 创建出来的参数结构），在真正的 C++ 函数中对引用参数的修改也只能改动 UHT 生产的参数结构实例，而非我们传递的真正的参数。 本篇文章对 UE 的反射做了一个简单的介绍，并示例了通过 UClass 获取反射信息来访问数据成员和成员函数的方式，UE 中反射的实现会在后续的文章中详细介绍，下一篇会介绍 UE 反射实现所依赖的 C++ 特性，目前文章已发表：UE4 反射实现分析：C++ 特性。 参考资料： Unreal Property System (Reflection)","tags":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"}],"categories":[{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"}]},{"title":"UE 热更新：UOD 资料","date":"2020-12-05T13:38:15.000Z","path":"wiki/11043/","text":"2020 年的 Unreal Open Day 是在线上直播和技术分会场的形式进行的，很开心参加了今年的 UOD 活动，我录制了一场 UOD 的技术视频，也去上海直播现场参加了 UOD 的颁奖活动，很荣幸也很感谢 Epic 授予我 杰出社区贡献者 奖项，对我既是认可也是激励，我也会尽力产出更多的技术内容，促进 UE 社区的发展。 本篇文章做一个简单的记录，把 UOD 的资料做一下整理，也把我参加 UOD 的视频、演讲 PPT，以及相关的资料做一个总结，还有一些在 UOD 直播现场拍的照片。 首先是虚幻中国 2020 Unreal Open Day 总结：2020 线上虚幻引擎技术开放日圆满落幕｜游戏引擎引领实时技术走向全行业 我在 UOD 演讲主题视频： UOD 演讲 PDF 预览： PPT 下载：UOD_UE4 全平台热更新方案_查利鹏 之前录制的 HotPatcher 的使用教程： 关于热更新演讲主题，之前的文章： UE4 资源热更打包工具 HotPatcher UE4 热更新：基于 UnLua 的 Lua 编程指南 UE4 热更新：需求分析与方案设计 开源的相关仓库： hxhb/HotPatcher hxhb/ue4-dtkit hxhb/debugable-unlua 去 UOD 直播现场拍的一些照片： 期待明年的 Unreal Open Day！","tags":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"UOD","slug":"UOD","permalink":"https://ue5wiki.com/tags/UOD/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"UPL 与 JNI 调用的最佳实践","date":"2020-11-15T22:32:01.000Z","path":"wiki/23f6c20d/","text":"在使用 UE4 开发 Android 时，有时需要获取平台相关的信息、或者执行平台相关的操作，在这种情况下，需要在代码中添加 Java 的代码以及在 C++ 中调用它们。有些需求也需要在游戏中从 Java 侧接收一些事件，需要处理 Java 调用 C++ 的流程。 本篇文章主要涉及以下几部分内容： UE 工程中添加 Java 代码 Java 函数的签名规则 Java 调用 C++ 的函数 C++ 调用 Java 的函数 如何利用 UE 的 UPL 特性、Java 的签名规则，以及在 UE 中进行 JNI 调用实现方法，会在文章中做详细的介绍。 UPLUPL 全称 Unreal Plugin Language，是一个 XML-Based 的结构化语言，用于介入 UE 的打包过程（如拷贝 so/ 编辑 AndroidManifest.xml，添加 IOS 的 framework/ 操作 plist 等），本篇文章主要介绍 UPL 在 Android 中的使用，UPL 在 IOS 上的使用，在我之前的文章UE4 开发笔记：Mac/iOS 篇 #UPL 在 iOS 中的应用 中有介绍。 往 UE 项目里添加 Java 代码，需要通过 UPL 在打包时往 GameActivity.java 插入代码来实现。 UPL 的语法使用 XML，文件也需要保存为 .xml 格式： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--Unreal Plugin Example--&gt;&lt;root xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;/root&gt; 在 &lt;root&gt;&lt;/root&gt; 中可以使用 UPL 提供的节点来编写逻辑（但是因为它的语法都是 XML 的形式来实现编程逻辑的，所以写起来循环等控制流程十分麻烦），以添加 AndroidManifest.xml 中权限请求为例（以下代码均位于 &lt;root&gt;&lt;/root&gt; 中）： 1234567891011&lt;androidManifestUpdates&gt; &lt;!-- 权限请求 --&gt; &lt;addPermission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;addPermission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;!--Android 的全面屏支持 --&gt; &lt;addElements tag=&quot;application&quot;&gt; &lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt; &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; &lt;/addElements&gt;&lt;/androidManifestUpdates&gt; 使用 androidManifestUpdates 节点，可以在其中更新AndroidManifest.xml，UPL 为 IOS 和 Android 都提供了很多平台相关的节点，在使用时需要注意，不能混用。 UPL 还提供了往 GameActivity 类中添加 Java 方法的节点：gameActivityClassAdditions，通过这个节点，可以直接在 UPL 里编写 Java 代码，在构建 Android 包时，会自动把这些代码插入到 GameActivity.java 中的 GameActivity 类中： 123456789101112131415161718192021&lt;gameActivityClassAdditions&gt; &lt;insert&gt; public String AndroidThunkJava_GetPackageName() &#123; Context context = getApplicationContext(); return context.getPackageName(); &#125; public String AndroidThunkJava_GetInstalledApkPath() &#123; Context context = getApplicationContext(); PackageManager packageManager = context.getPackageManager(); ApplicationInfo appInfo; try&#123; appInfo = packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA); return appInfo.sourceDir; &#125;catch (PackageManager.NameNotFoundException e)&#123; return &quot;invalid&quot;; &#125; &#125; &lt;/insert&gt;&lt;/gameActivityClassAdditions&gt; 插入之后生成的文件： 这两个函数就在 GameActivity.java 中了，UPL 有很多增加 GameActivity 内容的节点，这部分内容在 UE 的文档中是不全的，具体还是要去看 UBT 的代码：UnrealBuildTool/System/UnrealPluginLanguage.cs#L378。 UPL 支持对 GameActivity 的扩展，不仅仅只是添加函数，还可以给 OnCreate/OnDestory 等函数添加额外的代码，方便根据需求介入到不同的时机。 12345678910111213141516171819202122232425262728293031323334353637383940/* Engine/Source/Programs/UnrealBuildTool/System/UnrealPluginLanguage.cs#L378 * &lt;!-- optional additions to the GameActivity imports in GameActivity.java --&gt;* &lt;gameActivityImportAdditions&gt; &lt;/gameActivityImportAdditions&gt;** &lt;!-- optional additions to the GameActivity after imports in GameActivity.java --&gt;* &lt;gameActivityPostImportAdditions&gt; &lt;/gameActivityPostImportAdditions&gt;* * &lt;!-- optional additions to the GameActivity class implements in GameActivity.java (end each line with a comma) --&gt;* &lt;gameActivityImplementsAdditions&gt; &lt;/gameActivityImplementsAdditions&gt;** &lt;!-- optional additions to the GameActivity class body in GameActivity.java --&gt;* &lt;gameActivityClassAdditions&gt; &lt;/gameActivityOnClassAdditions&gt;* * &lt;!-- optional additions to GameActivity onCreate metadata reading in GameActivity.java --&gt;* &lt;gameActivityReadMetadata&gt; &lt;/gameActivityReadMetadata&gt;* * &lt;!-- optional additions to GameActivity onCreate in GameActivity.java --&gt;* &lt;gameActivityOnCreateAdditions&gt; &lt;/gameActivityOnCreateAdditions&gt;* * &lt;!-- optional additions to GameActivity onDestroy in GameActivity.java --&gt;* &lt;gameActivityOnDestroyAdditions&gt; &lt;/gameActivityOnDestroyAdditions&gt;* * &lt;!-- optional additions to GameActivity onStart in GameActivity.java --&gt;* &lt;gameActivityOnStartAdditions&gt; &lt;/gameActivityOnStartAdditions&gt;* * &lt;!-- optional additions to GameActivity onStop in GameActivity.java --&gt;* &lt;gameActivityOnStopAdditions&gt; &lt;/gameActivityOnStopAdditions&gt;* * &lt;!-- optional additions to GameActivity onPause in GameActivity.java --&gt;* &lt;gameActivityOnPauseAdditions&gt; &lt;/gameActivityOnPauseAdditions&gt;* * &lt;!-- optional additions to GameActivity onResume in GameActivity.java --&gt;* &lt;gameActivityOnResumeAdditions&gt; &lt;/gameActivityOnResumeAdditions&gt;* * &lt;!-- optional additions to GameActivity onNewIntent in GameActivity.java --&gt;* &lt;gameActivityOnNewIntentAdditions&gt; &lt;/gameActivityOnNewIntentAdditions&gt;* * &lt;!-- optional additions to GameActivity onActivityResult in GameActivity.java --&gt;* &lt;gameActivityOnActivityResultAdditions&gt; &lt;/gameActivityOnActivityResultAdditions&gt;*/ 那么，写完了 UPL 的脚本之后，如何来使用它呢？ 需要在需要添加该 UPL 的 Module 的 build.cs 中添加以下代码： 1234567891011// for Androidif (Target.Platform == UnrealTargetPlatform.Android)&#123; PrivateDependencyModuleNames.Add(&quot;Launch&quot;); AdditionalPropertiesForReceipt.Add(&quot;AndroidPlugin&quot;, Path.Combine(ModuleDirectory, &quot;UPL/Android/FGame_Android_UPL.xml&quot;)); &#125;// for IOSif (Target.Platform == UnrealTargetPlatform.IOS)&#123; AdditionalPropertiesForReceipt.Add(&quot;IOSPlugin&quot;,Path.Combine(ModuleDirectory,&quot;UPL/IOS/FGame_IOS_UPL.xml&quot;));&#125; 通过 AdditionalPropertiesForReceipt 来指定我们的 UPL 脚本，注意 AndroidPlugin 和IOSPlugin不可修改，文件路径可以根据 UPL 文件在项目中的位置指定。 使用这种方式就把 UPL 添加到了 UE 的构建系统中，当构建 Android/IOS 平台时，就会自动执行我们在脚本中的逻辑了。 Java 函数签名JNI 是什么？JNI 全称 Java Native Interface，即 Java 原生接口。主要用来从 Java 调用其他语言代码、其他语言来调用 Java 的代码。 在上一节中，我们通过 UPL 往 GameActivity 中添加了 Java 的代码，在 UE 中如何通过 C++ 去调用这些 Java 的函数，需要使用 JNI 调用来实现。 通过 C++ 去调用 Java，首先需要知道，所要调用的 Java 函数的签名。签名 是描述一个函数的参数和返回值类型的信息。以该函数为例： 1public String AndroidThunkJava_GetPackageName()&#123; return &quot;&quot;; &#125; 以这个函数为例，它不接受参数，返回一个 Java 的 String 值，那么它的签名是什么呢？ 1()Ljava/lang/String; 签名的计算是有一个规则的，暂时先按下不表，后面会详细介绍。 JDK 提供的 javac 具有一个参数可以给 Java 代码生成 C++ 的头文件，用来方便 JNI 调用，其中就包含了签名。 写一个测试的 Java 代码，用来生成 JNI 调用的.h： 123public class GameActivity &#123; public static native String SingnatureTester();&#125; 生成命令： 1javac -h . GameActivity.java 会在当前目录下生成 .class 和.h文件，.h中的内容如下： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class GameActivity */#ifndef _Included_GameActivity#define _Included_GameActivity#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: GameActivity * Method: SingnatureTester * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_GameActivity_SingnatureTester (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 里面导出了 GameActivity 类成员SingnatureTesterJNI 调用的符号信息，在注释中包含了它的签名()Ljava/lang/String;。 Java_ue4game_GameActivity_SingnatureTester是当前函数可以在 C/C++ 中实现的函数名，当我们在 C++ 中实现了这个名字的函数，在 Java 中调用到 GameActivity 的SingnatureTester时，就会调用到我们 C++ 中的实现。 把函数声明改为： 123public class GameActivity &#123; public static native String SingnatureTester(int ival,double dval,String str);&#125; 它的签名则是： 12345/* * Class: GameActivity * Method: SingnatureTester * Signature: (IDLjava/lang/String;)Ljava/lang/String; */ 经过上面的两个例子，其实就可以看出来 Java 函数的签名规则：签名包含两部分——参数、返回值。 其中，()中的是参数的类型签名，按照参数顺序排列，()后面的是返回值的类型签名。 那么 Java 中的类型签名规则是怎么样的呢？可以依据下面的 Java 签名对照表：JNI 调用签名对照表。 Java 中的 基础类型和签名对照表： Java Native Signature byte jbyte B char jchar C double jdouble D float jfloat F int jint I short jshort S long jlong J boolean jboolean Z void void V 根据上面的规则，void EmptyFunc(int)的签名为(I)V。 非内置基础类型的签名规则 为： 以 L 开头 以 ; 结尾 中间用 / 隔开包和类名 如 Java 中类类型： String：Ljava/lang/String; Object：Ljava/lang/Object; 给上面的例子加上 package 时候再测试下： 1234package ue4game;public class GameActivity &#123; public static native String SingnatureTester(GameActivity activity);&#125; 则得到的签名为： 1234567/* * Class: ue4game_GameActivity * Method: SingnatureTester * Signature: (Lue4game/GameActivity;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_ue4game_GameActivity_SingnatureTester (JNIEnv *, jclass, jobject); JNI:Java to C++UE 给我们的游戏生成的 GameActivity 中也声明了很多的 native 函数，这些函数是在 C++ 实现的，在 Java 中执行到这些函数会自动调用到引擎的 C++ 代码中： 1234567891011121314151617181920212223242526272829public native int nativeGetCPUFamily();public native boolean nativeSupportsNEON();public native void nativeSetAffinityInfo(boolean bEnableAffinity, int bigCoreMask, int littleCoreMask);public native void nativeSetConfigRulesVariables(String[] KeyValuePairs);public native boolean nativeIsShippingBuild();public native void nativeSetAndroidStartupState(boolean bDebuggerAttached);public native void nativeSetGlobalActivity(boolean bUseExternalFilesDir, boolean bPublicLogFiles, String internalFilePath, String externalFilePath, boolean bOBBInAPK, String APKPath);public native void nativeSetObbFilePaths(String OBBMainFilePath, String OBBPatchFilePath);public native void nativeSetWindowInfo(boolean bIsPortrait, int DepthBufferPreference);public native void nativeSetObbInfo(String ProjectName, String PackageName, int Version, int PatchVersion, String AppType);public native void nativeSetAndroidVersionInformation(String AndroidVersion, String PhoneMake, String PhoneModel, String PhoneBuildNumber, String OSLanguage);public native void nativeSetSurfaceViewInfo(int width, int height);public native void nativeSetSafezoneInfo(boolean bIsPortrait, float left, float top, float right, float bottom);public native void nativeConsoleCommand(String commandString);public native void nativeVirtualKeyboardChanged(String contents);public native void nativeVirtualKeyboardResult(boolean update, String contents);public native void nativeVirtualKeyboardSendKey(int keyCode);public native void nativeVirtualKeyboardSendTextSelection(String contents, int selStart, int selEnd);public native void nativeVirtualKeyboardSendSelection(int selStart, int selEnd);public native void nativeInitHMDs();public native void nativeResumeMainInit();public native void nativeOnActivityResult(GameActivity activity, int requestCode, int resultCode, Intent data);public native void nativeGoogleClientConnectCompleted(boolean bSuccess, String accessToken);public native void nativeVirtualKeyboardShown(int left, int top, int right, int bottom);public native void nativeVirtualKeyboardVisible(boolean bShown);public native void nativeOnConfigurationChanged(boolean bPortrait);public native void nativeOnInitialDownloadStarted();public native void nativeOnInitialDownloadCompleted();public native void nativeHandleSensorEvents(float[] tilt, float[] rotation_rate, float[] gravity, float[] acceleration); 在上一节 Java 签名中已经提到过，native的方法是 Java 调用其他语言实现，上面这些函数在 UE 中均有实现，用于在引擎中接收 Android 设备的不同逻辑，定义分布在下列文件中： 12345678Runtime\\Android\\AndroidLocalNotification\\Private\\AndroidLocalNotification.cppRuntime\\ApplicationCore\\Private\\Android\\AndroidWindow.cppRuntime\\Core\\Private\\Android\\AndroidPlatformFile.cppRuntime\\Core\\Private\\Android\\AndroidPlatformMisc.cppRuntime\\Core\\Private\\Android\\AndroidPlatformProcess.cppRuntime\\Launch\\Private\\Android\\AndroidEventManager.cppRuntime\\Launch\\Private\\Android\\AndroidJNI.cppRuntime\\Launch\\Private\\Android\\LaunchAndroid.cpp 我们也可以自己在 GameActivity 添加 native 的函数，如果有一些 SDK 中提供了 native 这样的函数，也可以用以下方式来实现，我这里写一个简单的例子，使用 UPL 往 GameActivity 添加一个 native 函数，并在 C++ 端实现。 12345&lt;gameActivityClassAdditions&gt; &lt;insert&gt; public native void nativeDoTester(String Msg); &lt;/insert&gt;&lt;/gameActivityClassAdditions&gt; 在 C++ 中实现一个这样的函数即可： 1234567#if PLATFORM_ANDROIDJNI_METHOD void Java_com_epicgames_ue4_GameActivity_nativeDoTester (JNIEnv jenv*, jobject thiz, jstring msg);&#123; &#125;#endif com.epicgames.ue4是 UE 生成的 GameActivity.java 的包名(package com.epicgames.ue4;)。 可以看到，在 C++ 中实现 JNIMETHOD 的函数名是以下规则： 1RType Java_PACKAGENAME_CLASSNAME_FUNCNAME(JNIEnv*,jobject thiz,Oher...) 注意：这个函数必须是个 C 函数，不能参与 C++ 的 name mangling，不然签名就不对了。 在 UE 中可以使用 JNI_METHOD 宏，它定义在 AndroidPlatform.h 中。 12// Runtime/Core/Public/Android/AndroidPlatform.h#define JNI_METHOD __attribute__ ((visibility (&quot;default&quot;))) extern &quot;C&quot; 也可以使用extern &quot;C&quot;。在 C++ 中定义之后，如果 Java 端调用了该函数，就可以执行到我们在 C++ 里写的逻辑了。 JNI:C++ to Java通过上一节的内容，可以知道了 Java 中函数的签名信息，如何在 UE 中通过函数名和签名信息来在 C++ 中调用到游戏中的 Java 代码呢。 UE 在 C++ 端封装了大量的 JNI 的辅助函数，可以很方便地进行 JNI 操作。这些函数大多定义在下面三个头文件中： 123456// Runtime/Launch/Public/Android#include &quot;Android/AndroidJNI.h&quot;// Runtime/Core/Public/Android#include &quot;Android/AndroidJavaEnv.h&quot;// Runtime/Core/Public/Android#include &quot;Android/AndroidJava.h&quot; 因为 AndroidJNI.h 位于 Launch 模块中，所以在需要在 Build.cs 中为 Android 平台添加该模块。 以第一节我们使用 UPL 往 GameActivity 类中添加的下面这个函数为例： 12345public String AndroidThunkJava_GetPackageName()&#123; Context context = getApplicationContext(); return context.getPackageName();&#125; 想要在 UE 中调用到它，首先要获取它的 jmethodID，需要通过 函数所属的类 、 函数名字 ， 签名 三种信息来获取： 1234if (JNIEnv* Env = FAndroidApplication::GetJavaEnv())&#123; jmethodID GetPackageNameMethodID = FJavaWrapper::FindMethod(Env, FJavaWrapper::GameActivityClassID, &quot;AndroidThunkJava_GetPackageName&quot;, &quot;()Ljava/lang/String;&quot;, false);&#125; 因为我们的代码是插入到 GameActivity 类中的，而 UE 对 GameActivity 做了封装，所以可以通过 FJavaWrapper 来获取，FJavaWrapper定义位于Runtime/Launch/Public/Android。 得到的这个methodID，有点类似于 C++ 的成员函数指针，想要调用到它，需要通过某个对象来执行调用，UE 也做了封装： 1jstring JstringResult = (jstring)FJavaWrapper::CallObjectMethod(Env, FJavaWrapper::GameActivityThis,GetPackageNameMethodID); 通过 CallObjectMethod 来在 GameActivity 的实例上调用GetPackageNameMethodID，得到的值是 java 中的对象，这个值还不能直接转换为 UE 中的字符串使用，需要进行转换的流程： 12345678910111213141516171819202122232425262728namespace FJavaHelperEx&#123; FString FStringFromParam(JNIEnv* Env, jstring JavaString) &#123; if (!Env || !JavaString || Env-&gt;IsSameObject(JavaString, NULL)) &#123; return &#123;&#125;; &#125; const auto chars = Env-&gt;GetStringUTFChars(JavaString, 0); FString ReturnString(UTF8_TO_TCHAR(chars)); Env-&gt;ReleaseStringUTFChars(JavaString, chars); return ReturnString; &#125; FString FStringFromLocalRef(JNIEnv* Env, jstring JavaString) &#123; FString ReturnString = FStringFromParam(Env, JavaString); if (Env &amp;&amp; JavaString) &#123; Env-&gt;DeleteLocalRef(JavaString); &#125; return ReturnString; &#125;&#125; 通过上面定义的 FJavaHelperEx::FStringFromLocalRef 可以把 jstring 转换为 UE 的 FString： 1FString FinalResult = FJavaHelperEx::FStringFromLocalRef(Env,JstringResult); 到这里，整个 JNI 调用的流程就结束了，能够通过 C++ 去调用 Java 并获取返回值了。 结语 参考资料： Unreal Plugin Language Jni 符号对照 JNI Types and Data Structures","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"UPL","slug":"UPL","permalink":"https://ue5wiki.com/tags/UPL/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"UPL","slug":"Mobile/UPL","permalink":"https://ue5wiki.com/categories/Mobile/UPL/"}]},{"title":"构建支持多平台打包的二进制引擎","date":"2020-11-08T15:40:19.000Z","path":"wiki/11956/","text":"通常，UE4 开发者获取 UE4 引擎的方式有两种： 从 Epic Games Launcher 安装 从 Github 上 Clone 代码本地编译 从 EpicGamesLauncher 安装的是公版引擎，不能修改代码重新编译，可以在根据选择安装支持的平台、调试符号等。自己从 Github 上 Clone 代码进行编译的则是源码版引擎，有些功能只能在源码版中使用（比如 Standalone Application），但是如果在项目中修改了引擎的代码，导致每个人都需要 Clone 一遍源码编译一遍引擎，这个过程十分耗时，而且源码版引擎的占用的磁盘空间十分巨大，达到上百 G。在当需要把引擎部署到多台构建机时，编译引擎的时间和空间是冗余的，所以需要通过一台机器编译引擎，然后其他的机器只需要拉取编译后的引擎即可，实现与安装版引擎一样的行为。 本篇文章主要介绍 BuildGraph 的工作流程，以及对引擎默认构建脚本 InstalledEngineBuild.xml 的分析；如何使用 BuildGraph 从源码配置、编译并导出支持 Android/IOS 打包的二进制引擎、以及如何裁剪和加速整个的构建流程。 UE 提供了 BuildGraph 功能使我们可以从源码中构建出和 Epic Game Launcher 相同的安装版引擎。 使用参数如下： 1RunUAT.bat BuildGraph -target=&quot;Make Installed Build Win64&quot; -script=Engine/Build/InstalledEngineBuild.xml -set:WithMac=false -set:WithAndroid=false -set:WithIOS=false -set:WithTVOS=false -set:WithLinux=false -set:WithHTML5=false -set:WithSwitch=false -WithDDC=false -set:WithWin32=false -set:WithLumin=false -set:WithPS4=false -set:WithXboxOne=false -set:WithHoloLens=false -set:GameConfigurations=Development 通过 BuildGraph 来执行 InstalledEngineBuild.xml 脚本中的 Make Installed Build Win64 实现，引擎编译、导出二进制的一条龙流程。 但是这样有几个问题：默认这样构建出来的只能够打包 Windows，不能打包 Android/IOS。 如何构建 Android/IOS 的二进制引擎，暂时先按下不表，首先先来分析一下 UE 默认的 InstalledEngineBuild.xml 脚本。 优化 BuildGraph 的构建流程 InstalledEngineBuild.xml 是位于引擎的 Engine/Build/ 目录下的 BuildGraph 的构建脚本，主要实现了通过代码导出二进制引擎的功能，支持了很多的平台。BuildGraph 的官方介绍和语法：BuildGraph。 我们主要使用Make Installed Build Win64，是它的一个 Node 实现。 主要流程如下： 编译 UBT 等构建工具 编译 NotForLicence 工具 编译 Editor 编译支持的平台（默认 Win64） Make Feature Packs 拷贝构建结果 而且，经过分析Make Installed Build Win64，发现它其中有很多重复执行的编译流程。 以编译 UE4Game Win64 为例： 12345678&lt;Node Name=&quot;Compile UE4Game Win64&quot; Requires=&quot;Compile UnrealHeaderTool Win64&quot; Produces=&quot;#UE4Game Win64;#UE4Game Win64 Unstripped;#UE4Game Win64 Stripped;#UE4Game Win64 Unsigned;#UE4Game Win64 Signed&quot;&gt; &lt;ForEach Name=&quot;Target&quot; Values=&quot;UE4Game;$(OptionalClientTarget);$(OptionalServerTarget)&quot;&gt; &lt;ForEach Name=&quot;Configuration&quot; Values=&quot;$(GameConfigurations)&quot;&gt; &lt;Compile Target=&quot;$(Target)&quot; Platform=&quot;Win64&quot; Configuration=&quot;$(Configuration)&quot; Tag=&quot;#UE4Game Win64&quot; Arguments=&quot;-precompile -allmodules -nolink $(VSCompilerArg) $(TargetDebugInfoArg)&quot;/&gt; &lt;Compile Target=&quot;$(Target)&quot; Platform=&quot;Win64&quot; Configuration=&quot;$(Configuration)&quot; Tag=&quot;#UE4Game Win64&quot; Arguments=&quot;-precompile $(VSCompilerArg) $(TargetDebugInfoArg)&quot; Clean=&quot;false&quot;/&gt; &lt;/ForEach&gt; &lt;/ForEach&gt;&lt;/Node&gt; 可以看到，针对同一个编译的 Target，使用不同的编译参数执行了两次： 具有 -allmodules、-nolink 等参数 不具有上述参数 而开启了 -allmodules，则意味着引擎中所有的模块都要重新编译，是完整地编译引擎。当下次执行，还是要完整地编译整个引擎，UBT 中具有对-allmodules 的介绍： -allmodules参数是定义在 UBT 的 TargetRules.cs 中的： UnrealBuildTool/Configuration/TargetRules.cs12345/// &lt;summary&gt;/// Build all the modules that are valid for this target type. Used for CIS and making installed engine builds./// &lt;/summary&gt;[CommandLine(&quot;-AllModules&quot;)]public bool bBuildAllModules = false; 专门用来构建安装版引擎的，我觉得可以关掉，使用增量编译的方式执行，不然在 ci 上每次执行都太慢了。 而且这个脚本中对每个平台都执行了两遍，一遍是不含 -nolink 参数的，一遍是包含 -nolink 参数的，可以根据自己的需求决定是否关闭。UE 的文档中是这么介绍的(Unreal Engine 4.14 Released!)： New: Added a -nolink command line option for Unreal Build Tool, which enables compiling a target without linking it. This is useful for automated build tests, such as non-unity compiles. 当使用 BuildGraph 来构建引擎的时候，默认情况下对引擎的编译次数计算公式： 12UE4Editor DebugGame/Development 2 次UE4Game Win64/Android/IOS/... 每个平台 2*Configuration 次（-allmodules -nolink） 如果我们使用 BuildGraph 通过 Make Installed Build Win64 来构建出安装版引擎（支持 Win/Android/IOS 打包），至少需要编译2+3*2=8，对引擎的代码要编译八次！而且每一次执行都要完整的编译所有的模块，耗时非常之长。 所以裁剪是非常有必要的，上面也已经提到了： 去掉 -allmodules 参数，增量编译 去掉 -nolink 的构建（根据需求决定） 减少需要构建的平台 裁剪之后需要需要编译的次数： UE4Editor Development 1 次 UE4Game Win64/Android/IOS/… 每个平台 1*Configuration 次 则需要编译 4 次，与默认减少一倍，并且可以增量编译，时间会快很多了。 构建引擎支持 Android 打包 想要使用 Make Installed Build Win64 构建出支持 Android 打包的引擎，需要在执行 BuildGraph 脚本时添加 -set:WithAndroid=true，因为WithAndroid 是InstalledEngineBuild.xml中定义的参数，可以通过命令行传递。 不过，仅仅是命令行指定开启是不够的，在执行 BuildGraph 之前，需要安装好 Android 的开发环境，在 BuildGraph 在执行编译时会去系统 PATH 里查找 JDK/Android NDK/Android SDK 以及 gradle 的路径，需要自己进行预先配置： 注意：虽然在执行编译时会检测环境自动下载 gradle，但是由于在墙内的原因，不一定会下载成功。 需要把 Android 的环境按照添加至系统的环境变量中： 注意：当使用一些 ci 工具的时候，ci 只能查到服务启动的用户的环境变量，为避免额外的问题，最好添加至系统的环境变量。 默认情况下会编译出支持打包 Android 架构为 armv7 和arm64的引擎，如果不需要其中的某个架构，可以在 InstalledEngineBuild.xml 里选择注释掉指定的平台。 Android 比较简单，配置完 Android 的开发环境就可以直接导出可以打包 Android 的引擎： 构建引擎支持 IOS 打包 前面已经提到了，构建支持 Android 打包的二进制引擎，支持 IOS 平台要更复杂一些。 首先构建支持 IOS 打包的引擎必须要有一台 Mac 执行远程构建，因为 BuildGraph 需要编译 IOS 平台的 UE4Game，在 Win 上无法编译 IOS 的库，所以必须要一台 Mac。 局域网中有一台可访问的 Mac 具有 mobileprovision 生成 SSH Key 至于“为什么有了 Mac 还需要在 Win 上支持 IOS？”这个问题主要是因为： Mac 机能受限，直接在 Mac 上打包是编译 +Cook 的操作都在 Mac 上，如果进行远程构建，则 Mac 只需要处理代码的编译，而不需要执行 Cook 的流程，降低对 Mac 机能的依赖，可以提高构建的效率。 统一地使用 Win 来构建出全平台包（Win/Android/IOS） 首先需要在 Win 上生成 Mac 的 SSH Keys，BuildGraph 编译引擎支持 IOS 也需要设置 ssh key，生成的方法在我之前的博客中有记录，不再赘述：UE4 开发笔记：Mac/iOS 篇 #配置远程构建 当生成了 SSHkey 之后，需要在引擎的 Engine/Config/BaseEngine.ini 中修改以下配置： 123456[/Script/IOSRuntimeSettings.IOSRuntimeSettings]RemoteServerName=RSyncUsername=SSHPrivateKeyOverridePath=mobileprovision=SigningCertificate= 注意：这里的 mobileprovision 和 SigningCertificate 指定名字就可以，如： 12MobileProvision=com.XXXX.XXXX.fmgame_Development_SignProvision.mobileprovisionSigningCertificate=iPhone Developer: Created via API (JDPXHYVWYZ) 并且，可以不指定 SSHPrivateKeyOverridePath 的路径，在 RemoteMac.cs 中，针对引擎目录有三个自动查找的路径： 123456if (ProjectFile != null)&#123; Locations.Add(DirectoryReference.Combine(ProjectFile.Directory, &quot;Build&quot;, &quot;NotForLicensees&quot;)); Locations.Add(DirectoryReference.Combine(ProjectFile.Directory, &quot;Build&quot;, &quot;NoRedist&quot;)); Locations.Add(DirectoryReference.Combine(ProjectFile.Directory, &quot;Build&quot;));&#125; 把 SSH Key 按照这样的命名格式放到这三个目录下即可： 1SSHKeys/IP_ADDR/USER_NAME/RemoteToolChainPrivate.key 如： 1SSHKeys/192.168.1.123/buildmachine/RemoteToolChainPrivate.key 远程构建的 UBT 路径异常 在执行时 RemoteMac.cs 中报错的问题： // RemoteMac.cs12345678910111213/// &lt;summary&gt;/// Attempts to get the SSH private key from the standard locations/// &lt;/summary&gt;/// &lt;param name=&quot;OutPrivateKey&quot;&gt;If successful, receives the location of the private key that was found&lt;/param&gt;/// &lt;returns&gt;True if a private key was found, false otherwise&lt;/returns&gt;private bool TryGetSshPrivateKey(out FileReference OutPrivateKey)&#123; // Build a list of all the places to look for a private key List&lt;DirectoryReference&gt; Locations = new List&lt;DirectoryReference&gt;(); Locations.Add(DirectoryReference.Combine(DirectoryReference.GetSpecialFolder(Environment.SpecialFolder.ApplicationData), &quot;Unreal Engine&quot;, &quot;UnrealBuildTool&quot;)); Locations.Add(DirectoryReference.Combine(DirectoryReference.GetSpecialFolder(Environment.SpecialFolder.Personal), &quot;Unreal Engine&quot;, &quot;UnrealBuildTool&quot;)); // ...&#125; 上面的代码在 Combine 时没有做检测，Environment.SpecialFolder.ApplicationData这个路径是不一定能得到的，所以要修改 UBT 的 RemoteMac.cs 中的这部分代码，进行检测： 1234567891011121314private bool TryGetSshPrivateKey(out FileReference OutPrivateKey)&#123; // Build a list of all the places to look for a private key List&lt;DirectoryReference&gt; Locations = new List&lt;DirectoryReference&gt;(); DirectoryReference ApplicationData = DirectoryReference.GetSpecialFolder(Environment.SpecialFolder.ApplicationData); DirectoryReference Personal = DirectoryReference.GetSpecialFolder(Environment.SpecialFolder.Personal); if(ApplicationData != null) Locations.Add(DirectoryReference.Combine(ApplicationData, &quot;Unreal Engine&quot;, &quot;UnrealBuildTool&quot;)); if(Personal != null) Locations.Add(DirectoryReference.Combine(Personal, &quot;Unreal Engine&quot;, &quot;UnrealBuildTool&quot;)); // ...&#125; 上一步的操作，只能解决找 ssh key 时的路径报错问题。 远程构建时 SSH 连接错误 解决了这个问题还有另外一个问题： 1234567891011****** [4/11] Compile UnrealHeaderTool MacReading local file list from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Update Version Files\\Tag-Update Version Files.xmlRunning: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe UnrealHeaderTool Mac Development -NoUBTMakefiles -nobuilduht -precompile -allmodules -Manifest=C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Build\\Manifest.xml -NoHotReload -log=&quot;C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\UBT-UnrealHeaderTool-Mac-Development.txt&quot; [Remote] Using remote server &#x27;xx.xx.xx.xx&#x27; on port 2222 (user &#x27;buildmachine&#x27;) [Remote] Using private key at C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Build\\NotForLicensees\\SSHKeys\\xx.xx.xx.xx\\buildmachine\\RemoteToolChainPrivate.key ERROR: Unable to determine home directory for remote user. SSH output: Host key verification failed.Took 0.6103776s to run UnrealBuildTool.exe, ExitCode=6UnrealBuildTool failed. See log for more details. (C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\UBT-UnrealHeaderTool-Mac-Development.txt) 看到是 ssh key 的验证失败了，其实这个错误并不是 Key 的问题（这个问题非常坑）。而是因为 RemoteMac.cs 中对 ssh 连接命令的代码里是这么写的： 123456789101112131415161718192021222324class RemoteMac&#123; // ... /// &lt;summary&gt; /// The authentication used for SSH (probably similar to RsyncAuthentication). /// &lt;/summary&gt; [XmlConfigFile] private string SshAuthentication = &quot;-i &#x27;$&#123;CYGWIN_SSH_PRIVATE_KEY&#125;&#x27;&quot;; // ...&#125;;public RemoteMac(FileReference ProjectFile)&#123; // ... SshAuthentication = ExpandVariables(SshAuthentication); // Build a list of arguments for SSH CommonSshArguments = new List&lt;string&gt;(); CommonSshArguments.Add(&quot;-o BatchMode=yes&quot;); CommonSshArguments.Add(SshAuthentication); CommonSshArguments.Add(String.Format(&quot;-p &#123;0&#125;&quot;, ServerPort)); CommonSshArguments.Add(String.Format(&quot;\\&quot;&#123;0&#125;@&#123;1&#125;\\&quot;&quot;, UserName, ServerName)); // ...&#125; 这个代码生成的拼接的 ssh 命令： 1\\Engine\\Extras\\ThirdPartyNotUE\\DeltaCopy\\Binaries\\ssh.exe -o BatchMode=yes -i \\Engine\\Build\\NotForLicensees\\SSHKeys\\xx.xx.xx.xx\\buildmachine\\RemoteToolChainPrivate.key -p 22 buildmachine@xx.xx.xx.xx 问题的关键就是处在 BatchMode=yes 上，当我们第一次通过 ssh 连接一台主机，会下列提示： 123456$ Engine\\Extras\\ThirdPartyNotUE\\DeltaCopy\\Binaries\\ssh.exe -p 22 buildmachine@ 192.168.1.123 The authenticity of host &#x27;[192.168.1.123]:22 ([192.168.1.123]:22)&#x27; can&#x27;t be established.RSA key fingerprint is e0:8d:b9:7c:65:c7:9e:18:94:12:ed:ef:40:1a:15:47.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;[192.168.1.123]:22&#x27; (RSA) to the list of known hosts.Password: 会弹出提示让你验证这台主机（需要手动输入 yes），但是开启了 BatchMode=yes 之后，会禁止所有的交互式提示，出现交互直接连接失败！这就是我们使用正确的 Key，但是会提示 Host key verification failed. 的原因。那么，知道了原因，解决这个问题的办法有两种： 关闭 ssh 的连接时验证 在进行构建之前，手动使用 ssh 命令连接主机，通过交互式的验证（只需要初始化验证一次） 未导入 provision 的错误 编译时的其他错误： 1234567891011****** [6/11] Compile UE4Game IOSReading local file list from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Compile UnrealHeaderTool Mac\\Tag-Compile UnrealHeaderTool Mac.xmlReading local file list from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Update Version Files\\Tag-Update Version Files.xmlReading shared manifest from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Compile UnrealHeaderTool Mac\\Manifest.xmlRunning: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe UE4Game IOS Development -NoUBTMakefiles -nobuilduht -precompile -allmodules -nolink -nodebuginfo -Manifest=C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Build\\Manifest.xml -NoHotReload -log=&quot;C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\UBT-UE4Game-IOS-Development.txt&quot; [Remote] Using remote server &#x27;xx.xx.xx.xxx&#x27; on port 22 (user &#x27;buildmachine&#x27;) [Remote] Using private key at C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Build\\NotForLicensees\\SSHKeys\\10.75.27.129\\buildmachine\\RemoteToolChainPrivate.key [Remote] Using base directory &#x27;/Users/buildmachine/UE4/Builds/lipengzha-PC2&#x27; ERROR: Unable to find mobile provision for UE4Game. See log for more information.Took 4.0300959s to run UnrealBuildTool.exe, ExitCode=6 这是因为编译引擎时没有配置 provision，需要在Engine/Config/BaseEngine.ini 中设置。 在这里可以只指定 provision 文件的名字，在 UEBuildIOS.cs 中的代码会从 C:\\Users\\lipengzha\\AppData\\Local\\Apple Computer\\MobileDevice\\Provisioning Profiles 路径下去查找。 1234567891011121314151617181920212223protected IOSProvisioningData(IOSProjectSettings ProjectSettings, bool bIsTVOS, bool bForDistribtion)&#123; // ... if(!string.IsNullOrEmpty(MobileProvision)) &#123; DirectoryReference MobileProvisionDir; if(BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Mac) &#123; MobileProvisionDir = DirectoryReference.Combine(new DirectoryReference(Environment.GetEnvironmentVariable(&quot;HOME&quot;)), &quot;Library&quot;, &quot;MobileDevice&quot;, &quot;Provisioning Profiles&quot;); &#125; else &#123; MobileProvisionDir = DirectoryReference.Combine(DirectoryReference.GetSpecialFolder(Environment.SpecialFolder.LocalApplicationData), &quot;Apple Computer&quot;, &quot;MobileDevice&quot;, &quot;Provisioning Profiles&quot;); &#125; FileReference PossibleMobileProvisionFile = FileReference.Combine(MobileProvisionDir, MobileProvision); if(FileReference.Exists(PossibleMobileProvisionFile)) &#123; MobileProvisionFile = PossibleMobileProvisionFile; &#125; &#125; // ...&#125; 这部分操作也可以通过引擎来导入，不仅仅只需要导入 provision 还需要导入证书（也可以通过 iPhonePackager 来导入）： 如果不导入会有下列错误： 1234567891011121314151617181920212223242526****** [7/12] Compile UE4Game IOSReading local file list from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Compile UnrealHeaderTool Mac\\Tag-Compile UnrealHeaderTool Mac.xmlReading local file list from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Update Version Files\\Tag-Update Version Files.xmlReading shared manifest from C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Saved\\BuildGraph\\Compile UnrealHeaderTool Mac\\Manifest.xmlRunning: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe UE4Game IOS Development -NoUBTMakefiles -nobuilduht -precompile -allmodules -nolink -nodebuginfo -Manifest=C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Build\\Manifest.xml -NoHotReload -log=&quot;C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Programs\\AutomationTool\\Saved\\Logs\\UBT-UE4Game-IOS-Development.txt&quot; [Remote] Using remote server &#x27;192.168.1.123&#x27; on port 22 (user &#x27;buildmachine&#x27;) [Remote] Using private key at C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Build\\NotForLicensees\\SSHKeys\\192.168.1.123\\buildmachine\\RemoteToolChainPrivate.key [Remote] Using base directory &#x27;/Users/buildmachine/UE4/Builds/lipengzha-PC3&#x27; [Remote] Uploading C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Remote\\UE4Game\\IOS\\Development\\com.xxxxx.xxxx.xx_Development_SignProvision.mobileprovision [Remote] Exporting certificate for C:\\Users\\lipengzha\\AppData\\Local\\Apple Computer\\MobileDevice\\Provisioning Profiles\\com.xxxxx.xxxx.xx_Development_SignProvision.mobileprovision... Executing iPhonePackager ExportCertificate C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Source -provisionfile C:\\Users\\lipengzha\\AppData\\Local\\Apple Computer\\MobileDevice\\Provisioning Profiles\\com.xxxxx.xxxx.xx_Development_SignProvision.mobileprovision -outputcertificate C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Remote\\UE4Game\\IOS\\Development\\Certificate.p12 CWD: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Binaries\\DotNET\\IOS Initial Dir: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Source Env CWD: C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Binaries\\DotNET\\IOS BranchPath = lipengzha-PC3/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Binaries --- GameBranchPath = lipengzha-PC3/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Binaries ---------- Executing command &#x27;ExportCertificate&#x27; &#x27;&#x27; ... Looking for a certificate that matches the application identifier &#x27;9TV4ZYSS4J.com.xxxxx.xxxx.xx&#x27; .. Provision entry SN &#x27;61B440405D86B84D&#x27; matched 0 installed certificate(s) .. Failed to find a valid certificate that was in date IPP ERROR: Failed to find a valid certificate ERROR: IphonePackager failed.Took 2.9281688s to run UnrealBuildTool.exe, ExitCode=6 上述的问题解决完毕之后就能够正常地把 BuildGraph 的流程执行完毕，导出了根据引擎代码编译出的二进制引擎，启动之后就可以看到能够打包 Windows/Android/IOS 了。 错误排查 No certificate for team xxxx matching 如果有以下错误提示： 1Code Signing Error: No certificate for team &#x27;9TV4ZYSS4J&#x27; matching &#x27;iPhone Developer: Created via API (JDPXHYVWYZ)&#x27; found: Select a different signing certificate for CODE_SIGN_IDENTITY, a team that matches your selected certificate, or switch to autom atic provisioning. 解决办法： 在 Mac 上的 ~/Library/MobileDevice/Provisioning\\ Profiles 清理掉多余的 mobileprovision 文件。 在 Mac 钥匙串中清理掉过期的开发者证书 重新导入 mobileprovision 与证书 注意：导入的 mobileprovision 的文件命名要与在 BaseEngine.ini 中指定的 MobileProvision 相同。 errSecInternalComponent 错误 Xcode Command /usr/bin/codesign failed with exit code 1 : errSecInternalComponent iOS 远程自动打包问题 How to Fix iOS Application Code Signing Error? “Warning: unable to build chain to self-signed root for signer” warning in Xcode 9.2 方法一 是因为通过 ssh 去调用 /usr/bin/codesign 访问钥匙串没有权限，可以使用以下命令在 ssh 中执行解锁： 1security unlock-keychain -p password login.keychain 在 UE 远程构建时，可以先执行这条命令在当前的 ssh 环境下解锁 keychain，使后面的签名可以正常执行。修改 UE 中的 Engine\\Build\\BatchFiles\\Mac\\Build.sh 文件，在调用 UBT 编译之前，写入以下内容： 1234567891011121314151617181920212223#!/bin/shcd &quot;`dirname &quot;$0&quot;`/../../../..&quot;# Setup Monosource Engine/Build/BatchFiles/Mac/SetupMono.sh Engine/Build/BatchFiles/Macif [&quot;$4&quot; == &quot;-buildscw&quot; ] || [&quot;$5&quot; == &quot;-buildscw&quot; ]; then echo Building ShaderCompileWorker... mono Engine/Binaries/DotNET/UnrealBuildTool.exe ShaderCompileWorker Mac Developmentfiecho unlock mac keychain...security unlock-keychain -p password login.keychainecho Running command : Engine/Binaries/DotNET/UnrealBuildTool.exe &quot;$@&quot;mono Engine/Binaries/DotNET/UnrealBuildTool.exe &quot;$@&quot;ExitCode=$?if [$ExitCode -eq 254 ] || [$ExitCode -eq 255 ] || [$ExitCode -eq 2 ]; then exit 0else exit $ExitCodefi 因为编译时会把 Build.sh 通过 RSync 传递到 Mac 上，所以可以看到以下 log: 1234567891011[Remote] Executing build Running bundled mono, ue_version: Mono JIT compiler version 5.16.0.220 (2018-06/bb3ae37d71a Fri Nov 16 17:12:11 EST 2018) unlock mac keychain... Running command : Engine/Binaries/DotNET/UnrealBuildTool.exe UnrealHeaderTool Mac Development -SkipRulesCompile -XmlConfigCache=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Intermediate/Build/XmlConfigCache.bin -precompile -allmodules -Log=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Programs/AutomationTool/Saved/Logs/UBT-UnrealHeaderTool-Mac-Development_Remote.txt -Manifest=/Users/buildmachine/UE4/Builds/lipengzha-PC2/C/BuildAgent/workspace/FGameEngine/Engine/Engine/Intermediate/Remote/UnrealHeaderTool/Mac/Development/Manifest.xml Target is up to date Deploying UnrealHeaderTool Mac Development... Deploying now! Total execution time: 1.01 seconds[Remote] Downloading C:\\BuildAgent\\workspace\\FGameEngine\\Engine\\Engine\\Intermediate\\Remote\\UnrealHeaderTool\\Mac\\Development\\Manifest.xml[Remote] Downloading build products receiving file list ... done 这样每次编译都会解锁 keychain，从而避免 ssh 连接时没有访问 codesign 导致的签名错误。 注意：也需要排查 BaseEngine.ini 中 SigningCertificate 的值是否被指定。 方法二 导入新的苹果开发者根证书： Apple Worldwide Developer Relations Intermediate Certificate Expiration 把 钥匙串 - 系统 -Apple Worldwise Developer Relations Certification Authority 删除，然后从上面的连接中下载新的，重新导入即可。 Invalid trust settings如果 Log 中出现以下错误： 12Code Signing Error: Invalid trust settings. Restore system default trust settings for certificate &quot;iPhone Developer: Created via API (JDPXHYVWYZ)&quot; in order to sign code with it.Code Signing Error: Code signing is required for product type &#x27;Application&#x27; in SDK &#x27;iOS 13.6&#x27; 这是因为在 Mac 上的钥匙串中对证书的设置被修改为了 始终信任 ，修改回 使用系统默认 即可。 结语 本篇文章主要介绍了 BuildGraph 的工作流程、优化构建速度，以及支持 Android/IOS 的打包。 需要注意的是，文章开头使用的命令： 1RunUAT.bat BuildGraph -target=&quot;Make Installed Build Win64&quot; -script=Engine/Build/InstalledEngineBuild.xml -set:WithMac=false -set:WithAndroid=false -set:WithIOS=false -set:WithTVOS=false -set:WithLinux=false -set:WithHTML5=false -set:WithSwitch=false -WithDDC=false -set:WithWin32=false -set:WithLumin=false -set:WithPS4=false -set:WithXboxOne=false -set:WithHoloLens=false -set:GameConfigurations=Development 它的 GameConfigurations 只设置了 Dvelopment，所以编译出来的引擎也只能打包Development，如果想要支持 Shipping 打包，就需要在BuildGraph 中指定：-set:GameConfigurations=Development;Shipping，但是这样会增加构建的时间，因为 Development 和 Shipping 都是需要分别编译的，对执行支持的所有平台都增加了一次引擎编译的时间开销，当然是必要的，不过在日常的开发中，可以有选择性地开启，节省构建的时间。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"BuildGraph","slug":"BuildGraph","permalink":"https://ue5wiki.com/tags/BuildGraph/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"BuildGraph","slug":"BuildSystem/BuildGraph","permalink":"https://ue5wiki.com/categories/BuildSystem/BuildGraph/"}]},{"title":"Hook UObject","date":"2020-10-29T22:32:01.000Z","path":"wiki/e6148e24/","text":"Hook 是一种机制，通过拦截和勾取一些事件来实现自己需求的方式。不同于传统的底层 Hook，本篇文章主要介绍在 UE 中如何使用类似 Hook 的这种机制来实现业务需求。 有些需求是要全局地修改某个类的所有对象，比如在 UI 中为某种类型的的 Button 播放统一的音效，如果在每个控件都需要监听它的 OnClicked 再去播放音效，会有大量的重复操作。所以，我想要找一种全局的方法，可以监听所有 UButton 的点击事件，然后统一来处理。再或者想要控制一个在蓝图中不可见的属性，如果只是一些简单的需求就要去修改引擎的代码，有点得不偿失。 可以通过 UE 的反射机制来实现这些需求，本篇文章来提供一种思路，做一个简单的实现分析。 监听对象创建执行操作 需求有了，要修改指定类型所有的对象的属性，那么要实现这样的需求大致的思路是这样的： 首先需要能够知道 指定类型的对象 被创建了 当对象被 创建完成之后 修改它的属性 能够实现这两点，就可以解决我们的需求，那么问题的关键就是要先找到 知道对象被创建了 的方法。 经过翻阅 UE 的代码，发现 UE 创建和销毁对象时都可以注册 Listener 来接收通知： 123456789void FUObjectArray::AllocateUObjectIndex(UObjectBase* Object, bool bMergingThreads /*= false*/)&#123; // ... for (int32 ListenerIndex = 0; ListenerIndex &lt; UObjectCreateListeners.Num(); ListenerIndex++) &#123; UObjectCreateListeners[ListenerIndex]-&gt;NotifyUObjectCreated(Object,Index); &#125; // ...&#125; 调用栈： 既然知道了创建 UObject 的时候会调用到所有的 Listener，那么就自己注册进去一个对象。 UObjectCreateListeners的类型为： 1TArray&lt;FUObjectCreateListener* &gt; UObjectCreateListeners; FUObjectCreateListener是个抽象类，定义了两个虚函数，当作接口使用： 1234567891011121314151617class FUObjectCreateListener&#123;public: virtual ~FUObjectCreateListener() &#123;&#125; /** * Provides notification that a UObjectBase has been added to the uobject array * * @param Object object that has been destroyed * @param Index index of object that is being deleted */ virtual void NotifyUObjectCreated(const class UObjectBase *Object, int32 Index)=0; /** * Called when UObject Array is being shut down, this is where all listeners should be removed from it */ virtual void OnUObjectArrayShutdown()=0;&#125;; 同时，还有监听对象被删除的接口FUObjectDeleteListener： 123456789101112131415161718192021/*** Base class for UObjectBase delete class listeners*/class FUObjectDeleteListener&#123;public: virtual ~FUObjectDeleteListener() &#123;&#125; /** * Provides notification that a UObjectBase has been removed from the uobject array * * @param Object object that has been destroyed * @param Index index of object that is being deleted */ virtual void NotifyUObjectDeleted(const class UObjectBase *Object, int32 Index)=0; /** * Called when UObject Array is being shut down, this is where all listeners should be removed from it */ virtual void OnUObjectArrayShutdown() = 0;&#125;; 我既想监听对象创建也想监听删除，所以我写了个类来同时继承它们两个： 123456789101112struct FUButtonListener : public FUObjectArray::FUObjectCreateListener, public FUObjectArray::FUObjectDeleteListener&#123; static FButtonListenerMisc* Get() &#123; static FButtonListenerMisc StaticIns; return &amp;StaticIns; &#125; // Listener virtual void NotifyUObjectCreated(const class UObjectBase *Object, int32 Index); virtual void NotifyUObjectDeleted(const class UObjectBase *Object, int32 Index); FORCEINLINE virtual void OnUObjectArrayShutdown()override &#123; &#125;&#125;; 创建好了，关键的一步是要自己写的类注册到 GUObjectArray 中，FUObjectArray提供了两组 Add 和Remove的函数用来添加和移除 Listener。 1234567891011121314151617181920212223/*** Adds a new listener for object creation* @param Listener listener to notify when an object is deleted*/void AddUObjectCreateListener(FUObjectCreateListener* Listener);/*** Removes a listener for object creation* @param Listener listener to remove*/void RemoveUObjectCreateListener(FUObjectCreateListener* Listener);/*** Adds a new listener for object deletion* @param Listener listener to notify when an object is deleted*/void AddUObjectDeleteListener(FUObjectDeleteListener* Listener);/*** Removes a listener for object deletion* @param Listener listener to remove*/void RemoveUObjectDeleteListener(FUObjectDeleteListener* Listener); OK，知道怎么添加了，那么 什么时机 来添加 Listener 呢？ 当然需要在游戏运行时资源 UObject 创建之前，不然对象都已经创建了，再绑定也监听不到了。 因为区分了 PIE 和打包，所以 PIE Play 和打包运行需要分别处理： 在编辑器下可以通过监听以下两个事件来开始进行监听 UObject 创建的流程： 1234#if WITH_EDITOR FEditorDelegates::PreBeginPIE.AddStatic(&amp;PreBeginPIE); FGameDelegates::Get().GetEndPlayMapDelegate().AddRaw(FHookerMisc::Get(), &amp;FHookerMisc::Shutdown);#endif 打包的流程不是这两个事件，可以使用以下两个代理替换： 1234#if !WITH_EDITORFCoreDelegates::OnPostEngineInit.AddRaw(FHookerMisc::Get(),&amp;FHookerMisc::Init);FCoreDelegates::OnPreExit.AddRaw(FHookerMisc::Get(),&amp;FHookerMisc::Shutdown); #endif 这两个代理转发到的函数中可以进行处理添加 Listener 和删除的操作： 12345678910void FHookerMisc::Init()&#123; GUObjectArray.AddUObjectCreateListener(FHookerMisc::Get()); GUObjectArray.AddUObjectDeleteListener(FHookerMisc::Get());&#125;void FHookerMisc::Shutdown()&#123; GUObjectArray.RemoveUObjectCreateListener(FHookerMisc::Get()); GUObjectArray.RemoveUObjectDeleteListener(FHookerMisc::Get());&#125; 之后就可以通过 override 以下两个函数来获取 Object 的创建和删除事件了： 12void FHookerMisc::NotifyUObjectCreated(const UObjectBase* Object, int32 Index)&#123;&#125;void FHookerMisc::NotifyUObjectDeleted(const UObjectBase* Object, int32 Index)&#123;&#125; 注意 ：当NotifyUObjectCreated 函数被调用，这里传递过来的 UObject 并不是最终创建完成的对象，因为该 Object 还没有被初始化，它的构造函数还没有被调用，所以，如果此时直接修改 Object，是没有作用的，因为在引擎后续的流程中，在这个 Object 所在的内存上调用了它的构造函数。 调用栈： 12345678910111213141516171819202122232425262728UObject* StaticConstructObject_Internal( const UClass* InClass, UObject* InOuter /*=GetTransientPackage()*/, FName InName /*=NAME_None*/, EObjectFlags InFlags /*=0*/, EInternalObjectFlags InternalSetFlags /*=0*/, UObject* InTemplate /*=NULL*/, bool bCopyTransientsFromClassDefaults /*=false*/, FObjectInstancingGraph* InInstanceGraph /*=NULL*/, bool bAssumeTemplateIsArchetype /*=false*/)&#123; // ... bool bRecycledSubobject = false; Result = StaticAllocateObject(InClass, InOuter, InName, InFlags, InternalSetFlags, bCanRecycleSubobjects, &amp;bRecycledSubobject); check(Result != NULL); // Don&#x27;t call the constructor on recycled subobjects, they haven&#x27;t been destroyed. if (!bRecycledSubobject) &#123; STAT(FScopeCycleCounterUObject ConstructorScope(InClass, GET_STATID(STAT_ConstructObject))); (*InClass-&gt;ClassConstructor)(FObjectInitializer(Result, InTemplate, bCopyTransientsFromClassDefaults, true, InInstanceGraph) ); &#125; // ... return Result;&#125; 可以看到，是先通过 StaticAllocateObject 进行创建 UObject（其实是分配 UObject 的内存）在下面的流程中，通过 UClass 得到当前类的构造函数，并执行。 什么是构造函数？构造函数可以理解为 模具，一块内存拿过来，通过这块模具生成出来一个具体的对象，构造函数就是一种初始化内存的方式——以什么样的形式来解释这块内存，并给它初始值。 构造函数会调用基类的构造函数、执行类内初始化、调用类成员的构造函数，把这块内存修改为对象默认的状态。 所以，不能直接在 NotifyUObjectCreated 中对 UObject 进行修改，要等到它构造完成之后。 此时的 Object 具有RF_NeedInitializationFlag，标记当前对象需要初始化，而我们可以通过这个 FLAG 的有无来决定是否修改它。 当 NotifyUObjectCreated 事件调用时，可以把传递过来的 Object 存储到一个列表中，在下次创建事件过来以及下一帧时，对列表中的所有对象进行检测，是否还具有RF_NeedInitializationFlag，如果没有，就表明该对象已经被初始化成功了，可以对其进行修改了，不用担心修改的数据被覆盖了。 在 FObjectInitializer 的PostConstructInit函数 (由~FObjectInitializer 调用)中对该 FLAG 进行了清理： 123456void FObjectInitializer::PostConstructInit()&#123; // ... Obj-&gt;ClearFlags(RF_NeedInitialization); // ...&#125; 所以，只要当一个对象没有了RF_NeedInitializationFLAG，就可以对它进行操作了。 修改 UClass 控制反射属性 有时候，想要在编辑器中控制一个对象的属性，但是虽然该属性是 UProperty，但是没有标记为EditAnyWhere，在编辑器中是不可见的。 如： 123456789class ANetActor:public AActor&#123; GENERATE_BODY()public: UPROPERTY(EditAnywhere) int32 ival; UPROPERTY() int32 ival2;&#125;; 上述成员变量中 ival 是可以在蓝图和编辑中访问的，因为它有 EditAnywhere 属性，而 ival2 没有，则不能。 对于我们自己创建的类，可以通过修改代码解决，但是对于引擎或者其他第三方模块的类，直接去改动相关的代码并不是一个好主意，会带来额外的限制：需要使用源码版引擎、自己管理修改的代码版本。 有没有一种方法，不修改引擎里的代码，来实现我们的需求呢？ 有！因为 在编辑器中是否显示 是通过 UE 给对象和它的属性生成的反射信息来决定的，如果能够找到一种方法让引擎读取反射信息时认为 ival2 也是可以在编辑器显示的就 OK 了。 思路有了，即：修改 ival2 的反射信息，让编辑器认为它也需要在编辑器中显示。 通过代码分析，发现对象是否允许被显示在 Details 中显示时通过对 UProperty 检测CPF_EditFlag 实现的。 123456enum EPropertyFlags : uint64&#123; CPF_None = 0, CPF_Edit = 0x0000000000000001, ///&lt; Property is user-settable in the editor. // ...&#125;; EPropertyFlags中对 CPF_Edit 的描述也正是如此。 可以看一下上面例子中 ival 和ival2生成反射代码的差异： 12const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_ANetActor_Statics::NewProp_iVal2 = &#123; &quot;iVal2&quot;, nullptr, (EPropertyFlags)0x0010000000000000, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(ANetActor, iVal2), METADATA_PARAMS(Z_Construct_UClass_ANetActor_Statics::NewProp_iVal2_MetaData, UE_ARRAY_COUNT(Z_Construct_UClass_ANetActor_Statics::NewProp_iVal2_MetaData)) &#125;;const UE4CodeGen_Private::FIntPropertyParams Z_Construct_UClass_ANetActor_Statics::NewProp_ival = &#123; &quot;ival&quot;, nullptr, (EPropertyFlags)0x0010000000000001, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(ANetActor, ival), METADATA_PARAMS(Z_Construct_UClass_ANetActor_Statics::NewProp_ival_MetaData, UE_ARRAY_COUNT(Z_Construct_UClass_ANetActor_Statics::NewProp_ival_MetaData)) &#125;; 可以看到，它们除了 ival((EPropertyFlags)0x0010000000000001)/ival2((EPropertyFlags)0x0010000000000000) 这两个 FLag 内容不一样之外，其他的部分完全相同，ival的 FLAG 内容就是多了 CPF_Edit，它是EPropertyFlags 的第二个属性，它的值为 0x01，EPropertyFlags 的枚举值是按位来表示的。 UE 的反射机制通过引擎启动时，读取这些生成的反射信息，为类内的反射属性生成 FProperty 对象，用来在运行时获取该属性的反射信息。 FProperty类定义在 Runtime/CoreUObject/Public/UObject/UnrealType.h 中，它记录了当前属性在类内的偏移值、元素大小、名字，以及我们需要的PropertyFlags。 通过上面的分析，现在问题的关键是：如何在运行时（编辑器运行时），修改一个类反射属性的PropertyFlags。 流程有以下几步（在属性窗口创建之前）： 获取类的反射信息（UClass） 从反射信息获取指定的属性的反射信息（FProperty） 修改属性的反射信息，添加CPF_Edit 实现代码如下： 12345678910111213141516171819202122auto AddEditFlagLambda = [](UClass* Class,FName flagName)-&gt;bool&#123; bool bStatus = false; if(Class) &#123; for(TFieldIterator&lt;FProperty&gt; PropertyIter(Class);PropertyIter;++PropertyIter) &#123; FProperty* PropertyIns = *PropertyIter; if(PropertyIns-&gt;GetName().Equals(flagName.ToString())) &#123; if(!PropertyIns-&gt;HasAnyPropertyFlags(CPF_Edit)) &#123; PropertyIns-&gt;SetPropertyFlags(CPF_Edit); bStatus = true; &#125; &#125; &#125; &#125; return bStatus;&#125;;AddEditFlagLambda(ANetActor::StaticClass(),TEXT(&quot;ival2&quot;)); 使用上一节 NotifyUObjectCreated 的方法，来实现修改，不过有区别的地方在于，不是针对某个实例，而是直接修改指定的 UClass，所以也就不需要就对象进行初始化完成的判断。 运行起来的效果： 使用这种方式可以很简单地给引擎中的反射类的反射属性添加编辑器支持，如 EditAnywhere/Interp 等，从而实现不修改引擎，而修改引擎代码中的反射信息。 后记 使用反射的机制，可以很方便地修改反射类、反射属性，通过这样的形式来实现业务需求，可以避免修改引擎代码的行为。本篇文章只是开了一个脑洞，提供了一种思路，反射不仅仅能做这些事情，有时间分析一下 UE 的反射下实现以及它是如何使用这些反射信息的。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"UObject","slug":"UObject","permalink":"https://ue5wiki.com/tags/UObject/"},{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UE4 动画系统源码剖析","date":"2020-10-21T00:00:00.000Z","path":"wiki/external1251866798/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 动画系统源码剖析 。","tags":[{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/tags/Animation/"}],"categories":[{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/categories/Animation/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"title":"Patch 的挂载和资源加载","date":"2020-10-08T14:54:02.000Z","path":"wiki/10855/","text":"这两天在看 UE 打包 Patch 作为热更的方案，UE 打包 Patch 的逻辑是这样的： 如果在版本 1.0 中，场景 Scene01 中对资源 A 有直接引用（放在场景中），在修改了 A 资源之后，打包 Patch0.1，想要让场景 Scene01 中资源 A 的改动也生效，则需要把 Scene01 也需要打到 Patch 中，因为是直接放置在场景中的，场景记录了该资源 A 的引用信息，这个不会随着资源 A 的更新而更新，加载时会产生 AsyncLoading.cpp 中的报错。 12345678910111213[2019.11.13-06.03.27:766][68]LogLinker: Warning: The file &#x27;../../../GWorld/Content/PAK/Cube.uasset&#x27; contains unrecognizable data, check that it is of the expected type.[2019.11.13-06.03.27:770][68]LogStreaming: Error: ****DumpDependencies [Dependencies]:[2019.11.13-06.03.27:771][68]LogStreaming: Error: Export 8 /Game/Map2.Map2:PersistentLevel.Cube_2[2019.11.13-06.03.27:772][68]LogStreaming: Error: Linker is ../../../GWorld/Content/Map2.umap[2019.11.13-06.03.27:774][68]LogStreaming: Error: Dep C_BEFORE_S Export 38 /Game/Map2.Map2:PersistentLevel.Cube_2.Cube (class StaticMeshComponent)[2019.11.13-06.03.27:774][68]LogStreaming: Error: Dep C_BEFORE_S Export 29 /Game/Map2.Map2:PersistentLevel.Cube_2.DefaultSceneRoot (class SceneComponent)[2019.11.13-06.03.27:775][68]LogStreaming: Error: Dep S_BEFORE_C Import 3 /Game/PAK/Cube.Cube_C[2019.11.13-06.03.27:776][68]LogStreaming: Error: Dep S_BEFORE_C Import 42 /Game/PAK/Cube.Default__Cube_C[2019.11.13-06.03.27:776][68]LogStreaming: Error: Dep C_BEFORE_C Export 23 /Game/Map2.Map2:PersistentLevel (class Level)[2019.11.13-06.03.27:777][68]LogStreaming: Error: Missing Dependency, request for /Game/PAK/Cube.Cube_C but it hasn&#x27;t been created yet.[2019.11.13-06.03.27:778][68]LogStreaming: Error: Could not find class Cube_C to create Cube_2[2019.11.13-06.03.27:778][68]LogStreaming: Error: Could not find outer Cube_2 to create DefaultSceneRoot[2019.11.13-06.03.27:779][68]LogStreaming: Error: Could not find outer Cube_2 to create Cube 解决这个问题的办法是通过 SoftClassReference 动态加载资源，比如直接 SpawnActorFromClass 直接指定 Class 为具体的类也是会产生上面的错误，但是用 SoftClassReference 可以避免这个错误（因为 SoftClassReference 本质就是存了个路径）： 如果在版本 1.0 中，资源 A 引用了其他资源 B，在 Patch1.0 中将资源 A 中引用的 B 换为了资源 C，则该 Patch 的 pak 中会有资源 A/B/C 三个，因为资源的引用关系变了，但是如果不改动引用关系只是改动 B 中的信息，然后只 Patch 资源 B 是可以的。 直接使用 Unreal.pak 将Cooked的资源打包为 pak 文件需要注意一点：修改 Mount 的路径。如果说直接使用下列命令： 1$ UnrealPak.exe New_0_P.pak -create=D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\PAK 则打出来的 pak 的 Mount 路径为： 1D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\PAK 而查看使用引擎打包的 Pak 和 patch 的 pak 都是相对路径的，这个性格对路径就是 UE 的工程里资源的路径： 123456789101112131415161718192021222324252627D:\\GWorldPackage\\WindowsNoEditor\\GWorld\\Content\\Paks&gt;UnrealPak.exe GWorld-WindowsNoEditor.pak -listLogPaths: Warning: No paths for game localization data were specifed in the game configuration.LogPakFile: Display: Using command line for crypto configurationLogPakFile: Display: Added 0 entries to add to pak file.LogPakFile: Display: Mount point ../../../LogPakFile: Display: &quot;Engine/Content/BasicShapes/BasicShapeMaterial.uasset&quot; offset: 0, size: 749 bytes, sha1: E028879C8856192DC648EA4C422C145E38951DA9, compression: Zlib.LogPakFile: Display: &quot;Engine/Content/EditorMaterials/PreviewShadowIndicator.uasset&quot; offset: 819, size: 496 bytes, sha1: 80BCDD2FF2674FED35763CD6A8C93C5A0EC27442, compression: Zlib.// ....LogPakFile: Display: &quot;GWorld/AssetRegistry.bin&quot; offset: 16928768, size: 2759 bytes, sha1: 35E6A5C7667C23FDDFD1F3BDC5535FA4E3BFF24F, compression: Zlib.LogPakFile: Display: &quot;GWorld/Config/DefaultEngine.ini&quot; offset: 16932864, size: 2378 bytes, sha1: 7E33CA6CC805CC1A6E2FF84EF3010CEACBF99E04, compression: Zlib.LogPakFile: Display: &quot;GWorld/Config/DefaultGame.ini&quot; offset: 16935312, size: 523 bytes, sha1: DDD788C5E2C9446AB11E2C8BC7D83EA24CB85AA9, compression: Zlib.LogPakFile: Display: &quot;GWorld/Config/DefaultInput.ini&quot; offset: 16935905, size: 753 bytes, sha1: 6C03DCDAE9605BEB9CB2EB250631D6AA2C2A4336, compression: Zlib.LogPakFile: Display: &quot;GWorld/Content/Map2.uexp&quot; offset: 16936960, size: 339962 bytes, sha1: 6605D83E8355CC2B4D20DE31C3D6182324BA556C, compression: Zlib.LogPakFile: Display: &quot;GWorld/Content/Map2.umap&quot; offset: 17278976, size: 5541 bytes, sha1: A400A39FD85529E832750CB481D9F845E4C4A74B, compression: Zlib.LogPakFile: Display: &quot;GWorld/Content/Map2_BuiltData.uasset&quot; offset: 17285120, size: 795 bytes, sha1: 1388AE2CCFA55587DD0A3120CA9679AAF8FC9336, compression: Zlib.LogPakFile: Display: &quot;GWorld/Content/Map2_BuiltData.ubulk&quot; offset: 17287168, size: 8637 bytes, sha1: 7D8E7AE0D100415553DF6F222B9C35EBACF4BE28, compression: Zlib.LogPakFile: Display: &quot;GWorld/Content/Map2_BuiltData.uexp&quot; offset: 17297408, size: 586603 bytes, sha1: 3B776E46005F6A4BEECA505674ED7FB0B8C432D6, compression: Zlib.// ...LogPakFile: Display: &quot;GWorld/Content/ShaderArchive-GWorld-PCD3D_SM5.ushaderbytecode&quot; offset: 23377920, size: 1207165 bytes, sha1: 44474138CD033FEF89EDFA86A480E569615A8850, compression: None.LogPakFile: Display: &quot;GWorld/GWorld.uproject&quot; offset: 24585135, size: 323 bytes, sha1: D2E183A541A10DEEC5C87533400FFC0E89CA3B83, compression: Zlib.LogPakFile: Display: &quot;GWorld/Plugins/GWorld.upluginmanifest&quot; offset: 24586240, size: 5022 bytes, sha1: CFDB721323DABBA1C7C7ABE6CB967852EA2AC23B, compression: Zlib.LogPakFile: Display: &quot;GWorld/Plugins/LowEntryExtStdLib/LowEntryExtStdLib.uplugin&quot; offset: 24591332, size: 434 bytes, sha1: 5CD75BB5212731BEA8E0A552C99B69B259FA489C, compression: Zlib.LogPakFile: Display: &quot;GWorld/Plugins/UIFramework/UIFramework.uplugin&quot; offset: 24591836, size: 236 bytes, sha1: C9426AD575AA6ADECEF5C1AE79CF4A49304C3350, compression: Zlib.LogPakFile: Display: &quot;GWorld/Plugins/VaRestPlugin/VaRestPlugin.uplugin&quot; offset: 24592384, size: 393 bytes, sha1: 28B9C2F3CEB767F4A8D5D466CB8C6EEF772CDA43, compression: Zlib.LogPakFile: Display: 1257 files (24050765 bytes), (0 filtered bytes).LogPakFile: Display: Unreal pak executed in 1.746391 seconds 解决方案 是可以通过 UnrealPak.exe 的-create来指定一个 txt 文件来指定某个资源的绝对路径换算为相对路径： 12&quot;D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\PAK\\BasicShapeMaterial_3.uasset&quot; &quot;../../../GWorld/Content/PAK/BasicShapeMaterial_3.uasset&quot; -compress&quot;D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\PAK\\BasicShapeMaterial_3.uexp&quot; &quot;../../../GWorld/Content/PAK/BasicShapeMaterial_3.uexp&quot; -compress 可以看作有数列的表，第一列是资源的 绝对路径 ，第二列是 该绝对路径资源对应的相对路径 ，后面是 参数 （可以是-compress/-encrypt），生成的代码在Source/Programs/AutomationTool/Script/CopyBuildToStagingDirectory.Automation.cs 中。 123456789101112D:\\&gt;UnrealPak.exe D:\\NEW_6_P.pak -create=&quot;D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\New.txt&quot;LogPaths: Warning: No paths for game localization data were specifed in the game configuration.LogPakFile: Display: Using command line for crypto configurationLogPakFile: Display: Loading response file D:\\GWorldClient\\Saved\\Cooked\\WindowsNoEditor\\GWorld\\Content\\New.txtLogPakFile: Display: Added 2 entries to add to pak file.LogPakFile: Display: Collecting files to add to pak file...LogPakFile: Display: Collected 2 files in 0.00s.LogPakFile: Display: Encrypting using embedded keyLogPakFile: Display: Added 2 files, 8549 bytes total, time 0.00s.LogPakFile: Display: Compression summary: 13.27% of original size. Compressed Size 7981 bytes, Original Size 60159 bytes.LogPakFile: Display: Encryption - DISABLEDLogPakFile: Display: Unreal pak executed in 0.010672 seconds 检查打包出来的New_6_P.pak： 123456789D:\\&gt;UnrealPak.exe NEW_6_P.pak -listLogPaths: Warning: No paths for game localization data were specifed in the game configuration.LogPakFile: Display: Using command line for crypto configurationLogPakFile: Display: Added 0 entries to add to pak file.LogPakFile: Display: Mount point ../../../GWorld/Content/PAK/LogPakFile: Display: &quot;BasicShapeMaterial_3.uasset&quot; offset: 0, size: 753 bytes, sha1: 63E00757694E91070403390CFB808829E13D01FF, compression: Zlib.LogPakFile: Display: &quot;BasicShapeMaterial_3.uexp&quot; offset: 823, size: 7228 bytes, sha1: BD3C0B302FC49790327CF804F2B644F01A14EFCD, compression: Zlib.LogPakFile: Display: 2 files (7981 bytes), (0 filtered bytes).LogPakFile: Display: Unreal pak executed in 0.001987 seconds 可以看到变成了相对路径了。","tags":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"UE4 物理系统实现","date":"2020-09-30T00:00:00.000Z","path":"wiki/external1582524816/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 物理系统实现 。","tags":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"categories":[{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4-%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"UE 集成 WWise：概念与代码分析","date":"2020-09-12T15:31:46.000Z","path":"wiki/9809/","text":"WWise是 Audiokinetic 的跨平台音频引擎，可以与游戏引擎很好地进行交互，负责音频的同事可以只在 WWise 中处理音频，把游戏业务和音频的制作与管理分离，提供事件和参数给游戏引擎使用，实现与业务的解耦和对音频更精确的控制。本篇文章主要介绍 WWise 与 UE4 的集成、远程构建、资源分析、文档收录，WWise 与 UE 的控制交互以及 Bank 生成的代码分析。 集成至 UE4WWise 是全平台支持的，对 Linux/Lumin/PS4/Switch/XboxOne/Windows/Android/iOS/Mac 都支持。但是多数游戏不需要支持这么多平台，WWise 链接库很大，所以我在官方版本支持的多平台基础上做了裁剪，去掉了以下平台的支持： Linux Lumin PS4 Switch XboxOne 对 Android 和 Windows 平台做了以下裁剪： 移除 arm64-v8a 和 android_x86/x86_64 的链接库支持 移除 Win32 的所有链接库 / 移除 vc140/vc150 的支持 对 iOS 做了以下裁剪： 移除所有的 iphonesimulator，节省空间 2.31G 对 Mac 的支持： 目前的项目是不需要支持 Mac 的（使用 iOS 远程出包），但是为了避免想要在 Mac 上跑工程编译不过的问题，保留了 Mac 链接库和模块支持，保留它不会对 Android/iOS 的打包有任何影响。 链接库 我在裁剪版本中支持以下平台： Android_armabi_v7a iOS Mac Win vc160 每个平台均支持 Debug/Profile/Release 的支持，分别对应 UE 的 Debug/Development/Shipping 的 Configuration 配置。 在打包 Android Development 的配置下，包含 WWise 的链接库，APK 增大约 30M. WWise 版本的问题 Wwise 版本为 Wwise 2019.1.9.7221 在 AkAudio_Android.build.cs 中对 Android 的的链接库支持在 UE_4_25_OR_LATER 下路径错误。 原始路径: 1Path.Combine(ThirdPartyFolder, &quot;Android&quot;, &quot;armeabi-v7a&quot;, akConfigurationDir, &quot;lib&quot;) 实际的路径： 1Path.Combine(ThirdPartyFolder, &quot;Android_armeabi-v7a&quot;, akConfigurationDir, &quot;lib&quot;) 但是这样的修改会造成同时支持 armv7 和 arm64 时具有链接错误，解决方案看下节。 Android 支持 armv7 和 arm64当在 UE 的项目设置中为 Android 同时支持 arm64 和armb7时，上面的修改会具有链接错误，需要变动 WWise 中链接库的路径，具体的方法可以看我这篇笔记：同时支持 armv7 和 arm64 的链接库。 Android 链接库的拷贝WWise 的 SDK 中同时使用 UPL 和 RuntimeDependencies 添加了链接库，造成了重复，所以可以把 RuntimeDependencies 中针对移动平台去掉： 123456789101112public AkAudio(ReadOnlyTargetRules Target) : base(Target)&#123; // ... if (Target.Platform == UnrealTargetPlatform.Win64) &#123; foreach(var RuntimeDependency in AkUEPlatformInstance.GetRuntimeDependencies()) &#123; RuntimeDependencies.Add(RuntimeDependency); &#125; &#125; // ...&#125; 远程构建 iOS在我之前的笔记中写到过，远程构建 iOS 实际就是要把文件上传的 Mac 上执行编译，但是这就有一个问题，如果需要参与编译的文件没有被上传到 Mac 上，就会出现错误，很不巧在 WWise 中就会出现这个问题，解决的办法自然是要把编译 WWise 依赖的文件给上传到 Mac 上。 因为 UE 使用 RSync 来同步构建机和本地的文件传输，在我之前的文章 UE4 开发笔记：Mac/iOS 篇 #配置远程构建 有讲到，可以创建 &lt;ProjectDir&gt;/Build/Rsync/RsyncProject.txt 文件，来写入 RSync 的文件同步规则，把需要的文件上传到 Mac 中。 WWise 需要的规则如下： 12+ /Plugins/Wwise/ThirdParty/include/**+ /Plugins/Wwise/ThirdParty/iOS/** 其实就是指定 WWise 的链接库和 Include 目录全上传到 Mac 上。 WWise 资源 WWise 在 UE 中有两种资源格式，一种是UAkAudioEvent 用来执行 WWise 中指定的 Event，还有一种是UAkAudioBank，用来记录 Bank 中包含哪些 Event，用在生成时标记把属于相同 Bank 的 Event 打包到一起。 UAkAudioEvent AudioEvent UAkAudioEvent：主要作用是指定当前 Event 的 Bank，它唯一的函数就是 LoadBank 来加载当前 Event 所指定的 Bank（看到有用到的地方就是获取它的名字），WWise 集成到 UE 的插件也是通过拿到 UAkAudioEvent 对象的名字来与 UAkAudioBank 做绑定之后去 WWise 端生成 bnk 等文件的，这也是要求 UE 中资源的命名要和 WWise 中 Event 的命名完全一致的原因。 123456789101112131415161718192021222324252627282930313233343536UCLASS(meta=(BlueprintSpawnableComponent))class AKAUDIO_API UAkAudioEvent : public UObject&#123; GENERATED_UCLASS_BODY()public: /** Bank to which this event should be added. */ UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Bank&quot;) class UAkAudioBank * RequiredBank; /** Maximum attenuation radius for this event */ UPROPERTY(BlueprintReadOnly, Category=&quot;AkAudioEvent&quot;) float MaxAttenuationRadius; /** Whether this event is infinite (looping) or finite (duration parameters are valid) */ UPROPERTY(BlueprintReadOnly, Category = &quot;AkAudioEvent&quot;) bool IsInfinite; /** Minimum duration */ UPROPERTY(BlueprintReadOnly, Category = &quot;AkAudioEvent&quot;) float MinimumDuration; /** Maximum duration */ UPROPERTY(BlueprintReadOnly, Category = &quot;AkAudioEvent&quot;) float MaximumDuration;#if CPP /** * Load the required bank. * * @return true if the bank was loaded, otherwise false */ bool LoadBank();#endif&#125;; 通过获取 Event 的名字再传递给更深层次的 PostEvent： 123456789101112131415161718192021222324252627282930313233343536373839int32 UAkGameplayStatics::PostEvent( class UAkAudioEvent* AkEvent , class AActor* Actor , int32 CallbackMask , const FOnAkPostEventCallback&amp; PostEventCallback , const TArray&lt;FAkExternalSourceInfo&gt;&amp; ExternalSources , bool bStopWhenAttachedToDestroyed , FString EventName)&#123; if (AkEvent == NULL &amp;&amp; EventName.IsEmpty()) &#123; UE_LOG(LogScript, Warning, TEXT(&quot;UAkGameplayStatics::PostEvent: No Event specified!&quot;)); return AK_INVALID_PLAYING_ID; &#125; if (Actor == NULL) &#123; UE_LOG(LogScript, Warning, TEXT(&quot;UAkGameplayStatics::PostEvent: NULL Actor specified!&quot;)); return AK_INVALID_PLAYING_ID; &#125; AkDeviceAndWorld DeviceAndWorld(Actor); if (DeviceAndWorld.IsValid()) &#123; AkCallbackType AkCallbackMask = AkCallbackTypeHelpers::GetCallbackMaskFromBlueprintMask(CallbackMask); if (ExternalSources.Num() &gt; 0) &#123; FAkSDKExtrernalSourceArray SDKExternalSrcInfo(ExternalSources); return DeviceAndWorld.AkAudioDevice-&gt;PostEvent(GET_AK_EVENT_NAME(AkEvent, EventName), Actor, PostEventCallback, AkCallbackMask, false, SDKExternalSrcInfo.ExternalSourceArray); &#125; else &#123; return DeviceAndWorld.AkAudioDevice-&gt;PostEvent(GET_AK_EVENT_NAME(AkEvent, EventName), Actor, PostEventCallback, AkCallbackMask); &#125; &#125; return AK_INVALID_PLAYING_ID;&#125; UAkAudioBankUAkAudioBank的作用是用来调用 AkAudioDevice 来加载 Bank，如果在 UE 中开启了 AutoLoad，则在 UObejct 的 PostLoad 中就会去执行加载。 官方的对于 SoundBank 的介绍：SoundBank 1234567891011121314151617181920212223242526272829303132/** * Called after load process is complete. */void UAkAudioBank::PostLoad()&#123; Super::PostLoad(); if (AutoLoad &amp;&amp; !HasAnyFlags(RF_ClassDefaultObject)) &#123; Load(); &#125;&#125;/** * Loads an AkBank. * * @return Returns true if the laod was successful, otherwise false */bool UAkAudioBank::Load()&#123; if (!IsRunningCommandlet()) &#123; FAkAudioDevice * AudioDevice = FAkAudioDevice::Get(); if (AudioDevice) &#123; AkBankID BankID; AKRESULT eResult = AudioDevice-&gt;LoadBank(this, AK_DEFAULT_POOL_ID, BankID); return (eResult == AK_Success) ? true : false; &#125; &#125; return false;&#125; 而且 LoadBank 我看到使用的也是和 AkAudioEvent 类似，也是通过获取它的名字传递给FAkAudioDevices。 Bank 的生成分析 那么 AkAudioEvent 是如何与 SoundBank 进行关联起来的呢？因为我在代码里只看到使用之前需要LoadBank，但是没有看到在 UE 资源里 SounkBnak 和 Event 进行关联起来的地方，而且，SoundBank 的命名与在 WWise 中也没有关系。 答案就在通过 AkSoundBank 生成的文件上，在对 AkSoundBank 资源进行 Generate Selected SoundBank 时： 会在项目设置中的 WwiseSoundBankFolder 目录下创建出以下文件： 123456789101112131415161718D:\\WWise\\WwiseDemoGame\\Content\\WwiseAudio\\Windows&gt;tree /a /fD:.| Init.bnk| Init.json| Init.txt| Init.xml| PluginInfo.json| PluginInfo.xml| SoundbanksInfo.json| SoundbanksInfo.xml| SwitchBank.bnk| SwitchBank.json| SwitchBank.txt| SwitchBank.xml| VelocityBank.bnk| VelocityBank.json| VelocityBank.txt| VelocityBank.xml 其中 Init.* 相关的四个文件是必备的 Init 的 Bank 的内容。每个 Bank 都会生成 .bnk/.json/.txt/.xml 四个文件，UE 加载 bank 需要用到的就是 .bnk 文件，经过测试，删掉其他的几个文件也没什么问题。 bnk：数据文件，*.Bnk可以存储事件的详细信息、音频、其他插件所需要的数据结构。可以简单理解为是一个 数据存放的容器。该文件可以在运行中自由的控制加、卸载。 json：描述文件，用于记录当前的 bank 中有哪些数据、哪些 Event 等等，以及对应的 Event 在 WWise 工程中的路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;SoundBanksInfo&quot;: &#123; &quot;Platform&quot;: &quot;Windows&quot;, &quot;BasePlatform&quot;: &quot;Windows&quot;, &quot;SchemaVersion&quot;: &quot;11&quot;, &quot;SoundbankVersion&quot;: &quot;134&quot;, &quot;RootPaths&quot;: &#123; &quot;ProjectRoot&quot;: &quot;C:\\\\Users\\\\lipengzha\\\\Desktop\\\\WWise\\\\WwiseDemoGame\\\\UnrealWwiseDemo\\\\&quot;, &quot;SourceFilesRoot&quot;: &quot;C:\\\\Users\\\\lipengzha\\\\Desktop\\\\WWise\\\\WwiseDemoGame\\\\UnrealWwiseDemo\\\\.cache\\\\Windows\\\\&quot;, &quot;SoundBanksRoot&quot;: &quot;C:\\\\Users\\\\lipengzha\\\\Desktop\\\\WWise\\\\WwiseDemoGame\\\\Content\\\\WwiseAudio\\\\Windows\\\\&quot;, &quot;ExternalSourcesInputFile&quot;: &quot;&quot;, &quot;ExternalSourcesOutputRoot&quot;: &quot;C:\\\\Users\\\\lipengzha\\\\Desktop\\\\WWise\\\\WwiseDemoGame\\\\UnrealWwiseDemo\\\\GeneratedSoundBanks\\\\Windows&quot; &#125;, &quot;SoundBanks&quot;: [ &#123; &quot;Id&quot;: &quot;2001541346&quot;, &quot;Language&quot;: &quot;SFX&quot;, &quot;ObjectPath&quot;: &quot;\\\\SoundBanks\\\\Default Work Unit\\\\VelocityBank&quot;, &quot;ShortName&quot;: &quot;VelocityBank&quot;, &quot;Path&quot;: &quot;VelocityBank.bnk&quot;, &quot;IncludedEvents&quot;: [ &#123; &quot;Id&quot;: &quot;2099597577&quot;, &quot;Name&quot;: &quot;PlayRederenceSoundTest&quot;, &quot;ObjectPath&quot;: &quot;\\\\Events\\\\Default Work Unit\\\\PlayRederenceSoundTest&quot;, &quot;DurationType&quot;: &quot;OneShot&quot;, &quot;DurationMin&quot;: &quot;1.338833&quot;, &quot;DurationMax&quot;: &quot;1.338833&quot; &#125;, &#123; &quot;Id&quot;: &quot;3368745218&quot;, &quot;Name&quot;: &quot;VelocityLoop&quot;, &quot;ObjectPath&quot;: &quot;\\\\Events\\\\Default Work Unit\\\\VelocityLoop&quot;, &quot;DurationType&quot;: &quot;Infinite&quot; &#125; ], &quot;IncludedMemoryFiles&quot;: [ &#123; &quot;Id&quot;: &quot;386490851&quot;, &quot;Language&quot;: &quot;SFX&quot;, &quot;ShortName&quot;: &quot;Shotgun_Fire_01.wav&quot;, &quot;Path&quot;: &quot;SFX\\\\Shotgun_Fire_01_A07A4AEB.wem&quot; &#125; ] &#125; ] &#125;&#125; xml：描述文件，与 json 表示的内容相同 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;SoundBanksInfo Platform=&quot;Windows&quot; BasePlatform=&quot;Windows&quot; SchemaVersion=&quot;11&quot; SoundbankVersion=&quot;134&quot;&gt; &lt;RootPaths&gt; &lt;ProjectRoot&gt;C:\\Users\\lipengzha\\Desktop\\WWise\\WwiseDemoGame\\UnrealWwiseDemo\\&lt;/ProjectRoot&gt; &lt;SourceFilesRoot&gt;C:\\Users\\lipengzha\\Desktop\\WWise\\WwiseDemoGame\\UnrealWwiseDemo\\.cache\\Windows\\&lt;/SourceFilesRoot&gt; &lt;SoundBanksRoot&gt;C:\\Users\\lipengzha\\Desktop\\WWise\\WwiseDemoGame\\Content\\WwiseAudio\\Windows\\&lt;/SoundBanksRoot&gt; &lt;ExternalSourcesInputFile&gt;&lt;/ExternalSourcesInputFile&gt; &lt;ExternalSourcesOutputRoot&gt;C:\\Users\\lipengzha\\Desktop\\WWise\\WwiseDemoGame\\UnrealWwiseDemo\\GeneratedSoundBanks\\Windows&lt;/ExternalSourcesOutputRoot&gt; &lt;/RootPaths&gt; &lt;SoundBanks&gt; &lt;SoundBank Id=&quot;2001541346&quot; Language=&quot;SFX&quot;&gt; &lt;ObjectPath&gt;\\SoundBanks\\Default Work Unit\\VelocityBank&lt;/ObjectPath&gt; &lt;ShortName&gt;VelocityBank&lt;/ShortName&gt; &lt;Path&gt;VelocityBank.bnk&lt;/Path&gt; &lt;IncludedEvents&gt; &lt;Event Id=&quot;2099597577&quot; Name=&quot;PlayRederenceSoundTest&quot; ObjectPath=&quot;\\Events\\Default Work Unit\\PlayRederenceSoundTest&quot; DurationType=&quot;OneShot&quot; DurationMin=&quot;1.338833&quot; DurationMax=&quot;1.338833&quot;/&gt; &lt;Event Id=&quot;3368745218&quot; Name=&quot;VelocityLoop&quot; ObjectPath=&quot;\\Events\\Default Work Unit\\VelocityLoop&quot; DurationType=&quot;Infinite&quot;/&gt; &lt;/IncludedEvents&gt; &lt;IncludedMemoryFiles&gt; &lt;File Id=&quot;386490851&quot; Language=&quot;SFX&quot;&gt; &lt;ShortName&gt;Shotgun_Fire_01.wav&lt;/ShortName&gt; &lt;Path&gt;SFX\\Shotgun_Fire_01_A07A4AEB.wem&lt;/Path&gt; &lt;/File&gt; &lt;/IncludedMemoryFiles&gt; &lt;/SoundBank&gt; &lt;/SoundBanks&gt;&lt;/SoundBanksInfo&gt; txt：也是描述文件，但和 json 和 xml 中的内容相比少了一些（不过基础的 Event ID、EventName、）。 123456789101112Event ID Name Wwise Object Path Notes 2099597577 PlayRederenceSoundTest \\Default Work Unit\\PlayRederenceSoundTest 3368745218 VelocityLoop \\Default Work Unit\\VelocityLoop Game Parameter ID Name Wwise Object Path Notes 3519441192 Velocity \\Default Work Unit\\Velocity Source plug-ins ID Name Type Wwise Object Path Notes 778067245 Wwise Tone Generator Wwise Tone Generator \\Actor-Mixer Hierarchy\\RTPCDemo\\VelocityLoop\\Wwise Tone Generator In Memory Audio ID Name Audio source file Wwise Object Path Notes Data Size 386490851 RederenceSound C:\\Users\\lipengzha\\Desktop\\WWise\\WwiseDemoGame\\UnrealWwiseDemo\\.cache\\Windows\\SFX\\Shotgun_Fire_01_A07A4AEB.wem \\Actor-Mixer Hierarchy\\Default Work Unit\\RederenceSound 257120 UAkGameplayStatics中的类似 Post* 传递 Actor 的作用是获取 World，并且在从该 Actor 上获取AkComponent（若没有就创建，并 Attach 到该 Actor 的 RootComponent 上）： 12345678910111213141516171819202122struct AkDeviceAndWorld&#123; FAkAudioDevice* AkAudioDevice; UWorld* CurrentWorld; AkDeviceAndWorld(AActor* in_pActor) : AkAudioDevice(FAkAudioDevice::Get()), CurrentWorld(in_pActor ? in_pActor-&gt;GetWorld() : nullptr) &#123;&#125; AkDeviceAndWorld(UObject* in_pWorldContextObject) : AkAudioDevice(FAkAudioDevice::Get()),#if UE_4_17_OR_LATER CurrentWorld(GEngine-&gt;GetWorldFromContextObject(in_pWorldContextObject, EGetWorldErrorMode::ReturnNull))#else CurrentWorld(GEngine-&gt;GetWorldFromContextObject(in_pWorldContextObject))#endif // UE_4_17_OR_LATER &#123;&#125; bool IsValid() const &#123; return (CurrentWorld &amp;&amp; CurrentWorld-&gt;AllowAudioPlayback() &amp;&amp; AkAudioDevice); &#125;&#125;; 通过 Event 来指定 SoundBank，然后对 SoundBank 执行Generated Selected Bank，流程如下: 根据所选择的 SoundBank 得到 SoundBank 的名字列表 获取引擎中所有的 UAkAudioEvent 对象，通过分析 AkSoundEvent 中 RequireBank 的名字与第一步中获取的 SoundBank 中的名字是否匹配，从而得到 SoundBank 中所有的AkAudioEvent； 根据以上两步分析的结果生成SoundBankDefinitionFile，存储在 UE 的项目目录下，名字为TempDifinitionFile.txt 1234567891011VelocityBank &quot;PlayRederenceSoundTest&quot;VelocityBank &quot;VelocityLoop&quot;ExtSrcBnk &quot;Play_MyExtSrc&quot;AmbientBank &quot;AmbientNoise_NotSpatialized&quot;AmbientBank &quot;AmbientNoise_Spatialized&quot;ReverbBank &quot;Fire_Weapon&quot;MatineeBank &quot;Closed_Hi_Hat&quot;MatineeBank &quot;Kick&quot;MatineeBank &quot;Snare&quot;SubtitleBank &quot;Play_Subtitles&quot;SwitchBank &quot;Play_Tone&quot; 里面记录了 UE 里的 SoundBank 对象与其关联的 Event 以及 Bus 的名字，通过 -ImportDefinitionFile 参数传递给 WwiseCLI.exe，从而让 WWise 端知道 UE 侧 SoundBank 和Event 之间的对应关系。 WWise 端根据传入进来的 ImportDefinitionFile 文件，根据 WWise 工程里的 Event 以及 Bus 等匹配，产生出来包含指定 Event 的 SoundBank，并生成 json/xml/txt 等描述文件。 UE 通过 LoadBank 的加载流程应该是： 通过 Bank 对象拿到 Bank 的名字 根据 Bank 名字去 WwiseSoundBankFolder 目录下查找同名的 bnk 文件 拿到 bnk 文件，进行加载 UE 与 WWise 的交互 在 UE 中可以使用 WWise 的 API 来播放和控制声音的一些介绍。 PlaySoundAtLocationAPI 均在UAkGameplayStatics： 123456789101112131415/** Posts a Wwise Event at the specified location. This is a fire and forget sound, created on a temporary Wwise Game Object. Replication is also not handled at this point. * @param AkEvent - Wwise Event to post. * @param Location - Location from which to post the Wwise Event. * @param Orientation - Orientation of the event. */UFUNCTION(BlueprintCallable, BlueprintCosmetic, Category=&quot;Audiokinetic&quot;, meta=(WorldContext=&quot;WorldContextObject&quot;, AdvancedDisplay = &quot;3&quot;))static int32 PostEventAtLocation(class UAkAudioEvent* AkEvent, FVector Location, FRotator Orientation, const FString&amp; EventName, UObject* WorldContextObject );/** Posts a Wwise Event by name at the specified location. This is a fire and forget sound, created on a temporary Wwise Game Object. Replication is also not handled at this point. * @param AkEvent - Wwise Event to post. * @param Location - Location from which to post the Wwise Event. * @param Orientation - Orientation of the event. */UFUNCTION(BlueprintCallable, BlueprintCosmetic, Category=&quot;Audiokinetic&quot;, meta=(WorldContext=&quot;WorldContextObject&quot;, DeprecatedFunction, DeprecationMessage = &quot;Please use the \\&quot;Event Name\\&quot; field of PostEventAtLocation&quot;))static void PostEventAtLocationByName(const FString&amp; EventName, FVector Location, FRotator Orientation, UObject* WorldContextObject ); 这两个 API 可以通过传递 AkAudioEvent 的资源或者 Event 的名字来在指定的位置播放声音。PostEventAtLocationByName是 UAkGameplatStatics::PostEventAtLocation 的封装版本，AkAudioEvent 为 NULL。 PostEvent发送给定 Actor 的根组件绑定和控制的 Wwise Event。如果传递进来的 Actor 上没有挂载 AkComponent，会在 PostEvent 上创建出来一个组件，并默认 Attach 到该 Actor 的 RootComponent。 在 PostEvent 之后，如果后续需要控制 Event 的值，如 RTPC 或者 Switch 等，要传入对应的 Actor（因为 PostEvent 本质上是要通过AkComponent）： 123456789101112AkPlayingID FAkAudioDevice::PostEvent( const FString&amp; in_EventName, UAkComponent* in_pComponent, const FOnAkPostEventCallback&amp; PostEventCallback, AkUInt32 in_uFlags, /*= 0*/ const TArray&lt;AkExternalSourceInfo&gt;&amp; in_ExternalSources /*= TArray&lt;AkExternalSourceInfo&gt;()*/)&#123; return PostEvent(in_EventName, in_pComponent, in_ExternalSources, [PostEventCallback, in_uFlags, this](AkGameObjectID gameObjID) &#123; return CallbackManager-&gt;CreateCallbackPackage(PostEventCallback, in_uFlags, gameObjID); &#125;);&#125; 目前我的理解为：传入进去的 Actor(上的 AkComponent)是 WWise 播放声音的上下文，通过这个上下文可以在另外的操作中去控制指定的 Event. 而 PostEvent 还具有多种类型的回调函数，控制其的方式是传递进去的 Mask 值，它由 EAkCallbackType 枚举值控制(bitmask)： 1234567static int32 PostEvent(class UAkAudioEvent* AkEvent, class AActor* Actor, UPARAM(meta = (Bitmask, BitmaskEnum = EAkCallbackType)) int32 CallbackMask, const FOnAkPostEventCallback&amp; PostEventCallback, const TArray&lt;FAkExternalSourceInfo&gt;&amp; ExternalSources, bool bStopWhenAttachedToDestroyed = false, FString EventName = FString(&quot;&quot;)); EAkCallbackType 的可选值： 12345678910111213141516171819202122/// Type of callback. Used as a bitfield in methods AK::SoundEngine::PostEvent() and AK::SoundEngine::DynamicSequence::Open().UENUM(BlueprintType, meta = (Bitmask))enum class EAkCallbackType : uint8&#123; EndOfEvent = 0 UMETA(ToolTip = &quot;Callback triggered when reaching the end of an event. AkCallbackInfo can be cast to AkEventCallbackInfo.&quot;), Marker = 2 UMETA(ToolTip = &quot;Callback triggered when encountering a marker during playback. AkCallbackInfo can be cast to AkMarkerCallbackInfo.&quot;), Duration = 3 UMETA(ToolTip = &quot;Callback triggered when the duration of the sound is known by the sound engine. AkCallbackInfo can be cast to AkDurationCallbackInfo.&quot;), Starvation = 5 UMETA(ToolTip = &quot;Callback triggered when playback skips a frame due to stream starvation. AkCallbackInfo can be cast to AkEventCallbackInfo.&quot;), MusicPlayStarted = 7 UMETA(ToolTip = &quot;Callback triggered when a Play or Seek command has been executed (Seek commands are issued from AK::SoundEngine::SeekOnEvent()). Applies to objects of the Interactive-Music Hierarchy only. AkCallbackInfo can be cast to AkEventCallbackInfo.&quot;), MusicSyncBeat = 8 UMETA(ToolTip = &quot;Enable notifications on Music Beat. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncBar = 9 UMETA(ToolTip = &quot;Enable notifications on Music Bar. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncEntry = 10 UMETA(ToolTip = &quot;Enable notifications on Music Entry Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncExit = 11 UMETA(ToolTip = &quot;Enable notifications on Music Exit Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncGrid = 12 UMETA(ToolTip = &quot;Enable notifications on Music Grid. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncUserCue = 13 UMETA(ToolTip = &quot;Enable notifications on Music Custom Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MusicSyncPoint = 14 UMETA(ToolTip = &quot;Enable notifications on Music switch transition synchronization point. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo.&quot;), MIDIEvent = 16 UMETA(ToolTip = &quot;Enable notifications for MIDI events. AkCallbackInfo can be cast to AkMIDIEventCallbackInfo.&quot;),&#125;; EndOfEvent：事件结束时触发回调；能够转换到 AkEventCallbackInfo Marker：遇到标记时触发回调；能够转换到 AkMarkerCallbackInfo Duration：当 Sound Engine 知道当前声音的持续时间时触发回调；能够转换到 AkDurationCallbackInfo Starvation：当播放由于流不足而跳过下一帧时触发回调；能够转换到 AkEventCallbackInfo MusicPlayStarted：当执行 Play 或者 Seek 时触发（从 AK::SoundEngine::SeekOnEvent 发出搜索命令），只适用于交互音乐层次结构的对象。能够转换到 AkEventCallbackInfo MusicSyncBeat：在 Music beat 上启用通知；能够转换到 AkMusicSyncCallbackInfo MusicSyncBar：在 Music Bar 上启用通知；能够转换到 AkMusicSyncCallbackInfo MusicSyncEntry：在 Music Entry 上启用通知；能够转换到 AkMusicSyncCallbackInfo MusicSyncExit：在 Music Exit 上启用通知；能够转换到 AkMusicSyncCallbackInfo MusicSyncGrid：在 Music Grid 上启用通知；能够转换到 AkMusicSyncCallbackInfo MusicSyncPoint：在 Music switch transition synchronization point 上启用通知；能够转换到 AkMusicSyncCallbackInfo MIDIEvent：为 MIDI 事件启用通知；能够转换到 AkMIDIEventCallbackInfo Marker在 WWise 编辑器中添加的 Sound VFX 里添加的 Audio 可以通过编辑来添加 Marker，Marker 可以在 UE 调用 UAkGameplayStatics::PostEvent 时将 CallbakMask 参数设置为EAkCallbackType::Marker，这样可以在回调函数中接收每次播放到 WWise 中添加 Marker 的位置，用于在游戏逻辑中做一些事情，比如显示音频对应的字幕。 UE 中监听： 而且 Identifier 也是从 0 开始的： WWise 中添加 Marker： 在 UE 里 PostEvent 时可以把 CallbackMask 的值添加上Marker，就可以在绑定的事件中接收播放过程中每次遇到的 Marker 了。可以用在播放的过程中监听显示字幕。 RTPC Real-time Parameter Controls（实时参数控制，RTPC）用于根据游戏中发生的实时参数变化，实时控制各种 Wwise 对象（包括音效对象、容器、总线、效果器等）的特定属性。 RTPC 可以由程序端传递值给 WWiese 端，WWise 端可以根据 传入的值控制声音。 在 WWise 中 RTPC： Switch使用 Switch 可以在引擎中切换不同的模式，比如玩家走在不同地面上的声音。 概念：Switch 在 PostEvent 一个 AkEvent 之后，可以通过 SetSwitch 传入 SwitchGroup 和SwitchState以及 PostEvent 时传递的 Actor. Sequencer Level Sequencer WWise 提供了在 Sequence 中使用的支持，可以在 Sequence 中使用 AkAudioEvenes 和AkAudioRTPC，从而实现在 Sequence 中来播放和控制 Event. Animation Animation 并且可以使用在动画通知中： 给该通知指定 Event： CommandLetWWise 提供了 UE 中的 Commandlet，用于处理批量生成 Bank 的功能。 使用介绍： 12345678Commandlet allowing to generate Wwise SoundBanks.Usage: &lt;Editor.exe&gt; &lt;path_to_uproject&gt; -run=GenerateSoundBanks [-platforms=listOfPlatforms] [-banks=listOfBanks] [-wwiseCliPath=pathToWwiseCli]Parameters: - platforms: (Optional) Comma separated list of platforms for which SoundBanks will be generated, as specified in the Wwise project. If not specified, SoundBanks will be generated for all platforms. - banks: (Optional) Comma separated list of SoundBanks to generate. Bank names must correspond to a UAkAudioBank asset in the project. If now specified, all SoundBanks found in project will be generated. - wwiseCliPath: (Optional) Full path to the Wwise command-line application to use to generate the SoundBanks. If not specified, the path found in the Wwise settings will be used. - help: (Optional) Print this help message. This will quit the commandlet immediately.For more information, see https://www.audiokinetic.com/library/edge/?source=UE4&amp;id=using_features_generatecommandlet.html 生成 SoundBank 的 Commandle 为： 1Engine/Binaries/Win64/UE4Editor.exe &quot;D:/WwiseDemoGame.uproject&quot; -run=GenerateSoundBanks -platforms=Windows,Android,iOS -wait -wait参数是我加在 CommandLet 中的，可以用来控制执行完毕后等待用户输入，避免执行窗口一闪而过的情况。当没有指定生成哪些 SoundBank 时，会把项目中所有定义的 SoundBank 生成，如果想要自己指定，则可以使用 -banks=aaa,bbb,ccc 等形式来指定。 最终的执行命令为（可以看到 -ImportDefinitionFile 参数）： 1&quot;C:\\Program Files (x86)\\Audiokinetic\\Wwise 2019.1.9.7221\\Authoring\\x64\\Release\\bin\\WwiseCLI.exe&quot; &quot;D:/WwiseDemoGame/UnrealWwiseDemo/UnrealDemo.wproj&quot; -GenerateSoundBanks -Bank ExtSrcBnk -Bank AmbientBank -Bank ReverbBank -Bank VelocityBank -Bank MatineeBank -Bank SubtitleBank -Bank SwitchBank -ImportDefinitionFile &quot;D:/WwiseDemoGame/TempDefinitionFile.txt&quot; -Platform Windows -SoundBankPath Windows &quot;D:\\WwiseDemoGame\\Content\\WwiseAudio\\Windows&quot; -Platform Android -SoundBankPath Android &quot;D:\\WwiseDemoGame\\Content\\WwiseAudio\\Android&quot; -Platform iOS -SoundBankPath iOS &quot;D:\\WwiseDemoGame\\Content\\WwiseAudio\\iOS&quot; 拆分命令来看： WWiseCLI.exe 的路径 -GenerateSoundBanks：传递给 WWiseCLI.exe 标识用于生成 SoundBank -Bank：指定 Bank 的名字 -ImportDefinitionFile：指定 TempDefinitionFile.txt 文件 -Platform：指定平台 -SoundBankPath：指定生成平台保存到的目录 命令行参数 -nosound：关闭 WWise 的声音。 123456789bool FAkAudioDevice::EnsureInitialized()&#123; // We don&#x27;t want sound in those cases. if (FParse::Param(FCommandLine::Get(), TEXT(&quot;nosound&quot;)) || FApp::IsBenchmarking() || IsRunningDedicatedServer() || IsRunningCommandlet()) &#123; return false; &#125; // ...&#125; 全局暂停音乐 处理系统专用事件 可以通过以下代码实现： 123456// on enter backgraoundAK::SoundEngine::Suspend(false);// on enter foregroundAK::SoundEngine::WakeupFromSuspend();AK::SoundEngine::RenderAudio(); 热更 WWise 的 Bank根据上面的分析可以看到， WWise 在生成 Bank 时以平台为单位生成，每个平台都会生成对应的文件夹。这要求我们在热更时需要根据不同的平台包含不同的外部文件，HotPatcher已经支持了这个特性，可以实现特定平台包含特殊的文件。 WWise 集成至 UE 的缺点 官方提供的 Event 导入和指定 Bank 的流程太繁琐了，每个 Event 都需要拖到 Content Browser 里才可以创建出 UE 的 Event 资源，然后还需要打开手动指定 RequireBank，十分的麻烦。其实 WWise 编辑器中本身包含了 Bank 的编辑功能，但是在 UE 中官方没有提供方法可以批量地生成 UE 里的 Event 和 Bank 资源，这个可以作为业余扩展开发的点，自己搞一个批量导入的功能，不过是后话了，有时间再来搞。 文档 WWise 中的概念概述：Wwise 概念概述 DLC 注意事项及限制","tags":[{"name":"Music","slug":"Music","permalink":"https://ue5wiki.com/tags/Music/"},{"name":"Wwise","slug":"Wwise","permalink":"https://ue5wiki.com/tags/Wwise/"}],"categories":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://ue5wiki.com/categories/Gameplay/"}]},{"title":"UE 导入图集：TexturePacker","date":"2020-09-11T15:53:22.000Z","path":"wiki/28513/","text":"在开发游戏时，会使用到大量的图片资源，使用图集的作用在于减少 DrawCall，提高性能。在 UE 中没有图集的打包工具，比较流行的方案是使用第三方的图集打包工具 TexturePacker。新版本的 TexturePacker 支持直接导出 UE4 的 Sprite，并且可以在引擎中直接导入。在之前的版本中可以使用VaTexAtlas 通过 Json Array 的数据导入，不过与 TexturePacker 直接导出 UE 的 Sprite 相比，VaTexAtlas 并没有优势，UE 的 Sprite 还可以直接预览，VaTexAtlas 则不可以，在官方已经支持的情况下不建议再使用 VaTexAtlas 作为 UE 导入图集的方式。 本篇文章主要内容是记录 TexturePacker 图集生成文件的分析、导入 UE、选项介绍、以及记录在 UE 中使用遇到的问题。 图集文件结构和导入 UETexturePacker 的项目文件格式为*.tps，在使用 TexturePacker 导出 UE 的图集会产生两个文件（以 Icons 项目为例）： 123icons.tpsicons.paper2dspritesicons.webp 其中 icons.webp 是导出的 Texture。icons.paper2dsprites是当前图集的描述文件，使用 json 格式，用于描述图集中包含的每个 Sprite 的信息： 12345678910111213141516171819202122232425262728293031&#123; &quot;frames&quot;: &#123; &quot;BackIcon.webp&quot;: &#123; &quot;frame&quot;: &#123;&quot;x&quot;:49,&quot;y&quot;:1,&quot;w&quot;:36,&quot;h&quot;:36&#125;, &quot;rotated&quot;: false, &quot;trimmed&quot;: false, &quot;spriteSourceSize&quot;: &#123;&quot;x&quot;:0,&quot;y&quot;:0,&quot;w&quot;:36,&quot;h&quot;:36&#125;, &quot;sourceSize&quot;: &#123;&quot;w&quot;:36,&quot;h&quot;:36&#125; &#125;, &quot;Cross_12x.webp&quot;: &#123; &quot;frame&quot;: &#123;&quot;x&quot;:251,&quot;y&quot;:53,&quot;w&quot;:12,&quot;h&quot;:12&#125;, &quot;rotated&quot;: false, &quot;trimmed&quot;: false, &quot;spriteSourceSize&quot;: &#123;&quot;x&quot;:0,&quot;y&quot;:0,&quot;w&quot;:12,&quot;h&quot;:12&#125;, &quot;sourceSize&quot;: &#123;&quot;w&quot;:12,&quot;h&quot;:12&#125; &#125; &#125;, &quot;meta&quot;: &#123; &quot;app&quot;: &quot;https://www.codeandweb.com/texturepacker&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;target&quot;: &quot;paper2d&quot;, &quot;image&quot;: &quot;icons.webp&quot;, &quot;format&quot;: &quot;RGBA8888&quot;, &quot;size&quot;: &#123;&quot;w&quot;:288,&quot;h&quot;:120&#125;, &quot;scale&quot;: &quot;1&quot;, &quot;smartupdate&quot;: &quot;$TexturePacker:SmartUpdate:25f0f996e96d501a04346c8b7185b520:81c127855f3c19ba3f655bd8ca6a90ac:7e03caed8675e493d8b522094ff94bba$&quot; &#125;&#125; 将 icons.paper2dsprite 文件拖入 UE 的 Content Browser 窗口会创建出下面这些资源： Frames 目录下是当前图集中的每个 Sprite，原始导入的资源关系均是软引用（Sprite-&gt;Sprite 以及 Sprite-&gt;Texture），但是有些 Sprite 会硬引用 /Paper2D/TranslucentUnlitSpriteMaterial 这个Material Instance Texture 目录中具有一个当前图集的完整 Texture，该资源的原始路径依赖为硬盘中的 png 文件，图集中的 Sprite 对该 Texture 的资源引用关系是软引用。 SpriteSheet 这个资源则是导入 *.paper2dsprite 文件创建的资源，该资源的原始路径依赖为 *.paper2dsprite 文件，该资源对图集的完整 Texture 是硬引用，对图集中的 Sprite 是软引用。 Texture Settings主界面： 参数说明。 Data Data Format：选择 Publish 时生成的格式，支持 UE Trim sprite names：是否裁剪 Sprite 的名字，在 false 的情况下，Sprite 的名字会包含后缀如BackIcon.webp，导入引擎时名字为 BackIcon_png，为 true 时则把后缀裁剪掉。 Prepend Folder name：导出的 Sprite 是否包含目录名字，若为 false，则所有的 Sprite 都按照原本的名字，若为 true，导出的 *.paper2dsprite 文件中对 sprite 的描述中会包含路径信息（如 Icons/BackIcon.webp，导入引擎中的名字就为 Icons_BackIcon_png） TexturePatth：指定要导出的 Texture 路径 Texture Texture format：导出图集的 Texture 的格式，默认PNG-32 Texture file：导出的 Texture 的文件名 Png Opt Level：PNG 文件的优化，所有的优化都是有损压缩，0 为 32 位 png 文件.（0 always write 32 bit png files、1write indexed (8 bit) png files if possible、2..7 optimize packing, high values might be slow） Pixel format：像素格式：默认RGB8888 所有支持的格式： Transparency Handling：使用何种方式处理 Alpha 透明像素的颜色值，支持四种模式，默认选项为Clear Transparent pixel，该模式节省磁盘空间。 Layout Max Sise：图集的最大尺寸 Fixes Size: 手动指定图集的大小，为空则让 TexturePacker 确定图集大小 Size Contraints：图集的大小约束，默认选项是 Any Size。在 UE 中导入的 Texture 要求是 2 次幂的，否则在 IOS 上会有显示问题，如果非 2 次幂，在 UE 中可以设置填充，不填充也可以，要把 Compression-Compression Settings 设置为 USerInterface2D，但是非 2 次幂的 Texture 会有性能问题。（之前遇到的问题：UE4：IOS 贴图非 2 次幂的显示问题） Forces squared：强制 Texture 具有 2 次幂大小，勾选后(Max Size 和 Fixes Size 被锁定为单个值)。 Scaling variants：缩放变体的设置 Scale：缩放 Scale Mode：缩放模式，默认为Smooth。 Algorithm：Sprite 的排列算法，默认是 MaxRects，大小混排，也可以使用Grid/Strip 使用最大 Sprite 的格子布局。选择不同的算法，可以控制的选项不一样。 Basic：Sort by/Sort order/Pack，用于控制 Sprite 的排列规则 Grid/Strip：按照最大的 Sprite 为基本格子单位 MaxRects：Heuristics/Pack，其中 Heuristics 又控制着几种模式 Multipack：如果不想要把所有的 Sprite 打包到单个 Texture 里，可以使用此选项打包出多个 Texture 和数据文件，默认 false Allow rotation：是否允许旋转 Sprite，能够使生成的 Texture 贴合的更好，开启后可以将他们顺时针或者逆时针旋转 90 度（在有些引擎中可能会不支持，在 UE 中测试没有问题），默认为 true Detect identical sprites：自动别名相同的图片只在 Texture 中存储一次，但是数据文件中包含多份，相当于一个 Texture 中包含了一个 Sprite 的图，但是数据中可以存储两个 Sprite 的信息，在导入引擎时就会生成两个 Sprite，但原始的 Texture 中只有一份图像数据，可以节省空间。 Sprites Trim mode：可以裁剪 Sprite 边界的透明像素，由于不需要处理透明像素，因此可以缩小 Sprite 的尺寸，可以使图集排布的更加紧密，并加快渲染速度。有四种模式None/Trim/Crop,keep Pos/Crop,flush Pos。 None：不裁剪，保持 Sprite 原始大小，保持原有的透明像素，在此种模式下在 UE 中使用该 Sprite 与原图相同。 Trim：移除 Sprite 周围的透明度，在使用时，应该具有原有大小，但该选项并非在所有框架中都可用。实际测试时在 UE 中使用 Sprite 比例与原图不同，没有原图中的周围透明像素。 Crop,keep Pos：导入 UE 中与 Trim 看起来相同，目前还没发现其他的区别。 Crop,flush Pos：导入 UE 中与 Trim 以及 Crop,flush Pos 看起来相同。 Trim margin：当开启裁剪时，裁剪算法会尽可能多地删除边界的透明像素，设置 Trim margin 可以指定保留边界的像素。 Transparency Threshold：值范围为 1~255，默认值为 1。当开启裁剪时，低于此值的 alpha 值将被视为透明，对于边界几乎不可见的 alpha 像素的 Sprite 可以起到裁剪的作用。 Extrude：默认值为 1，用于指定拉伸 Sprite 边界重复的像素，Sprite 的大小保持不变。但设置之后在 UE 中 Sprite 的中心位置发生了变化。当 Extruct 设置为 10，之前和之后的区别： Border padding：填充图集 Texture 边缘为透明像素（边缘的位置不放置 Sprite） Shape padding：设置 Sprite 之间的填充，默认为 2，填充的像素不会添加到 sprite 中，在使用 OpenGL 渲染时应至少设置为 2. Common divisor：扩展 Sprite 的大小使其能被设置的值整除，扩展的 Sprite 会透明，默认值为 1，表示 Sprite 大小不变，最大为 2048。用途为强制设置大小相同的 Sprite，在多个缩放因子上强制相同的布局。 Normal maps Pack with same layout：Sprite 图像和他们的法线贴图使用相同的布局打包在单独的 Sprite sheets 上。 UE4 使用图集的问题UMG 中使用的问题UMG 里使用 TexturePacker 图集，在 UImage 空间中使用 Sprit，用 Draw As=Image ,Tiling=Horizontal，发现整个图集都被平铺出来了。 在 Tiling 为No Tile的模式下是正常的，但是在其他的模式下都会有问题。应该是引擎支持不够的问题，只能暂时先不用这种方式，有时间具体分析一下原因。 Reimport 问题reimport 图集有一个坑，可能会出现 uv 混乱，出现 UV 不对的问题。 避免问题的操作流程是： 保证没有打开使用到该图集的 UMG 删掉图集和所有 sprite 重新拖进来一次","tags":[{"name":"TexturePacker","slug":"TexturePacker","permalink":"https://ue5wiki.com/tags/TexturePacker/"},{"name":"图集","slug":"图集","permalink":"https://ue5wiki.com/tags/%E5%9B%BE%E9%9B%86/"}],"categories":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://ue5wiki.com/categories/Gameplay/"}]},{"title":"使用 HTTP 请求下载文件的坑和技巧","date":"2020-09-08T14:46:58.000Z","path":"wiki/42238/","text":"使用 HTTP 可以请求下载文件，response 的结果就是文件的内容。在下载一个文件之前可以先使用 HEAD 请求来只获取头，可以从 Content-Length 头获取到文件的大小。 1234567// head requestTSharedRef&lt;IHttpRequest&gt; HttpHeadRequest = FHttpModule::Get().CreateRequest();HttpHeadRequest-&gt;OnHeaderReceived().BindUObject(this, &amp;UDownloadProxy::OnRequestHeadHeaderReceived);HttpHeadRequest-&gt;OnProcessRequestComplete().BindUObject(this, &amp;UDownloadProxy::OnRequestHeadComplete);HttpHeadRequest-&gt;SetURL(InternalDownloadFileInfo.URL);HttpHeadRequest-&gt;SetVerb(TEXT(&quot;HEAD&quot;));HttpHeadRequest-&gt;ProcessRequest(); 在 UE 中需要通过监听 HTTP 请求的 OnHeaderReceived 派发来获得想要的头数据： 1234567void UDownloadProxy::OnRequestHeadHeaderReceived(FHttpRequestPtr RequestPtr, const FString&amp; InHeaderName, const FString&amp; InNewHeaderValue)&#123; if (InHeaderName.Equals(TEXT(&quot;Content-Length&quot;))) &#123; InternalDownloadFileInfo.Size = UKismetStringLibrary::Conv_StringToInt(InNewHeaderValue); &#125;&#125; 之后就可以用 Get 方法来请求文件了： 123456789// get requestTSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();HttpRequest-&gt;OnRequestProgress().BindUObject(this, &amp;UDownloadProxy::OnDownloadProcess, bIsSlice?EDownloadType::Slice:EDownloadType::Start);HttpRequest-&gt;OnProcessRequestComplete().BindUObject(this, &amp;UDownloadProxy::OnDownloadComplete);HttpRequest-&gt;SetURL(InternalDownloadFileInfo.URL);HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));RangeArgs = TEXT(&quot;bytes=0-&quot;)+FString::FromInt(FileTotalByte);HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), RangeArgs);HttpRequest-&gt;ProcessRequest(); 其中 Range 头的格式为：Byte=0-指请求整个文件的大小，Byte=0-99则是请求前 100byte，注意请求的范围不要超过文件大小 ，不然会有 400 错误。 通过控制 HTTP 请求的 Range 头，我们可以指定下载文件的任意部分，可以实现暂停继续 / 分片下载。 在 UE 中使用 HTTP 请求一个大文件的时候，如果该请求没有结束就去拿 response 的结果一定要注意一个问题：那就是 Response 的 Content 数据 Payload 是一个 TArray 动态数组，当 Content 的内容不断地被写入，会导致容器的 Reserve 也就是内存重新分配，获取该数组的内存地址是非常危险的。 所以建议在 HTTP 请求时先对 response 的 Content 的 Payload 进行 Reserve 使其能够容纳足够数量的数据，缺点就是会一次性占用整个文件的内存。解决内存占用的办法就是通过 Http 请求的 Range 来实现分片下载（也就是把一个大文件分成数个小块，一块一块地下载），从而降低内存占用， 当下载文件后，通常还有进行文件校验的操作，等文件下载完之后再执行校验（如 MD5 计算）时间会很长，所以要解决校验的时间问题，想过开一个线程去计算，但是开线程只解决了不阻塞主线程，不会加速 MD5 的计算过程，后来想到 MD5 是摘要计算，进而联想到可不可以边下边进行 MD5 计算，根据 没有全新的轮子定理 （我瞎掰的），我查到了 OpenSSL 中的 MD5 实现支持使用MD5_Update 来增量计算，所以这个问题就迎刃而解了，具体看我前面的笔记MD5 的分片校验。 基于上面这些内容，可以实现一个简陋的下载器功能了，可作为游戏中的下载组件，虽然看似简单，但是设计一个合理的结构和没有 bug 的版本还是要花点功夫的。我把上面介绍的内容写成了一个插件： HTTP 的分片请求在服务端的 Log: 资料文档： 从服务器端请求特定的范围","tags":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/tags/Network/"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"}]},{"title":"Android 在 Windows 的编译环境","date":"2020-09-01T22:32:01.000Z","path":"wiki/external1206210905/","text":"本篇文章为外部内容，请点击链接跳转至原站点：Android 在 Windows 的编译环境 。","tags":[],"categories":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Android","slug":"开发环境/Android","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Android/"}],"is_external":true,"jump_to":"/wiki/52d36a"},{"title":"Android 在 Windows 的编译环境","date":"2020-09-01T22:32:01.000Z","path":"wiki/52d36a/","text":"Android 的开发环境需要 JDK/NDK/SDK/Ant/Gradle 等组合而成，UE 的文档中介绍需要安装 NVDIA 的 CodeWorks，但是由于国内网络问题难以下载，并且有些组件并不需要，所以我打包了一份 Android 的开发环境，可以快速部署。 组件版本： JDK 18077 NDK r14b SDK android19-26 Ant 1.8.2 Gradle 4.1 下载地址：AndroidSDK_1R7u1_20190923.7z，解压之后有 AddToPath.bat 脚本，一键添加所需的环境变量。 123456789101112@echo offset &quot;current_dir_name=%cd%&quot;setx JAVA_HOME &quot;%current_dir_name%\\jdk18077&quot;setx ANDROID_HOME &quot;%current_dir_name%\\android-sdk-windows&quot;setx ANDROID_NDK_ROOT &quot;%current_dir_name%\\android-ndk-r14b&quot;setx ANT_HOME &quot;%current_dir_name%\\apache-ant-1.8.2&quot;setx GRADLE_HOME &quot;%current_dir_name%\\gradle-4.1&quot;setx NDK_ROOT &quot;%current_dir_name%\\android-ndk-r14b&quot;setx NDKROOT &quot;%current_dir_name%\\android-ndk-r14b&quot;setx NVPACK_NDK_TOOL_VERSION &quot;4.9&quot;setx NVPACK_NDK_VERSION &quot;android-ndk-r14b&quot;setx NVPACK_ROOT &quot;%current_dir_name%&quot; 如果需要更新版本的 NDK 和 SDK 支持的版本有些老，可以自行在下载所需的版本： Online Android SDK Manager Android Developer NDK Downloads Unsupported NDK Downloads 下载之后放到对应的目录下即可，并且需要修改环境变量中的值。 添加完环境变量之后之后无需再从 UE 中设置 SDK 与 NDK 的路径，保持默认即可打包。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"Windows","slug":"Windows","permalink":"https://ue5wiki.com/tags/Windows/"},{"name":"编译环境","slug":"编译环境","permalink":"https://ue5wiki.com/tags/%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"Android 常用的工具和命令","date":"2020-09-01T22:32:01.000Z","path":"wiki/6fa72650/","text":"Adbadb 是 Android 的调试工具，非常强大，熟悉一些 adb 的命令能够让效率加倍。首先先要下载Adb。 安装 Apk1$ adb install APK_FILE_NAME.apk 启动 App安装的 renderdoccmd 是没有桌面图标的，想要自己启动的话只能使用下列 adb 命令： 1adb shell am start org.renderdoc.renderdoccmd.arm64/.Loader -e renderdoccmd &quot;remoteserver&quot; renderdoc-cmd-apk adb 启动 App 的 shell 命令模板: 1adb shell am start PACKAGE_NAME/.ActivityName 这个方法需要知道 App 的包名和 Activity 名，包名很容易知道，但是 Activity 如果不知道可以通过下列操作获取： 首先使用一个反编译工具将 apk 解包(可以使用之前的apktools)： 1apktool.bat d -o ./renderdoccmd_arm64 org.renderdoc.renderdoccmd.arm64.apk 然后打开 org.renderdoc.renderdoccmd.arm64 目录下的 AndroidManifest.xml 文件，找到其中的 Application 项： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.renderdoc.renderdoccmd.arm64&quot; platformBuildVersionCode=&quot;26&quot; platformBuildVersionName=&quot;8.0.0&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-feature android:glEsVersion=&quot;0x00030000&quot; android:required=&quot;true&quot;/&gt; &lt;application android:debuggable=&quot;true&quot; android:hasCode=&quot;true&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;RenderDocCmd&quot;&gt; &lt;activity android:configChanges=&quot;keyboardHidden|orientation&quot; android:exported=&quot;true&quot; android:label=&quot;RenderDoc&quot; android:name=&quot;.Loader&quot; android:screenOrientation=&quot;landscape&quot;&gt; &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;renderdoccmd&quot;/&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 其中有所有注册的Activity，没有有界面的 apk 只有一个 Activity，所以上面的 renderdoccmd 的主 Activity 就是.Loader。 如果说有界面的 app，则会有多个，则可以从 AndroidManifest.xml 查找 Category 或者根据命名 (名字带main 的 Activity)来判断哪个是主 Activity。一般都是从 lanucher 开始，到 main，或者有的进登陆界面。 PS：使用 UE 打包出游戏的主 Activity 是com.epicgames.ue4.SplashActivity，可以通过下列命令启动。 1adb shell am start com.imzlp.GWorld/com.epicgames.ue4.SplashActivity 传输文件 使用 adb 往手机传文件： 12# adb push 1.0_Android_ETC2_P.pak /sdcard/Android/data/com.imzlp.TEST/files/UE4GameData/Mobile422/Mobile422/Saved/Paks$ adb push FILE_NAME REMOATE_PATH 从手机传递到电脑： 12# adb pull /sdcard/Android/data/com.imzlp.TEST/files/UE4GameData/Mobile422/Mobile422/Saved/Paks/1.0_Android_ETC2_P.pak A.Pak$ adb pull REMOATE_FILE_PATH LOCAL_PATH Logcat使用 logcast 可以看到 Android 的设备 Log 信息。 1$ adb logcat 会打印出当前设备的所有信息，但是我们调试 App 时不需要看到这么多，可以使用 find 进行筛选(注意大小写严格区分)： 12# adb logcat | find &quot;GWorld&quot;$ adb logcat | find &quot;KEY_WORD&quot; 查看 UE 打包的 APP 所有的 log 可以筛选： 1$ adb logcat | find &quot;UE4&quot; 如果运行的次数过多积累了大量的 Log，可以使用清理： 1adb logcat -c 从设备中提取已安装的 APK注意：执行下列命令时需要检查手机是否开放开发者权限，手机上提示的验证指纹信息要允许。 12345678910111213141516171819202122232425262728# 查看链接设备$ adb devicesList of devices attachedb2fcxxxx unauthorized# 列出手机中安装的所有 app$ adb shell pm list package# 如果提示下问题，则需要执行 adb kill-servererror: device unauthorized.This adb servers $ADB_VENDOR_KEYS is not setTry &#x27;adb kill-server&#x27; if that seems wrong.Otherwise check for a confirmation dialog on your device.# 正常情况下会列出一堆这样的列表C:\\Users\\imzlp&gt;adb shell pm list packagepackage:com.miui.screenrecorderpackage:com.amazon.mShop.android.shoppingpackage:com.mobisystems.officepackage:com.weico.internationalpackage:com.github.shadowsockspackage:com.android.cts.priv.ctsshimpackage:com.sorcerer.sorcery.iconpackpackage:com.google.android.youtube# 找到指定 app 的的 apk 位置$ adb shell pm path com.github.shadowsockspackage:/data/app/com.github.shadowsocks-iBtqbmLo8rYcq2BqFhJtsA==/base.apk# 然后将该文件拉取到本地来即可$ adb pull /data/app/com.github.shadowsocks-iBtqbmLo8rYcq2BqFhJtsA==/base.apk/data/app/com.github.shadowsocks-iBtqbmLo8rYcq2BqFhJtsA==/...se.apk: 1 file pulled. 21.5 MB/s (4843324 bytes in 0.215s) 刷入 Recovery下载Adb，然后根据具体情况使用下列命令(如果当前已经在 bootloader 就不需要执行第一条了)。 123456adb reboot bootloader# 写入 img 到设备fastboot flash recovery recovery.imgfastboot flash boot boot.img# 引导 imgfastboot boot recovery.img 端口转发 可以通过 adb 命令来指定： 1234# PC to Deviceadb reverse tcp:1985 tcp:1985# Device to PCadb forward tcp:1985 tcp:1985 Android 上超级好用的前端调试方法（adb reverse） 根据包名查看 apk 位置 可以使用以下 adb 命令： 12$ adb shell pm list package -f com.tencent.tmgp.fmpackage:/data/app/com.tencent.tmgp.fm-a_cOsX8G3VClXwiI-RD9wQ==/base.apk=com.tencent.tmgp.fm 最后一个参数是包名, 输出的则是 apk 的路径。 查看当前窗口的 app 的包名 使用以下 adb 命令： 12345678$ adb shell dumpsys window w | findstr \\/ | findstr name= mSurface=Surface(name=SideSlideGestureBar-Bottom)/@0xa618588 mSurface=Surface(name=SideSlideGestureBar-Right)/@0x619b646 mSurface=Surface(name=SideSlideGestureBar-Left)/@0xea02007 mSurface=Surface(name=StatusBar)/@0x7e4962d mAnimationIsEntrance=true mSurface=Surface(name=com.tencent.tmgp.fm/com.epicgames.ue4.GameActivity)/@0x43b30a0 mSurface=Surface(name=com.tencent.tmgp.fm/com.epicgames.ue4.GameActivity)/@0xa3481e mAnimationIsEntrance=true mSurface=Surface(name=com.vivo.livewallpaper.monster.bmw.MonsterWallpaperService)/@0x53e44ae 其中的 mAnimationIsEntrance=true mSurface=Surface(name= 之后，到 / 之前的字符串就是我们的 app 包名。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"UE 开发 Android 的工程实践","date":"2020-09-01T22:32:01.000Z","path":"wiki/22ba95f2/","text":"Android 运行时请求权限ActivityCompact 里面有个 requestPermission 方法，可以用来处理这种情况。 请求应用权限 Android 运行时请求权限 Android 中的权限 Android 获取包名 通过 UPL 在 Java 里添加以下代码： 12345public String AndroidThunkJava_GetPackageName()&#123; Context context = getApplicationContext(); return context.getPackageName();&#125; 在 C++ 里通过 JNI 调用即可： 123456789101112FString UFlibAppHelper::GetAppPackageName()&#123; FString result;#if PLATFORM_ANDROID if (JNIEnv* Env = FAndroidApplication::GetJavaEnv()) &#123; jmethodID GetInstalledPakPathMethodID = FJavaWrapper::FindMethod(Env, FJavaWrapper::GameActivityClassID, &quot;AndroidThunkJava_GetPackageName&quot;, &quot;()Ljava/lang/String;&quot;, false); result = FJavaHelper::FStringFromLocalRef(Env, (jstring)FJavaWrapper::CallObjectMethod(Env, FJavaWrapper::GameActivityThis,GetInstalledPakPathMethodID)); &#125;#endif return result; &#125; Android 获取外部存储路径 获取 App 的沙盒路径： 123456789101112131415161718192021222324252627// /storage/emulated/0/Android/data/com.xxxx.yyyy.zzzz/filesFString FAndroidGCloudPlatformMisc::getExternalStorageDirectory()&#123; FString result; if (JNIEnv* Env = FAndroidApplication::GetJavaEnv()) &#123; // get context jobject JniEnvContext; &#123; jclass activityThreadClass = Env-&gt;FindClass(&quot;android/app/ActivityThread&quot;); jmethodID currentActivityThread = FJavaWrapper::FindStaticMethod(Env, activityThreadClass, &quot;currentActivityThread&quot;, &quot;()Landroid/app/ActivityThread;&quot;, false); jobject at = Env-&gt;CallStaticObjectMethod(activityThreadClass, currentActivityThread); jmethodID getApplication = FJavaWrapper::FindMethod(Env, activityThreadClass, &quot;getApplication&quot;, &quot;()Landroid/app/Application;&quot;, false); JniEnvContext = FJavaWrapper::CallObjectMethod(Env, at, getApplication); &#125; jmethodID getExternalFilesDir = Env-&gt;GetMethodID(Env-&gt;GetObjectClass(JniEnvContext), &quot;getExternalFilesDir&quot;, &quot;(Ljava/lang/String;)Ljava/io/File;&quot;); // get File jobject ExternalFileDir = Env-&gt;CallObjectMethod(JniEnvContext, getExternalFilesDir,nullptr); // getPath method in File class jmethodID getFilePath = Env-&gt;GetMethodID(Env-&gt;FindClass(&quot;java/io/File&quot;), &quot;getPath&quot;, &quot;()Ljava/lang/String;&quot;); jstring pathString = (jstring)Env-&gt;CallObjectMethod(ExternalFileDir, getFilePath, nullptr); const char *nativePathString = Env-&gt;GetStringUTFChars(pathString, 0); result = ANSI_TO_TCHAR(nativePathString); &#125; return result;&#125; Android 获取已安装 App 的 Apk 路径 有个需求，需要在运行时获取到，App 的 Apk 路径，查了一下 UE 里没有现成的接口，只能用 JNI 调用从 Java 那边想办法了。通过在 Android Developer 上查找，发现 ApplicationInfo 中具有 sourceDir 属性，记录着 APK 的路径。而可以通过 PackageManager 调用 getApplicationInfo 可以获取指定包名的 ApplicationInfo。 那么就好说了，UPL 里 java 代码走起： 123456789101112public String AndroidThunkJava_GetInstalledApkPath()&#123; Context context = getApplicationContext(); PackageManager packageManager = context.getPackageManager(); ApplicationInfo appInfo; try&#123; appInfo = packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA); return appInfo.sourceDir; &#125;catch (PackageManager.NameNotFoundException e)&#123; return &quot;invalid&quot;; &#125;&#125; 然后在 UE 里使用 JNI 调用： 12345if (JNIEnv* Env = FAndroidApplication::GetJavaEnv())&#123; jmethodID GetInstalledPakPathMethodID = FJavaWrapper::FindMethod(Env, FJavaWrapper::GameActivityClassID, &quot;AndroidThunkJava_GetInstalledApkPath&quot;, &quot;()Ljava/lang/String;&quot;, false); FString ResultApkPath = FJavaHelperEx::FStringFromLocalRef(Env, (jstring)FJavaWrapper::CallObjectMethod(Env, FJavaWrapper::GameActivityThis,GetInstalledPakPathMethodID));&#125; 其中 FJavaHelperEx::FStringFromLocalRef 是我封装的从 jstring 到 FString 的转换函数： 12345678910111213141516171819202122232425262728namespace FJavaHelperEx&#123; FString FStringFromParam(JNIEnv* Env, jstring JavaString) &#123; if (!Env || !JavaString || Env-&gt;IsSameObject(JavaString, NULL)) &#123; return &#123;&#125;; &#125; const auto chars = Env-&gt;GetStringUTFChars(JavaString, 0); FString ReturnString(UTF8_TO_TCHAR(chars)); Env-&gt;ReleaseStringUTFChars(JavaString, chars); return ReturnString; &#125; FString FStringFromLocalRef(JNIEnv* Env, jstring JavaString) &#123; FString ReturnString = FStringFromParam(Env, JavaString); if (Env &amp;&amp; JavaString) &#123; Env-&gt;DeleteLocalRef(JavaString); &#125; return ReturnString; &#125;&#125; 获取的结果： 升级至 AndroidX 资料 看操作方式也是使用 UPL 来介入打包过程，先记录下。 AndroidX support How to force the Unreal Engine Android project to use AndroidX? 为 APK 添加外部存储读写权限 在Project Settings-Platform-Android-Advanced APK Packaging-Extra Permissions下添加： 12android.permission.WRITE EXTERNAL STORAGEandroid.permission.READ_EXTERNAL_STORAGE AndroidP HTTP 请求错误 在 Android P 上使用 HTTP 请求上传数据会有以下错误提示： 12345678910111213142018-10-10 16:39:21.312 31611-31646/com.xfhy.tinkerfirmdemo W/CrashReport: java.io.IOException: Cleartext HTTP traffic to android.bugly.qq.com not permitted at com.android.okhttp.HttpHandler$CleartextURLFilter.checkURLPermitted(HttpHandler.java:115) at com.android.okhttp.internal.huc.HttpURLConnectionImpl.execute(HttpURLConnectionImpl.java:458) at com.android.okhttp.internal.huc.HttpURLConnectionImpl.connect(HttpURLConnectionImpl.java:127) at com.android.okhttp.internal.huc.HttpURLConnectionImpl.getOutputStream(HttpURLConnectionImpl.java:258) at com.tencent.bugly.proguard.ai.a(BUGLY:265) at com.tencent.bugly.proguard.ai.a(BUGLY:114) at com.tencent.bugly.proguard.al.run(BUGLY:355) at com.tencent.bugly.proguard.ak$1.run(BUGLY:723) at java.lang.Thread.run(Thread.java:764)2018-10-10 16:39:21.312 31611-31646/com.xfhy.tinkerfirmdemo E/CrashReport: Failed to upload, please check your network.2018-10-10 16:39:21.312 31611-31646/com.xfhy.tinkerfirmdemo D/CrashReport: Failed to execute post.2018-10-10 16:39:21.312 31611-31646/com.xfhy.tinkerfirmdemo E/CrashReport: [Upload] Failed to upload(1): Failed to upload for no response!2018-10-10 16:39:21.313 31611-31646/com.xfhy.tinkerfirmdemo E/CrashReport: [Upload] Failed to upload(1) userinfo: failed after many attempts Android P - CLEARTEXT communication not permitted by network security policy 这需要我们在打包时把指定的域名给配置成白名单。 方法如下: 在 res/xml 下创建 network_security_config.xml 文件 填入以下内容（网址自行修改）： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;android.bugly.qq.com&lt;/domain&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 然后在 AndroifManifest.xml 中引用该文件： 1&lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot;/&gt; 重新打包即可，在运行时会有以下 Log： 102-25 21:09:15.831 27760 27791 D NetworkSecurityConfig: Using Network Security Config from resource network_security_config debugBuild: true Android P 新特性 适配 Bugly 不支持 Android P Android Developer 网络安全配置 Android 写入文件 当调用 FFileHelper::SaveArrayToFile 时： 1FFileHelper::SaveArrayToFile(TArrayView&lt;const uint8&gt;(data, delta), *path, &amp;IFileManager::Get(), EFileWrite::FILEWRITE_Append)); 在该函数内部会创建一个 FArchive 的对象来管理当前文件，其内部具有一个 IFileHandle 的对象Handle，在 Android 平台上是FFileHandleAndroid。 在 FArchive 中写入文件调用的是 Serialize，它又会调用Handle 的Write： 1234bool FArchiveFileWriterGeneric::WriteLowLevel(const uint8* Src, int64 CountToWrite )&#123; return Handle-&gt;Write(Src, CountToWrite);&#125; Android 的 Write 的实现为： 12345678910111213141516171819202122232425262728293031// Runtime/Core/Private/Android/AndroidFile.hvirtual bool Write(const uint8* Source, int64 BytesToWrite) override&#123; CheckValid(); if (nullptr != File-&gt;Asset) &#123; // Can&#x27;t write to assets. return false; &#125; bool bSuccess = true; while (BytesToWrite) &#123; check(BytesToWrite &gt;= 0); int64 ThisSize = FMath::Min&lt;int64&gt;(READWRITE_SIZE, BytesToWrite); check(Source); if (__pwrite(File-&gt;Handle, Source, ThisSize, CurrentOffset) != ThisSize) &#123; bSuccess = false; break; &#125; CurrentOffset += ThisSize; Source += ThisSize; BytesToWrite -= ThisSize; &#125; // Update the cached file length Length = FMath::Max(Length, CurrentOffset); return bSuccess;&#125; 可以看到是每次 1M 往文件里存的。 Android 写入文件错误码对照 http://androidxref.com/8.0.0_r4/xref/bionic/libc/bionic/strerror.cpp#35 根据 error code number 查找 error string. http://androidxref.com/8.0.0_r4/xref/bionic/libc/bionic/strerror_r.cpp#_sys_error_strings http://androidxref.com/8.0.0_r4/xref/bionic/libc/private/bionic_errdefs.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// bionic_errdefs.h#ifndef __BIONIC_ERRDEF#error &quot;__BIONIC_ERRDEF must be defined before including this file&quot;#endif__BIONIC_ERRDEF(0 , 0, &quot;Success&quot; )__BIONIC_ERRDEF(EPERM , 1, &quot;Operation not permitted&quot; )__BIONIC_ERRDEF(ENOENT , 2, &quot;No such file or directory&quot; )__BIONIC_ERRDEF(ESRCH , 3, &quot;No such process&quot; )__BIONIC_ERRDEF(EINTR , 4, &quot;Interrupted system call&quot; )__BIONIC_ERRDEF(EIO , 5, &quot;I/O error&quot; )__BIONIC_ERRDEF(ENXIO , 6, &quot;No such device or address&quot; )__BIONIC_ERRDEF(E2BIG , 7, &quot;Argument list too long&quot; )__BIONIC_ERRDEF(ENOEXEC , 8, &quot;Exec format error&quot; )__BIONIC_ERRDEF(EBADF , 9, &quot;Bad file descriptor&quot; )__BIONIC_ERRDEF(ECHILD , 10, &quot;No child processes&quot; )__BIONIC_ERRDEF(EAGAIN , 11, &quot;Try again&quot; )__BIONIC_ERRDEF(ENOMEM , 12, &quot;Out of memory&quot; )__BIONIC_ERRDEF(EACCES , 13, &quot;Permission denied&quot; )__BIONIC_ERRDEF(EFAULT , 14, &quot;Bad address&quot; )__BIONIC_ERRDEF(ENOTBLK , 15, &quot;Block device required&quot; )__BIONIC_ERRDEF(EBUSY , 16, &quot;Device or resource busy&quot; )__BIONIC_ERRDEF(EEXIST , 17, &quot;File exists&quot; )__BIONIC_ERRDEF(EXDEV , 18, &quot;Cross-device link&quot; )__BIONIC_ERRDEF(ENODEV , 19, &quot;No such device&quot; )__BIONIC_ERRDEF(ENOTDIR , 20, &quot;Not a directory&quot; )__BIONIC_ERRDEF(EISDIR , 21, &quot;Is a directory&quot; )__BIONIC_ERRDEF(EINVAL , 22, &quot;Invalid argument&quot; )__BIONIC_ERRDEF(ENFILE , 23, &quot;File table overflow&quot; )__BIONIC_ERRDEF(EMFILE , 24, &quot;Too many open files&quot; )__BIONIC_ERRDEF(ENOTTY , 25, &quot;Not a typewriter&quot; )__BIONIC_ERRDEF(ETXTBSY , 26, &quot;Text file busy&quot; )__BIONIC_ERRDEF(EFBIG , 27, &quot;File too large&quot; )__BIONIC_ERRDEF(ENOSPC , 28, &quot;No space left on device&quot; )__BIONIC_ERRDEF(ESPIPE , 29, &quot;Illegal seek&quot; )__BIONIC_ERRDEF(EROFS , 30, &quot;Read-only file system&quot; )__BIONIC_ERRDEF(EMLINK , 31, &quot;Too many links&quot; )__BIONIC_ERRDEF(EPIPE , 32, &quot;Broken pipe&quot; )__BIONIC_ERRDEF(EDOM , 33, &quot;Math argument out of domain of func&quot; )__BIONIC_ERRDEF(ERANGE , 34, &quot;Math result not representable&quot; )__BIONIC_ERRDEF(EDEADLK , 35, &quot;Resource deadlock would occur&quot; )__BIONIC_ERRDEF(ENAMETOOLONG , 36, &quot;File name too long&quot; )__BIONIC_ERRDEF(ENOLCK , 37, &quot;No record locks available&quot; )__BIONIC_ERRDEF(ENOSYS , 38, &quot;Function not implemented&quot; )__BIONIC_ERRDEF(ENOTEMPTY , 39, &quot;Directory not empty&quot; )__BIONIC_ERRDEF(ELOOP , 40, &quot;Too many symbolic links encountered&quot; )__BIONIC_ERRDEF(ENOMSG , 42, &quot;No message of desired type&quot; )__BIONIC_ERRDEF(EIDRM , 43, &quot;Identifier removed&quot; )__BIONIC_ERRDEF(ECHRNG , 44, &quot;Channel number out of range&quot; )__BIONIC_ERRDEF(EL2NSYNC , 45, &quot;Level 2 not synchronized&quot; )__BIONIC_ERRDEF(EL3HLT , 46, &quot;Level 3 halted&quot; )__BIONIC_ERRDEF(EL3RST , 47, &quot;Level 3 reset&quot; )__BIONIC_ERRDEF(ELNRNG , 48, &quot;Link number out of range&quot; )__BIONIC_ERRDEF(EUNATCH , 49, &quot;Protocol driver not attached&quot; )__BIONIC_ERRDEF(ENOCSI , 50, &quot;No CSI structure available&quot; )__BIONIC_ERRDEF(EL2HLT , 51, &quot;Level 2 halted&quot; )__BIONIC_ERRDEF(EBADE , 52, &quot;Invalid exchange&quot; )__BIONIC_ERRDEF(EBADR , 53, &quot;Invalid request descriptor&quot; )__BIONIC_ERRDEF(EXFULL , 54, &quot;Exchange full&quot; )__BIONIC_ERRDEF(ENOANO , 55, &quot;No anode&quot; )__BIONIC_ERRDEF(EBADRQC , 56, &quot;Invalid request code&quot; )__BIONIC_ERRDEF(EBADSLT , 57, &quot;Invalid slot&quot; )__BIONIC_ERRDEF(EBFONT , 59, &quot;Bad font file format&quot; )__BIONIC_ERRDEF(ENOSTR , 60, &quot;Device not a stream&quot; )__BIONIC_ERRDEF(ENODATA , 61, &quot;No data available&quot; )__BIONIC_ERRDEF(ETIME , 62, &quot;Timer expired&quot; )__BIONIC_ERRDEF(ENOSR , 63, &quot;Out of streams resources&quot; )__BIONIC_ERRDEF(ENONET , 64, &quot;Machine is not on the network&quot; )__BIONIC_ERRDEF(ENOPKG , 65, &quot;Package not installed&quot; )__BIONIC_ERRDEF(EREMOTE , 66, &quot;Object is remote&quot; )__BIONIC_ERRDEF(ENOLINK , 67, &quot;Link has been severed&quot; )__BIONIC_ERRDEF(EADV , 68, &quot;Advertise error&quot; )__BIONIC_ERRDEF(ESRMNT , 69, &quot;Srmount error&quot; )__BIONIC_ERRDEF(ECOMM , 70, &quot;Communication error on send&quot; )__BIONIC_ERRDEF(EPROTO , 71, &quot;Protocol error&quot; )__BIONIC_ERRDEF(EMULTIHOP , 72, &quot;Multihop attempted&quot; )__BIONIC_ERRDEF(EDOTDOT , 73, &quot;RFS specific error&quot; )__BIONIC_ERRDEF(EBADMSG , 74, &quot;Not a data message&quot; )__BIONIC_ERRDEF(EOVERFLOW , 75, &quot;Value too large for defined data type&quot; )__BIONIC_ERRDEF(ENOTUNIQ , 76, &quot;Name not unique on network&quot; )__BIONIC_ERRDEF(EBADFD , 77, &quot;File descriptor in bad state&quot; )__BIONIC_ERRDEF(EREMCHG , 78, &quot;Remote address changed&quot; )__BIONIC_ERRDEF(ELIBACC , 79, &quot;Can not access a needed shared library&quot; )__BIONIC_ERRDEF(ELIBBAD , 80, &quot;Accessing a corrupted shared library&quot; )__BIONIC_ERRDEF(ELIBSCN , 81, &quot;.lib section in a.out corrupted&quot; )__BIONIC_ERRDEF(ELIBMAX , 82, &quot;Attempting to link in too many shared libraries&quot; )__BIONIC_ERRDEF(ELIBEXEC , 83, &quot;Cannot exec a shared library directly&quot; )__BIONIC_ERRDEF(EILSEQ , 84, &quot;Illegal byte sequence&quot; )__BIONIC_ERRDEF(ERESTART , 85, &quot;Interrupted system call should be restarted&quot; )__BIONIC_ERRDEF(ESTRPIPE , 86, &quot;Streams pipe error&quot; )__BIONIC_ERRDEF(EUSERS , 87, &quot;Too many users&quot; )__BIONIC_ERRDEF(ENOTSOCK , 88, &quot;Socket operation on non-socket&quot; )__BIONIC_ERRDEF(EDESTADDRREQ , 89, &quot;Destination address required&quot; )__BIONIC_ERRDEF(EMSGSIZE , 90, &quot;Message too long&quot; )__BIONIC_ERRDEF(EPROTOTYPE , 91, &quot;Protocol wrong type for socket&quot; )__BIONIC_ERRDEF(ENOPROTOOPT , 92, &quot;Protocol not available&quot; )__BIONIC_ERRDEF(EPROTONOSUPPORT, 93, &quot;Protocol not supported&quot; )__BIONIC_ERRDEF(ESOCKTNOSUPPORT, 94, &quot;Socket type not supported&quot; )__BIONIC_ERRDEF(EOPNOTSUPP , 95, &quot;Operation not supported on transport endpoint&quot; )__BIONIC_ERRDEF(EPFNOSUPPORT , 96, &quot;Protocol family not supported&quot; )__BIONIC_ERRDEF(EAFNOSUPPORT , 97, &quot;Address family not supported by protocol&quot; )__BIONIC_ERRDEF(EADDRINUSE , 98, &quot;Address already in use&quot; )__BIONIC_ERRDEF(EADDRNOTAVAIL , 99, &quot;Cannot assign requested address&quot; )__BIONIC_ERRDEF(ENETDOWN , 100, &quot;Network is down&quot; )__BIONIC_ERRDEF(ENETUNREACH , 101, &quot;Network is unreachable&quot; )__BIONIC_ERRDEF(ENETRESET , 102, &quot;Network dropped connection because of reset&quot; )__BIONIC_ERRDEF(ECONNABORTED , 103, &quot;Software caused connection abort&quot; )__BIONIC_ERRDEF(ECONNRESET , 104, &quot;Connection reset by peer&quot; )__BIONIC_ERRDEF(ENOBUFS , 105, &quot;No buffer space available&quot; )__BIONIC_ERRDEF(EISCONN , 106, &quot;Transport endpoint is already connected&quot; )__BIONIC_ERRDEF(ENOTCONN , 107, &quot;Transport endpoint is not connected&quot; )__BIONIC_ERRDEF(ESHUTDOWN , 108, &quot;Cannot send after transport endpoint shutdown&quot; )__BIONIC_ERRDEF(ETOOMANYREFS , 109, &quot;Too many references: cannot splice&quot; )__BIONIC_ERRDEF(ETIMEDOUT , 110, &quot;Connection timed out&quot; )__BIONIC_ERRDEF(ECONNREFUSED , 111, &quot;Connection refused&quot; )__BIONIC_ERRDEF(EHOSTDOWN , 112, &quot;Host is down&quot; )__BIONIC_ERRDEF(EHOSTUNREACH , 113, &quot;No route to host&quot; )__BIONIC_ERRDEF(EALREADY , 114, &quot;Operation already in progress&quot; )__BIONIC_ERRDEF(EINPROGRESS , 115, &quot;Operation now in progress&quot; )__BIONIC_ERRDEF(ESTALE , 116, &quot;Stale NFS file handle&quot; )__BIONIC_ERRDEF(EUCLEAN , 117, &quot;Structure needs cleaning&quot; )__BIONIC_ERRDEF(ENOTNAM , 118, &quot;Not a XENIX named type file&quot; )__BIONIC_ERRDEF(ENAVAIL , 119, &quot;No XENIX semaphores available&quot; )__BIONIC_ERRDEF(EISNAM , 120, &quot;Is a named type file&quot; )__BIONIC_ERRDEF(EREMOTEIO , 121, &quot;Remote I/O error&quot; )__BIONIC_ERRDEF(EDQUOT , 122, &quot;Quota exceeded&quot; )__BIONIC_ERRDEF(ENOMEDIUM , 123, &quot;No medium found&quot; )__BIONIC_ERRDEF(EMEDIUMTYPE , 124, &quot;Wrong medium type&quot; )__BIONIC_ERRDEF(ECANCELED , 125, &quot;Operation Canceled&quot; )__BIONIC_ERRDEF(ENOKEY , 126, &quot;Required key not available&quot; )__BIONIC_ERRDEF(EKEYEXPIRED , 127, &quot;Key has expired&quot; )__BIONIC_ERRDEF(EKEYREVOKED , 128, &quot;Key has been revoked&quot; )__BIONIC_ERRDEF(EKEYREJECTED , 129, &quot;Key was rejected by service&quot; )__BIONIC_ERRDEF(EOWNERDEAD , 130, &quot;Owner died&quot; )__BIONIC_ERRDEF(ENOTRECOVERABLE, 131, &quot;State not recoverable&quot; )#undef __BIONIC_ERRDEF UE 项目启动参数 看了一下引擎里的代码，在 Launch 模块下 Launch\\Private\\Android\\LaunchAndroid.cpp 中有 InitCommandLine 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Launch\\Private\\Android\\LaunchAndroid.cppstatic void InitCommandLine()&#123; static const uint32 CMD_LINE_MAX = 16384u; // initialize the command line to an empty string FCommandLine::Set(TEXT(&quot;&quot;)); AAssetManager* AssetMgr = AndroidThunkCpp_GetAssetManager(); AAsset* asset = AAssetManager_open(AssetMgr, TCHAR_TO_UTF8(TEXT(&quot;UE4CommandLine.txt&quot;)), AASSET_MODE_BUFFER); if (nullptr != asset) &#123; const void* FileContents = AAsset_getBuffer(asset); int32 FileLength = AAsset_getLength(asset); char CommandLine[CMD_LINE_MAX]; FileLength = (FileLength &lt; CMD_LINE_MAX - 1) ? FileLength : CMD_LINE_MAX - 1; memcpy(CommandLine, FileContents, FileLength); CommandLine[FileLength] = &#x27;\\0&#x27;; AAsset_close(asset); // chop off trailing spaces while (*CommandLine &amp;&amp; isspace(CommandLine[strlen(CommandLine) - 1])) &#123; CommandLine[strlen(CommandLine) - 1] = 0; &#125; FCommandLine::Append(UTF8_TO_TCHAR(CommandLine)); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;APK Commandline: %s&quot;), FCommandLine::Get()); &#125; // read in the command line text file from the sdcard if it exists FString CommandLineFilePath = GFilePathBase + FString(&quot;/UE4Game/&quot;) + (!FApp::IsProjectNameEmpty() ? FApp::GetProjectName() : FPlatformProcess::ExecutableName()) + FString(&quot;/UE4CommandLine.txt&quot;); FILE* CommandLineFile = fopen(TCHAR_TO_UTF8(*CommandLineFilePath), &quot;r&quot;); if(CommandLineFile == NULL) &#123; // if that failed, try the lowercase version CommandLineFilePath = CommandLineFilePath.Replace(TEXT(&quot;UE4CommandLine.txt&quot;), TEXT(&quot;ue4commandline.txt&quot;)); CommandLineFile = fopen(TCHAR_TO_UTF8(*CommandLineFilePath), &quot;r&quot;); &#125; if(CommandLineFile) &#123; char CommandLine[CMD_LINE_MAX]; fgets(CommandLine, ARRAY_COUNT(CommandLine) - 1, CommandLineFile); fclose(CommandLineFile); // chop off trailing spaces while (*CommandLine &amp;&amp; isspace(CommandLine[strlen(CommandLine) - 1])) &#123; CommandLine[strlen(CommandLine) - 1] = 0; &#125; // initialize the command line to an empty string FCommandLine::Set(TEXT(&quot;&quot;)); FCommandLine::Append(UTF8_TO_TCHAR(CommandLine)); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Override Commandline: %s&quot;), FCommandLine::Get()); &#125;#if !UE_BUILD_SHIPPING if (FString* ConfigRulesCmdLineAppend = FAndroidMisc::GetConfigRulesVariable(TEXT(&quot;cmdline&quot;))) &#123; FCommandLine::Append(**ConfigRulesCmdLineAppend); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;ConfigRules appended: %s&quot;), **ConfigRulesCmdLineAppend); &#125;#endif&#125; 简单来说就是在 UE4Game/ProjectName/ue4commandline.txt 中把启动参数写到里面，引擎启动的时候会从这个文件去读，然后添加到 FCommandLine 中。 Android 设置宽高比 在Project Settings-Platforms-Android-Maximum support aspect ratio的值，默认是 2.1，但是在全面屏的情况下会有黑边。 它控制的值是 AndroidManifest.xml 中的值： 1&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot;/&gt; 我目前设置的值是 2.5. 注：Enable FullScreen Immersive on KitKat and above devices控制的是进入游戏时是否隐藏虚拟按键。","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"app:assembleDebug 报错","date":"2020-09-01T22:32:01.000Z","path":"wiki/6eed44f8/","text":"打包 Android 时的错误信息： 1UATHelper: Packaging (Android…) ERROR: cmd.exe failed with args /c “[ProjectPath]\\Intermediate/Android/APK/gradle/rungradle.bat” :app:assembleDebug 将下面选项取消勾选即可： 在 4.24+ 中没有了 Enable Gradle instead of Ant 选项，仔细看了下 log 发现是因为 UE 要从网络上下载 Grade 下载失败导致的，可以在打包时开启全局代理。或者使用我打包的 gradle 版本：gradle-5.4.1.7z，将其解压到以下路径即可： 1C:\\Users\\lipengzha\\.gradle\\wrapper\\dists\\gradle-5.4.1-all\\3221gyojl5jsh0helicew7rwx\\gradle-5.4.1 然后创建一个环境变量 ANDROID_HOME 指向该路径即可。 还有一些相关的文章，可以更新 Android Tools，操作方法为： run NVPACK/android-sdk-windows/tools/android.bat click on “Deselect All” update Extras/Android Support Repository 文章： Android packaging build fail - UE 4.18","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"引擎的环境依赖与 NDK 支持","date":"2020-09-01T22:32:01.000Z","path":"wiki/38594c17/","text":"引擎对 Android 版本的支持 在之前的笔记里：Android SDK 版本与 Android 的版本 列出了 Android 系统版本和 API Leve 版本之间的对照表。 但是 UE 不同的引擎版本对 Android 的系统支持也是不一样的，在 Project Setting-Android 中的 Minimum SDK Version 中可以设置最小的 SDK 版本，也就是 UE 打包 Android 所支持的最低系统版本。 在 UE4.25 中，最低可以设置 Level 为 19，即 Android4.4，在 4.25 之前的引擎版本最低支持 Level 9，也就是 Android 2.3。 这部分的代码可以在 Runtime/Android/AndroidRuntimeSettings/Classes/AndroidRuntimeSettings.h 中查看，并对比不同引擎版本的区别。 SDK 版本与 Android 的版本对照表 可以在 Google 的开发者站点看到：Android SDK PlatformBuild.VERSION_CODES 的含义：Build.VERSION_CODES AndroidVersion SDK Version Build.VERSION_CODES Android 11 (API level 30) R Android 10 (API level 29) Q Android 9 (API level 28) P Android 8.1 (API level27) O_MR1 Android 8.0 (API level 26) O Android 7.1 (API level 25) N_MR1 Android 7.0 (API level 24) N Android 6.0 (API level 23) M Android 5.1 (API level 22) LOLLIPOP_MR1 Android 5.0 (API level 21) LOLLIPOP Android 4.4W (API level 20) KITKAT_WATCH Android 4.4 (API level 19) KITKAT Android 4.3 (API level 18) JELLY_BEAN_MR2 Android 4.2 (API level 17) JELLY_BEAN_MR1 Android 4.1 (API level 16) JELLY_BEAN Android 4.0.3 (API level15) ICE_CREAM_SANDWICH_MR1 Android 4.0 (API level 14) ICE_CREAM_SANDWICH Android 3.2 (API level 13) HONEYCOMB_MR2 Android 3.1 (API level 12) HONEYCOMB_MR1 Android 3.0 (API level 11) HONEYCOMB Android 2.3.3 (API level 10) GINGERBREAD_MR1 Android 2.3 (API level 9) GINGERBREAD UE4 对 Android 的最低支持是 SDK9，也就是 Android2.3。 引擎对 AndroidNDK 的要求UE 在打包 Android 的时候会要求系统中具有 NDK 环境，但是不同的引擎版本对 NDK 的版本要求也不一样。 当使用不支持的 NDK 版本时，打包会有如下错误： 12UATHelper: Packaging (Android (ETC2)): ERROR: Android toolchain NDK r14b not supported; please use NDK r21 to NDK r23 (NDK r21b recommended)PackagingResults: Error: Android toolchain NDK r14b not supported; please use NDK r21 to NDK r23 (NDK r21b recommended) 提示当前系统中的 NDK 版本不支持，并会显示支持的版本。 UE 打包时对 NDK 版本的检测是在 UBT 中执行的，具体文件为UnrealBuildTool/Platform/Android/AndroidToolChain.cs。 其中定义了当前引擎版本支持的 NDK 的最低和最高版本： 1234// in ue 4.25readonly int MinimumNDKToolchain = 210100;readonly int MaximumNDKToolchain = 230100;readonly int RecommendedNDKToolchain = 210200; 可以在 Github 上比较方便地查看不同引擎版本要求的 NDK 版本:UE_425_AndroidToolChain.cs 不同的引擎版本对 NDK 的要求 UE 文档中也有介绍：Setting Up Android SDK and NDK for Unreal Unreal Engine NDK Version 4.25+ NDK r21b, NDK r20b 4.21 - 4.24 NDK r14b 4.19 - 4.20 NDK r12b NDK 的编译器版本 UE4 支持r14b-r18b 的 Android NDK，但是我在 UE4.22.3 中设置 r18b 被引擎识别为r18c: 12345678910UATHelper: Packaging (Android (ETC2)): Using &#x27;git status&#x27; to determine working set for adaptive non-unity build (C:\\Users\\imzlp\\Documents\\Unreal Projects\\GWorldClient).UATHelper: Packaging (Android (ETC2)): ERROR: Android toolchain NDK r18c not supported; please use NDK r14b to NDK r18b (NDK r14b recommended)PackagingResults: Error: Android toolchain NDK r18c not supported; please use NDK r14b to NDK r18b (NDK r14b recommended)UATHelper: Packaging (Android (ETC2)): Took 7.4575476s to run UnrealBuildTool.exe, ExitCode=5UATHelper: Packaging (Android (ETC2)): ERROR: UnrealBuildTool failed. See log for more details. (C:\\Users\\imzlp\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.22\\UBT-GWorld-Android-Development.txt)UATHelper: Packaging (Android (ETC2)): (see C:\\Users\\imzlp\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.22\\Log.txt for full exception trace)PackagingResults: Error: UnrealBuildTool failed. See log for more details. (C:\\Users\\imzlp\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.22\\UBT-GWorld-Android-Development.txt)UATHelper: Packaging (Android (ETC2)): AutomationTool exiting with ExitCode=5 (5)UATHelper: Packaging (Android (ETC2)): BUILD FAILEDPackagingResults: Error: Unknown Error 之所以要换 NDK 的版本是因为不同的 NDK 版本所包含的编译器对 C++11 标准支持度不同。 NDK clang version r14b clang 3.8.275480 (based on LLVM 3.8.275480) r17c clang version 6.0.2 r18b clang version 7.0.2 r20b clang version 8.0.7","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"测试 iOS 包的常见问题","date":"2020-09-01T22:32:01.000Z","path":"wiki/28decf0e/","text":"iOS UE4App 的数据目录 访问 iOS 程序的文稿目录需要 App 开启文件共享 (File Sharing)，需要在 UE 的Project Settings-Platform-IOS-File System 里开启： 这样打包之后才可以访问应用程序的文稿目录。 可以使用 iMaZing 这个工具来访问 ios App 的文稿目录，可以创建文件夹、拷贝文件等等，还是比较方便的。 UE 在 Win 和 Android 平台都有这样的目录结构： 123456789+---Engine| +---Content\\---FGame +---Content | +---Movies | \\---Paks \\---Saved +---Logs \\---Paks 在 Win 上是相对于打包目录，在 Android 上默认是 &lt;Sdcard&gt;/UE4Game/PROJECT_NAME/ 的。 而在 iOS 上这个结构是相对于 App 的文稿目录的（这几个文件夹都是我手动创建的，Shipping 时也没有 log）： 如果想要 mount pak 就按照这个目录结构把 pak 放到相关目录即可，在程序中就可以通过 FPaths 的 API 来访问了。 在 Windows 上查看 iOS 设备 logAndorid 的设备可以使用 adb logcat 来捕获 log，在想要看 iOS 的 log 却十分麻烦，还要 Mac。 但是经过一番查找，找到了一个工具，可以在 Windows 上实时地查看当前设备 log：IOSLogInfo 下载之后解压，执行 sdsiosloginfo.exe 就可以看到类似 logcat 的日志输出了，如果装了 Git bash 环境也可以使用 | 来进行过滤。 UE 项目在 MAC 上的 Log 位置 MacOS 上打开 UE 项目的 Log 位置为~/Library/Logs/Unreal Engine/ProjectName，Locating Project Logs 相关链接 UE4 移动设备开发指南 Building for iOS on Windows ios 上类似 logcat 的工具iOS Console","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"部署 Windows 远程构建 iOS","date":"2020-09-01T22:32:01.000Z","path":"wiki/df679169/","text":"UE 可以在 Windows 可以直接出 Android 和 Win 的包（Android 需要配置 JDK/SDK/NDK/Gradle 等环境）。打包 iOS 则需要一台 Mac，如果是每次打包 iOS 都要在 Mac 上进行操作，其实就是与 Win 上完全相同的操作，但是流程上不能复用就显得很繁琐，尤其是在修改了引擎的情况下，需要先更新引擎代码并编译，然后再更新项目、执行打包。好在 UE 提供了远程构建 iOS，可以把 Win/Android/iOS 三端的包在相同的构建流程里出完。 前置需求： 内网搭载 MacOS 的电脑一台（白黑都可） 申请 p12 证书和 mobileprovision PC 和 Mac 需要在网络内可以相互访问（在相同网段） IOS 证书申请 打包 iOS 之前需要申请 iOS 的开发者账号来创建证书，可以在 developer.apple.com 申请。需要得到 p12 证书和 mobileprovision，然后在 UE 的项目设置中导入它们。需要注意创建的证书是 Developer 还是 Distribution 证书，在出包的时候要匹配，否则会打包失败。 申请证书的流程网上有很多文章，我这里是简单记录了下我申请证书的流程，步骤不是最详细的，仅供参考。 首先在 Mac 上导出一个证书：打开软件 钥匙串访问 - 证书助理 - 从证书颁发机构请求证书 ： 选择存储到磁盘，会生成一个 CertificateSigningRequest.certSigningRequest 的文件。然后登录Apple Developer，进入Account-Certificates： 进去之后创建 Apple Development 或者 iOS App Development，创建过程中需要把上面生成的CertificateSigningRequest.certSigningRequest 文件上传。 添加设备： 可以使用 UE 的 IPhonePackager.exe 来查看 ios 设备的 uuid： 生成 Provision： 生成之后要下载 provision 文件： 配置远程构建 UE 打包 iOS 需要在项目设置中导入证书和provision，以及把BundleName 和Bundle Identifier设置为在 Apple 开发者网站上设置的 Bundle ID，格式为com.xxxxx.yyyyyy。 p12 证书和 mobileprovision 导入之后如图： 导入证书之后就可以开始远程打包的配置了。 首先在 MAC 的 系统偏好设置 - 共享 中启用远程登录： 然后在 Windows 上对项目添导入 mobileproversion 和设置 BundleName 和Bundle Identifier。之后继续往下拉找到 IOS-Build 下的 Remote Build Options: 填入目标 MAC 机器的 IP 地址（如果不指定端口则默认为 22，如果指定端口则使用 xx.xx.xx.xx:2222 这种形式，以冒号分隔）和用户名。 然后点击 Generated SSH Key 会弹出一个窗口：按任意键继续。会提示你输入一个密码，按照提示输入，之后会提示你输入 MAC 电脑的密码，输入之后会提示： 1Enter passphrase (empty for no passphrase): 这是让你输入生成的 ssh Key 的密码，默认情况下可以不输，直接 Enter 就好。按照提示一直 Enter 会提示你 ssh key 生成成功：再继续会提示让你输入第一次设置的密码，和目标 MAC 机器的密码，执行完毕之后就会提示没有错误，就 ok 了： 生成的 SSH Key 的存放路径为： 1C:\\Users\\imzlp\\AppData\\Roaming/Unreal Engine/UnrealBuildTool/SSHKeys/192.168.2.89/imzlp/RemoteToolChainPrivate.key 如果要将其共享给组内的其他成员，则把这个 RemoteToolChainPrivate.key 共享，然后让他们把 IOS-Build-RemoteBuildOptions 下的 Override existing SSH Permissions file 设置为 RemoteToolChainPrivate.key 的路径即可。 之后就可以像打包 Windows 或者在 Win 上打包 IOS 一样了： 远程到 Mac 打包分了几个阶段： 把本机的引擎和工程代码上传至 Mac 在 Mac 上执行编译 编译完毕之后在 Mac 上生成 ipa 包（但不包含 Cook 资源） 把生成的 ipa 包拉回本地，解包，Cook 美术资源，再合并为 ipa 其中第一步，把本机引擎和工程的代码上传至 Mac 是通过 rsync 来实现的，引擎中的 Engine\\Build\\Rsync 目录下包含了远程构建时需要上传至目标机器的过滤器。对于项目，可以在工程目录的 &lt;ProjectDir&gt;/Build/Rsync/RsyncProject.txt 创建该文件，添加自己想要上传至 Mac 的文件过滤器，可以解决执行远程打包时有些文件被遗漏掉的问题。UE 上传时默认使用的 RsyncProject.txt 过滤器有引擎和项目目录的，具体的代码看：UnrealBuildTool/ToolChain/RemoteMac.cs#L927 Building for iOS on Windows WWise 常见问题解答 iOS 打包证书配置报错问题 在 UE 的项目设置中添加 Provision 和Certificate，Bundle Identifier要和证书能对应上，但是在设置完之后选择打包还是会提示以下错误： 12Provision not found. A provision is required for deploying your app to the device. Signing key not found. The app could not be digitally signed, because the signing key is not configured. 配置完证书和 Provision 之后出现这种情况需要检查下证书是 开发 (Development) 还是 发行 (Distribution)，默认情况下项目设置中是不勾选 发行 (Distribution) 的，如果导入的证书是发行证书则 只能打包 Shipping并且 ** 需要勾上发行(Distribution)**。 如果使用发行证书不勾选 ** 发行(For Distribution)** 则打包时会有以下错误： 123Check dependenciesCode Signing Error: Provisioning profile &quot;com.tencent.tmgp.zyhx_Production_SignProvision&quot; doesn&#x27;t match the entitlements file&#x27;s value for the get-task-allow entitlement.Code Signing Error: Code signing is required for product type &#x27;Application&#x27; in SDK &#x27;iOS 13.6&#x27; SSHKey 路径查找的 bug前面提到了在 Project Settings-Platforms-iOS 中可以在 Override Existing SSH Permissions file 中指定 SSHKey，如果不指定会默认使用引擎查找路径，默认情况下会从以下路径中查找： 12345678910const FString DefaultKeyFilename = TEXT(&quot;RemoteToolChainPrivate.key&quot;);const FString RelativeFilePathLocation = FPaths::Combine(TEXT(&quot;SSHKeys&quot;), *RemoteServerName, *RSyncUsername, *DefaultKeyFilename);TArray&lt;FString&gt; PossibleKeyLocations;PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NotForLicensees&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NoRedist&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NotForLicensees&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NoRedist&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), *RelativeFilePathLocation));PossibleKeyLocations.Add(FPaths::Combine(*Path, TEXT(&quot;Unreal Engine&quot;), TEXT(&quot;UnrealBuildTool&quot;), *RelativeFilePathLocation)); 但是在 RemoveServerName 包含端口的情况下，希望使用引擎查找路径时，UE 的实现有 Bug。 123456789101112131415161718192021222324252627282930313233343536void UIOSRuntimeSettings::PostInitProperties()&#123; Super::PostInitProperties(); // We can have a look for potential keys if (!RemoteServerName.IsEmpty() &amp;&amp; !RSyncUsername.IsEmpty()) &#123; SSHPrivateKeyLocation = TEXT(&quot;&quot;); const FString DefaultKeyFilename = TEXT(&quot;RemoteToolChainPrivate.key&quot;); const FString RelativeFilePathLocation = FPaths::Combine(TEXT(&quot;SSHKeys&quot;), *RemoteServerName, *RSyncUsername, *DefaultKeyFilename); FString Path = FPlatformMisc::GetEnvironmentVariable(TEXT(&quot;APPDATA&quot;)); TArray&lt;FString&gt; PossibleKeyLocations; PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NotForLicensees&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NoRedist&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*FPaths::ProjectDir(), TEXT(&quot;Build&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NotForLicensees&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), TEXT(&quot;NoRedist&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*FPaths::EngineDir(), TEXT(&quot;Build&quot;), *RelativeFilePathLocation)); PossibleKeyLocations.Add(FPaths::Combine(*Path, TEXT(&quot;Unreal Engine&quot;), TEXT(&quot;UnrealBuildTool&quot;), *RelativeFilePathLocation)); // Find a potential path that we will use if the user hasn&#x27;t overridden. // For information purposes only for (const FString&amp; NextLocation : PossibleKeyLocations) &#123; if (IFileManager::Get().FileSize(*NextLocation) &gt; 0) &#123; SSHPrivateKeyLocation = NextLocation; break; &#125; &#125; &#125; // ...&#125; 这个代码在 Windows 上有 bug，因为当 RemoteServerName 具有指定端口时，在 Windows 上就会找不到 SSHKey，因为 Windows 上路径中不能包含冒号，所以在查找 Key 路径的时候会有问题，这个问题需要修改引擎才能解决。修改上面的代码： 123456789SSHPrivateKeyLocation = TEXT(&quot;&quot;);FString RealRemoteServerName = RemoteServerName;if(RemoteServerName.Contains(TEXT(&quot;:&quot;)))&#123; FString RemoteServerPort; RemoteServerName.Split(TEXT(&quot;:&quot;),&amp;RealRemoteServerName,&amp;RemoteServerPort);&#125;const FString DefaultKeyFilename = TEXT(&quot;RemoteToolChainPrivate.key&quot;);const FString RelativeFilePathLocation = FPaths::Combine(TEXT(&quot;SSHKeys&quot;), *RealRemoteServerName, *RSyncUsername, *DefaultKeyFilename); 重新编译引擎即可。 远程编译 Shader 的 Key 查找 bug 注意：在 4.26 及之后的引擎版本支持在 Windows 上编译 metal 的 Shader 了，详情见文档：Using the Windows Metal Shader Compiler for iOS。 在 Project Settings-Platforms-IOS 中开启 Enable Remote Shader Compile 后，如果填入的构建机地址具有指定端口，在查找 SSHkey 时会有问题： 1234567891011121314151617181920212223242526272829// Developer/Apple/MetalShaderFormat/Private/MetalShaderCompiler.cppbool IsRemoteBuildingConfigured(const FShaderCompilerEnvironment* InEnvironment)&#123; // ... GRemoteBuildServerSSHKey = &quot;&quot;; if (InEnvironment != nullptr &amp;&amp; InEnvironment-&gt;RemoteServerData.Contains(TEXT(&quot;SSHPrivateKeyOverridePath&quot;))) &#123; GRemoteBuildServerSSHKey = InEnvironment-&gt;RemoteServerData[TEXT(&quot;SSHPrivateKeyOverridePath&quot;)]; &#125; if (GRemoteBuildServerSSHKey.Len() == 0) &#123; GConfig-&gt;GetString(TEXT(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;), TEXT(&quot;SSHPrivateKeyOverridePath&quot;), GRemoteBuildServerSSHKey, GEngineIni); GConfig-&gt;GetString(TEXT(&quot;/Script/IOSRuntimeSettings.IOSRuntimeSettings&quot;), TEXT(&quot;SSHPrivateKeyOverridePath&quot;), GRemoteBuildServerSSHKey, GEngineIni); if (GRemoteBuildServerSSHKey.Len() == 0) &#123; if (!FParse::Value(FCommandLine::Get(), TEXT(&quot;serverkey&quot;), GRemoteBuildServerSSHKey) &amp;&amp; GRemoteBuildServerSSHKey.Len() == 0) &#123; if (GRemoteBuildServerSSHKey.Len() == 0) &#123; // RemoteToolChain.cs in UBT looks in a few more places but the code in FIOSTargetSettingsCustomization::OnGenerateSSHKey() only puts the key in this location so just going with that to keep things simple FString Path = FPlatformMisc::GetEnvironmentVariable(TEXT(&quot;APPDATA&quot;)); GRemoteBuildServerSSHKey = FString::Printf(TEXT(&quot;%s\\\\Unreal Engine\\\\UnrealBuildTool\\\\SSHKeys\\\\%s\\\\%s\\\\RemoteToolChainPrivate.key&quot;), *Path, *GRemoteBuildServerHost, *GRemoteBuildServerUser); &#125; &#125; &#125; &#125; // ... &#125; 可以看到这里查找的 Key 路径时直接通过 GRemoteBuildServerHost 拼接的，但是如果在配置中指定了端口，那么 GRemoteBuildServerHost 的值为这种格式xxx.xx.xx.xx:1234，但是 Win 上目录名不能带:，就会导致 Key 查找失败。 还有在同文件的 ExecRemoteProcess 函数中，没有针对具有指定端口的情况做处理： 1234567891011121314bool ExecRemoteProcess(const TCHAR* Command, const TCHAR* Params, int32* OutReturnCode, FString* OutStdOut, FString* OutStdErr)&#123;#if PLATFORM_MAC &amp;&amp; !UNIXLIKE_TO_MAC_REMOTE_BUILDING return FPlatformProcess::ExecProcess(Command, Params, OutReturnCode, OutStdOut, OutStdErr);#else if (GRemoteBuildServerHost.IsEmpty()) &#123; return false; &#125; FString CmdLine = FString(TEXT(&quot;-i \\&quot;&quot;)) + GRemoteBuildServerSSHKey + TEXT(&quot;\\&quot; \\&quot;&quot;) + GRemoteBuildServerUser + &#x27;@&#x27; + GRemoteBuildServerHost + TEXT(&quot;\\&quot; &quot;) + Command + TEXT(&quot; &quot;) + (Params != nullptr ? Params : TEXT(&quot;&quot;)); return ExecProcess(*GSSHPath, *CmdLine, OutReturnCode, OutStdOut, OutStdErr);#endif&#125; 需要做一些处理： 1234567891011121314151617181920212223bool ExecRemoteProcess(const TCHAR* Command, const TCHAR* Params, int32* OutReturnCode, FString* OutStdOut, FString* OutStdErr)&#123;#if PLATFORM_MAC &amp;&amp; !UNIXLIKE_TO_MAC_REMOTE_BUILDING return FPlatformProcess::ExecProcess(Command, Params, OutReturnCode, OutStdOut, OutStdErr);#else if (GRemoteBuildServerHost.IsEmpty()) &#123; return false; &#125; FString RemoteBuildServerIP = GRemoteBuildServerHost; FString RemoteBuildServerPort = TEXT(&quot;22&quot;); if(GRemoteBuildServerHost.Contains(TEXT(&quot;:&quot;))) &#123; GRemoteBuildServerHost.Split(TEXT(&quot;:&quot;),&amp;RemoteBuildServerIP,&amp;RemoteBuildServerPort); &#125; FString CmdLine = FString(TEXT(&quot;-i \\&quot;&quot;)) + GRemoteBuildServerSSHKey + TEXT(&quot;\\&quot; \\&quot;&quot;) + GRemoteBuildServerUser + &#x27;@&#x27; + RemoteBuildServerIP + TEXT(&quot;\\&quot; &quot;) TEXT(&quot;-p &quot;) + RemoteBuildServerPort +TEXT(&quot; &quot;)+ Command + TEXT(&quot; &quot;) + (Params != nullptr ? Params : TEXT(&quot;&quot;)); return ExecProcess(*GSSHPath, *CmdLine, OutReturnCode, OutStdOut, OutStdErr);#endif&#125;","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"远程构建","slug":"远程构建","permalink":"https://ue5wiki.com/tags/%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA/"},{"name":"Mac","slug":"Mac","permalink":"https://ue5wiki.com/tags/Mac/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"}]},{"title":"UPL for Android","date":"2020-09-01T22:32:01.000Z","path":"wiki/d03bb27/","text":"在 UE 中为移动端添加第三方模块或者修改配置文件时经常会用到 AdditionalPropertiesForReceipt，里面创建ReceiptProperty 传入的 xml 文件就是 UE 的 Unreal Plugin Language 脚本。 ReceiptProperty的平台名称在 IOS 和 Android 上是固定的，分别是 IOSPlugin 和AndroidPlugin，不可以指定其他的名字（详见代码 UEDeployIOS.cs#L1153 和UEDeployAndroid.cs#L4303）。 1AdditionalPropertiesForReceipt.Add(new ReceiptProperty(&quot;AndroidPlugin&quot;, Path.Combine(ThirdPartyPath, &quot;Android/PlatformUtils_UPL_Android.xml&quot;))); Unreal Plugin Language 虚幻插件语言参考(Android 版) Engine/Source/Programs/UnrealBuildTool/System/UnrealPluginLanguage.cs Android 项目中所有的 UPL可以在项目路径下Intermediate/Android/ActiveUPL.xml，里面列出了当前项目中所有的 UPL 文件路径： 1234567Plugins\\Online\\Android\\OnlineSubsystemGooglePlay\\Source\\OnlineSubsystemGooglePlay_UPL.xmlPlugins\\Runtime\\AndroidPermission\\Source\\AndroidPermission\\AndroidPermission_APL.xmlPlugins\\Runtime\\GoogleCloudMessaging\\Source\\GoogleCloudMessaging\\GoogleCloudMessaging_UPL.xmlPlugins\\Runtime\\GooglePAD\\Source\\GooglePAD\\GooglePAD_APL.xmlPlugins\\Runtime\\Oculus\\OculusVR\\Source\\OculusHMD\\OculusMobile_APL.xmlSource\\Runtime\\Online\\Voice\\AndroidVoiceImpl_UPL.xmlSource\\ThirdParty\\GoogleGameSDK\\GoogleGameSDK_APL.xml 删除 AndroidManifest.xml 中的项 因为 UE 默认会给 AndroidManifest.xml 添加项，如果其中的项我们想要手动控制，直接添加的话会产生错误，提示已经存在： 1234567891011121314151617181920212223242526272829UATHelper: Packaging (Android (ASTC)): &gt; Task :app:processDebugManifest FAILEDUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): Z:\\app\\src\\main\\AndroidManifest.xml:47:5-106 Error:UATHelper: Packaging (Android (ASTC)): Element meta-data#com.epicgames.ue4.GameActivity.bUseExternalFilesDir at AndroidManifest.xml:47:5-106 duplicated with element declared at AndroidManifest.xml:27:5-107UATHelper: Packaging (Android (ASTC)): Z:\\app\\src\\main\\AndroidManifest.xml Error:UATHelper: Packaging (Android (ASTC)): Validation failed, exitingUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): FAILURE: Build failed with an exception.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * What went wrong:UATHelper: Packaging (Android (ASTC)): Execution failed for task &#x27;:app:processDebugManifest&#x27;.UATHelper: Packaging (Android (ASTC)): &gt; Manifest merger failed with multiple errors, see logsUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): See http://g.co/androidstudio/manifest-merger for more information about the manifest merger.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * Try:UATHelper: Packaging (Android (ASTC)): Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * Get more help at https://help.gradle.orgUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): BUILD FAILED in 10sUATHelper: Packaging (Android (ASTC)): 189 actionable tasks: 1 executed, 188 up-to-dateUATHelper: Packaging (Android (ASTC)): ERROR: cmd.exe failed with args /c &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\GCloudExample\\Intermediate\\Android\\armv7\\gradle\\rungradle.bat&quot; :app:assembleDebugPackagingResults: Error: cmd.exe failed with args /c &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\GCloudExample\\Intermediate\\Android\\armv7\\gradle\\rungradle.bat&quot; :app:assembleDebugUATHelper: Packaging (Android (ASTC)): Took 13.3060694s to run UnrealBuildTool.exe, ExitCode=6UATHelper: Packaging (Android (ASTC)): UnrealBuildTool failed. See log for more details. (C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.25\\UBT-.txt)UATHelper: Packaging (Android (ASTC)): AutomationTool exiting with ExitCode=6 (6)UATHelper: Packaging (Android (ASTC)): BUILD FAILEDPackagingResults: Error: Unknown Error 如果想要修改或者删除 UE 默认生成的 AndroidManifest.xml 中的项，可以通过先删除再添加的方式。 以删除以下项为例: 1&lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;false&quot; /&gt; 在 UPL 的 androidManifestUpdates 中编写以下代码： 1234567891011&lt;androidManifestUpdates&gt; &lt;loopElements tag=&quot;meta-data&quot;&gt; &lt;setStringFromAttribute result=&quot;ApplicationSectionName&quot; tag=&quot;$&quot; name=&quot;android:name&quot;/&gt; &lt;setBoolIsEqual result=&quot;bUseExternalFilesDir&quot; arg1=&quot;$S(ApplicationSectionName)&quot; arg2=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot;/&gt; &lt;if condition=&quot;bUseExternalFilesDir&quot;&gt; &lt;true&gt; &lt;removeElement tag=&quot;$&quot;/&gt; &lt;/true&gt; &lt;/if&gt; &lt;/loopElements&gt;&lt;/androidManifestUpdates&gt; 就是去遍历 AndroidManfest.xml 中已经存在 meta-data 中，android:name为 com.epicgames.ue4.GameActivity.bUseExternalFilesDir 的项给删除。 JNI 调用接收 ActivityResult有时需要通过 startActivityForResult 来创建 Intent 来执行一些操作，如打开摄像头、打开相册选择图片等。 但是 Android 做这些操作的时候不是阻塞在当前的函数中的，所以不能直接在调用的函数里接收这些数据。而通过 startActivityForResult 执行的 Action 的结果都会调用到 Activity 的 onActivityResult 中。 123// GameActivity.java@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123;&#125; UE 在 UPL 中提供了往 OnActivityResult 追加 Java 代码的用法： 12&lt;!-- optional additions to GameActivity onActivityResult in GameActivity.java --&gt;&lt;gameActivityOnActivityResultAdditions&gt; &lt;/gameActivityOnActivityResultAdditions&gt; 使用这种方式添加的 Java 代码会追加到 OnActivityResult 函数的末尾，但是这种方式有一个问题，那就是执行了自己追加到 OnActivityResult 的代码之后，还要处理接收到的结果，并且传递到 UE 端来，有点麻烦。 经过翻阅代码，发现 UE 提供了 Java 端的 OnActivityResult 的多播代理事件，这样就可以直接在 UE 里用 C++ 来监听 OnActivityResult 的事件，自己做处理。 123456// Launch/Puclic/Android/AndroidJNI.hDECLARE_MULTICAST_DELEGATE_SixParams(FOnActivityResult, JNIEnv *, jobject, jobject, jint, jint, jobject);// 该代理是定义在 `FJavaWrapper` 里的// Delegate that can be registered to that is called when an activity is finishedstatic FOnActivityResult OnActivityResultDelegate; 在 UE 侧就可以通过绑定这个多播代理来监听 Java 端的 OnActivityResult 调用，可以在其中做分别的处理。 它由 AndroidJNI.cpp 中的 Java_com_epicgames_ue4_GameActivity_nativeOnActivityResult 函数从 Java 那边调用过来，调用机制在上个笔记中有记录。 Java 调 C++有些需求和实现需要从 Java 调到 C++ 这边，可以通过下面这种方式：首先，在 GameActivity 中新建一个 native 的 java 函数声明（不需要定义）： 1public native void nativeOnActivityResult(GameActivity activity, int requestCode, int resultCode, Intent data); 然后在 C++ 端按照下面的规则定义一个 C++ 函数： 1234JNI_METHOD void Java_com_epicgames_ue4_GameActivity_nativeOnActivityResult(JNIEnv* jenv, jobject thiz, jobject activity, jint requestCode, jint resultCode, jobject data)&#123; FJavaWrapper::OnActivityResultDelegate.Broadcast(jenv, thiz, activity, requestCode, resultCode, data);&#125; 可以看到函数名字的规则为： 函数前需要加 JNI_METHOD 修饰，它是一个宏__attribute__ ((visibility (&quot;default&quot;))) extern &quot;C&quot; 函数名需要以 Java_ 开头，并且后面跟上 com_epicgames_ue4_GameActivity_，标识是定义在GameActivity 中的 然后再跟上 java 中的函数名 接受参数的规则： 第一个参数是 Java 的 Env 第二个是 java 里的 this 后面的参数以此是从 java 里传递参数 AndroidP 的全面屏适配 在 UE4 打包的时候，会给项目生成 GameActivity.java 文件，里面的 OnCreate 具有适配全面屏的代码： 12345678910111213@Overridepublic void onCreate(Bundle savedInstanceState)&#123; // ... if (UseDisplayCutout) &#123; // will not be true if not Android Pie or later WindowManager.LayoutParams params = getWindow().getAttributes(); params.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; getWindow().setAttributes(params); &#125; // ...&#125; Android P 和之后的系统不支持，所以就要自己写 Jni 调用来强制让 P 和之后系统版本支持。在 UE4.23+ 以后的引擎版本，支持了通过 UPL 往 OnCreate 函数添加代码，就可以直接把代码插入到 GameActivity.java 了： 12345678910&lt;gameActivityOnCreateFinalAdditions&gt;&lt;insert&gt; // P 版本允许使用刘海 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; WindowManager.LayoutParams lp = this.getWindow().getAttributes(); lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; this.getWindow().setAttributes(lp); &#125;&lt;/insert&gt;&lt;/gameActivityOnCreateFinalAdditions&gt; 在 UE4.23 之前不可以给 OnCreate 添加代码，只能自己写个 JNI 调用： 1234567891011121314151617181920public void AndroidThunkJava_SetFullScreenDisplayForP()&#123; final GameActivity Activity = this; runOnUiThread(new Runnable() &#123; private GameActivity InActivity = Activity; public void run() &#123; WindowManager windowManager = InActivity.getWindowManager(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; WindowManager.LayoutParams lp = InActivity.getWindow().getAttributes(); lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; InActivity.getWindow().setAttributes(lp); Log.debug(&quot;call AndroidThunkJava_SetFullScreenDisplayForP&quot;); &#125; &#125; &#125;);&#125; 将其在 UPL 中通过 &lt;gameActivityClassAdditions&gt; 添加到 GameActivity.java 中，在游戏启动时通过 JNI 调用即可。 注： layoutInDisplayCutoutMode的可选项为： LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS(Added in API level 30)：始终允许窗口扩展到 DisplayCutout 屏幕所有边缘上的区域。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT(Added in API level 28)：仅当窗口完全包含在系统栏中时DisplayCutout，才允许该窗口扩展到该区域 DisplayCutout。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER(Added in API level 28)：永远不要让窗口与 DisplayCutout 区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES(Added in API level 28)：始终允许窗口扩展到 DisplayCutout 屏幕短边的区域。 外部资料 UE4.23 的更新日志 Android 重启 App当游戏更新完毕之后有时候需要重启 App 才可以生效，在 UE 中可以使用 UPL 写入以下 java 代码： 12345678910public void AndroidThunkJava_AndroidAPI_RestartApplication() &#123; Context context = getApplicationContext(); PackageManager pm = context.getPackageManager(); Intent intent = pm.getLaunchIntentForPackage(context.getPackageName()); int delayTime = 500; AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); PendingIntent restartIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT); alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + delayTime, restartIntent); System.exit(0);&#125; 在需要重启的时候通过 jni 调用来触发： 123456789void RestartApplication()&#123;#if PLATFORM_ANDROID if (JNIEnv* Env = FAndroidApplication::GetJavaEnv(true)) &#123; FJavaWrapper::CallVoidMethod(Env, FJavaWrapper::GameActivityThis, AndroidThunkJava_AndroidAPI_RestartApplication); &#125;#endif&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"UPL","slug":"UPL","permalink":"https://ue5wiki.com/tags/UPL/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"UPL","slug":"Mobile/UPL","permalink":"https://ue5wiki.com/categories/Mobile/UPL/"}]},{"title":"UPL 在 iOS 中的应用","date":"2020-09-01T22:32:01.000Z","path":"wiki/10d03e93/","text":"Unreal Plugin Language是 UE 提供的以 XML 语法为基础的语言，用来可以控制构建 Apk 以及 ipa 的过程，如实现修改 AndroidManifest.xml 或者 info.plist 等。 分析 plist 的生成流程 在UEDeployIOS.cs的 GeneratePList 函数中通过传入进来的 UPLScripts 来构造出 UPL 对象： 12345678910111213141516171819202122232425262728293031323334public virtual bool GeneratePList(FileReference ProjectFile, UnrealTargetConfiguration Config, string ProjectDirectory, bool bIsUE4Game, string GameName, bool bIsClient, string ProjectName, string InEngineDir, string AppDirectory, List&lt;string&gt; UPLScripts, VersionNumber SdkVersion, string BundleID, bool bBuildAsFramework, out bool bSupportsPortrait, out bool bSupportsLandscape, out bool bSkipIcons)&#123; // remember name with -IOS-Shipping, etc // string ExeName = GameName; // strip out the markup GameName = GameName.Split(&quot;-&quot;.ToCharArray())[0]; List&lt;string&gt; ProjectArches = new List&lt;string&gt;(); ProjectArches.Add(&quot;None&quot;); string BundlePath; // get the receipt if (bIsUE4Game) &#123; // ReceiptFilename = TargetReceipt.GetDefaultPath(UnrealBuildTool.EngineDirectory, &quot;UE4Game&quot;, UnrealTargetPlatform.IOS, Config, &quot;&quot;); BundlePath = Path.Combine(UnrealBuildTool.EngineDirectory.ToString(), &quot;Intermediate&quot;, &quot;IOS-Deploy&quot;, &quot;UE4Game&quot;, Config.ToString(), &quot;Payload&quot;, &quot;UE4Game.app&quot;); &#125; else &#123; // ReceiptFilename = TargetReceipt.GetDefaultPath(new DirectoryReference(ProjectDirectory), GameName, UnrealTargetPlatform.IOS, Config, &quot;&quot;); BundlePath = AppDirectory;//Path.Combine(ProjectDirectory, &quot;Binaries&quot;, &quot;IOS&quot;, &quot;Payload&quot;, ProjectName + &quot;.app&quot;); &#125; string RelativeEnginePath = UnrealBuildTool.EngineDirectory.MakeRelativeTo(DirectoryReference.GetCurrentDirectory()); UnrealPluginLanguage UPL = new UnrealPluginLanguage(ProjectFile, UPLScripts, ProjectArches, &quot;&quot;, &quot;&quot;, UnrealTargetPlatform.IOS); // Passing in true for distribution is not ideal here but given the way that ios packaging happens and this call chain it seems unavoidable for now, maybe there is a way to correctly pass it in that I can&#x27;t find? UPL.Init(ProjectArches, true, RelativeEnginePath, BundlePath, ProjectDirectory, Config.ToString(), false); return GenerateIOSPList(ProjectFile, Config, ProjectDirectory, bIsUE4Game, GameName, bIsClient, ProjectName, InEngineDir, AppDirectory, SdkVersion, UPL, BundleID, bBuildAsFramework, out bSupportsPortrait, out bSupportsLandscape, out bSkipIcons);&#125; 在最后调用的 GeneratedIOSList 中，构造出默认的 pliat 内容、从 Additional Plist Data 中读取的内容、以及调用 UPL 来处理 plist 的内容，UPL 的过程是最后处理的。 而且需要注意的是，在 GeneratedPList 函数中，通过 GeneratedIOSList 获取所有模块中添加的 UPL.xml 文件，然后把这些 xml 文件合并成一个，注意合并的顺序是 AdditionalProperties 的顺序，最后添加的 UPL 会放在最后执行，在一个项目中如果有多个使用 UPL 的操作要注意顺序问题。 介入 ipa 生成过程：操作 plistios 的 ipa 包中都会有 plist 文件，可以用来配置 app 的一些属性，apple 的开发者文档里对每个支持的 key 有详细的描述：iOS Keys UE 4.25.1 默认打包会产生下面这样一个 plist 文件：info.plist，在一些特殊的需求中，需要往这个 plist 中添加元素或者修改以及删除。 在 UE 的项目设置中，可以给 plist 添加元素，在 Project Settings-Platform-iOS-Additional Plist data 中可以填入一个字符串，它会被插入到 plist 文件中： 1&lt;key&gt;AdditionalElementAAA&lt;/key&gt;\\n&lt;string&gt;this key is a test element.&lt;/string&gt; 中间的 \\n 是格式化代码，用于另起一行。 如果想要修改或者删除 plist 的元素，需要通过 UPL 来写逻辑（当然也可以使用 UPL 来添加元素，建议使用这种做法）。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;init&gt; &lt;log text=&quot;UPL Exalpme adding element to plist...&quot;/&gt; &lt;/init&gt; &lt;trace enable=&quot;true&quot;/&gt; &lt;iosPListUpdates&gt; &lt;addElements tag=&quot;dict&quot; once=&quot;true&quot;&gt; &lt;key&gt;AdditionalElementAAA&lt;/key&gt; &lt;string&gt;this key is a test element.&lt;/string&gt; &lt;/addElements&gt; &lt;/iosPListUpdates&gt;&lt;/root&gt; 上面是用来添加元素的，上面的内容和直接写到 Additional Plist data 是一样的。 遍历 plist 中的 key： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;init&gt; &lt;log text=&quot;UPL Exalpme...&quot;/&gt; &lt;/init&gt; &lt;trace enable=&quot;true&quot;/&gt; &lt;iosPListUpdates&gt; &lt;loopElements tag=&quot;dict&quot;&gt; &lt;loopElements tag=&quot;$&quot;&gt; &lt;setStringFromTag result=&quot;TagName&quot; tag=&quot;$&quot;/&gt; &lt;setBoolIsEqual result=&quot;bIsKey&quot; arg1=&quot;$S(TagName)&quot; arg2=&quot;key&quot;/&gt; &lt;if condition=&quot;bIsKey&quot;&gt; &lt;true&gt; &lt;log text=&quot;$S(TagName):$S(TagValue)&quot;/&gt; &lt;/true&gt; &lt;/if&gt; &lt;/loopElements&gt; &lt;/loopElements&gt; &lt;/iosPListUpdates&gt;&lt;/root&gt; 注意：当前元素以 tag = &quot;$&quot; 方式引用。 编译时就会有以下 log： 12345678910111213141516171819202122232425262728293031323334353637383940UPL: /Users/buildmachine/UE4/Builds/lipengzha-PC1/C/BuildAgent/workspace/PackageFGameClient/FGame/Plugins/UPLExample/Source/UPLExample/ThirdParty/IOS/IOS_UPL.xmlUPL Init: NoneUPLExalpme adding element to plist...key : CFBundleURLTypeskey : CFBundleDevelopmentRegionkey : CFBundleDisplayNamekey : CFBundleExecutablekey : CFBundleIdentifierkey : CFBundleInfoDictionaryVersionkey : CFBundleNamekey : CFBundlePackageTypekey : CFBundleSignaturekey : CFBundleVersionkey : CFBundleShortVersionStringkey : LSRequiresIPhoneOSkey : UIStatusBarHiddenkey : UIFileSharingEnabledkey : UIRequiresFullScreenkey : UIViewControllerBasedStatusBarAppearancekey : UIInterfaceOrientationkey : UISupportedInterfaceOrientationskey : UIRequiredDeviceCapabilitieskey : CFBundleIconskey : CFBundleIcons~ipadkey : UILaunchStoryboardNamekey : CFBundleSupportedPlatformskey : MinimumOSVersionkey : ITSAppUsesNonExemptEncryptionkey : NSLocationAlwaysAndWhenInUseUsageDescriptionkey : NSLocationWhenInUseUsageDescriptionkey : CFBundleURLNamekey : CFBundleURLSchemeskey : CFBundlePrimaryIconkey : CFBundleIconFileskey : CFBundleIconNamekey : UIPrerenderedIconkey : CFBundlePrimaryIconkey : CFBundleIconFileskey : CFBundleIconNamekey : UIPrerenderedIcon 对于新增比较简单，但是对于删除和修改就比较麻烦了，需要遍历一遍所有的节点，然后根据匹配来删掉当前的元素（注意 plist 的是键值对的，一个 &lt;key&gt;&lt;/key&gt; 下面还对应着一个 value 元素，这两个都要删掉，不然会打包不过）： 12&lt;key&gt;BuildMachineOSBuild&lt;/key&gt;&lt;string&gt;19C57&lt;/string&gt; 我写了个方便删除 plist 中元素的流程，可以方便删除多组元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;init&gt; &lt;log text=&quot;UPLExalpme adding element to plist...&quot;/&gt; &lt;/init&gt; &lt;trace enable=&quot;true&quot;/&gt; &lt;iosPListUpdates&gt; &lt;addElements tag=&quot;dict&quot; once=&quot;true&quot;&gt; &lt;key&gt;AdditionalElementA&lt;/key&gt; &lt;string&gt;this key is a AdditionalElementA element.&lt;/string&gt; &lt;key&gt;AdditionalElementB&lt;/key&gt; &lt;string&gt;this key is a AdditionalElementB element.&lt;/string&gt; &lt;/addElements&gt; &lt;setString result=&quot;NeedDeleteKey_1&quot; value=&quot;AdditionalElementA&quot;/&gt; &lt;setString result=&quot;NeedDeleteKey_2&quot; value=&quot;AdditionalElementB&quot;/&gt; &lt;setInt result=&quot;loopSumNum&quot; value=&quot;2&quot;/&gt; &lt;setInt result=&quot;loopCount&quot; value=&quot;1&quot;/&gt; &lt;setBoolIsLessEqual result=&quot;loopRun&quot; arg1=&quot;$I(loopCount)&quot; arg2=&quot;$I(loopSumNum)&quot;/&gt; &lt;while condition=&quot;loopRun&quot;&gt; &lt;log text=&quot;count:$I(loopCount) SearchKey:$S(NeedDeleteKey_$I(loopCount))&quot;/&gt; &lt;setBool result=&quot;bIsDeleteElement&quot; value=&quot;false&quot;/&gt; &lt;loopElements tag=&quot;dict&quot;&gt; &lt;loopElements tag=&quot;$&quot;&gt; &lt;!-- delete value --&gt; &lt;if condition=&quot;bIsDeleteElement&quot;&gt; &lt;true&gt; &lt;setBool result=&quot;bIsDeleteElement&quot; value=&quot;false&quot;/&gt; &lt;log text=&quot;bIsDeleteElement is true!!!&quot;/&gt; &lt;setStringFromTag result=&quot;TagName&quot; tag=&quot;$&quot;/&gt; &lt;setStringFromTagText result=&quot;TagValue&quot; tag=&quot;$&quot;/&gt; &lt;log text=&quot;Delete element value,tagname:$S(TagName) value:$S(TagValue)&quot;/&gt; &lt;removeElement tag=&quot;$&quot; once=&quot;true&quot;/&gt; &lt;/true&gt; &lt;/if&gt; &lt;!-- delete key --&gt; &lt;setStringFromTag result=&quot;TagName&quot; tag=&quot;$&quot;/&gt; &lt;setBoolIsEqual result=&quot;bIsKey&quot; arg1=&quot;$S(TagName)&quot; arg2=&quot;key&quot;/&gt; &lt;if condition=&quot;bIsKey&quot;&gt; &lt;true&gt; &lt;setStringFromTagText result=&quot;TagValue&quot; tag=&quot;$&quot;/&gt; &lt;log text=&quot;tagname:$S(TagName) tagvalue:$S(TagValue)&quot;/&gt; &lt;setBoolIsEqual result=&quot;bIs_NeedDeleteKey_$I(loopCount)&quot; arg1=&quot;$S(TagValue)&quot; arg2=&quot;$S(NeedDeleteKey_$I(loopCount))&quot;/&gt; &lt;if condition=&quot;bIs_NeedDeleteKey_$I(loopCount)&quot;&gt; &lt;true&gt; &lt;log text=&quot;Match key $S(NeedDeleteKey_$I(loopCount)).&quot;/&gt; &lt;log text=&quot;Delete element key,tagname:$S(TagName) value:$S(TagValue).&quot;/&gt; &lt;removeElement tag=&quot;$&quot; once=&quot;true&quot;/&gt; &lt;setBool result=&quot;bIsDeleteElement&quot; value=&quot;true&quot;/&gt; &lt;/true&gt; &lt;/if&gt; &lt;/true&gt; &lt;/if&gt; &lt;/loopElements&gt; &lt;/loopElements&gt; &lt;!--control loop end--&gt; &lt;setIntAdd result=&quot;loopCount&quot; arg1=&quot;$I(loopCount)&quot; arg2=&quot;1&quot;/&gt; &lt;setBoolIsLessEqual result=&quot;loopRun&quot; arg1=&quot;$I(loopCount)&quot; arg2=&quot;$I(loopSumNum)&quot;/&gt; &lt;if condition=&quot;loopRun&quot;&gt; &lt;true&gt; &lt;log text=&quot;add loopCount to $I(loopCount)&quot;/&gt; &lt;/true&gt; &lt;false&gt; &lt;log text=&quot;the loop is finished!&quot;/&gt; &lt;/false&gt; &lt;/if&gt; &lt;/while&gt; &lt;/iosPListUpdates&gt;&lt;/root&gt; 脚本最开始 Add 了两个元素对，后面则是删除的代码，使用时需要关注的是下面三行： 123&lt;setString result=&quot;NeedDeleteKey_1&quot; value=&quot;AdditionalElementA&quot;/&gt;&lt;setString result=&quot;NeedDeleteKey_2&quot; value=&quot;AdditionalElementB&quot;/&gt;&lt;setInt result=&quot;loopSumNum&quot; value=&quot;2&quot;/&gt; 头两行是要删除的元素的变量，值是要删除的 key 的字符串，注意命名规则都是以 NeedDeleteKey_ 开头，要遵守这个命名规则。第三行是创建了一个 loopSumNum 的变量，用于记录有多少个需要删除的元素对，这里我测试删除两个，它的值就是 2。 当打包构建的时候，这个脚本执行起来就会有下面的输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293UPL: /Users/buildmachine/UE4/Builds/lipengzha-PC1/C/BuildAgent/workspace/PackageFGameClient/FGame/Plugins/UPLExample/Source/UPLExample/ThirdParty/IOS/IOS_UPL.xmlUPL Init: NoneUPLExalpme adding element to plist...count:1 SearchKey:AdditionalElementAtagname:key tagvalue:CFBundleURLTypestagname:key tagvalue:CFBundleDevelopmentRegiontagname:key tagvalue:CFBundleDisplayNametagname:key tagvalue:CFBundleExecutabletagname:key tagvalue:CFBundleIdentifiertagname:key tagvalue:CFBundleInfoDictionaryVersiontagname:key tagvalue:CFBundleNametagname:key tagvalue:CFBundlePackageTypetagname:key tagvalue:CFBundleSignaturetagname:key tagvalue:CFBundleVersiontagname:key tagvalue:CFBundleShortVersionStringtagname:key tagvalue:LSRequiresIPhoneOStagname:key tagvalue:UIStatusBarHiddentagname:key tagvalue:UIFileSharingEnabledtagname:key tagvalue:UIRequiresFullScreentagname:key tagvalue:UIViewControllerBasedStatusBarAppearancetagname:key tagvalue:UIInterfaceOrientationtagname:key tagvalue:UISupportedInterfaceOrientationstagname:key tagvalue:UIRequiredDeviceCapabilitiestagname:key tagvalue:CFBundleIconstagname:key tagvalue:CFBundleIcons~ipadtagname:key tagvalue:UILaunchStoryboardNametagname:key tagvalue:CFBundleSupportedPlatformstagname:key tagvalue:MinimumOSVersiontagname:key tagvalue:ITSAppUsesNonExemptEncryptiontagname:key tagvalue:NSLocationAlwaysAndWhenInUseUsageDescriptiontagname:key tagvalue:NSLocationWhenInUseUsageDescriptiontagname:key tagvalue:AdditionalElementAMatch key AdditionalElementA.Delete element key,tagname:key value:AdditionalElementA.bIsDeleteElement is true!!!Delete element value,tagname:string value:this key is a AdditionalElementA element.tagname:key tagvalue:AdditionalElementBtagname:key tagvalue:CFBundleURLNametagname:key tagvalue:CFBundleURLSchemestagname:key tagvalue:CFBundlePrimaryIcontagname:key tagvalue:CFBundleIconFilestagname:key tagvalue:CFBundleIconNametagname:key tagvalue:UIPrerenderedIcontagname:key tagvalue:CFBundlePrimaryIcontagname:key tagvalue:CFBundleIconFilestagname:key tagvalue:CFBundleIconNametagname:key tagvalue:UIPrerenderedIconadd loopCount to 2count:2 SearchKey:AdditionalElementBtagname:key tagvalue:CFBundleURLTypestagname:key tagvalue:CFBundleDevelopmentRegiontagname:key tagvalue:CFBundleDisplayNametagname:key tagvalue:CFBundleExecutabletagname:key tagvalue:CFBundleIdentifiertagname:key tagvalue:CFBundleInfoDictionaryVersiontagname:key tagvalue:CFBundleNametagname:key tagvalue:CFBundlePackageTypetagname:key tagvalue:CFBundleSignaturetagname:key tagvalue:CFBundleVersiontagname:key tagvalue:CFBundleShortVersionStringtagname:key tagvalue:LSRequiresIPhoneOStagname:key tagvalue:UIStatusBarHiddentagname:key tagvalue:UIFileSharingEnabledtagname:key tagvalue:UIRequiresFullScreentagname:key tagvalue:UIViewControllerBasedStatusBarAppearancetagname:key tagvalue:UIInterfaceOrientationtagname:key tagvalue:UISupportedInterfaceOrientationstagname:key tagvalue:UIRequiredDeviceCapabilitiestagname:key tagvalue:CFBundleIconstagname:key tagvalue:CFBundleIcons~ipadtagname:key tagvalue:UILaunchStoryboardNametagname:key tagvalue:CFBundleSupportedPlatformstagname:key tagvalue:MinimumOSVersiontagname:key tagvalue:ITSAppUsesNonExemptEncryptiontagname:key tagvalue:NSLocationAlwaysAndWhenInUseUsageDescriptiontagname:key tagvalue:NSLocationWhenInUseUsageDescriptiontagname:key tagvalue:AdditionalElementAAAtagname:key tagvalue:AdditionalElementBMatch key AdditionalElementB.Delete element key,tagname:key value:AdditionalElementB.bIsDeleteElement is true!!!Delete element value,tagname:string value:this key is a AdditionalElementB element.tagname:key tagvalue:CFBundleURLNametagname:key tagvalue:CFBundleURLSchemestagname:key tagvalue:CFBundlePrimaryIcontagname:key tagvalue:CFBundleIconFilestagname:key tagvalue:CFBundleIconNametagname:key tagvalue:UIPrerenderedIcontagname:key tagvalue:CFBundlePrimaryIcontagname:key tagvalue:CFBundleIconFilestagname:key tagvalue:CFBundleIconNametagname:key tagvalue:UIPrerenderedIconthe loop is finished! 其实只要可以删除，就可以在删除之后自己通过 addElements 来再把已删除的元素添加一遍了，从而实现要修改的目的。 为 IOS 添加 FramaworkIOS 上的 Framework 有点类似于静态链接库的意思，相当于把.a+.h+ 资源打包到一块的集合体。更具体的区别描述请看：iOS 库 .a 与.framework 区别 在 UE 中以集成 IOS 上操作 Keycahin 的 SSKeychain 为例，在 Module 的 build.cs 中使用 PublicAdditionalFrameworks 来添加： 1234567PublicAdditionalFrameworks.Add( new Framework( &quot;SSKeychain&quot;, &quot;ThirdParty/IOS/SSKeychain.embeddedframework.zip&quot;, &quot;SSKeychain.framework/SSKeychain.bundle&quot; )); 构造 Framework 的第一个参数是名字，第二个是 framework 的路径（相对于 Module），第三个则是解压之后的 Framework 的 bundle 路径（如果 framework 没有 bundle 则可以忽略这个参数，而且就算有 bundle，但是不写这第三个参数貌似也没什么问题）。 这个可以打开 SSKeychain.embeddedframework.zip 文件看： 12345678910111213141516171819202122SSKeychain.embeddedframework └─SSKeychain.framework │ Info.plist │ SSKeychain │ ├─Headers │ SSKeychain.h │ SSKeychainQuery.h │ ├─Modules │ module.modulemap │ ├─SSKeychain.bundle │ └─en.lproj │ SSKeychain.strings │ └─_CodeSignature CodeDirectory CodeRequirements CodeRequirements-1 CodeResources CodeSignature 相对于 .framework 的路径，这个路径一定要填正确，不然是不能用的，因为打包时会把这个 zip 解压出来，然后拷贝到包体中，路径指定错了就无法拷贝了。 1[2020.05.14-11.04.48:324][988]UATHelper: Packaging (iOS): [2/183] sh Unzipping : /Users/zyhmac/UE4/Builds/ZHALIPENG/C/Users/imzlp/Documents/UnrealProjectSSD/MicroEnd_423/Plugins/PlatformUtils/Source/PlatformUtils/ThirdParty/IOS/SSKeychain.embeddedframework.zip -&gt; /Users/zyhmac/UE4/Builds/ZHALIPENG/D/UnrealEngine/Epic/UE_4.23/Engine/Intermediate/UnzippedFrameworks/SSKeychain/SSKeychain.embeddedframework 注意：不要在两个不同的模块里同时引入一个相同的第三方 framework 文件，不然会有以下错误（如我在插件 A 中引入了 SSKeychain.embeddedframework.zip 然后在相同工程的另一个插件 B 中也引入了它）。 1Unable to merge actions producing SSKeychain.embeddedframework.extracted: prerequisites are different.","tags":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"UPL","slug":"UPL","permalink":"https://ue5wiki.com/tags/UPL/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"UPL","slug":"Mobile/UPL","permalink":"https://ue5wiki.com/categories/Mobile/UPL/"}]},{"title":"Mac 部署 UE 开发环境","date":"2020-09-01T22:32:01.000Z","path":"wiki/2329190d/","text":"MacOS 安装 UEUE 要求 MacOS 的分区格式为 不区分大小写 （不然 EpicLauncher 也无法安装），而且安装引擎的要求是系统版本大于10.13.5，否则会出现引擎崩溃和一些不支持的情况(尝试忽略错误无法安装成功)。 编译依赖 xcode，就像依赖 VS 一样，需要安装编译环境。如果安装完 UE 和 Xcode 之后创建项目提示下列错误： 1234567891011121314An error occurred while trying to generate project files.Running Mono...Setting up Mono/Users/Shared/UnrealEngine/4.22/Engine /Users/Shared/UnrealEngine/4.22/Engine/Binaries/MacDiscovering modules, targets and source code for project...Compiling with non-standard Xcode (xcode-select): /Library/Developer/CommandLineTools/Triggered an exception while looking for SDK directory in Xcode.appSystem.IO.DirectoryNotFoundException: Directory &#x27;/Library/Developer/CommandLineTools/Platforms/MacOSX.platform/Developer/SDKs&#x27; not found. at System.IO.Directory.ValidateDirectoryListing (System.String path, System.String searchPattern, System.Boolean&amp; stop) [0x00000] in &lt;filename unknown&gt;:0 at System.IO.Directory.GetFileSystemEntries (System.String path, System.String searchPattern, FileAttributes mask, FileAttributes attrs) [0x00000] in &lt;filename unknown&gt;:0 at System.IO.Directory.GetDirectories (System.String path, System.String searchPattern) [0x00000] in &lt;filename unknown&gt;:0 at System.IO.Directory.GetDirectories (System.String path) [0x00000] in &lt;filename unknown&gt;:0 at UnrealBuildTool.AppleToolChain.SelectSDK (System.String BaseSDKDir, System.String OSPrefix, System.String&amp; PlatformSDKVersion, Boolean bVerbose) [0x00000] in &lt;filename unknown&gt;:0 ERROR: Invalid SDK MacOSX.sdk, not found in /Library/Developer/CommandLineTools/Platforms/MacOSX.platform/Developer/SDKs 则安装Xcode Command Line Tools，然后执行以下命令即可： 1$ sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms /Library/Developer/CommandLineTools/ OS X: Can’t create new project I can’t build a c++ program on my Mac with Xcode Mac 修改 SSHD 默认端口 有些内网有端口限制，低于 xxxx 的端口默认不开放，所以在 22 端口被限制的情况下如何进行远程构建？修改 SSH 的默认端口！ 编辑 /etc/services 文件中的 ssh 的端口： 1$ vim /etc/services 把 SSH 的端口改为其他的： 12ssh 22/udp # SSH Remote Login Protocolssh 22/tcp # SSH Remote Login Protocol 修改为： 12ssh 2222/udp # SSH Remote Login Protocolssh 2222/tcp # SSH Remote Login Protocol 保存退出。还需要重新加载配置使端口生效： 12$ sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist$ sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist 然后测试端口是否可以连接: 1$ ssh localhost -p 2222 Can’t change PORT listen on macOS X Mojave for built-in SSH 为 xcode 开启多线程编译 首先看一下 Mac 的硬件配置： 1$ sysctl machdep.cpu 找到 machdep.cpu.core_count 字段，其中的数值就是 Mac 的核心数。 然后可以给 xcode 开启多线程，数量数为核心数 *2，如我的是 8 核，就可以开启 16 线程： 1$ defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 16 Mac 系统内置的 Framework有时候需要在 UE 的模块中引入系统的 Framework，那么 Mac 默认包含哪些 Framework 呢？可以通过以下方式查看。我使用的系统版本为 10.15.2，可以通过sw_vers 查看： 1234buildmachine@LIPENGZHA-MC0 ~ % sw_versProductName: Mac OS XProductVersion: 10.15.2BuildVersion: 19C57 系统内置的 Framework 在以下目录中： 1/System/Library/Frameworks 在 10.15.2 版本中包含以下 framework： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950AGL.framework ColorSync.framework CoreVideo.framework GameKit.frameworkLinkPresentation.framework OpenGL.framework SoundAnalysis.frameworkAVFoundation.framework Combine.framework CoreWLAN.framework GameplayKit.frameworkLocalAuthentication.framework PCSC.framework Speech.frameworkAVKit.framework Contacts.framework CryptoKit.framework HIDDriverKit.frameworkMapKit.framework PDFKit.framework SpriteKit.frameworkAccelerate.framework ContactsUI.framework CryptoTokenKit.framework Hypervisor.frameworkMediaAccessibility.framework PencilKit.framework StoreKit.frameworkAccounts.framework CoreAudio.framework DVDPlayback.framework ICADevices.frameworkMediaLibrary.framework Photos.framework SwiftUI.frameworkAdSupport.framework CoreAudioKit.framework DeviceCheck.framework IMServicePlugIn.frameworkMediaPlayer.framework PhotosUI.framework SyncServices.frameworkAddressBook.framework CoreAudioTypes.framework DirectoryService.framework IOBluetooth.frameworkMediaToolbox.framework PreferencePanes.framework System.frameworkAppKit.framework CoreBluetooth.framework DiscRecording.framework IOBluetoothUI.frameworkMessage.framework PushKit.framework SystemConfiguration.frameworkAppleScriptKit.framework CoreData.framework DiscRecordingUI.framework IOKit.frameworkMetal.framework Python.framework SystemExtensions.frameworkAppleScriptObjC.framework CoreDisplay.framework DiskArbitration.framework IOSurface.frameworkMetalKit.framework QTKit.framework TWAIN.frameworkApplicationServices.framework CoreFoundation.framework DriverKit.framework IOUSBHost.frameworkMetalPerformanceShaders.framework Quartz.framework Tcl.frameworkAudioToolbox.framework CoreGraphics.framework EventKit.framework IdentityLookup.frameworkMetricKit.framework QuartzCore.framework Tk.frameworkAudioUnit.framework CoreHaptics.framework ExceptionHandling.framework ImageCaptureCore.frameworkModelIO.framework QuickLook.framework USBDriverKit.frameworkAudioVideoBridging.framework CoreImage.framework ExecutionPolicy.framework ImageIO.frameworkMultipeerConnectivity.framework QuickLookThumbnailing.framework UserNotifications.frameworkAuthenticationServices.framework CoreLocation.framework ExternalAccessory.framework InputMethodKit.frameworkNaturalLanguage.framework RealityKit.framework VideoDecodeAcceleration.frameworkAutomator.framework CoreMIDI.framework FWAUserLib.framework InstallerPlugins.frameworkNetFS.framework Ruby.framework VideoSubscriberAccount.frameworkBackgroundTasks.framework CoreMIDIServer.framework FileProvider.framework InstantMessage.frameworkNetwork.framework SafariServices.framework VideoToolbox.frameworkBusinessChat.framework CoreML.framework FileProviderUI.framework Intents.frameworkNetworkExtension.framework SceneKit.framework Vision.frameworkCFNetwork.framework CoreMedia.framework FinderSync.framework JavaFrameEmbedding.frameworkNetworkingDriverKit.framework ScreenSaver.framework WebKit.frameworkCalendarStore.framework CoreMediaIO.framework ForceFeedback.framework JavaScriptCore.frameworkNotificationCenter.framework ScriptingBridge.framework iTunesLibrary.frameworkCallKit.framework CoreMotion.framework Foundation.framework JavaVM.frameworkOSAKit.framework Security.framework vecLib.frameworkCarbon.framework CoreServices.framework GLKit.framework Kerberos.frameworkOSLog.framework SecurityFoundation.framework vmnet.frameworkCloudKit.framework CoreSpotlight.framework GLUT.framework Kernel.frameworkOpenAL.framework SecurityInterface.frameworkCocoa.framework CoreTelephony.framework GSS.framework LDAP.frameworkOpenCL.framework ServiceManagement.frameworkCollaboration.framework CoreText.framework GameController.framework LatentSemanticMapping.frameworkOpenDirectory.framework Social.framework 安装 CommandLineTool Xcode’s metal shader compiler was not found, verify Xcode has been installed on this Mac and that it has been selected in Xcode &gt; Preferences &gt; Locations &gt; Command-line Tools. 相关问题： Unreal Engine inaccurately reports “XCode is too old” when CommandLineTools installed 离线安装 XCode 和Command Line Tools for Xcode可以从苹果的开发者网站下载：More Downloads for Apple Developers 在安装完 Command Line Tools 之后，如果 cook 时还是提示这个错误，则需要执行下列命令 (当然要首先确保/Library/Developer/CommandLineTools 路径存在，一般 Command Line Tools 的默认安装路径是这个)： 1$ sudo xcode-select -s /Library/Developer/CommandLineTools 当设置 CommandLineTools 之后打包时可能会提示: 1ERROR: Invalid SDK MacOSX.sdk, not found in /Library/Developer/CommandLineTools/Platforms/MacOSX.platform/Developer/SDKs 这是因为通过 xcode-select 设置为 CommandLineTools 之后，打包时找不到 Xcode 里的库了。解决的办法是在 CommandLineTools 的目录下创建一个 Xcode 中的 Platforms 目录的软连接： 1sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms /Library/Developer/CommandLineTools/Platforms actool 错误12UATHelper: Packaging (iOS): xcrun: error: unable to find utility &quot;actool&quot;, not a developer tool or in PATHPackagingResults: Error: unable to find utility &quot;actool&quot;, not a developer tool or in PATH 这是因为把 CommandLinTool 设置为默认的命令行工具之后，CommandLinTool/use/bin下并没有 actool 等工具。这是个十分坑爹的问题，用 xcode 作为默认的命令行工具导致 Cook 不过，用 CommandLineTool 又在编译时有问题。我的解办法是把 /Applications/Xcode.app/Contents/Developer/usr/bin 通过软连接方式链接到/Library/Developer/CommandLineTools/usr: 1234# 当然要先备份 CommandLineTool/usr/bin$ mv /Library/Developer/CommandLineTools/usr/bin /Library/Developer/CommandLineTools/usr/Command_bin# 创建 xcode 的 bin 目录的软连接$ sudo ln -s /Applications/Xcode.app/Contents/Developer/usr/bin /Library/Developer/CommandLineTools/usr/bin 解除 MacOS 安装软件的限制 允许任何来源，运行第三方应用 1sudo spctl --master-disable 安装灰色的 dmg 1hdiutil attach #dmg 文件名 # 打开 macOS Sierra 允许“任何来源”选项，运行第三方应用 Mac dmg 文件灰色无法安装 MacOS 读写 NTFS装上 macOS 之后发现，macOS 可以读取 ntfs 的文件，但是不可以写入，这十分蛋疼。查了一下说是因为微软的限制，但是 macOS 本身是做了读写的功能的，只是被关闭了，可以通过以下方法开启。 首先，在终端下执行 diskutil list 查看磁盘信息： 12345678910111213141516171819202122232425262728visionsmile$ diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *240.1 GB disk0 1: EFI 312.5 MB disk0s1 2: Microsoft Reserved 134.2 MB disk0s2 3: Microsoft Basic Data Windows 164.3 GB disk0s3 4: Apple_APFS Container disk1 75.3 GB disk0s4/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +75.3 GB disk1 Physical Store disk0s4 1: APFS Volume OSX 34.2 GB disk1s1 2: APFS Volume Preboot 21.1 MB disk1s2 3: APFS Volume Recovery 509.8 MB disk1s3 4: APFS Volume VM 2.1 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *4.0 TB disk2 1: Microsoft Reserved 134.2 MB disk2s1 2: Microsoft Basic Data Document 4.0 TB disk2s2/dev/disk3 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *1.0 TB disk3 1: Windows_NTFS Documents2 1.0 TB disk3s1 需要记录的是 ntfs 磁盘的 NAME 信息，我这里有三个 ntfs 分区windows/Documents/Documents2. 然后继续执行命令，更新 fatab 文件： 1sudo nano /etc/fstab 输入下列内容，并把 LABEL= 之后的内容替换为上面记录的分区的名字： 123LABEL=Windows none ntfs rw,auto,nobrowseLABEL=Documents none ntfs rw,auto,nobrowseLABEL=Documents2 none ntfs rw,auto,nobrowse 重启之后即可。注意：重启之后的移动磁盘不会在桌面上现实，必须要打开 Finder 才可以看到。","tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"Mac","permalink":"https://ue5wiki.com/tags/Mac/"}],"categories":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"开发环境/Mac","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Mac/"}]},{"title":"Windows 的 UE 编译环境","date":"2020-09-01T22:32:01.000Z","path":"wiki/c4fd7a75/","text":"Visual Studio Intaller 的下载地址：Visual Studio IDE, Code Editor 开发 UE，可以使用以下 VS 的安装配置文件（保存为.vsconfig 文件，在 vs_installer 中导入）： 12345678910111213141516171819202122232425262728293031323334353637&#123;&quot;version&quot;: &quot;1.0&quot;,&quot;components&quot;: [&quot;Microsoft.VisualStudio.Workload.NativeDesktop&quot;,&quot;Microsoft.VisualStudio.Workload.Python&quot;,&quot;Microsoft.VisualStudio.Workload.Node&quot;,&quot;Microsoft.VisualStudio.Workload.NativeGame&quot;,&quot;Microsoft.VisualStudio.Workload.NativeCrossPlat&quot;,&quot;microsoft.visualstudio.component.debugger.justintime&quot;,&quot;microsoft.net.component.4.6.2.sdk&quot;,&quot;microsoft.net.component.4.6.2.targetingpack&quot;,&quot;microsoft.net.component.4.7.sdk&quot;,&quot;microsoft.net.component.4.7.targetingpack&quot;,&quot;microsoft.net.component.4.7.1.sdk&quot;,&quot;microsoft.net.component.4.7.1.targetingpack&quot;,&quot;microsoft.net.component.4.7.2.sdk&quot;,&quot;microsoft.net.component.4.7.2.targetingpack&quot;,&quot;microsoft.visualstudio.component.vc.diagnostictools&quot;,&quot;microsoft.visualstudio.component.vc.cmake.project&quot;,&quot;microsoft.visualstudio.component.vc.atl&quot;,&quot;microsoft.visualstudio.component.vc.testadapterforboosttest&quot;,&quot;microsoft.visualstudio.component.vc.testadapterforgoogletest&quot;,&quot;microsoft.visualstudio.component.winxp&quot;,&quot;microsoft.visualstudio.component.vc.cli.support&quot;,&quot;microsoft.visualstudio.component.vc.modules.x86.x64&quot;,&quot;microsoft.component.netfx.core.runtime&quot;,&quot;microsoft.component.cookiecuttertools&quot;,&quot;microsoft.component.pythontools.web&quot;,&quot;microsoft.visualstudio.component.classdesigner&quot;,&quot;microsoft.net.component.3.5.developertools&quot;,&quot;component.unreal.android&quot;,&quot;component.linux.cmake&quot;,&quot;microsoft.component.helpviewer&quot;,&quot;microsoft.visualstudio.component.vc.clangc2&quot;,&quot;microsoft.visualstudio.component.vc.tools.14.14&quot;]&#125;","tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Windows","slug":"Windows","permalink":"https://ue5wiki.com/tags/Windows/"}],"categories":[{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Windows","slug":"开发环境/Windows","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Windows/"}]},{"title":"抓取 UE4 API 并生成带索引的 Dash 文档","date":"2020-08-27T22:32:01.000Z","path":"wiki/836faf56/","text":"不知为何，UE API现在已经不随引擎发布 chm 的离线文档了，官方发布的最新版本还是 2014 年的，UE 发展到现在有了很多变化，显然四年前的 API 文档已经丧失部分参考价值了。但是 UE 文档站自身的搜索功能就我的体验而言，十分的烂。所以折腾了一下把 UE API 的所有页面爬了下来，并且生成了 Dash 支持的文档，检索起来十分酸爽。(文后附下载链接) 2020.08.27 更新：把 API 文档更新至 UE4.25。 先来看一下成果图(我在 Windows 下使用的是Zeal，它使用的是 Dash 的文档源)： 最开始的打算是把 UE API 的文档爬下来之后生成 chm，但是在我爬下来之后发现太大了，现在 (2018.07.05)，UE 的 API 文档 html 页面总大小为 2.89G，做成一个 chm 不太现实，所以就想到了其他办法——做成 Dash 支持的文档。 本着不重复造轮子的精神我查了一下有没有相关的实现，查到了一位仁兄几年前做的一个东西：Unreal Engine API documentation in Dash.该项目地址为：DrummerB/UnrealEngineDocset(作者已经四年没有更新了 ) 他实现的是把官方提供的 chm 解包出来，然后通过 bs4 爬虫框架来生成 Dash 的文档、并建立索引。我已经直接抓取了所有的 Html 文件，所以略过这一步。 可以使用 wget 来下载站点，吐个槽：windows 下的 WebZIP 并不好用。具体的用法可以从我之前的记录 (imzlp.com/notes) 里查看。 但是经过生成后发现，当时作者解析的方法和现在 UE 的 API 页面已经不一样了，所以我在它的基础上改进了一下，增加了以下几个支持： 对所有成员的索引增加 namespace(我手动关闭了 Class/Struct/union 的，因为增加了 namespace 后会对索引排序不友好，可以手动开启) 对没有独立页面的变量 / 函数 / 枚举等建立类页面的索引(之前作者的是不对没有独立页面的建立索引，会导致有些成员检索不到，我觉得不太好) 增加对 Overridden 的函数索引支持 增加 Constructor/Operator/Emum/Typedef 的索引支持 对具有 Inheritance Hierarchy 的结构，从 Inheritance Hierarchy 的 tag 中获取 Name，从而避免具有很多同名索引的情况 尽可能多地对不同类的相同名字的成员增加 Namespace 的标识 一些 bug 修复和优化 生成大约需要十分钟左右(视机器性能而定，当然 Py 的效率也是很一般的)，用法(要求 python2 和 bs4)： 首先要安装 bs4： 1$ pip install bs4 然后执行脚本生成： 1$ python ue4docset.py -n &quot;UE4&quot; ~/Desktop/API ~/Desktop/UE4.docset 代码在这里(ue4docset.py)： 另外，除了代码之外还需要对 UE API 的页面的 css 文件做一些处理，把下面红框里的部分隐藏掉(实在太影响观感)： 需要做的是修改 udn_public.css 和navBar.css： 12345678910111213141516171819202122232425262728293031323334353637# udn_public.css# 将下面列出的替换到 udn_public.css中#contentContainer&#123; transition: margin-left 0.5s linear 0s; margin-left:0px;&#125;#pagenav&#123; margin:0px 10px; overflow:hidden; position:relative; max-width:1562px; height:0px;&#125;#sideinfo&#123; position:absolute; right:-260px; top:0px; width:250px; display: none;&#125;#pagecontainer &#123; margin: 0; # padding: 5px 265px 0px 5px;&#125;#pagenav &#123; width: auto; display: none;&#125;#head &#123; width:100%; clear:both; display: none;&#125; 1234567891011121314# navBar.css# 将下面列出的替换到 navBar.css中nav#navPanel&#123; left:0px; display: none;&#125;div#navigation&#123; left:300px; display: none;&#125; 其实我对 Py 和 CSS 以及 bs4 爬虫框架都不熟，没有专门学习过，只是这两天用到了就现查现学现用，这样能够解决问题也挺好。 资源下载 (Windows 下推荐Zeal 来使用 Dash 文档)： api.unrealengine.com.tar.gz UE4.docset.7z（Dash 文档 / 索引） 将 UE4.docset.7z 与api.unrealengine.com.tar.gz均解压，并将 api.unrealengine.com/ 下的 images/Include/INT 三个目录放入 UE4.docset/Contents/Resources/Documents 下即可。如果使用的是 Zeal，则将UE4.docset 放入 Zeal 安装目录下的 docsets 下即可。 Update我创建了一个 git 仓库，来存放生成的文档版本：UE4_API_FOR_DASH，可以在仓库的 Release 中下载。 20200827 更新 UE425 CPP_API 20200827.docset 20190628 更新 UE API 20190628.docset","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"DASH","slug":"DASH","permalink":"https://ue5wiki.com/tags/DASH/"},{"name":"UE API","slug":"UE-API","permalink":"https://ue5wiki.com/tags/UE-API/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"UnrealPakViewer 可视化 Pak 分析工具","date":"2020-07-24T00:00:00.000Z","path":"wiki/external1237318848/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UnrealPakViewer 可视化 Pak 分析工具 。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/163501071"},{"title":"VR 硬件适配与调试经验","date":"2020-07-09T08:41:46.000Z","path":"wiki/92565514/","text":"UE 适配不同 VR 设备的高度问题 在 UE 适配 Oculus Rift 和 HTC Vive 时注意把 TrackingOrigin(EHMDTrackingOrigin::Type) 改为Floor，不然默认的追踪起源是在眼睛位置，导致头盔位置在游戏场景中高度不对。 还有一个问题是，使用 PlayerStart 放置时，PlayerStart是有高度的，所以高度可能是不对的 (取决于你的 Pawn 是怎么写的)，解决的办法是可以重写AGameModeBase 的SpawnDefaultPawnAtTransform，来指定高度。 UE 中游戏启动 VR 头显初始化 12Stereo On/OffNotice: Enables or Disables stereo rendering for Head Mounted Display (HMD) devices. 重置 VR 头显旋转和位置 因为 VR 头显默认的朝向 X 轴是与房间设置的定位有关的，所以，当我们初始就与定位时的朝向偏离时，进入游戏就会偏离我们设定让玩家看到的东西，所以需要进行修正。可以使用以下函数： 123456789/** * Resets orientation by setting roll and pitch to 0, assuming that current yaw is forward direction and assuming * current position as a &#x27;zero-point&#x27; (for positional tracking). * * @param Yaw (in) the desired yaw to be set after orientation reset. * @param Options (in) specifies either position, orientation or both should be reset.*/UFUNCTION(BlueprintCallable, Category=&quot;Input|HeadMountedDisplay&quot;)static void ResetOrientationAndPosition(float Yaw = 0.f, EOrientPositionSelector::Type Options = EOrientPositionSelector::OrientationAndPosition); 蓝图中也是同名的节点。 在 UE 中使用 Oculus Rift在 Oculus Rift 设备安装完成之后需要在 Oculus 商店中启用Unknow Source，不然无法在 UE 中使用 Oculus Rift 预览。 Unreal 的文档中适配 Oculus Rift 的页面：Developing for Oculus Rift. Oculus 官方提供的按键操作介绍： 以及 Oculus Rift 在 UE 中的按键映射： HTC Vive 的按键映射 与上面的 Oculus Rift 作为对比，附一张 HTC Vive 的按键映射： HTC VIVE 设备设置 SteamVR Support - HTC Vive 安装指南 SteamVR 2.0 定位基站 HTC Vive Pro 支持的定位器是 SteamVR 2.0，支持 150°和 7 米的追踪范围，而且支持基站串联(最多 16 个) 实现大空间定位方案。 注意：二代基站不支持一代 HTC Vive 头显。 使用 Proxifier 让 Oculus 走 SS 代理 昨天公司买了台 Oculus Rift 设备，在安装设备时需要全局代理，在 Windows 下我使用的是 Proxifier 来让 Oculus 相关软件走代理。首先先添加 Proxifier 的代理：测试连接成功之后即可执行下列操作。 上面连接成功后可以添加一个代理规则，而 Oculus 程序相关的进程如下，我们需要做的是让下列的进程走 SS 的代理： 1OculusSetup.exe;OculusClient.exe;OVRServiceLauncher.exe;OVRServer_x64.exe;OculusVR.exe;OculusCompatCheck.exe;CompatToolCommandLine.exe;OculusLogGatherer.exe;OVRLibrarian.exe;oculus-driver.exe;OVRLibraryService.exe;oculus-overlays.exe;OVRRedistributableInstaller.exe; 将上面的内容填入 应用程序 文本框内之后，选择走 SS 的本地代理端口就可以了。 其他的程序(如外服游戏、Steam 等)，如果需要强制走 SS 代理也是同样的方法。 VR 画面模糊的问题 因为 UE 项目中默认的 Screen Percentage 值是很低的，所以会感觉很模糊，但直接调高之后会有严重的帧率下降问题。一般设置为 200 以内画面质量就不错了，下面列有 UE 的建议值(理想值)。然后需要美术在此基础上对场景进行优化，保证接近满帧的帧率。 在 4.19 之前 (不含 4.19)，VR HMD 建议的理想值(r.ScreenPercentage) 为： DeviceType r.ScreenPercentage Oculus Rift 133 HTC Vive 140 PSVR 140 GearVR 120 GoogleVR 120 在 4.19 之后 UE 增加了 vr.PixelDensity，在r.ScreenPercentage 保持为 100 时，就可以在不同平台的设备上使用标准化的值: DeviceType r.ScreenPercentage vr.PixelDensity Oculus Rift 100 1 HTC Vive 100 1 PSVR 100 1 GearVR 100 1 GoogleVR 100 1 Lower values will perform faster but will be undersampled (more blurry) while values over 1 will perform slower and will supersample (extra sharp). 这样就可以通过控制 vr.PixelDensity 这个标准化的值来控制显示质量。具体介绍链接：Significant Changes Coming To VR Resolution Settings in 4.19 HTC VIVE 定位器故障 (03) 的解决办法 如果定位器面板上闪红灯且 SteamVR 显示 ** 定位器故障 (03)**，请试着手动烧录定位器(基站) 固件。步骤如下:固件路径在 Steam 的安装路径下：Steam\\steamapps\\common\\SteamVR\\tools\\lighthouse\\firmware\\lighthouse_tx\\archive\\htc_2.0，找到以下两个文件： 12* lighthouse_tx_htc_2_0-calibration-rescue-244.bin* lighthouse_tx_htc_2_0-244-2016-03-12.bin 在定位器 (基站) 未通电情况下，将其通过 micro-B USB 传输线连接到电脑。 按住定位器 (基站) 背后的模式键并插入电源线. 一旦电脑端确认为 USB 大容量存储设备(USB mass storage device)，才可以释放模式键。 被连接的定位器 (基站) 储存设备名为“CRP_DISABLED”，打开后包含一个文件“firmware.bin”，删除它。 将“lighthouse_tx_htc_2_0-calibration-rescue-244.bin”文件复制到基站的储存空间上。 复制完成后，拔掉电源线。 等几秒，然后再次插上电源。在此过程中不要按模式键。几秒后定位器 (基站) 应该会快速的闪烁绿灯或者红灯。绿灯表示修复成功。 如果它闪烁红灯，这表示不能自动修复，请您送修。 再次拔下电源。 重复步骤 1 到 7，但第 5 步复制文件改为“lighthouse_tx_htc_2_0-244-2016-03-12.bin”。 完整后定位器 (基站) 就恢复正常了，讲其频道设置为“A”并单独跟踪（另一个基站不通电）来确认运行情况。一旦确认工作正常，再打开另一个基站。 如果出现闪烁绿灯无法正常使用，重复步骤 1 到 7，但在第五步清除”CRP_DISABLED”中所有文件，只复制 “lighthouse_tx_htc_2_0-244-2016-03-12.bin” 即可。 如果手动烧录定位器 (基站) 固件和校准文还是无效，请使用手机拍照确定下列两个雷射点是否正常（不能用 iphone/ipad 雷射点拍不出來），如果这两个雷射点任一个没有显示，代表雷射损坏，请送客服检查。 参考链接：定位器故障(03)","tags":[{"name":"HTC Vive","slug":"HTC-Vive","permalink":"https://ue5wiki.com/tags/HTC-Vive/"},{"name":"VR","slug":"VR","permalink":"https://ue5wiki.com/tags/VR/"},{"name":"Oculus","slug":"Oculus","permalink":"https://ue5wiki.com/tags/Oculus/"}],"categories":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"}]},{"title":"FPaths 中 Dir 函数的对应路径","date":"2020-07-09T08:17:13.000Z","path":"wiki/67808803/","text":"FPaths 提供了很多 EngineDir 等之类的函数，我在 unlua 里导出了这些符号： 123456789101112131415print(fmt(&quot;EngineDir: &#123;&#125;&quot;,UE4.FPaths.EngineDir()))print(fmt(&quot;EngineUserDir: &#123;&#125;&quot;,UE4.FPaths.EngineUserDir()))print(fmt(&quot;EngineContentDir: &#123;&#125;&quot;,UE4.FPaths.EngineContentDir()))print(fmt(&quot;EngineConfigDir: &#123;&#125;&quot;,UE4.FPaths.EngineConfigDir()))print(fmt(&quot;EngineSavedDir: &#123;&#125;&quot;,UE4.FPaths.EngineSavedDir()))print(fmt(&quot;EnginePluginsDir: &#123;&#125;&quot;,UE4.FPaths.EnginePluginsDir()))print(fmt(&quot;RootDir: &#123;&#125;&quot;,UE4.FPaths.RootDir()))print(fmt(&quot;ProjectDir: &#123;&#125;&quot;,UE4.FPaths.ProjectDir()))print(fmt(&quot;ProjectUserDir: &#123;&#125;&quot;,UE4.FPaths.ProjectUserDir()))print(fmt(&quot;ProjectContentDir: &#123;&#125;&quot;,UE4.FPaths.ProjectContentDir()))print(fmt(&quot;ProjectConfigDir: &#123;&#125;&quot;,UE4.FPaths.ProjectConfigDir()))print(fmt(&quot;ProjectSavedDir: &#123;&#125;&quot;,UE4.FPaths.ProjectSavedDir()))print(fmt(&quot;ProjectIntermediateDir: &#123;&#125;&quot;,UE4.FPaths.ProjectIntermediateDir()))print(fmt(&quot;ProjectPluginsDir: &#123;&#125;&quot;,UE4.FPaths.ProjectPluginsDir()))print(fmt(&quot;ProjectLogDir: &#123;&#125;&quot;,UE4.FPaths.ProjectLogDir())) 他们对应的具体路径为： 123456789101112131415EngineDir: ../../../Engine/EngineUserDir: : /Users/imzlp/AppData/Local/UnrealEngine/4.22/EngineContentDir: ../../../Engine/Content/EngineConfigDir: ../../../Engine/Config/EngineSavedDir: : /Users/imzlp/AppData/Local/UnrealEngine/4.22/Saved/EnginePluginsDir: ../../../Engine/Plugins/RootDir: : /Program Files/Epic Games/UE_4.22/ProjectDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/ProjectUserDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/ProjectContentDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Content/ProjectConfigDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Config/ProjectSavedDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Saved/ProjectIntermediateDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Intermediate/ProjectPluginsDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Plugins/ProjectLogDir: ../../../../../../Users/imzlp/Documents/UnrealProjectSSD/GWorldClient/Saved/Logs/ 这些相对路径都是 相对于引擎的 exe的路径的：","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"FPaths","slug":"FPaths","permalink":"https://ue5wiki.com/tags/FPaths/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"未变动资源 Cook 稳定性的 BUG","date":"2020-07-09T00:00:00.000Z","path":"wiki/external1636799000/","text":"本篇文章为外部内容，请点击链接跳转至原站点： 未变动资源 Cook 稳定性的 BUG。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"}],"is_external":true,"jump_to":"https://zhuanlan.zhihu.com/p/388094053"},{"title":"Mount Point 的作用","date":"2020-07-08T15:11:39.000Z","path":"wiki/14307/","text":"在 Mount Pak 的时候，有一个参数可以指定 MountPoint: 1234567/*** Mounts a pak file at the specified path.** @param InPakFilename Pak filename.* @param InPath Path to mount the pak at.*/bool Mount(const TCHAR* InPakFilename, uint32 PakOrder, const TCHAR* InPath = NULL, bool bLoadIndex = true); 那么它是干什么的呢？首先从 Mount 函数开始： 1234if (InPath != NULL)&#123; Pak-&gt;SetMountPoint(InPath);&#125; 如果在调用 Mount 时传递了 InPath，则通过加载 Pak 的 FPakFile 实例调用SetMountPoint，把 InPath 设置给它。 其实在 FPakFile 中，MountPath 是有默认值的（从 Pak 文件中读取），在 FPakFile 的构造函数中调用了 Initialize(Reader, bLoadIndex);，Initialize 中又调用了LoadIndex，在LoadIndex 中从 Pak 中读取 Pak 的 Mount Point 的逻辑： 123456789101112131415161718192021222324252627282930313233// Runtime/PakFile/Private/IPlatformFilePak.cppvoid FPakFile::LoadIndex(FArchive* Reader)&#123; if (CachedTotalSize &lt; (Info.IndexOffset + Info.IndexSize)) &#123; UE_LOG(LogPakFile, Fatal, TEXT(&quot;Corrupted index offset in pak file.&quot;)); &#125; else &#123; if (Info.Version &gt;= FPakInfo::PakFile_Version_FrozenIndex &amp;&amp; Info.bIndexIsFrozen) &#123; SCOPED_BOOT_TIMING(&quot;PakFile_LoadFrozen&quot;); // read frozen data Reader-&gt;Seek(Info.IndexOffset); int32 FrozenSize = Info.IndexSize; // read in the index, etc data in one lump void* DataMemory = FMemory::Malloc(FrozenSize); Reader-&gt;Serialize(DataMemory, FrozenSize); Data = TUniquePtr&lt;FPakFileData&gt;((FPakFileData*)DataMemory); // cache the number of entries NumEntries = Data-&gt;Files.Num(); // @todo loadtime: it is nice to serialize the mountpoint right into the Data so that IndexSize is right here // but it takes this to copy it out, because it&#x27;s too painful for the string manipulation when dealing with // MemoryImageString everywhere MountPoint is used MountPoint = Data-&gt;MountPoint; &#125; // ... &#125; // ...&#125; 简单的可以理解为：如果 Mount 时不传递 Mount Point 就会从 Pak 文件中读取，如果有传入就设置为传入的值（Pak 文件中的 MountPoint 是 Pak 中所有文件的公共路径）。 那么，给 Pak 设置 MountPoint 的作用是什么呢？真实目的是，检测要加载的文件是否存在于当前 Pak 中！因为 Pak 的 Mount Point 的默认含义是当前 Pak 中所有文件的公共路径，所以只需要检测要读取的文件是否以这个路径开头，就可以首先排除掉基础路径不对的文件（基础路径都不对，意味着这个文件在 Pak 中也不存在）。 具体逻辑可以看这个函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Runtime/PakFile/Public/IPlatformFilePak.h/*** Finds a file in the specified pak files.** @param Paks Pak files to find the file in.* @param Filename File to find in pak files.* @param OutPakFile Optional pointer to a pak file where the filename was found.* @return Pointer to pak entry if the file was found, NULL otherwise.*/static bool FindFileInPakFiles(TArray&lt;FPakListEntry&gt;&amp; Paks,const TCHAR* Filename,FPakFile** OutPakFile,FPakEntry* OutEntry = nullptr)&#123; FString StandardFilename(Filename); FPaths::MakeStandardFilename(StandardFilename); int32 DeletedReadOrder = -1; for (int32 PakIndex = 0; PakIndex &lt; Paks.Num(); PakIndex++) &#123; int32 PakReadOrder = Paks[PakIndex].ReadOrder; if (DeletedReadOrder != -1 &amp;&amp; DeletedReadOrder &gt; PakReadOrder) &#123; //found a delete record in a higher priority patch level, but now we&#x27;re at a lower priority set - don&#x27;t search further back or we&#x27;ll find the original, old file. UE_LOG(LogPakFile, Verbose, TEXT(&quot;Delete Record: Accepted a delete record for %s&quot;), Filename ); return false; &#125; FPakFile::EFindResult FindResult = Paks[PakIndex].PakFile-&gt;Find(*StandardFilename, OutEntry); if (FindResult == FPakFile::EFindResult::Found) &#123; if (OutPakFile != NULL) &#123; *OutPakFile = Paks[PakIndex].PakFile; &#125; UE_CLOG(DeletedReadOrder != -1, LogPakFile, Verbose, TEXT(&quot;Delete Record: Ignored delete record for %s - found it in %s instead (asset was moved between chunks)&quot;), Filename, *Paks[PakIndex].PakFile-&gt;GetFilename()); return true; &#125; else if (FindResult == FPakFile::EFindResult::FoundDeleted) &#123; DeletedReadOrder = PakReadOrder; UE_LOG(LogPakFile, Verbose, TEXT(&quot;Delete Record: Found a delete record for %s in %s&quot;), Filename, *Paks[PakIndex].PakFile-&gt;GetFilename()); &#125; &#125; UE_CLOG(DeletedReadOrder != -1, LogPakFile, Warning, TEXT(&quot;Delete Record: No lower priority pak files looking for %s. (maybe not downloaded?)&quot;), Filename ); return false;&#125; 当我们从 Pak 中读取文件时，通过对游戏中所有 Mount 的 Pak 调用 Find 函数，而 FPakFile::Find 的函数就实现了上述我说的逻辑： 1234567891011// Runtime/PakFile/Private/IPlatformFilePak.cppFPakFile::EFindResult FPakFile::Find(const FString&amp; Filename, FPakEntry* OutEntry) const&#123; QUICK_SCOPE_CYCLE_COUNTER(PakFileFind); if (Filename.StartsWith(MountPoint)) &#123; FString Path(FPaths::GetPath(Filename)); // ... &#125; // ...&#125; 所以，MountPoint 的作用就是在从 Pak 中查找文件时，首先判断文件的路径是否与 Pak 中所有文件的 基础路径 相匹配（StartWith），如果不存在也就不会进入后续的流程了。","tags":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"引擎启动时 Pak 的加载","date":"2020-07-08T14:59:01.000Z","path":"wiki/11831/","text":"当在 UE 的 Project Setting 里Project-Packaging-UsePakFile启用时，会打包出来 pak 文件，以 Windows 平台为例，打包出来的 pak 路径为： 1WindowsNoEditor/PROJECT_NAME/Content/Paks 该目录下的 pak 文件在游戏启动时会自动加载，在引擎的 FEngineLoop::PreInit 中调用 LaunchCheckForFileOverride(LaunchEngineLoop.cpp) 又调用 ConditionallyCreateFileWrapper 来加载 PakFile 的PlatformFile，但是在 ConditionallyCreateFileWrapper 的代码中做了一层 WrapperFile-&gt;ShouldBeUsed 判断： 1234567891011121314151617181920212223242526272829303132333435// Runtime/Launch/Private/LaunchEngineLoop.cppstatic IPlatformFile* ConditionallyCreateFileWrapper(const TCHAR* Name, IPlatformFile* CurrentPlatformFile, const TCHAR* CommandLine, bool* OutFailedToInitialize = nullptr, bool* bOutShouldBeUsed = nullptr )&#123; if (OutFailedToInitialize) &#123; *OutFailedToInitialize = false; &#125; if (bOutShouldBeUsed) &#123; *bOutShouldBeUsed = false; &#125; IPlatformFile* WrapperFile = FPlatformFileManager::Get().GetPlatformFile(Name); if (WrapperFile != nullptr &amp;&amp; WrapperFile-&gt;ShouldBeUsed(CurrentPlatformFile, CommandLine)) &#123; if (bOutShouldBeUsed) &#123; *bOutShouldBeUsed = true; &#125; if (WrapperFile-&gt;Initialize(CurrentPlatformFile, CommandLine) == false) &#123; if (OutFailedToInitialize) &#123; *OutFailedToInitialize = true; &#125; // Don&#x27;t delete the platform file. It will be automatically deleted by its module. WrapperFile = nullptr; &#125; &#125; else &#123; // Make sure it won&#x27;t be used. WrapperFile = nullptr; &#125; return WrapperFile;&#125; 如果为 false 不会对该 PlatformFile 调用 Initialize，而FPakPlatformFile 的一些成员就是在这里被设置的。FPakPlatformFile::ShoubleBeUsed的定义如下(UE_4.22.3)： 1234567891011121314// Runtime/PakFile/Private/IPlatformFilePak.cppbool FPakPlatformFile::ShouldBeUsed(IPlatformFile* Inner, const TCHAR* CmdLine) const&#123; bool Result = false;#if !WITH_EDITOR if (!FParse::Param(CmdLine, TEXT(&quot;NoPak&quot;))) &#123; TArray&lt;FString&gt; PakFolders; GetPakFolders(CmdLine, PakFolders); Result = CheckIfPakFilesExist(Inner, PakFolders); &#125;#endif return Result;&#125; 编辑器模式下直接就是 false，即编辑器模式下不可以使用 pak 的 mount 操作，因为 mount 中需要用到 LowerLevel 成员，而该成员在 FPakPlatformFile::Initialize 中被设置，所以不可以调用 mount，否则必 Crash。 Mount 所有 pak 的相关代码在： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Runtime\\PakFile\\Private\\IPlatformFilePak.cppbool FPakPlatformFile::Initialize(IPlatformFile* Inner, const TCHAR* CmdLine)&#123; LLM_SCOPE(ELLMTag::FileSystem); SCOPED_BOOT_TIMING(&quot;FPakPlatformFile::Initialize&quot;); // Inner is required. check(Inner != NULL); LowerLevel = Inner;#if EXCLUDE_NONPAK_UE_EXTENSIONS // Extensions for file types that should only ever be in a pak file. Used to stop unnecessary access to the lower level platform file ExcludedNonPakExtensions.Add(TEXT(&quot;uasset&quot;)); ExcludedNonPakExtensions.Add(TEXT(&quot;umap&quot;)); ExcludedNonPakExtensions.Add(TEXT(&quot;ubulk&quot;)); ExcludedNonPakExtensions.Add(TEXT(&quot;uexp&quot;));#endif#if DISABLE_NONUFS_INI_WHEN_COOKED IniFileExtension = TEXT(&quot;.ini&quot;); GameUserSettingsIniFilename = TEXT(&quot;GameUserSettings.ini&quot;);#endif // signed if we have keys, and are not running with fileopenlog (currently results in a deadlock). bSigned = GetPakSigningKey().IsValid() &amp;&amp; !FParse::Param(FCommandLine::Get(), TEXT(&quot;fileopenlog&quot;));; // Find and mount pak files from the specified directories. TArray&lt;FString&gt; PakFolders; GetPakFolders(FCommandLine::Get(), PakFolders); MountAllPakFiles(PakFolders);#if !UE_BUILD_SHIPPING GPakExec = MakeUnique&lt;FPakExec&gt;(*this);#endif // !UE_BUILD_SHIPPING FCoreDelegates::OnMountAllPakFiles.BindRaw(this, &amp;FPakPlatformFile::MountAllPakFiles); FCoreDelegates::OnMountPak.BindRaw(this, &amp;FPakPlatformFile::HandleMountPakDelegate); FCoreDelegates::OnUnmountPak.BindRaw(this, &amp;FPakPlatformFile::HandleUnmountPakDelegate);#if !(IS_PROGRAM || WITH_EDITOR) FCoreDelegates::OnFEngineLoopInitComplete.AddLambda([this] &#123; FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Checking Pak Config&quot;)); bool bUnloadPakEntryFilenamesIfPossible = false; GConfig-&gt;GetBool(TEXT(&quot;Pak&quot;), TEXT(&quot;UnloadPakEntryFilenamesIfPossible&quot;), bUnloadPakEntryFilenamesIfPossible, GEngineIni); if (bUnloadPakEntryFilenamesIfPossible) &#123; // With [Pak] UnloadPakEntryFilenamesIfPossible enabled, [Pak] DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames // can contain pak entry directory wildcards of which the entire recursive directory structure of filenames underneath a // matching wildcard will be kept. // // Example: // [Pak] // DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Config/Tags/&quot; // +DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames=&quot;*/Content/Localization/*&quot; TArray&lt;FString&gt; DirectoryRootsToKeep; GConfig-&gt;GetArray(TEXT(&quot;Pak&quot;), TEXT(&quot;DirectoryRootsToKeepInMemoryWhenUnloadingPakEntryFilenames&quot;), DirectoryRootsToKeep, GEngineIni); FPakPlatformFile* PakPlatformFile = (FPakPlatformFile*)(FPlatformFileManager::Get().FindPlatformFile(FPakPlatformFile::GetTypeName())); PakPlatformFile-&gt;UnloadPakEntryFilenames(&amp;DirectoryRootsToKeep); &#125; bool bShrinkPakEntriesMemoryUsage = false; GConfig-&gt;GetBool(TEXT(&quot;Pak&quot;), TEXT(&quot;ShrinkPakEntriesMemoryUsage&quot;), bShrinkPakEntriesMemoryUsage, GEngineIni); if (bShrinkPakEntriesMemoryUsage) &#123; FPakPlatformFile* PakPlatformFile = (FPakPlatformFile*)(FPlatformFileManager::Get().FindPlatformFile(FPakPlatformFile::GetTypeName())); PakPlatformFile-&gt;ShrinkPakEntriesMemoryUsage(); &#125; &#125;);#endif return !!LowerLevel;&#125; UE 自动加载的 pak 路径： 1234567891011121314151617181920// Runtime\\PakFile\\Private\\IPlatformFilePak.cppvoid FPakPlatformFile::GetPakFolders(const TCHAR* CmdLine, TArray&lt;FString&gt;&amp; OutPakFolders)&#123;#if !UE_BUILD_SHIPPING // Command line folders FString PakDirs; if (FParse::Value(CmdLine, TEXT(&quot;-pakdir=&quot;), PakDirs)) &#123; TArray&lt;FString&gt; CmdLineFolders; PakDirs.ParseIntoArray(CmdLineFolders, TEXT(&quot;*&quot;), true); OutPakFolders.Append(CmdLineFolders); &#125;#endif // @todo plugin urgent: Needs to handle plugin Pak directories, too // Hardcoded locations OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::ProjectContentDir())); OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::ProjectSavedDir())); OutPakFolders.Add(FString::Printf(TEXT(&quot;%sPaks/&quot;), *FPaths::EngineContentDir()));&#125; 在非 Shipping 打包的时候可以通过才命令行加启动参数 -pakdir 来添加额外的 pak 路径。 引擎默认添加的路径为： 12345# relative to Project PathContent/Paks/Saved/Paks/# relative to Engine PathContent/Paks 之后又调用了 FPakPlatformFile::MountAllPakFiles 来把挂载所有 pak（默认对 pak 的名字进行了个降序排序，但是这里的排序没用），在该函数中 mount 的时候会给不同的路径加载的 pak 设置不同的Order，其函数在： 12345678910111213141516171819202122// Runtime\\PakFile\\Private\\IPlatformFilePak.cppint32 FPakPlatformFile::GetPakOrderFromPakFilePath(const FString&amp; PakFilePath)&#123; if (PakFilePath.StartsWith(FString::Printf(TEXT(&quot;%sPaks/%s-&quot;), *FPaths::ProjectContentDir(), FApp::GetProjectName()))) &#123; return 4; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectContentDir())) &#123; return 3; &#125; else if (PakFilePath.StartsWith(FPaths::EngineContentDir())) &#123; return 2; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectSavedDir())) &#123; return 1; &#125; return 0;&#125; 概括来说： 1234567# relative to project path4 Content/Paks/PROJECT_NAME-*.pak3 Content/Paks/1 Saved/Paks# relative to engine path2 Content/Paks/ 可以看到 Saved/Paks 下的 pak 文件加载的优先级是最低的。 在 Mount 的时候如果上述路径中有打出来 Patch 包，以 _Num_P.pak 结尾的文件，其中 Num 是数字，Patch 包的优先级高于普通的 pak，在 IPlatformFilePak.cpp 中默认给 _P.pak 的PakOrder加了 100，_P.pak前面的数字越大，其加载的优先级就越高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Runtime\\PakFile\\Private\\IPlatformFilePak.cppbool FPakPlatformFile::Mount(const TCHAR* InPakFilename, uint32 PakOrder, const TCHAR* InPath /*= NULL*/)&#123; bool bSuccess = false; TSharedPtr&lt;IFileHandle&gt; PakHandle = MakeShareable(LowerLevel-&gt;OpenRead(InPakFilename)); if (PakHandle.IsValid()) &#123; FPakFile* Pak = new FPakFile(LowerLevel, InPakFilename, bSigned); if (Pak-&gt;IsValid()) &#123; if (InPath != NULL) &#123; Pak-&gt;SetMountPoint(InPath); &#125; FString PakFilename = InPakFilename; if (PakFilename.EndsWith(TEXT(&quot;_P.pak&quot;))) &#123; // Prioritize based on the chunk version number // Default to version 1 for single patch system uint32 ChunkVersionNumber = 1; FString StrippedPakFilename = PakFilename.LeftChop(6); int32 VersionEndIndex = PakFilename.Find(&quot;_&quot;, ESearchCase::CaseSensitive, ESearchDir::FromEnd); if (VersionEndIndex != INDEX_NONE &amp;&amp; VersionEndIndex &gt; 0) &#123; int32 VersionStartIndex = PakFilename.Find(&quot;_&quot;, ESearchCase::CaseSensitive, ESearchDir::FromEnd, VersionEndIndex - 1); if (VersionStartIndex != INDEX_NONE) &#123; VersionStartIndex++; FString VersionString = PakFilename.Mid(VersionStartIndex, VersionEndIndex - VersionStartIndex); if (VersionString.IsNumeric()) &#123; int32 ChunkVersionSigned = FCString::Atoi(*VersionString); if (ChunkVersionSigned &gt;= 1) &#123; // Increment by one so that the first patch file still gets more priority than the base pak file ChunkVersionNumber = (uint32)ChunkVersionSigned + 1; &#125; &#125; &#125; &#125; PakOrder += 100 * ChunkVersionNumber; &#125; &#123; // Add new pak file FScopeLock ScopedLock(&amp;PakListCritical); FPakListEntry Entry; Entry.ReadOrder = PakOrder; Entry.PakFile = Pak; PakFiles.Add(Entry); PakFiles.StableSort(); &#125; bSuccess = true; &#125; else &#123; if (Pak-&gt;GetInfo().EncryptionKeyGuid.IsValid()) &#123; UE_LOG(LogPakFile, Log, TEXT(&quot;Deferring mount of pak \\&quot;%s\\&quot; until encryption key &#x27;%s&#x27; becomes available&quot;), InPakFilename, *Pak-&gt;GetInfo().EncryptionKeyGuid.ToString()); check(!GetRegisteredEncryptionKeys().HasKey(Pak-&gt;GetInfo().EncryptionKeyGuid)); FPakListDeferredEntry&amp; Entry = PendingEncryptedPakFiles[PendingEncryptedPakFiles.Add(FPakListDeferredEntry())]; Entry.Filename = InPakFilename; Entry.Path = InPath; Entry.ReadOrder = PakOrder; Entry.EncryptionKeyGuid = Pak-&gt;GetInfo().EncryptionKeyGuid; Entry.ChunkID = Pak-&gt;ChunkID; delete Pak; PakHandle.Reset(); return false; &#125; else &#123; UE_LOG(LogPakFile, Warning, TEXT(&quot;Failed to mount pak \\&quot;%s\\&quot;, pak is invalid.&quot;), InPakFilename); &#125; &#125; &#125; else &#123; UE_LOG(LogPakFile, Warning, TEXT(&quot;Pak \\&quot;%s\\&quot; does not exist!&quot;), InPakFilename); &#125; return bSuccess;&#125; 另外，腾讯的和平精英的热更新的 pak 就是放在 Saved/Paks 里面。 而且，和平精英的 apk 的大小是 1.6G，我下载完之后又热更新了 1.2G 左右的内容，总共占了 3 个多 G…这样的 apk 里面 obb 的数据估计和外部的 pak 中的内容都是覆盖的，但是 apk 内容又没办法改，只能越更新越多了（但是可以在用户更新 APK 之后删除多余的 pak）。 注：腾讯的吃鸡用 sluaunreal，脚本的热更也是通过 pak 方式来加载的，这点在 sluaunreal 中有写：sluaunreal 增量打包问题 如果从省空间的角度考虑，最好的方式就是基础 apk+ 更新的方式修改游戏内容，但是玩家下载完 apk 之后还需要再更新可能会造成用户流失，这是个要考虑的问题。","tags":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"运行时在 Pak 中访问非资源文件","date":"2020-07-08T14:52:00.000Z","path":"wiki/10456/","text":"可以把一些非 UE 资源文件（比如 txt，视频）等文件打包到 Pak 中，在游戏运行中访问，可以使用我上面写的 HotPatcher 工具来打包，这里写一下在运行时访问的方法。 首先将文件打包到 Pak： 这里我是将文件 AAAAA.json 打包到了 Pak 中，其挂载路径为../../../PROJECT_NAME/AAAAA.json. 在游戏中访问一定要使用挂载路径，可以使用 FPaths::ProjectDir 在打包后获取到的是相对路径，在 PIE 下是项目的相对路径。 使用方法： 其中的 PeojectDir 是FPaths::ProjectDir，LoadFileToString则是 IFileManager::LoadFileToString 的封装。 运行结果： 如果想要访问打包出的项目文件和挂载的 Pak 中的文件，可以使用下面的代码： 123456789101112131415161718void UPakVisitorHelper::VisitorProjectDir()&#123; IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile(); FFillArrayDirectoryVisitor Visitor; PlatformFile.IterateDirectory(*FPaths::ProjectDir(), Visitor); UE_LOG(LogTemp,Log,TEXT(&quot;Found Files:&quot;)); for (const auto&amp; File : Visitor.Files) &#123; UE_LOG(LogTemp, Log, TEXT(&quot;%s&quot;), *File); &#125; UE_LOG(LogTemp, Log, TEXT(&quot;Found Directorys:&quot;)); for (const auto&amp; Dir : Visitor.Directories) &#123; UE_LOG(LogTemp, Log, TEXT(&quot;%s&quot;), *Dir); &#125;&#125; IPlatformFile::IterateDirectory这个函数有两个原型： 12virtual bool IterateDirectory(const TCHAR * Directory, FDirectoryVisitor Visitor);virtual bool IterateDirectory(const TCHAR * Directory,FDirectoryVisitorFunc Visitor); 可以传入一个继承自 FDirectoryVisitor 的对象，或者传入一个下列签名的函数对象： 1typedef TFunctionRef &lt; bool(const TCHAR *, bool)&gt; FDirectoryVisitorFunc 支持传入一个 Lambda 也是可以的： 1234567891011121314151617TArray&lt;FString&gt; Files;TArray&lt;FString&gt; Dirs;IPlatformFile&amp; PlatformFile = FPlatformFileManager::Get().GetPlatformFile();auto FallArrayDirVisitor = [&amp;Files,&amp;Dirs](const TCHAR* InItem,bool bInDir)-&gt;bool&#123; if (bInDir) &#123; Dirs.AddUnique(InItem); &#125; else &#123; Files.AddUnique(InItem); &#125; return true;&#125;;PlatformFile.IterateDirectory(*InRelativePath, FallArrayDirVisitor); 执行结果： AssetRegistry.bin/*.uproject等文件都是在打包的时候打包进 pak 里的，AAAAA.json则是上面手动打到 Patch 的 Pak 里的。","tags":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"}]},{"title":"成员模板函数特化不要放在 Class Scope","date":"2020-07-08T14:44:53.000Z","path":"wiki/41830/","text":"如下面代码： 12345678910111213141516class Template&#123;public: template&lt;typename T&gt; Template&amp; operator&gt;&gt;(T&amp; Value) &#123; return *this; &#125; template&lt;&gt; Template&amp; operator&gt;&gt;&lt;bool&gt;(bool&amp; Value) &#123; // do something return *this; &#125;&#125;; 声明了模板函数 operator&gt;&gt;，而且添加了一个 bool 的特化，这个代码在 Windows 下编译没有问题，但是在打包 Android 时会产生错误： 1error: explicit specialization of &#x27;operator&gt;&gt;&#x27; in class scope 说时显式特化写在了类作用域内，解决办法是把特化的版本放到类之外： 123456789101112131415class Template&#123;public: template&lt;typename T&gt; Template&amp; operator&gt;&gt;(T&amp; Value) &#123; return *this; &#125;&#125;;template&lt;&gt;Template&amp; Template::operator&gt;&gt;&lt;bool&gt;(bool&amp; Value)&#123; // do something return *this;&#125; How can I use template specialization in c++ classes, and why this doesn’t compile?","tags":[{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"},{"name":"Template","slug":"Template","permalink":"https://ue5wiki.com/tags/Template/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"}]},{"title":"GC Config of BaseEngine.ini","date":"2020-06-29T22:32:01.000Z","path":"wiki/810b02a6/","text":"打开 ProjectSettings-Engine-GarbageCollection 查看设置:它们是在配置文件 Engine\\Config\\BaseEngine.ini 中的。 1234567891011121314; Engine\\Config\\BaseEngine.ini[/Script/Engine.GarbageCollectionSettings]gc.MaxObjectsNotConsideredByGC=0gc.SizeOfPermanentObjectPool=0gc.FlushStreamingOnGC=0gc.NumRetriesBeforeForcingGC=0gc.AllowParallelGC=Truegc.TimeBetweenPurgingPendingKillObjects=60gc.MaxObjectsInEditor=8388607gc.CreateGCClusters=Truegc.MergeGCClusters=Falsegc.ActorClusteringEnabled=Falsegc.BlueprintClusteringEnabled=Falsegc.UseDisregardForGCOnDedicatedServers=False AllowParallelGC：允许多线程执行 GC TimeBetweenPurgingPendingKillObjects：GC 的清理周期默认为 60s，可以通过调用： 1GetWorld()-&gt;ForceGarbageCollection(true); 来强制 GC。但是如果不想然一个 UObject 被 GC 回收，可以使用AddToRoot。 CreateGCClusters：开启可以防止对很多子物体进行 GC 遍历。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"GC","slug":"GC","permalink":"https://ue5wiki.com/tags/GC/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UE 热更新：需求分析与方案设计","date":"2020-05-16T11:22:35.000Z","path":"wiki/17371/","text":"游戏热更新是在玩家不重新安装游戏的前提下获取最新游戏内容的方式，在 PC 和移动端的网络游戏中有很多应用，因为游戏上上线后要快速调整、修复 bug、更新内容等等。如果每修改一点点内容都需要玩家去 AppStore 更新应用，甚至去网站手动下载再安装，而且不同的平台对于游戏的审核规则和反馈时间也不一致，运营也会疯掉。 在其他引擎中的热更应该有比较成熟的方案，但是在 UE 里还没看到有比较全面的文章来讲 UE4 的热更实现的文章，恰好之前分析和实现了 UE4 热更的内容，准备写两篇文章来记录一下思路和实现方案，并会实现一个可以运行的 Demo，希望能对有需要的朋友一点帮助。 为了方便地统一收集和管理热更新和 HotPatcher 常见的问题与解决方案，我新建了一篇文章来记录和整理：UE4 热更新：Questions &amp; Answers，遇到问题可以先去看这个 FAQ 页面。 本篇文章会从 需求分析 、 方案设计 两个部分入手，主要是研究热更方案时的思考总结。热更的具体实现写到下一篇文章中。 核心需求分析 因为是 热更新，实际上是要把游戏内容的更新推迟到运行时，从最简单但是最核心的流程上来说是下面这样的执行结构： 根据上面的流程图可以把热更要做的具体任务拆分成以下几个要解决的问题： UE 中哪些内容可以被热更？ 如何打包可以热更的内容和管理热更？ UE 里如何使用热更下载下来的资源包？ 如何对比本地和服务器最新的版本？ 热更文件的下载和校验 热更新的需求里 最重要 的是要解决 如何打包资源 和进行 版本管理 的问题，至于下载流程则不同的业务自己变动，我这里只写最基本可以实现热更的下载更新流程。 一条条来分析这些问题。 在 UE 中哪些内容可以被热更？首先，从 程序角度 来说，UE 官方提供 C++ 和蓝图作为引擎提供的开发语言和脚本，而 C++ 是个编译型语言，所有的变动都需要执行编译操作，所以 C++ 的代码无法热更。而 蓝图 本质上是 资产 (uasset)，资产的更新并不需要重新安装，所以使用 蓝图 所写的游戏逻辑是可以热更的。 但是，蓝图毕竟是 资源，这就要求当每改动一点点蓝图逻辑，都需要执行 Cook 才可以打包，更新起来很不方便，而且蓝图项目协同开发很难管理，所以需要集成一种文本化的脚本语言。 在国内的游戏开发以集成 Lua 为业务脚本的居多，腾讯也开源了两个 UE 集成 Lua 的插件，分别是 sluaunreal 和UnLua，可以在 UE 内集成 Lua 的脚本来替代蓝图写业务逻辑。 我在项目中选择的是 UnLua，并且我在 UnLua 的官方版本基础上集成了一些常用的 Lua 库、编辑器的拓展、常用的库导出、以及一些 bug 的修复。在 Github 上开源：debugable-unlua，我会 不定期 地合并官方版本。 我之前的一篇文章写了使用 UnLua 的一些内容：UE4 热更新：基于 UnLua 的 Lua 编程指南 其次，工程内的所有 uasset 资源 （地图、蓝图、模型、动画、贴图、UMG、音频、字体等等）资源也是可以更新的，UE 的 uasset 在打包之前都需要 Cook，而 Cook 的含义是把 UE 中 平台无关 的虚幻内部格式转换为特定平台的格式，因为各个平台使用自己的专有格式或者各个平台上具有性能更好的存储格式。 以 Windows 为例，在对 UE 的工程进行打包后会产生出类似下面这种路径关系的文件： 12345678910111213141516D:\\Examples\\PackageExample\\Package&gt;tree /f卷 Windows 的文件夹 PATH 列表 卷序列号为 BAB5-5234C:.└─WindowsNoEditor │ Manifest_NonUFSFiles_Win64.txt │ PackageExample.exe │ ├─Engine │ ├─ ... │ └─PackageExample └─Content └─Paks PackageExample-WindowsNoEditor.pak 其中 Content/Paks 下的 *.pak 文件就是 UE 打包出的所有非代码资源，游戏启动时会从 pak 里读取资源，里面不仅仅只有 uasst 的内容，可以这么理解：pak 就是游戏运行所需要的资源包。pak 中支持的内容就是 UE 热更所支持的内容。 默认情况下（未设置忽略文件）UE4 打包时会默认把工程中的资源都打包到一个 Pak 文件中，具体有以下内容： 以下描述中有几个关键字：PROJECT_NAME项目名，PLATFORN_NAME打包的平台名。 Package 时不会检测资源是否有引用，工程内的所有资源都会被 Cook 然后打包到 Pak 里； 引擎 Slate 的资源文件Engine\\Content\\Slate\\，字体 / 图片等等 引擎的 Content\\Internationalization 下相关语言的文件 引擎和启用插件目录下的 Content\\Localization 的locmeta/locres文件 项目的 uproject 文件，挂载点为../../../PROJECT_NAME/PROJECT_NAME.uproject； 项目启用的所有插件的 uplugin 文件，挂载点为插件的相对与 ../../../Engine/ 或者 ../../../PROJECT_NAME/Plugins/ 的路径； 项目目录下 Intermediate\\Staging\\PROJECT_NAME.upluginmanifest 文件，挂载点为../../../PROJECT_NAME/Plugins/PROJECT_NAME.upluginmanifest 引擎的 ini 文件，在引擎的 Engine/Config 下除了 Editor 的 ini 和 BaseLightmass.ini/BasePakFileRules.ini 之外都包含； 引擎下平台的 ini，在 Engine/Config/PLATFORM_NAME 内的所有 ini 文件； 项目启用的插件的 ini，在插件的目录的 config 下； Cook 出来的AssetRegistry.bin； Cook 出的PLATFORN_NAME\\Engine\\GlobalShaderCache*.bin； Cook 出来的 PLATFORM_NAME\\PROJECT_NAME\\Content\\ShaderArchive-*.ushaderbytecode 文件 通过 Project Setting-Packaing-Add Non-Asset Directory* 等添加的非 uasst 文件 以上这些文件在 UE 中都是可以热更的。 可以在 Engine\\Config\\BaseGame.ini 中看到相关配置： 123456789101112131415161718192021+EarlyDownloaderPakFileFiles=...\\Content\\Internationalization\\...\\*.icu+EarlyDownloaderPakFileFiles=...\\Content\\Internationalization\\...\\*.brk+EarlyDownloaderPakFileFiles=...\\Content\\Internationalization\\...\\*.res+EarlyDownloaderPakFileFiles=...\\Content\\Internationalization\\...\\*.nrm+EarlyDownloaderPakFileFiles=...\\Content\\Internationalization\\...\\*.cfu+EarlyDownloaderPakFileFiles=...\\Content\\Localization\\...\\*.*+EarlyDownloaderPakFileFiles=...\\Content\\Localization\\*.*+EarlyDownloaderPakFileFiles=...\\Content\\Certificates\\...\\*.*+EarlyDownloaderPakFileFiles=...\\Content\\Certificates\\*.*; have special cased game localization so that it&#x27;s not required for early pak file+EarlyDownloaderPakFileFiles=-...\\Content\\Localization\\Game\\...\\*.*+EarlyDownloaderPakFileFiles=-...\\Content\\Localization\\Game\\*.*+EarlyDownloaderPakFileFiles=...\\Config\\...\\*.ini+EarlyDownloaderPakFileFiles=...\\Config\\*.ini+EarlyDownloaderPakFileFiles=...\\Engine\\GlobalShaderCache*.bin+EarlyDownloaderPakFileFiles=...\\Content\\ShaderArchive-Global*.ushaderbytecode+EarlyDownloaderPakFileFiles=...\\Content\\Slate\\*.*+EarlyDownloaderPakFileFiles=...\\Content\\Slate\\...\\*.*+EarlyDownloaderPakFileFiles=...\\*.upluginmanifest+EarlyDownloaderPakFileFiles=...\\*.uproject+EarlyDownloaderPakFileFiles=...\\global_sf*.metalmap 除了引擎内置的资源类型，要实现 程序热更 最关键的一点在于：也可以把 非资源文件 打包到 Pak 中，所以前面提到的使用 UnLua 来作为业务脚本后的更新问题就可以解决了。 如何打包热更内容和管理版本？ 通过上一小节，可以知道了 UE 能够热更的内容有哪些，热更还有一个最关键的点是：如何把想要更新的内容打包出来作为热更的下载文件？ UE 全平台的打包都有包含 pak 文件（有的在包内，有的则是单独的文件），所以如何把需要的资源打出 pak 就是我们的需求。UE 使用 UnrealPak 这个工具把文件打包成一个 pak，同时 UnrealPak 还提供了查看 Pak 中有哪些文件、以及从 Pak 中解压文件的命令，这部分的内容可以在我之前的一篇文章中查看：UE4 工具链配置与开发技巧 #UnrealPak 的参数，网络上也有不少相关的文章。 UE 打包时会调用 UnrealPak 来生成 Pak 文件，通过打包时收集到的资源信息生成 pak-commandlist.txt 里面记录着要打到 Pak 中的资源信息以及挂载点。 基础命令如下： 1UnrealPak.exe D:\\TEST.pak -create=&quot;XXXXXXX.txt&quot; 只是单纯地打出 pak 的问题可以直接调用 UnrealPak，而热更另一个更重要的点在于： 该如何控制把哪些资源打包到指定的 pak 里？ 其实 UE 本身提供了类似 Chunk 的功能，但是用起来很不方便，需要给每个资源指定 chunk id，只有打包才会产生，没有办法很方便地控制每个 pak 中会包含哪些资源。 而且 UE 默认打包的时候只能添加 Content 路径下的非资源文件，这样的限制就导致了很多文件没办法很方便地更新。虽然在 Project Launcher 中也提供了打 Patch 的操作，但是哪些资源会被打包进来是黑盒的，没办法精确地知道这个 Patch 中会包含哪些文件。而且还无法基于一个 Patch 再打出一个 Patch，这些问题导致官方的打包方案解决不了我们的热更需求。 所以我开发了一款插件用来解决这些问题，开源在 Github 上：hxhb/HotPatcher，以及文档介绍：UE4 资源热更打包工具 HotPatcher 它的功能就是为了方便地在 UE 编辑器中来指定把哪些资源、哪个文件打包到哪个 pak 中，而且还提供了一键 Cook 多平台的功能，可以一键打出多个平台的 pak 包，支持导出版本信息，支持迭代 Patch。 核心思路为：打基础包时可以通过 HotPatcher 导出基础包内的资源信息，在变动了工程中内容时，通过导入 基础包内的资源信息 与当前工程中的资源信息进行比对，得到差异资源，将差异资源打包到 Pak 中。 本篇文章不详细介绍 HotPatcher 的用法，具体的使用文档和参数说明可以从上面的文档链接中查看。 总的来说，使用 hxhb/HotPatcher 就可以实现 UE 热更资源的打包和热更版本的管理！ UE 里如何使用热更下载下来的资源包？这里所说的 资源包 就是上一小节打包出来的 pak 文件。 UE 默认情况下提供了自动挂载 Pak 的三个路径： 12345# relative to Project PathContent/Paks/Saved/Paks/# relative to Engine PathContent/Paks 在我之前的笔记中记录了引擎启动时加载 Pak 的流程：UE4: 引擎启动时 Pak 的加载 把打出来的 Pak 直接放到这三个目录下，在没有开启 Signing 的情况下，是会默认加载这三个路径下的所有 Pak 的。从测试角度来说，可以把打包出来的 pak 文件放到这三个文件夹下的其中一个，再启动游戏，游戏就会自动挂载。 这又衍生出来了另一个问题。怎么让 UE 知道我哪个 Pak 文件是最新的？ 因为热更就是要把新更新的资源替换掉之前的旧的资源，必须要能够找到我们指定的最新的 pak 所有的新内容才会生效。 以引擎自动挂载的那三个路径为例，引擎从文件夹层面给这三个路径分别的优先级： 12345678910111213141516171819202122// Runtime\\PakFile\\Private\\IPlatformFilePak.cppint32 FPakPlatformFile::GetPakOrderFromPakFilePath(const FString&amp; PakFilePath)&#123; if (PakFilePath.StartsWith(FString::Printf(TEXT(&quot;%sPaks/%s-&quot;), *FPaths::ProjectContentDir(), FApp::GetProjectName()))) &#123; return 4; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectContentDir())) &#123; return 3; &#125; else if (PakFilePath.StartsWith(FPaths::EngineContentDir())) &#123; return 2; &#125; else if (PakFilePath.StartsWith(FPaths::ProjectSavedDir())) &#123; return 1; &#125; return 0;&#125; 可以看到位于 Content/Paks 目录下并且以项目名为前缀的 pak 文件默认具有最高优先级，其次分别为Project/Content/Paks&gt;Engine/Content/Pak&gt;Saved/Paks。 而且，Pak 文件的命名也会对优先级有影响。 以 _Num_P.pak 结尾的文件，其中 Num 是数字，Patch 包的优先级高于普通的 pak，在 IPlatformFilePak.cpp 中默认给 _P.pak 的PakOrder加了 100，_P.pak前面的数字越大，其加载的优先级就越高。 这个 优先级 数组会用在 mount pak 时，需要给每个 pak 文件指定，用与引擎在进行资源查找、文件加载时精确地找到哪个 pak 中的文件才是最新的版本。 但是这种情况下如果被恶意者知道了规则，故意把 pak 的文件命名给搞乱了，就会导致程序错误，所以不建议直接使用基于文件命名来确定优先级的规则，自己在热更时应该做一次校验。 还有，为了热更需求，需要自己控制 pak 的挂载时机，这就需要自己来调用 MountPak 的函数，我写了一个封装函数： 123456789101112131415161718192021222324252627282930bool MountPak(const FString&amp; PakPath, int32 PakOrder, const FString&amp; InMountPoint)&#123; bool bMounted = false;#if !WITH_EDITOR FPakPlatformFile* PakFileMgr=(FPakPlatformFile*)FPlatformFileManager::Get().GetPlatformFile(FPakPlatformFile::GetTypeName()); if (!PakFileMgr) &#123; UE_LOG(LogTemp, Log, TEXT(&quot;GetPlatformFile(TEXT(\\&quot;PakFile\\&quot;) is NULL&quot;)); return false; &#125; PakOrder = FMath::Max(0, PakOrder); if (FPaths::FileExists(PakPath) &amp;&amp; FPaths::GetExtension(PakPath) == TEXT(&quot;pak&quot;)) &#123; const TCHAR* MountPount = InMountPoint.GetCharArray().GetData(); if (PakFileMgr-&gt;Mount(*PakPath, PakOrder,MountPount)) &#123; UE_LOG(LogTemp, Log, TEXT(&quot;Mounted = %s, Order = %d, MountPoint = %s&quot;), *PakPath, PakOrder, !MountPount ? TEXT(&quot;(NULL)&quot;) : MountPount); bMounted = true; &#125; else &#123; UE_LOG(LogTemp, Error, TEXT(&quot;Faild to mount pak = %s&quot;), *PakPath); bMounted = false; &#125; &#125;#endif return bMounted;&#125; 当 Pak 文件从服务器下载下来时就可以调用这个函数来把 Pak 挂载的到引擎中，只要 保证 PakOrder 没问题，之后就不需要管 pak 的问题了，加载文件时引擎会自动找到最新版本的资源。 注意：一般情况下都是在一个新地图中执行热更的流程，热更之前不要执行任何加载游戏资源的行为，不然如果一个资源在热更之前被加载了一遍，之后就算把新的 pak 挂载上，已经加载的资源也不会更新。 如何对比本地版本与服务器最新的版本？不同的业务可以做不同的处理，关键思路就是：游戏启动时热更模块会最先去请求服务器上所有的热更版本信息，然后客户端会根据本体包的版本信息来扫描本地已经下载的 patch，把两个信息进行比对之后就可以分析出需要下载哪些版本。 简单的思路是写一个 json 的文件，记录着所有的 patch 信息（文件名、MD5 值），每次客户端启动时会去下载这个 json 的文件，并解析出来。然后客户端本地从指定的文件夹中去扫描 pak 文件，把文件名和 MD5 值进行比对检查，分析出本地合法的 pak 列表，再与服务器的版本列表进行比对，把差异部分下载即可。 热更文件的下载与校验？上一部分写到了从服务器请求和本地版本扫描分析出来当前用户需要下载的 Patch 版本，这一部分就讲在 UE 中如何下载和校验。 UE 本身提供了跨平台的的 HTTP 库，可以使用引擎中 Online 下的 HTTP 模块： 123456HttpRequest = FHttpModule::Get().CreateRequest();HttpRequest-&gt;OnRequestProgress().BindUObject(this, &amp;UDownloadProxy::OnDownloadProcess);HttpRequest-&gt;OnProcessRequestComplete().BindUObject(this, &amp;UDownloadProxy::OnDownloadComplete);HttpRequest-&gt;SetURL(InternalDownloadFileInfo.URL);HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));HttpRequest-&gt;ProcessRequest(); 但是 ，我又要说但是了，直接默认使用这样 HTTP 下载，需要在文件下载完毕时再写入到文件中，如果文件很大写入很花时间，会阻塞。而且，需要对下载的文件进行校验，我选择的是 MD5，MD5 是摘要算法，需要把文件从头到尾读一遍才能计算出结果，如果 下载 、 存储 、 校验 三步都拆开来做，其实浪费了很多时间。 所以我简单封装了一个下载库，支持 边下边存 / 边下边计算 MD5，这样当文件下载完也已经存到本地了，并且还计算出了 MD5 值可以供校验用。还支持暂停 / 继续 / 分片下载，自己改一下也可以改成断点续传的。 同样是 UE 的插件，并开源在 Github 上：ue4-dtkit，支持 IOS/Android/Windows/Mac 四个平台。 在这个插件我还封装了一个 MD5Wrapper.hpp 可以用来在其他地方的 MD5 计算，使用的是 OpenSSL 的库。 在下载之后拿到了文件的 MD5 之后再与服务器的版本信息里的 MD5 进行比对，完全匹配的情况下就可以 MountPak 了。 结语 本篇文章的主要内容是介绍了 UE 里热更的思路和可以使用的工具，主要的重点在于 UE4 里的资源打包，使用我写的 hxhb/HotPatcher 可以比较方便地来完成这个工作，至于下载和验证的流程，我的这部分只做参考，可以根据自己的流程自己实现。 下一篇热更新的文章会根据本篇文章的思路和工具来具体实现热更的例子，工程和代码也会开源，有时间再来写。不过根据本篇文章的思路和提供的工具自己实现一个问题也不大。 本篇文章列举的工具和文档: hxhb/HotPatcher UE4 资源热更打包工具 HotPatcher ue4-dtkit debugable-unlua UE4 热更新：基于 UnLua 的 Lua 编程指南 UE4: 引擎启动时 Pak 的加载 UE4 工具链配置与开发技巧 #UnrealPak 的参数 Tencent/UnLua 热更新系列文章 UE4 热更新：需求分析与方案设计 UE4 资源热更打包工具 HotPatcher UE4 热更新：基于 HotPatcher 的自动化流程 UE4 热更新：拆分基础包 UE4 热更新：资产管理与审计工具 UE4 热更新：Create Shader Patch UE4 热更新：Questions &amp; Answers","tags":[{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"categories":[{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"CharCast 的坑","date":"2020-05-09T08:19:36.000Z","path":"wiki/70212204/","text":"CharCast是定义在 StringConv.h 的模板函数： 12345678910111213/** * Casts one fixed-width char type into another. * * @param Ch The character to convert. * @return The converted character. */template &lt;typename To, typename From&gt;FORCEINLINE To CharCast(From Ch)&#123; To Result; FPlatformString::Convert(&amp;Result, 1, &amp;Ch, 1, (To)UNICODE_BOGUS_CHAR_CODEPOINT); return Result;&#125; 就是对 FPlatformString::Convert 的转发调用。 PS：UNICODE_BOGUS_CHAR_CODEPOINT 宏定义为&#39;?&#39;。 FPlatformString::Convert有两个版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Converts the [Src, Src+SrcSize) string range from SourceChar to DestChar and writes it to the [Dest, Dest+DestSize) range. * The Src range should contain a null terminator if a null terminator is required in the output. * If the Dest range is not big enough to hold the converted output, NULL is returned. In this case, nothing should be assumed about the contents of Dest. * * @param Dest The start of the destination buffer. * @param DestSize The size of the destination buffer. * @param Src The start of the string to convert. * @param SrcSize The number of Src elements to convert. * @param BogusChar The char to use when the conversion process encounters a character it cannot convert. * @return A pointer to one past the last-written element. */template &lt;typename SourceEncoding, typename DestEncoding&gt;static FORCEINLINE typename TEnableIf&lt; // This overload should be called when SourceEncoding and DestEncoding are &#x27;compatible&#x27;, i.e. they&#x27;re the same type or equivalent (e.g. like UCS2CHAR and WIDECHAR are on Windows). TAreEncodingsCompatible&lt;SourceEncoding, DestEncoding&gt;::Value, DestEncoding*&gt;::Type Convert(DestEncoding* Dest, int32 DestSize, const SourceEncoding* Src, int32 SrcSize, DestEncoding BogusChar = (DestEncoding)&#x27;?&#x27;)&#123; if (DestSize &lt; SrcSize) return nullptr; return (DestEncoding*)Memcpy(Dest, Src, SrcSize * sizeof(SourceEncoding)) + SrcSize;&#125;template &lt;typename SourceEncoding, typename DestEncoding&gt;static typename TEnableIf&lt; // This overload should be called when the types are not compatible but the source is fixed-width, e.g. ANSICHAR-&gt;WIDECHAR. !TAreEncodingsCompatible&lt;SourceEncoding, DestEncoding&gt;::Value &amp;&amp; TIsFixedWidthEncoding&lt;SourceEncoding&gt;::Value, DestEncoding* &gt;::Type Convert(DestEncoding* Dest, int32 DestSize, const SourceEncoding* Src, int32 SrcSize, DestEncoding BogusChar = (DestEncoding)&#x27;?&#x27;)&#123; const int32 Size = DestSize &lt;= SrcSize ? DestSize : SrcSize; bool bInvalidChars = false; for (int I = 0; I &lt; Size; ++I) &#123; SourceEncoding SrcCh = Src[I]; Dest[I] = (DestEncoding)SrcCh; bInvalidChars |= !CanConvertChar&lt;DestEncoding&gt;(SrcCh); &#125; if (bInvalidChars) &#123; for (int I = 0; I &lt; Size; ++I) &#123; if (!CanConvertChar&lt;DestEncoding&gt;(Src[I])) &#123; Dest[I] = BogusChar; &#125; &#125; LogBogusChars&lt;DestEncoding&gt;(Src, Size); &#125; return DestSize &lt; SrcSize ? nullptr : Dest + Size;&#125; 其中关键的是第二个实现， 通过判断 CanConvertChar 来检测是否能够转换字符，如果不能转换就把转换结果设置为 BogusChar，默认也就是?，这也是把不同编码的数据转换为 FString 有些会显示一堆? 的原因。 1234567891011/** * Tests whether a particular character can be converted to the destination encoding. * * @param Ch The character to test. * @return True if Ch can be encoded as a DestEncoding. */template &lt;typename DestEncoding, typename SourceEncoding&gt;static bool CanConvertChar(SourceEncoding Ch)&#123; return IsValidChar(Ch) &amp;&amp; (SourceEncoding)(DestEncoding)Ch == Ch &amp;&amp; IsValidChar((DestEncoding)Ch);&#125; 所以：类似 LoadFileToString 去读文件如果编码不支持，那么读出来的数据和原始文件里是不一样的。","tags":[{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"},{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/tags/Programming/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"}]},{"title":"引擎版本获取","date":"2020-05-09T08:02:19.000Z","path":"wiki/52783345/","text":"有些需求工程中需要检测引擎版本，如在支持多个引擎版本的插件，在引擎中包含不同的模块，引擎版本之间 API 的差异等。 C++ 获取引擎版本 Runtime/Launch/Resources/Version.h 中有版本宏定义： Runtime/Launch/Resources/Version.h1234// newer than a 4.11.* version, regardless of the changelist that it was built with)#define ENGINE_MAJOR_VERSION 4#define ENGINE_MINOR_VERSION 26#define ENGINE_PATCH_VERSION 2 在代码中通过预处理指令即可使用。 从 TargetRules 获取引擎版本 TargetRules 中具有 Version(ReadOnlyBuildVersion)成员，它是 BuildVersion 的类型，定义在 Programs\\UnrealBuildTool\\System\\BuildVersion.cs 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// UnrealBuildTools/System/BuildVersion.csnamespace UnrealBuildTool&#123; /// &lt;summary&gt; /// Holds information about the current engine version /// &lt;/summary&gt; [Serializable] public class BuildVersion &#123; /// &lt;summary&gt; /// The major engine version (4 for UE4) /// &lt;/summary&gt; public int MajorVersion; /// &lt;summary&gt; /// The minor engine version /// &lt;/summary&gt; public int MinorVersion; /// &lt;summary&gt; /// The hotfix/patch version /// &lt;/summary&gt; public int PatchVersion; /// &lt;summary&gt; /// The changelist that the engine is being built from /// &lt;/summary&gt; public int Changelist; /// &lt;summary&gt; /// The changelist that the engine maintains compatibility with /// &lt;/summary&gt; public int CompatibleChangelist; /// &lt;summary&gt; /// Whether the changelist numbers are a licensee changelist /// &lt;/summary&gt; public bool IsLicenseeVersion; /// &lt;summary&gt; /// Whether the current build is a promoted build, that is, built strictly from a clean sync of the given changelist /// &lt;/summary&gt; public bool IsPromotedBuild; /// &lt;summary&gt; /// Name of the current branch, with &#x27;/&#x27; characters escaped as &#x27;+&#x27; /// &lt;/summary&gt; public string BranchName; /// &lt;summary&gt; /// The current build id. This will be generated automatically whenever engine binaries change if not set in the default Engine/Build/Build.version. /// &lt;/summary&gt; public string BuildId; /// &lt;summary&gt; /// The build version string /// &lt;/summary&gt; public string BuildVersionString; // ... &#125;&#125; 其中的 MajorVersion/MinorVersion/PatchVersion 分别对应 X.XX.X。 在 UE4.19 版本之前从 UBT 获取引擎版本比较麻烦： 1234567BuildVersion Version;if (BuildVersion.TryRead(BuildVersion.GetDefaultFileName(), out Version))&#123; System.Console.WriteLine(Version.MajorVersion); System.Console.WriteLine(Version.MinorVersion); System.Console.WriteLine(Version.PatchVersion);&#125; 在 UE4.19 及以后的引擎版本，可以通过 ReadOnlyTargetRules.Version 来获得，它是 ReadOnlyBuildVersion 类型，包裹了一个 BuildVersion 类。 可以在 Target.cs 或者 Build.cs 里通过 Target.Version 来访问引擎版本，可以根据不同的引擎版本来使用不同的库。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"自定义蓝图节点","date":"2020-05-08T15:01:25.000Z","path":"wiki/12302/","text":"在蓝图中类似于 SpawnActor 或者 GetClassDefaults 之类的函数，可以根据参数的变化来改变节点的信息(如增加引脚，修改返回值类型等等)。 其实在蓝图中这样的节点都是继承自 UK2Node 的类，每一个节点是一个类，如 SpawnActor 它就是定义在 Editor/BlueprintEditor 下的 K2Node_SpawnActor 类。UK2Node提供了很多的方法供继承类重写，如： 12345678910111213141516// 鼠标指到节点上的提示信息virtual FText GetTooltipText()const;// 节点在蓝图中显示的名字virtual FText GetNodeTitle(ENodeTitleType::Type TitleType)const;// 将节点添加至上下文菜单virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar&amp; ActionRegister)const;// 设置节点在编辑器中右键菜单的分类virtual FText GetMenuCategory()const;// 在编译时扩展节点，可以添加或移除节点的 Pin// 在这个函数中需要绑定真正需要执行的函数，注意绑定的函数要是 BlueprintCallable 的virtual void ExpandNode(FKismetCompilerContext &amp; CompilerContext, UEdGraph * SourceGraph);// 当节点中的 Pin 信息被改变virtual void PinDefaultValueChanged(UEdGraphPin* ChangedPin);// 给节点分配默认的 Pin，如初始添加 InExec 和 OutExec，声明在 UEdGraphNode 中// 默认在 ReallocatePinsDuringReconstruction 中调用，也可以自己在 ExpandNode 中调用virtual void AllocateDefaultPins(); 上面列出的就是创建一个自定义的蓝图节点需要实现的最重要的几个函数。 当在蓝图中点击节点右键刷新的时候会调用到 ExpandNode 函数，如果在其中调用了 AllocateDefaultPins 要考虑从序列化中读取已有配置的问题。 一个例子，实现的效果为根据枚举值修改节点的参数类型： 代码放在了 Gist：CustomK2Node.cpp","tags":[{"name":"Blueprint","slug":"Blueprint","permalink":"https://ue5wiki.com/tags/Blueprint/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"Blueprint","slug":"Programming/Blueprint","permalink":"https://ue5wiki.com/categories/Programming/Blueprint/"}]},{"title":"基于 UnLua 的 Lua 编程指南","date":"2020-03-24T10:50:17.000Z","path":"wiki/36659/","text":"UE 使用的是 C++ 这种编译型语言，在编译之后就成了二进制，只有通过玩家重新安装才能打到更新游戏的目的。但是对于游戏业务而言，对于需求调整和 bug 修复时间要求非常迫切，频繁地让玩家更新 App 是不能接受的，游戏项目一般使用 Lua 作为游戏业务的脚本语言，是为了把运行时不可变的 C++ 代码变成运行时可更新的 Lua 代码。 UE 官方没有提供 Lua 的支持，但是腾讯开源了UnLua，在我当前的项目使用了，这两天我梳理了一下 UnLua 的资料（主要是官方文档、issus、宣讲 PPT），加上自己测试 UnLua 写了一个小 Demo 的感悟，形成了本篇 UE 结合 UnLua 的编程指南，主要是总结使用 UnLua 来写业务的一些基本方法和坑，方便查看，本篇文章会持续更新。 另外，Lua 文件打包成 Pak 可以用我之前开源的工具：hxhb/HotPatcher，而且我基于 UnLua 自己修改了一个版本，添加了一些额外的优化，源码集成了 Luasocket/Luapanda/lpeg/Sproto/Luacrypt 库，可以直接使用 LuaPanda 调试，Github 地址为：hxhb/debugable-unlua. 参考资料： UnLua_UE4 下的 Lua 脚本插件 PPT UnLua_Programming_Guide_EN Programming in Lua,1th Tencent/UnLua/issus UnLua 注意事项 这些是 UnLua 官方仓库里我摘录出来的一些可能有坑的地方。 并非所有的 UFUNCTION 都支持，只支持BlueprintNativeEvent/BlueprintImplementationEvent/Replication Notify/Animation Notify/Input Event。 UnLua 不支持多 State，所以在 PIE 模式下运行多个 Client 会有问题。issus/78 不要在 Lua 里访问蓝图定义的结构体。issues/119 / issus/40（新的提交已支持） UnLua 里使用 self.Super 不会递归向下遍历继承层次中的所有基类。issus/131 非 dynamic delegate 不支持。issus/128 不可以直接导出类的 static 成员，但可以为它封装一个 static 方法。issus/22 不支持绑定 lua 脚本到对象实例，NewObject 指定的脚本是绑定到 UCLASS 的。issus/134 Unlua 里使用 UE4.TArray 的下标规则是从 1 开始的，与引擎中 TArray 以 0 开始不同.issues/41 注意导出给 Lua 的函数很多与蓝图中的名字不同，如蓝图中的 GetActorTransform 其实在 lua 里要用 GetTransform，在 lua 里使用的名字都是 C++ 真实定义的函数名字，而不是DisplayName 的名字。 Lua 代码提示 导出符号 UnLua 提供了对引擎内反射符号的导出，也可以自己静态导出非反射类的符号，并且提供了一个Commandlet 类UUnLuaIntelliSenseCommandlet导出这些符号。 下面简单介绍一下 Commandlet 的调用方法： 1UE4Editor-cmd.exe PROJECT_PATH.uproject -run=COMMANDLET 那么 UnLua 的 Commandlet 用法为： 1D:\\UnrealEngine\\Epic\\UE_4.23\\Engine\\Binaries\\Win64\\UE4Editor-cmd.exe C:\\Users\\imzlp\\Documents\\UnrealProjectSSD\\MicroEnd_423\\MicroEnd_423.uproject -run=UnLuaIntelliSense 执行完毕之后，会生成 UnLua/Interamate/IntelliSense 这个目录，里面有引擎导出到 lua 的符号。 VSCode 中使用 在 VSCode 中安装 Emmylua 插件，安装之后把上一步生成的 IntelliSense 目录添加到 vcode 的工作区即可。 调用父类函数 在 UEC++ 中，当我们重写了一个父类的虚函数，可以通过调用 Super:: 来指定调用父类实现，但是在 Lua 中不同。 1self.Super.ReceiveBeginPlay(self) 在 Lua 使用 self.Super 来调用父类的函数。 注意：UnLua 里的 Super 只是简单模拟了“继承”语义，在继承多层的情况下会有问题，Super 不会主动向下遍历 Super。“父类”不是 Class()返回的表的元表，只设置在 Super 这个 field 上（元表在插件的 c++ 代码里定义了，这个过程已经固化）。 对于 基类的基类 的 Super 调用： 1234567891011121314151617181920a.lualocal a = Class()function a:test()endreturn a--------------------------------------b.lualocal b = Class(&quot;a&quot;)--------------------------------------c.lualocal c = Class(&quot;b&quot;)function a:test() c.Super.Super.test(self)end 该问题摘录于 UnLua 的 issus：Class 内的 Super 的使用问题 调用被覆写的方法 注意：Lua 和原来的类并不是继承关系，而是依附关系，lua 依赖于蓝图或者 C++ 的类。Lua 覆写的类的函数，相当于给当前类的函数换了一个实现。 当在 Lua 中重写了一个附属类的 UFUNCTION 函数时，可以通过下列方法调用, 有点类似于 Super 但要写成Overridden： 123function BP_Game_C:ReceiveBeginPlay() self.Overridden.ReceiveBeginPlay(self) end 注意一定要传 self 进去，不然 Unlua 调用的时候执行的参数检查会 Crash，在 UnLua 中调用 UE 函数有点类似于拿到成员函数的原生指针，必须要手动传 this 进去。 调用 UE 的 C++ 函数UnLua 在编译时可以开启是否启用 UE 的 namespace（也就是 UE 的函数都需要加 UE4 前缀）。 调用方法为： 1UE4.UKismetSystemLibrary.PrintString(self,&quot;HelloWorld&quot;) 参数与 C++ 调用的相匹配（具有默认参数的同样可以不写）： 1UKismetSystemLibrary::PrintString(this,TEXT(&quot;Hello&quot;)) 覆写多返回值的函数 蓝图 覆写的 lua 代码： 1234function LoadingMap_C:GetName(InString) UE4.UKismetSystemLibrary.PrintString(self,InString) return true,&quot;helloworld&quot;end C++因为 C++ 的多返回值是通过传递引用参数进去实现的，所以在 Lua 中这个不太一样。 如下面的 C++ 函数： 1234567891011121314151617// .hUFUNCTION(BlueprintCallable, Category = &quot;GameCore|Flib|GameFrameworkStatics&quot;, meta = (CallableWithoutWorldContext, WorldContext = &quot;WorldContextObject&quot;))static bool LuaGetMultiReturnExample(UObject* WorldContextObject, FString&amp; OutString, int32&amp; OutInt, UObject*&amp; OutGameInstance);// .cppbool UFlibGameFrameworkStatics::LuaGetMultiReturnExample(UObject* WorldContextObject, FString&amp; OutString, int32&amp; OutInt, UObject*&amp; OutGameInstance)&#123; bool bStatus = false; if (WorldContextObject) &#123; OutString = TEXT(&quot;HelloWorld&quot;); OutInt = 1111; OutGameInstance = UGameplayStatics::GetGameInstance(WorldContextObject); bStatus = true; &#125; return bStatus;&#125; 这个函数接收 WorldContextObject 的参数，并接收 FString/int32/UObject* 这三个类型的引用类型，并返回一个 bool，那么这个函数该怎么在 lua 中接收这些参数值的？ 1local ret1,ret2,ret3,ret4 = UE4.UFlibGameFrameworkStatics.LuaGetMultiReturnExample(self,nil,nil,nil) 这种 local ret1,ret2=func() 的这种写法是 Lua 里的规则，可以看 Programming in Lua，4th 的第六章。 注意：接收引用参数的返回值和真正函数返回值的顺序是：ret1,ret2,ret3 都是引用参数，最终函数的返回 bool 是最后一个 ret4。 非 const 引用参数作为返回值需要注意的问题 注意：当调用 UFUNCTION 函数时，非 const 引用参数可以忽略，但是非 UFUNCTION 而是静态导出的函数则不行，因为 UnLua 对静态导出的函数有参数个数检查。 而且，使用引用作为返回参数的的使用方式需要考虑到下面两种情况： 非 const 引用作为纯输出 123456void GetPlayerBaseInfo(int32 &amp;Level, float &amp;Health, FString &amp;Name)&#123; Level = 7; Health = 77; Name = &quot;Marcus&quot;;&#125; 这种情况下返回值和传入值是没有任何关系的。在 lua 中可以这么使用： 1local level,heath,name = self:GetPlayerBaseInfo(0,0,&quot;&quot;); 非 const 引用参数既作为输入又作为输出 123456void GetPlayerBaseInfo(int32 &amp;Level, float &amp;Health, FString &amp;Name)&#123; Level += 7; Health += 77; Name += &quot;Marcus&quot;;&#125; 在这种情况下，返回值和输入是有直接关系的，所以不能像情况 1 中那样使用： 12local level,heath,namelevel,heath,name = self:GetPlayerBaseInfo(level,heath,name); 在这种情况下，在 lua 里调用传入的参数和返回的参数是都 必须 要传递和接收的，这样才会有正常的行为，如果不接收返回值： 12local level,heath,nameself:GetPlayerBaseInfo(level,heath,name); level,heath,name这些传进去的对象的值并不会像 C++ 中传递的引用那样值会改变。 所以函数怎么调用还是要看函数里是怎么写的。 这个在 UnLua 的 issus 里有提到：issus/25 检测是否继承接口C++ 里使用UKismetSystemLibrary::DoesImplementInterface，Lua 里也一样，不过区别是接口类型的传入： 1234567local CubeClass = UE4.UClass.Load(&quot;/Game/Cube_Blueprint.Cube_Blueprint&quot;)local World = self:GetWorld()local Cube_Ins = World:SpawnActor(CubeClass,self:GetTransform(),UE4.ESpawnActorCollisionHandlingMethod.AlwaysSpawn, self, self)if UE4.UKismetSystemLibrary.DoesImplementInterface(Cube_Ins,UE4.UMyInterface) then print(fmt(&quot;&#123;1&#125; inheritanced &#123;2&#125;&quot;,CubeClass,UE4.UMyInterface))end 要使用 UE4.U*Interface 这种形式。 获取 TScriptInterface 接口对象 当我们在 C++ 中获得一个接口时，获得的类型是 TScriptInterface&lt;&gt; 类型，本来以为还要自己导出 TScriptInterface 才可以拿到接口，但是发现并不是这样，UnLua 里可以直接拿到 TScriptInterface&lt;&gt; 就像普通的 UObject 对象： 如下面这样一个函数： 12UFUNCTION(BlueprintCallable, Category = &quot;GameCore|Flib|GameFrameworkStatics&quot;, meta = (CallableWithoutWorldContext,WorldContext=&quot;WorldContextObject&quot;))static TScriptInterface&lt;IINetGameInstance&gt; GetNetGameInstance(UObject* WorldContextObject); 在 Lua 里调用： 1local GameInstance = UE4.UFlibGameFrameworkStatics.GetNetGameInstance(self); 这个得到的类型在 C++ 里是 TScriptInterface&lt;&gt; 但在 Lua 里得到的就是该接口的 UObject 对象。 调用成员函数 上面讲了怎么得到 TScriptInterface 的接口（在 lua 里得到的其实就是该接口的 UObject），那么怎么通过它来调用接口的函数呢？有三种方法。 1234567891011121314// This class does not need to be modified.UINTERFACE(BlueprintType,MinimalAPI)class UINetGameInstance : public UIBaseEntityInterface&#123; GENERATED_BODY()&#125;;class GWORLD_API IINetGameInstance&#123; GENERATED_BODY()public: UFUNCTION(Category = &quot;GameCore|GamePlayFramework&quot;) virtual bool FindSubsystem(const FString&amp; InSysName,TScriptInterface&lt;IISubsystem&gt;&amp; OutSubsystem)=0;&#125;; 通过对象调用函数 可以通过拿到实现接口的对象然后通过该对象调用函数（使用 lua 的 : 操作符）： 12local GameInstance = UE4.UFlibGameFrameworkStatics.GetNetGameInstance(self);local findRet1,findRet2 = GameInstance:FindSubsystem(&quot;TouchController&quot;) 指定类和函数名调用 也可以直接通过指定实现该接口的类型名字来调用，就像函数指针，需要把调用该函数的对象传递进去： 12local GameInstance = UE4.UFlibGameFrameworkStatics.GetNetGameInstance(self);local findRet1,findRet2 = UE4.UNetGameInstance.FindSubsystem(GameInstance,&quot;TouchController&quot;) 指定接口的类和函数名调用 以及通过接口的类型调用（因为接口也是 UClass，接口中的函数也都标记了 UFUNCTION）： 12local GameInstance = UE4.UFlibGameFrameworkStatics.GetNetGameInstance(self);local findRet1,findRet2 = UE4.UINetGameInstance.FindSubsystem(GameInstance,&quot;TouchController&quot;) 获取 UClasslua 中获取 uclass 可以用于创建对象，其方法为： 1local uclass = UE4.UClass.Load(&quot;/Game/Core/Blueprints/AI/BP_AICharacter.BP_AICharacter_C&quot;) Load 的路径是该类的PackagePath。 如，在 lua 中加载 UMG 的类然后创建并添加至视口： 12345function LoadingMap_C:ReceiveBeginPlay() local UMG_C = UE4.UClass.Load(&quot;/Game/Test/BPUI_TestMain.BPUI_TestMain_C&quot;) local UMG_TestMain_Ins = UE4.UWidgetBlueprintLibrary.Create(self,UMG_C) UMG_TestMain_Ins:AddToViewport()end 注意：UnLua 官方的 UE4.UClass.Load 实现是默认只能创建蓝图类的，具体实现看 LuaLib_Class.cpp 中的 UClass_Load 的实现。 可以修改一下支持 C++ 的类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int32 UClass_Load(lua_State *L)&#123; int32 NumParams = lua_gettop(L); if (NumParams != 1) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid parameters!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; const char *ClassName = lua_tostring(L, 1); if (!ClassName) &#123; UE_LOG(LogUnLua, Log, TEXT(&quot;%s: Invalid class name!&quot;), ANSI_TO_TCHAR(__FUNCTION__)); return 0; &#125; FString ClassPath(ClassName); bool IsCppClass = ClassPath.StartsWith(TEXT(&quot;/Script&quot;)); if (!IsCppClass) &#123; const TCHAR *Suffix = TEXT(&quot;_C&quot;); int32 Index = INDEX_NONE; ClassPath.FindChar(TCHAR(&#x27;.&#x27;), Index); if (Index == INDEX_NONE) &#123; ClassPath.FindLastChar(TCHAR(&#x27;/&#x27;), Index); if (Index != INDEX_NONE) &#123; const FString Name = ClassPath.Mid(Index + 1); ClassPath += TCHAR(&#x27;.&#x27;); ClassPath += Name; ClassPath.AppendChars(Suffix, 2); &#125; &#125; else &#123; if (ClassPath.Right(2) != TEXT(&quot;_C&quot;)) &#123; ClassPath.AppendChars(TEXT(&quot;_C&quot;), 2); &#125; &#125; &#125; FClassDesc *ClassDesc = RegisterClass(L, TCHAR_TO_ANSI(*ClassPath)); if (ClassDesc &amp;&amp; ClassDesc-&gt;AsClass()) &#123; UnLua::PushUObject(L, ClassDesc-&gt;AsClass()); &#125; else &#123; lua_pushnil(L); &#125; return 1;&#125; C++ 类的路径为： 1/Script/GWorld.GWorldGameEngine 以 /Script 开头，其后是该 C++ 类所属的模块名，.之后的是类名（不包含 U/A 之类的开头）。 LoadObject把资源加载到内存： 1local Object = LoadObject(&quot;/Game/Core/Blueprints/AI/BT_Enemy&quot;) 比如加载某个材质球给模型： 1234function Cube3_Blueprint_C:ReceiveBeginPlay() local MatIns = LoadObject(&quot;/Game/TEST/Cube_Mat_Ins&quot;) UE4.UPrimitiveComponent.SetMaterial(self.StaticMeshComponent,0,MatIns)end 注：LuaObject 在 UnLua 里对应的是LoadObject&lt;Object&gt;: 123456int32 UObject_Load(lua_State *L)&#123;// ... UObject *Object = LoadObject&lt;UObject&gt;(nullptr, *ObjectPath);// ...&#125; 创建对象 注意：Lua 中创建的对象使用动态绑定是绑定到该类的 UCLASS 上，并不是绑定到该 New 出来的实例。 UnLua 中对 NewObject 处理的代码为Global_NewObject： 12FScopedLuaDynamicBinding Binding(L, Class, ANSI_TO_TCHAR(ModuleName), TableRef);UObject *Object = StaticConstructObject_Internal(Class, Outer, Name); SpawnActorLua 中 SpawnActor 以及动态绑定： 123local World = self:GetWorld()local WeaponClass = UE4.UClass.Load(&quot;/Game/Core/Blueprints/Weapon/BP_DefaultWeapon.BP_DefaultWeapon&quot;)local NewWeapon = World:SpawnActor(WeaponClass, self:GetTransform(), UE4.ESpawnActorCollisionHandlingMethod.AlwaysSpawn, self, self, &quot;Weapon.BP_DefaultWeapon_C&quot;) NewObjectlua 中调用 NewObject 以及动态绑定： 1local ProxyObj = NewObject(ObjClass, self, nil, &quot;Objects.ProxyObject&quot;) UnLua 中的 NewObject 可以接收四个参数，依次是：创建的 UClass、Outer、Name，以及动态绑定的 Lua 脚本。 Component 注意：原版 UnLua 只可以加载 BP 的 UClass，这个需要做改动 (修改LuaLib_Class.cpp 中的 UClass_Load 函数，检测传入是 C++ 类时把添加 _C 后缀的逻辑去掉)， 而且创建 Component 时也需要对其调用 OnComponentCreated 和RegisterComponent，这两个函数不是 UFUNCTION，需要手动导出。 导出 ActorComponent 中 OnComponentCreated 和RegisterComponent等函数： 123456789// Export Actor ComponentBEGIN_EXPORT_REFLECTED_CLASS(UActorComponent) ADD_FUNCTION(RegisterComponent) ADD_FUNCTION(OnComponentCreated) ADD_FUNCTION(UnregisterComponent) ADD_CONST_FUNCTION_EX(&quot;IsRegistered&quot;,bool, IsRegistered) ADD_CONST_FUNCTION_EX(&quot;HasBeenCreated&quot;,bool, HasBeenCreated)END_EXPORT_CLASS()IMPLEMENT_EXPORTED_CLASS(UActorComponent) 则使用时与 C++ 的使用方法一致： 123456789local StaticMeshClass = UE4.UClass.Load(&quot;/Script/Engine.StaticMeshComponent&quot;)local MeshObject = LoadObject(&quot;/Engine/VREditor/LaserPointer/CursorPointer&quot;)local StaticMeshComponent= NewObject(StaticMeshClass,self,&quot;StaticMesh&quot;)StaticMeshComponent:SetStaticMesh(MeshObject)StaticMeshComponent:RegisterComponent()StaticMeshComponent:OnComponentCreated()self:ReceiveStaticMeshComponent(StaticMeshComponent)-- StaticMeshComponent:K2_AttachToComponent(self.StaticMeshComponent,&quot;&quot;,EAttachmentRule.SnapToTarget,EAttachmentRule.SnapToTarget,EAttachmentRule.SnapToTarget)UE4.UStaticMeshComponent.K2_AttachToComponent(StaticMeshComponent,self.StaticMeshComponent,&quot;&quot;,EAttachmentRule.SnapToTarget,EAttachmentRule.SnapToTarget,EAttachmentRule.SnapToTarget) UMG创建 UMG 首先需要获取到 UI 的 UClass，然后使用 UWidgetBlueprintLibrary::Create 来创建，与 C++ 一致： 123local UMG_C = UE4.UClass.Load(&quot;/Game/Test/BPUI_TestMain.BPUI_TestMain_C&quot;)local UMG_TestMain_Ins = UE4.UWidgetBlueprintLibrary.Create(self,UMG_C)UMG_TestMain_Ins:AddToViewport() 绑定代理 动态多播代理 在 C++ 代码中写了一个动态多播代理： 12345DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FGameInstanceDyDlg, const FString&amp;,InString);// in classUPROPERTY()FGameInstanceDyDlg GameInstanceDyDlg; 在 lua 中绑定，可以绑定到 lua 的函数： 1234567local GameInstance = UE4.UFlibGameFrameworkStatics.GetNetGameInstance(self);GameInstance.GameInstanceDyMultiDlg:Add(self,LoadingMap_C.BindGameInstanceDyMultiDlg)-- test bind dynamic multicast delegate lua funcfunction LoadingMap_C:BindGameInstanceDyMultiDlg(InString) UE4.UKismetSystemLibrary.PrintString(self,InString)end 同样也可以对该代理进行调用、清理、移除： 123456-- remove GameInstance.GameInstanceDyMultiDlg:Remove(self,LoadingMap_C.BindGameInstanceDyDlg)-- ClearGameInstance.GameInstanceDyMultiDlg:Clear()-- broadcastGameInstance.GameInstanceDyMultiDlg:Broadcast(&quot;66666666&quot;) 动态代理C++ 中有如下动态代理声明： 12345DECLARE_DYNAMIC_DELEGATE_OneParam(FGameInstanceDyDlg,const FString&amp;,InString);// in classUPROPERTY()FGameInstanceDyDlg GameInstanceDyDlg; 在 lua 中绑定： 123456GameInstance.GameInstanceDyDlg:Bind(self,LoadingMap_C.BindGameInstanceDyMultiDlg)-- test bind dynamic delegate lua funcfunction LoadingMap_C:BindGameInstanceDyDlg(InString) UE4.UKismetSystemLibrary.PrintString(self,InString)end 动态代理支持 Bind/Unbind/Execute 操作： 123456-- bindGameInstance.GameInstanceDyDlg:Bind(self,LoadingMap_C.BindGameInstanceDyMultiDlg)-- UnBindGameInstance.GameInstanceDyDlg:Unbind()-- ExecuteGameInstance.GameInstanceDyDlg:Execute(&quot;GameInstanceDyMultiDlg&quot;) 不支持非 Dynamic Delegate因为 BindStatic/BindRaw/BindUFunction 这些都是模板函数，UnLua 的静态导出方案不支持将他们导出。 官方 issus：如何正确静态导出继承自 FScriptDelegate 的普通委托 使用异步事件 Delay 如果想要使用类似 Delay 的函数： 123456789/** * Perform a latent action with a delay (specified in seconds). Calling again while it is counting down will be ignored. * * @param WorldContextWorld context. * @param Duration length of delay (in seconds). * @param LatentInfo The latent action. */UFUNCTION(BlueprintCallable, Category=&quot;Utilities|FlowControl&quot;, meta=(Latent, WorldContext=&quot;WorldContextObject&quot;, LatentInfo=&quot;LatentInfo&quot;, Duration=&quot;0.2&quot;, Keywords=&quot;sleep&quot;))static voidDelay(UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo ); 在 lua 中可以通过 协程 (coroutine) 来实现： 123456789function LoadingMap_C:DelayFunc(Induration) coroutine.resume(coroutine.create( function(WorldContectObject,duration) UE4.UKismetSystemLibrary.Delay(WorldContectObject,duration) UE4.UKismetSystemLibrary.PrintString(WorldContectObject,&quot;Helloworld&quot;) end ), self,Induration)end 就是通过 coroutine.create 绑定上一个函数，可以直接在 coroutine.create 里写，或者绑定上一个已有的函数： 12345678function LoadingMap_C:DelayFunc(Induration) coroutine.resume(coroutine.create(LoadingMap_C.DoDelay),self,self,Induration)endfunction LoadingMap_C:DoDelay(WorldContectObject,duration) UE4.UKismetSystemLibrary.Delay(WorldContectObject,duration) UE4.UKismetSystemLibrary.PrintString(WorldContectObject,&quot;Helloworld&quot;)end 但是要 注意一点：在绑定已有的 lua 函数时，传递的参数需要多一个self，标识调用指定函数的调用者。 1coroutine.resume(coroutine.create(LoadingMap_C.DoDelay),self,self,Induration) 这里的第一个 self，就是在通过self 调用LoadingMap_C.DoDelay，后面的两个参数才作为传递给协程函数的参数。 调用代码为： 1234function LoadingMap_C:ReceiveBeginPlay() -- 5s 后输出 HelloWorld self:DelayFunc(5.0)end 注意：对于直接是 UFUNCTION 但是带有 FLatentActionInfo 的函数可以直接使用上面的方法，但是对于 UE 封装的异步节点，不是函数而是一个类的节点需要自己导出。 AsyncLoadPrimaryAsset在 C++ 里可以使用 UAsyncActionLoadPrimaryAsset::AsyncLoadPrimaryAsset 来异步加载资源： 123456/** * Load a primary asset into memory. The completed delegate will go off when the load succeeds or fails, you should cast the Loaded object to verify it is the correct type. * If LoadBundles is specified, those bundles are loaded along with the asset */UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly=&quot;true&quot;, Category = &quot;AssetManager&quot;, AutoCreateRefTerm = &quot;LoadBundles&quot;, WorldContext = &quot;WorldContextObject&quot;))static UAsyncActionLoadPrimaryAsset* AsyncLoadPrimaryAsset(UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray&lt;FName&gt;&amp; LoadBundles); 想要在 Lua 中使用的话需要把 FPrimaryAssetId 这个结构导出： 12345678910#include &quot;UnLuaEx.h&quot;#include &quot;LuaCore.h&quot;#include &quot;UObject/PrimaryAssetId.h&quot;BEGIN_EXPORT_CLASS(FPrimaryAssetId,const FString&amp;) ADD_FUNCTION_EX(&quot;ToString&quot;,FString, ToString) ADD_STATIC_FUNCTION_EX(&quot;FromString&quot;,FPrimaryAssetId, FromString,const FString&amp;) ADD_FUNCTION_EX(&quot;IsValid&quot;, bool, IsValid)END_EXPORT_CLASS()IMPLEMENT_EXPORTED_CLASS(FPrimaryAssetId) 然后就可以在 Lua 中使用了，如异步加载关卡资源，加载完成后打开： 12345678910function Cube_Blueprint_C:ReceiveBeginPlay() local Map = UE4.FPrimaryAssetId(&quot;Map:/Game/Test/LoadingMap&quot;) local AsyncActionLoadPrimaryAsset = UE4.UAsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset(self,Map,nil) AsyncActionLoadPrimaryAsset.Completed:Add(self,Cube_Blueprint_C.ReceiveLoadedMap) AsyncActionLoadPrimaryAsset:Activate()endfunction Cube_Blueprint_C:ReceiveLoadedMap(Object) UE4.UGameplayStatics.OpenLevel(self,&quot;/Game/Test/LoadingMap&quot;,true)end SetTimer有些需求需要 Timer 循环调用，在 C++ 里可以使用 UKismetSystemLibrary::K2_SetTimerDelegate，在蓝图中对应的是SetTimerByEvent，因为它是UFUNCTION 的函数，所以在 lua 中也可以调用。 绑定代理和清理操作： 12345678910111213function LoadingMap_C:ReceiveBeginPlay() UpdateUILoopCount = 0; UpdateUITimerHandle = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;self,LoadingMap_C.UpdateUI&#125;,0.3,true)endfunction LoadingMap_C:UpdateUI() if UpdateUILoopCount &lt; 10 then print(&quot;HelloWorld&quot;) UpdateUILoopCount = UpdateUILoopCount + 1 else UE4.UKismetSystemLibrary.K2_ClearAndInvalidateTimerHandle(self,UpdateUITimerHandle) end end {self,FUNCTION}会创建出来一个 Delegate，本来还以为要自己导出一个创建 Dynamic Delegate 的方法，其实不用。 绑定 UMG 控件事件 如果要绑定类似 UButton 的OnPressed/OnClicked/OnReleased/OnHovered/OnUnhovered等事件，它们都是多播代理，所以要用 Add 来添加： 1234DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnButtonClickedEvent);DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnButtonPressedEvent);DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnButtonReleasedEvent);DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnButtonHoverEvent); 在 lua 中绑定： 1234567function UMG_LoadingMap_C:Construct() self.ButtonItem.OnPressed:Add(self,UMG_LoadingMap_C.OnButtonItemPressed)endfunction UMG_LoadingMap_C:OnButtonItemPressed() print(&quot;On Button Item Pressed&quot;)end UE4.TArrayUnlua 里使用 UE4.TArray 的下标规则是从 1 开始的，而不是与引擎中相同的 0.issues/41 CastUnLua 里的类型转换语法为： 1Obj:Cast(UE4.AActor) 如： 1local Character = Pawn:Cast(UE4.ABP_CharacterBase_C) lua 使用蓝图结构 在 bp 里创建一个蓝图结构:在 UnLua 里可以通过下列方式访问: 12345local bp_struct_ins = UE4.FBPStruct()bp_struct_ins.string = &quot;123456&quot;bp_struct_ins.int32 = 12345bp_struct_ins.float = 123.456print(fmt(&quot;string: &#123;&#125;,int32: &#123;&#125;,float: &#123;&#125;&quot;,bp_struct_ins.string,bp_struct_ins.int32,bp_struct_ins.float)) 可以像 C++ 的结构那样使用, 需要 注意 的地方为, 需要在蓝图结构类型的名字前加F, 如上面的例子里, 在蓝图中的名字为BPStruct, 在 UnLua 中访问时则为FBPStruct. Insight Profiler详见 wiki：Insight Profiling in lua","tags":[{"name":"UnLua","slug":"UnLua","permalink":"https://ue5wiki.com/tags/UnLua/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Lua","slug":"Lua","permalink":"https://ue5wiki.com/tags/Lua/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"Lua","slug":"Programming/Lua","permalink":"https://ue5wiki.com/categories/Programming/Lua/"}]},{"title":"UE4 Rendering Dependency Graph","date":"2020-03-02T00:00:00.000Z","path":"wiki/external1873084730/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 Rendering Dependency Graph。","tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/tags/Rendering/"},{"name":"RDG","slug":"RDG","permalink":"https://ue5wiki.com/tags/RDG/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"RDG","slug":"Rendering/RDG","permalink":"https://ue5wiki.com/categories/Rendering/RDG/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4renderingdependencygraph/"},{"title":"UEC++ 与标准 C++ 的区别与联系","date":"2020-02-11T11:22:44.000Z","path":"wiki/20425/","text":"UEC++ 本质是 C++ 的一个超集，它支持和使用 C++ 的全部特性，但是它在标准特性之上自己构建了一套语法。很多开发中的编译问题只有知道了两者的边界，才能够快速和准确地定位问题出现在哪个阶段。对于使用 UE 之前就学习过 C++ 的来说这不是什么问题，但是对于先接触 UE 然后慢慢学 C++ 的同学来说，这是个挺大的问题。 标准 C++是基于 ISO/IEC 14882 的语言规范（C++98/03/11/14/17 等标准），UEC++ 则是我们开发当中使用的 Epic 在标准 C++ 之上扩展的用法，这里不讨论 GC、反射之类的基于 C++ 之上自己构建的对象体系，也不涉及 UE 中的各种库，关注的着重点在于核心语法层面。 近期博客的更新文章里，写了一些 UE 反射机制的内容，可以作为本篇文章的进阶内容结合来看： UE4 反射实现分析：基础概念 UE4 反射实现分析：C++ 特性 UE4 的反射实现分析：反射代码生成（一） 在 UE4.23+ 以后，UE 所支持的 C++ 标准是可以被控制的，在 *.target.cs 和*.build.cs中均可以设置 CppStandard 的值，目前有三个标准可选：Cpp14、Cpp17、Latast，它控制了传递给编译器的 /std:c++* 值。 开始具体的分析之前，首先要知道标准 C++ 和 UE C++ 都是怎么执行编译的，因为只有先区分了最根本的使用区别，才能够进一步分析为什么会有这些区别。 编译标准 C++ 代码 首先，C++ 的代码只依赖于编译器，如下面代码: 12345678// hw.cpp#include &lt;iostream&gt;#define HW_MSG &quot;HelloWorld&quot;int main()&#123; std::cout&lt;&lt;HW_MSG&lt;&lt;std::endl;&#125; 想要编译上面的代码，需要使用一个编译器（GCC/MSVC）等，VS 使用的是 MSVC，以 GCC 为例： 1$ g++ hw.cpp -o hw.exe 通过这一行命令就会编译出 hw.exe，但是编译器是一套工具链，虽然只执行了一条命令，但是它其实是调用了一串的工具进行预处理、语法分析、编译、链接等等一系列操作，不过它们不是本篇文章的重点，有兴趣的可以看一下我之前的这篇文章：C/C++ 编译和链接模型分析 。 举上面的例子需要关注的有两点： 标准 C++ 语法可以直接用编译器编译； 编译器对代码需要执行预处理、语法分析、编译、链接等操作； 编译 UEC++ 代码 首先，UEC++ 代码，并不像标准 C++ 那样把代码单独存在一个文件就可以编译的，UE 自己搭建了一套编译体系，所有基于 UE 引擎的代码必须要通过 UE 的这套编译体系才可以编译。我之前写过 UE 构建系统的一些文章，想要 UE 项目的构建系统可以看一下： Build flow of the Unreal Engine4 project UE4 Build System：Target and Module UEC++ 的代码必须要依赖于一个UE 项目，其基本项目结构为： 123456789Example\\GWorld\\Source&gt;tree /a /f| GWorld.Target.cs|\\---GWorld GWorld.Build.cs GWorld.cpp GWorld.h Public/ Private/ 其中各个文件的职责为： *.Target.cs是用来控制的是生成的可执行程序的外部编译环境，就是所谓的 Target。比如，生成的是什么 Type(Game/Client/Server/Editor/Program)，开不开启 RTTI(bForceEnableRTTI)，CRT 使用什么方式链接(bUseStaticCRT) 等等。 *.Build.cs控制的是 Module 编译过程，由它来控制所属 Module 的对其他 Module 的依赖、文件包含、链接、宏定义等等相关的操作，*.Build.cs告诉 UE 的构建系统，它是一个 Module，并且编译的时候要做哪些事情。 其余的是代码源文件(一般情况下头文件放在Public/，实现放在Private/) UE 构建系统的重点是 UBT 和 UHT，他们各自的作用我之前的文章中有提到： UBT 的作用是收集和构建编译环境，调用 UHT 生成代码，然后 调用真正的编译器进行编译 UHT 的作用是把项目中所有代码里的 UHT 标记翻译为真正的 C++ 代码（如 UCLASS/GENERATED_BODY 等等），它属于 UBT 工作流程中的一环 上面写的需要关注的有三点： UEC++ 的代码必须通过 UE 自己的构建体系 UEC++ 的代码必须要通过 UHT 进行翻译成 真正的 C++ 代码 UE 的项目里真正进入编译阶段的，全部都是标准 C++ 的代码 所以，UEC++ 和标准 C++ 的区别在于，UEC++ 自己定义了一些语法，需要通过专门的解释器进行翻译，然后再通过 C++ 编译器进行编译（进入标准 C++ 的编译流程）。 关于流程上的区别就说这么多，下面的内容来写 UE 具体有哪些特殊的语法。 UEC++ 的特殊语法 UEC++ 的特殊语法主要是用于指导 UHT 来产生辅助代码的方式。 来聊 UEC++ 的特殊语法之前，需要先明确一点：UCLASS/UFUNCTION/UPROPERTY等都不是 真正有意义的 C++ 宏 ，他们是UHT 的标记，在经过 UHT 生成代码之后他们就是空宏了，没有意义。UE 的代码是把UHT 标记 和真正的宏 都以 宏的形式 来表现，从结果来说，它们都是生成了一些代码，但是它们的处理流程不同。UHT 标记是先通过 UHT 进行扫描并生成代码，再通过编译器进行预处理等等，这里存在一个先后的过程，其限制就为：对 UHT 对代码的处理在前，编译器对宏的预处理在后，所以在 UE 中没办法用宏来包裹 UHT 标记。 UE 的 UHT 标记包括但不限于： Function Specifiers Metadata Specifiers Property Specifiers Struct Specifiers Interfaces 可以从 Runtime\\CoreUObject\\Public\\ObjectMacros.h 看更多的 UHT 标记，有一个简单的分辨方法：如果这个宏是一个空宏，那么它就是一个 UHT 标记： 12345678910111213141516171819202122232425262728293031323334// Runtime\\CoreUObject\\Public\\ObjectMacros.h// ...// These macros wrap metadata parsed by the Unreal Header Tool, and are otherwise// ignored when code containing them is compiled by the C++ compiler#define UPROPERTY(...)#define UFUNCTION(...)#define USTRUCT(...)#define UMETA(...)#define UPARAM(...)#define UENUM(...)#define UDELEGATE(...)// This pair of macros is used to help implement GENERATED_BODY() and GENERATED_USTRUCT_BODY()#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)// Include a redundant semicolon at the end of the generated code block, so that intellisense parsers can start parsing// a new declaration if the line number/generated code is out of date.#define GENERATED_BODY_LEGACY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY_LEGACY);#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);#define GENERATED_USTRUCT_BODY(...) GENERATED_BODY()#define GENERATED_UCLASS_BODY(...) GENERATED_BODY_LEGACY()#define GENERATED_UINTERFACE_BODY(...) GENERATED_BODY_LEGACY()#define GENERATED_IINTERFACE_BODY(...) GENERATED_BODY_LEGACY()#if UE_BUILD_DOCS || defined(__INTELLISENSE__)#define UCLASS(...)#else#define UCLASS(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_PROLOG)#endif#define UINTERFACE(...) UCLASS()// ... 下面简单列举一些： *.generated.h这个文件是 UE 特有的，它是 UHT 生成的代码（大多都是宏） UCLASS/UFUNCTION/UPROPERTY/UENUM等 标记 在 C++ 中是没有的，它们的作用是指导 UHT 生成什么样的辅助代码； GENERATED_BODY等系列宏标准 C++ 是没有的，它的作用在于把 UHT 生成的代码包含到当前类中来； BlueprintNativeEvent函数的实现需要加 _Implementation，这个规则是没有的，上面提到了 C++ 中连UFUNCTION 都没有； C++ 中没有 Slate UE 项目中的宏都会生成在 Intermediate\\Build\\Win64\\UE4Editor\\Development\\MODULE_NAME 下，如 MODULE_NAME_API 是导出符号，在标准 C++ 项目中需要你自己定义导出。 标准 C++ 的接口可以通过抽象类的来实现，并不需要一个特定基类，而且并没有 UE 中不可以提供数据成员的限制（仅从语法的角度，当然从设计思路上接口要无状态） 标准 C++ 没有 UE 中的 DELEGATE Cast&lt;&gt;和 NewObject&lt;&gt; 是 UE 特有的，C++ 使用四种标准 cast 和new C++ 也没有 UE 的 Thunk 函数 … 了解 UEC++ 和标准 C++ 的区别的关键点在于能够了解两者在构建流程上的区别，这一点能够区分开之后，再多的语法区别都是在这个结构内。至于 UEC++ 的反射，这是另一个可以写很大篇幅的内容了，先挖个坑。 如何学习 C++从最开始接触 C 语言到现在快有十年了，也看了不少 C++ 的书，但是我觉得学习 C++ 最重要的是要去了解一下那些特性为什么这么设计，受哪些历史特性的限制，了解特性之间的关联，再去看看这些特性的编译器的实现，很多犄角旮旯的东西产生的原因就很明显了。推荐一些书（建议按照顺序阅读，带 * 建议必读）： The C Programing Language *C++ Primer / The C++ Programming Language *inside the c++ object model *Effective C++ Modern Effective C++ C++ coding standard: 101 rules, guidelines and best practices *The design and evolution of c++ 前两本是基础语法，如果没有太多时间，可以读 C++ Primer 或者 TC++PL 中的其中一本即可，我还写过一篇文章对比这两本书 读 TC++PL、C++Primer 和 ISO C++，有兴趣的可以读一下，学习 C++ 后面的路还很长。我建议学完基础语法之后就开始大量地写代码，因为只看懂了理论，不上手多写是没有意义的。 如何学习 UEC++在 C++ 的基础语法学的差不多了之后，直接就开始在 UE 中写项目吧，作为 开放源代码 的引擎（但 UE 不是开源软件，许可证区别），没有什么是藏着掖着的，可以在边写项目的同时边尝试看 UE 引擎里的代码，去尝试分析 UE 的构建流程和代码生成。 我的一个小技巧就是，可以多去翻一下 Intermediate 中通过 UHT 生产的代码，不少的错误或者疑问的问题都能在里面找到答案。 最重要的还是：多看！多写！多思考！","tags":[{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"}]},{"title":"修改游戏默认的数据存储路径","date":"2020-01-22T09:10:02.000Z","path":"wiki/20367/","text":"默认情况下，使用 UE 打包出游戏的 Apk 并在手机上安装之后，启动游戏会在 /storage/emulated/0/UE4Game/ 下创建游戏的数据目录 (也就是内部存储器的根目录下)。按照 Google 的规则，每个 APP 的数据文件最好都是放在自己的私有目录，所以我想要把 UE 打包出来的游戏的数据全放到/storage/emulated/0/Android/data/PACKAGE_NAME 目录中 (不管是 log、ini、还是 crash 信息)。 一个看似简单的需求，有几种不同的方法，涉及到了 UE4 的路径管理 /JNI/Android Manifest 以及对 UBT 的代码的分析。 默认的路径： 有两种方法，一种是改动引擎代码实现对 GFilePathBase 的修改，另一种是不改动引擎只添加项目设置中的 manifest 就可以，当然不改动引擎是最好的，不过既然是分析，我就两个都来搞一下，顺便从 UBT 代码分析一下 Project Setting-Android-Use ExternalFilesDir for UE4Game Files 选项没有作用的原因。 改动引擎代码实现 翻了一下引擎代码，发现路径的这部分代码是写在这里的：AndroidPlatformFile.cpp#L946，它是在 GFilePathBase 然后组合 UE4Game+PROJECT_NAME 的路径。 在 UE4.22 及之前的引擎版本中是在 AndroidFile.cpp 文件中的，4.23+ 是在 AndroidPlatformFile.cpp 中的。基础路径 GFilePathBase 的初始化是在 Launch\\Private\\Android\\AndroidJNI.cpp 中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Launch\\Private\\Android\\AndroidJNI.cppJNIEXPORT jint JNI_OnLoad(JavaVM* InJavaVM, void* InReserved)&#123; FPlatformMisc::LowLevelOutputDebugString(TEXT(&quot;In the JNI_OnLoad function&quot;)); JNIEnv* Env = NULL; InJavaVM-&gt;GetEnv((void **)&amp;Env, JNI_CURRENT_VERSION); // if you have problems with stuff being missing especially in distribution builds then it could be because proguard is stripping things from java // check proguard-project.txt and see if your stuff is included in the exceptions GJavaVM = InJavaVM; FAndroidApplication::InitializeJavaEnv(GJavaVM, JNI_CURRENT_VERSION, FJavaWrapper::GameActivityThis); FJavaWrapper::FindClassesAndMethods(Env); // hook signals if (!FPlatformMisc::IsDebuggerPresent() || GAlwaysReportCrash) &#123; // disable crash handler.. getting better stack traces from system for now //FPlatformMisc::SetCrashHandler(EngineCrashHandler); &#125; // Cache path to external storage jclass EnvClass = Env-&gt;FindClass(&quot;android/os/Environment&quot;); jmethodID getExternalStorageDir = Env-&gt;GetStaticMethodID(EnvClass, &quot;getExternalStorageDirectory&quot;, &quot;()Ljava/io/File;&quot;); jobject externalStoragePath = Env-&gt;CallStaticObjectMethod(EnvClass, getExternalStorageDir, nullptr); jmethodID getFilePath = Env-&gt;GetMethodID(Env-&gt;FindClass(&quot;java/io/File&quot;), &quot;getPath&quot;, &quot;()Ljava/lang/String;&quot;); jstring pathString = (jstring)Env-&gt;CallObjectMethod(externalStoragePath, getFilePath, nullptr); const char *nativePathString = Env-&gt;GetStringUTFChars(pathString, 0); // Copy that somewhere safe GFilePathBase = FString(nativePathString); GOBBFilePathBase = GFilePathBase; // then release... Env-&gt;ReleaseStringUTFChars(pathString, nativePathString); Env-&gt;DeleteLocalRef(pathString); Env-&gt;DeleteLocalRef(externalStoragePath); Env-&gt;DeleteLocalRef(EnvClass); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Path found as &#x27;%s&#x27;\\n&quot;), *GFilePathBase); // Get the system font directory jstring fontPath = (jstring)Env-&gt;CallStaticObjectMethod(FJavaWrapper::GameActivityClassID, FJavaWrapper::AndroidThunkJava_GetFontDirectory); const char * nativeFontPathString = Env-&gt;GetStringUTFChars(fontPath, 0); GFontPathBase = FString(nativeFontPathString); Env-&gt;ReleaseStringUTFChars(fontPath, nativeFontPathString); Env-&gt;DeleteLocalRef(fontPath); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;Font Path found as &#x27;%s&#x27;\\n&quot;), *GFontPathBase); // Wire up to core delegates, so core code can call out to Java DECLARE_DELEGATE_OneParam(FAndroidLaunchURLDelegate, const FString&amp;); extern CORE_API FAndroidLaunchURLDelegate OnAndroidLaunchURL; OnAndroidLaunchURL = FAndroidLaunchURLDelegate::CreateStatic(&amp;AndroidThunkCpp_LaunchURL); FPlatformMisc::LowLevelOutputDebugString(TEXT(&quot;In the JNI_OnLoad function 5&quot;)); char mainThreadName[] = &quot;MainThread-UE4&quot;; AndroidThunkCpp_SetThreadName(mainThreadName); return JNI_CURRENT_VERSION;&#125; 我们的目的就是要改动 GFilePathBase 的值，因为默认引擎里是通过调用 getExternalStorageDirectory 得到的，其是外部存储的目录即 /storage/emulated/0/，再拼接上UE4Game 就是默认平时我们看到的路径。 因为 getExternalStorageDirectory 这些都是 Environment 的静态成员，没有我们想要获取的路径的方法，但是 Context 中有，UE 的代码中并没有获取到，所以我们要像一个办法得到 App 的 Context。 可以通过下列方法从 JNI 获取 Context，: 12345678910// get contextjobject JniEnvContext;&#123; jclass activityThreadClass = Env-&gt;FindClass(&quot;android/app/ActivityThread&quot;); jmethodID currentActivityThread = FJavaWrapper::FindStaticMethod(Env, activityThreadClass, &quot;currentActivityThread&quot;, &quot;()Landroid/app/ActivityThread;&quot;, false); jobject at = Env-&gt;CallStaticObjectMethod(activityThreadClass, currentActivityThread); jmethodID getApplication = FJavaWrapper::FindMethod(Env, activityThreadClass, &quot;getApplication&quot;, &quot;()Landroid/app/Application;&quot;, false); JniEnvContext = FJavaWrapper::CallObjectMethod(Env, at, getApplication);&#125; 之后可以使用 Context 下的函数 getExternalFilesDir 获取到我们想要的路径： 注意 getExternalFilesDir 的原型是：File getExternalFilesDir(String)，在使用 JNI 获取 jmehodID 时一定注意签名要传对，不然会 Crash，其签名是(Ljava/lang/String;)Ljava/io/File;。 1234567jmethodID getExternalFilesDir = Env-&gt;GetMethodID(Env-&gt;GetObjectClass(JniEnvContext), &quot;getExternalFilesDir&quot;, &quot;(Ljava/lang/String;)Ljava/io/File;&quot;);// get Filejobject ExternalFileDir = Env-&gt;CallObjectMethod(JniEnvContext, getExternalFilesDir,nullptr);// getPath method in File classjmethodID getFilePath = Env-&gt;GetMethodID(Env-&gt;FindClass(&quot;java/io/File&quot;), &quot;getPath&quot;, &quot;()Ljava/lang/String;&quot;);jstring pathString = (jstring)Env-&gt;CallObjectMethod(ExternalFileDir, getFilePath, nullptr);const char *nativePathString = Env-&gt;GetStringUTFChars(pathString, 0); 得到的 nativePathString 的值为： 1/storage/emulated/0/Android/data/com.imzlp.GWorld/files 其中的 com.imzlp.GWorld 是你的 App 的包名。 然后将其赋值给 GFilePathBase 即可，打开编辑器重新打包 Apk，安装上之后该 APP 所有的数据就会在 /storage/emulated/0/Android/data/PACKAGE_NAME/files 下了。 在 UE 中调用和操作 JNI 以及 Android 存储路径相关的链接： How to get the Android context instance when calling JNI method? Android JNI get Context Android Environment API Android Context API Android 存储路径你了解多少？ 使用 Manifest 控制 OK，关于分析引擎中修改GFilePathBase 的大致写完了，其实有个不改动引擎的办法，就是在项目设置中添加minifest。 其实原理也在 AndoidJNI.cpp 里了，AndroidJNI.cpp中有以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//This function is declared in the Java-defined class, GameActivity.java: &quot;public native void nativeSetGlobalActivity();&quot;JNI_METHOD void Java_com_epicgames_ue4_GameActivity_nativeSetGlobalActivity(JNIEnv* jenv, jobject thiz, jboolean bUseExternalFilesDir, jstring internalFilePath, jstring externalFilePath, jboolean bOBBinAPK, jstring APKFilename /*, jobject googleServices*/)&#123; if (!FJavaWrapper::GameActivityThis) &#123; GGameActivityThis = FJavaWrapper::GameActivityThis = jenv-&gt;NewGlobalRef(thiz); if (!FJavaWrapper::GameActivityThis) &#123; FPlatformMisc::LowLevelOutputDebugString(TEXT(&quot;Error setting the global GameActivity activity&quot;)); check(false); &#125; // This call is only to set the correct GameActivityThis FAndroidApplication::InitializeJavaEnv(GJavaVM, JNI_CURRENT_VERSION, FJavaWrapper::GameActivityThis); // @todo split GooglePlay, this needs to be passed in to this function FJavaWrapper::GoogleServicesThis = FJavaWrapper::GameActivityThis; // FJavaWrapper::GoogleServicesThis = jenv-&gt;NewGlobalRef(googleServices); // Next we check to see if the OBB file is in the APK //jmethodID isOBBInAPKMethod = jenv-&gt;GetStaticMethodID(FJavaWrapper::GameActivityClassID, &quot;isOBBInAPK&quot;, &quot;()Z&quot;); //GOBBinAPK = (bool)jenv-&gt;CallStaticBooleanMethod(FJavaWrapper::GameActivityClassID, isOBBInAPKMethod, nullptr); GOBBinAPK = bOBBinAPK; const char *nativeAPKFilenameString = jenv-&gt;GetStringUTFChars(APKFilename, 0); GAPKFilename = FString(nativeAPKFilenameString); jenv-&gt;ReleaseStringUTFChars(APKFilename, nativeAPKFilenameString); const char *nativeInternalPath = jenv-&gt;GetStringUTFChars(internalFilePath, 0); GInternalFilePath = FString(nativeInternalPath); jenv-&gt;ReleaseStringUTFChars(internalFilePath, nativeInternalPath); const char *nativeExternalPath = jenv-&gt;GetStringUTFChars(externalFilePath, 0); GExternalFilePath = FString(nativeExternalPath); jenv-&gt;ReleaseStringUTFChars(externalFilePath, nativeExternalPath); if (bUseExternalFilesDir) &#123;#if UE_BUILD_SHIPPING GFilePathBase = GInternalFilePath;#else GFilePathBase = GExternalFilePath;#endif FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;GFilePathBase Path override to&#x27;%s&#x27;\\n&quot;), *GFilePathBase); &#125; FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;InternalFilePath found as &#x27;%s&#x27;\\n&quot;), *GInternalFilePath); FPlatformMisc::LowLevelOutputDebugStringf(TEXT(&quot;ExternalFilePath found as &#x27;%s&#x27;\\n&quot;), *GExternalFilePath); &#125;&#125; 在引擎启动的时候会从 JNI 调过来，其中有一个参数 bUseExternalFilesDir 用来控制修改 GFilePathBase 的值，如果它为 ture，在 Shipping 打包的模式下就会把 GFilePathBase 设置为 GInternalFilePath 的值，也就是下列路径： 1/data/user/PACKAGE_NAME/files 在非 Shipping 打包模式下会设置为 GExternalFilePath 的值： 1/storage/emulated/0/Android/data/PACKAGE_NAME/files 但是，问题的关键是 bUseExternalFilesDir 这个从 JNI 调过来的参数我们又如何控制呢？ 问题的答案是添加 manifest 信息！本来以为是 ProjectSettings-Android-UseExternalFilesDirForUE4GameFiles 这个选项，但是选中没有任何效果，原因后面会分析。 在详细解释怎么通过 manifest 控制 bUseExternalFilesDir 这个变量之前，需要先知道，UE4 打包出来的 APK 的 Manifest 中默认有什么。 下列是我解包出来的 APK 中的 Manifest 文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:installLocation=&quot;internalOnly&quot; package=&quot;com.imzlp.TEST&quot; platformBuildVersionCode=&quot;29&quot; platformBuildVersionName=&quot;10&quot;&gt; &lt;application android:debuggable=&quot;true&quot; android:hardwareAccelerated=&quot;true&quot; android:hasCode=&quot;true&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;activity android:debuggable=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;singleTask&quot; android:name=&quot;com.epicgames.ue4.SplashActivity&quot; android:screenOrientation=&quot;landscape&quot; android:theme=&quot;@style/UE4SplashTheme&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:configChanges=&quot;density|keyboard|keyboardHidden|mcc|mnc|orientation|screenSize|uiMode&quot; android:debuggable=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;singleTask&quot; android:name=&quot;com.epicgames.ue4.GameActivity&quot; android:screenOrientation=&quot;landscape&quot; android:theme=&quot;@style/UE4SplashTheme&quot;&gt; &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;UE4&quot;/&gt; &lt;/activity&gt; &lt;activity android:configChanges=&quot;density|keyboard|keyboardHidden|mcc|mnc|orientation|screenSize|uiMode&quot; android:name=&quot;.DownloaderActivity&quot; android:screenOrientation=&quot;landscape&quot; android:theme=&quot;@style/UE4SplashTheme&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.EngineVersion&quot; android:value=&quot;4.22.3&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.EngineBranch&quot; android:value=&quot;++UE4+Release-4.22&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.ProjectVersion&quot; android:value=&quot;1.0.0.0&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.DepthBufferPreference&quot; android:value=&quot;0&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bPackageDataInsideApk&quot; android:value=&quot;true&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bVerifyOBBOnStartUp&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bShouldHideUI&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.ProjectName&quot; android:value=&quot;Mobile422&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.AppType&quot; android:value=&quot;&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bHasOBBFiles&quot; android:value=&quot;true&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.BuildConfiguration&quot; android:value=&quot;Development&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.CookedFlavors&quot; android:value=&quot;ETC2&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bValidateTextureFormats&quot; android:value=&quot;true&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseDisplayCutout&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bAllowIMU&quot; android:value=&quot;true&quot;/&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bSupportsVulkan&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;com.google.android.gms.games.APP_ID&quot; android:value=&quot;@string/app_id&quot;/&gt; &lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot;/&gt; &lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation|screenLayout|screenSize|smallestScreenSize|uiMode&quot; android:name=&quot;com.google.android.gms.ads.AdActivity&quot;/&gt; &lt;service android:name=&quot;OBBDownloaderService&quot;/&gt; &lt;receiver android:name=&quot;AlarmReceiver&quot;/&gt; &lt;receiver android:name=&quot;com.epicgames.ue4.LocalNotificationReceiver&quot;/&gt; &lt;receiver android:exported=&quot;true&quot; android:name=&quot;com.epicgames.ue4.MulticastBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.android.vending.INSTALL_REFERRER&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot;/&gt; &lt;/application&gt; &lt;uses-feature android:glEsVersion=&quot;0x00030000&quot; android:required=&quot;true&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt; &lt;uses-permission android:name=&quot;com.android.vending.CHECK_LICENSE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;&lt;/manifest&gt; 该文件在 UnrealBuildTool\\Platform\\Android\\UEDeployAdnroid.cs 中的 GenerateManifest 函数中生成。 其中控制了 APK 安装后的权限要求、属性配置等等，可以看到其中有一条： 1&lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;false&quot;/&gt; bUseExternalFilesDir的值为 false!，那么怎么把它设置为 true 呢？ 需要打开 Project Settings-Android-Advanced APK Packaging，找到Extra Tags for&lt;application&gt; node，因为&lt;meta-data /&gt; 是在 Application 下的，所以需要在这个选项下添加。 添加内容为： 1&lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;true&quot;/&gt; 没错！直接把 meta-data 这一行直接粘贴过来改一下值就可以了，UE 打包时会自动把这里的内容追加到 Manifest 的Application项尾部，这样就覆盖了默认的 false 的值。 然后再打包就可以看到 bUseExternalFilesDir 这个选项起作用了。 UPL 控制 bUseExternalFilesDir因为 UE 默认会给 AndroidManifest.xml 添加了 com.epicgames.ue4.GameActivity.bUseExternalFilesDir 项，如果我们想要手动控制，直接添加的话会产生错误，提示已经存在： 1234567891011121314151617181920212223242526272829UATHelper: Packaging (Android (ASTC)): &gt; Task :app:processDebugManifest FAILEDUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): Z:\\app\\src\\main\\AndroidManifest.xml:47:5-106 Error:UATHelper: Packaging (Android (ASTC)): Element meta-data#com.epicgames.ue4.GameActivity.bUseExternalFilesDir at AndroidManifest.xml:47:5-106 duplicated with element declared at AndroidManifest.xml:27:5-107UATHelper: Packaging (Android (ASTC)): Z:\\app\\src\\main\\AndroidManifest.xml Error:UATHelper: Packaging (Android (ASTC)): Validation failed, exitingUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): FAILURE: Build failed with an exception.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * What went wrong:UATHelper: Packaging (Android (ASTC)): Execution failed for task &#x27;:app:processDebugManifest&#x27;.UATHelper: Packaging (Android (ASTC)): &gt; Manifest merger failed with multiple errors, see logsUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): See http://g.co/androidstudio/manifest-merger for more information about the manifest merger.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * Try:UATHelper: Packaging (Android (ASTC)): Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.UATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): * Get more help at https://help.gradle.orgUATHelper: Packaging (Android (ASTC)): UATHelper: Packaging (Android (ASTC)): BUILD FAILED in 10sUATHelper: Packaging (Android (ASTC)): 189 actionable tasks: 1 executed, 188 up-to-dateUATHelper: Packaging (Android (ASTC)): ERROR: cmd.exe failed with args /c &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\GCloudExample\\Intermediate\\Android\\armv7\\gradle\\rungradle.bat&quot; :app:assembleDebugPackagingResults: Error: cmd.exe failed with args /c &quot;C:\\Users\\lipengzha\\Documents\\Unreal Projects\\GCloudExample\\Intermediate\\Android\\armv7\\gradle\\rungradle.bat&quot; :app:assembleDebugUATHelper: Packaging (Android (ASTC)): Took 13.3060694s to run UnrealBuildTool.exe, ExitCode=6UATHelper: Packaging (Android (ASTC)): UnrealBuildTool failed. See log for more details. (C:\\Users\\lipengzha\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.25\\UBT-.txt)UATHelper: Packaging (Android (ASTC)): AutomationTool exiting with ExitCode=6 (6)UATHelper: Packaging (Android (ASTC)): BUILD FAILEDPackagingResults: Error: Unknown Error 如果想要修改或者删除 UE 默认生成的 AndroidManifest.xml 中的项，可以通过先删除再添加的方式。 以删除以下项为例: 1&lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;false&quot; /&gt; 在 UPL 的 androidManifestUpdates 中编写以下代码： 123456789101112131415&lt;androidManifestUpdates&gt; &lt;loopElements tag=&quot;meta-data&quot;&gt; &lt;setStringFromAttribute result=&quot;ApplicationSectionName&quot; tag=&quot;$&quot; name=&quot;android:name&quot;/&gt; &lt;setBoolIsEqual result=&quot;bUseExternalFilesDir&quot; arg1=&quot;$S(ApplicationSectionName)&quot; arg2=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot;/&gt; &lt;if condition=&quot;bUseExternalFilesDir&quot;&gt; &lt;true&gt; &lt;removeElement tag=&quot;$&quot;/&gt; &lt;/true&gt; &lt;/if&gt; &lt;/loopElements&gt; &lt;addElements tag=&quot;application&quot;&gt; &lt;meta-data android:name=&quot;com.epicgames.ue4.GameActivity.bUseExternalFilesDir&quot; android:value=&quot;true&quot; /&gt; &lt;/addElements&gt;&lt;/androidManifestUpdates&gt; 就是去遍历 AndroidManfest.xml 中已经存在 meta-data 中，android:name为 com.epicgames.ue4.GameActivity.bUseExternalFilesDir 的项给删除。 项目设置 bUseExternalFilesDir 选项无效分析 下面来分析一下 Project Settings-Android-Use ExternalFilesDir for UE4Game Files 这个选项不生效。其实这个选项确实是控制 manifest 中的 bUseExternalFilesDir 的值的，在 UBT 中操作的，上面已经提到 manifest 文件就是在 UBT 中生成的。但是 ，虽然 UE 提供了这个参数，但是目前的引擎中(4.22.3) 这个选项是没有作用的，因为它被默认禁用了。首先，UBT 的构建调用栈为： AndroidPlatform(UEBuildAndroid.cs)的Deploy UEDeployAndroid(UEDeployAndroid.cs)中的PrepTargetForDeployment UEDeployAndroid(UEDeployAndroid.cs)中的MakeApk(最关键的函数) MakeApk这个函数接收了一个特殊的控制参数bDisallowExternalFilesDir: 12// UEDeployAndroid.csprivate void MakeApk(AndroidToolChain ToolChain, string ProjectName, TargetType InTargetType, string ProjectDirectory, string OutputPath, string EngineDirectory, bool bForDistribution, string CookFlavor, bool bMakeSeparateApks, bool bIncrementalPackage, bool bDisallowPackagingDataInApk, bool bDisallowExternalFilesDir); 它用来控制是否启用项目设置中的 Use ExternalFilesDir for UE4Game Files 选项。 12345678910111213141516171819202122232425262728// UEDeployAndroid.csprivate void MakeApk(AndroidToolChain ToolChain, string ProjectName, TargetType InTargetType, string ProjectDirectory, string OutputPath, string EngineDirectory, bool bForDistribution, string CookFlavor, bool bMakeSeparateApks, bool bIncrementalPackage, bool bDisallowPackagingDataInApk, bool bDisallowExternalFilesDir)&#123; // ... bool bUseExternalFilesDir = UseExternalFilesDir(bDisallowExternalFilesDir); // ...&#125;// func UseExternalFilesDirpublic bool UseExternalFilesDir(bool bDisallowExternalFilesDir, ConfigHierarchy Ini = null)&#123; if (bDisallowExternalFilesDir) &#123; return false; &#125; // make a new one if one wasn&#x27;t passed in if (Ini == null) &#123; Ini = GetConfigCacheIni(ConfigHierarchyType.Engine); &#125; // we check this a lot, so make it easy bool bUseExternalFilesDir; Ini.GetBool(&quot;/Script/AndroidRuntimeSettings.AndroidRuntimeSettings&quot;, &quot;bUseExternalFilesDir&quot;, out bUseExternalFilesDir); return bUseExternalFilesDir;&#125; 可以看到，如果 bDisallowExternalFilesDir 为 true 的话，就完全不会去读项目设置里的配置。 而关键的地方就在于，在 PrepTargetForDeployment 中调用 MakeApk 的时候，给了默认参数 true： 12345678910111213141516171819202122232425262728293031// UEDeployAndroid.cspublic override bool PrepTargetForDeployment(UEBuildDeployTarget InTarget)&#123; //Log.TraceInformation(&quot;$$$$$$$$$$$$$$ PrepTargetForDeployment $$$$$$$$$$$$$$$$$ &#123;0&#125;&quot;, InTarget.TargetName); AndroidToolChain ToolChain = new AndroidToolChain(InTarget.ProjectFile, false, InTarget.AndroidArchitectures, InTarget.AndroidGPUArchitectures); // we need to strip architecture from any of the output paths string BaseSoName = ToolChain.RemoveArchName(InTarget.OutputPaths[0].FullName); // get the receipt UnrealTargetPlatform Platform = InTarget.Platform; UnrealTargetConfiguration Configuration = InTarget.Configuration; string ProjectBaseName = Path.GetFileName(BaseSoName).Replace(&quot;-&quot; + Platform, &quot;&quot;).Replace(&quot;-&quot; + Configuration, &quot;&quot;).Replace(&quot;.so&quot;, &quot;&quot;); FileReference ReceiptFilename = TargetReceipt.GetDefaultPath(InTarget.ProjectDirectory, ProjectBaseName, Platform, Configuration, &quot;&quot;); Log.TraceInformation(&quot;Receipt Filename: &#123;0&#125;&quot;, ReceiptFilename); SetAndroidPluginData(ToolChain.GetAllArchitectures(), CollectPluginDataPaths(TargetReceipt.Read(ReceiptFilename, UnrealBuildTool.EngineDirectory, InTarget.ProjectDirectory))); // make an apk at the end of compiling, so that we can run without packaging (debugger, cook on the fly, etc) string RelativeEnginePath = UnrealBuildTool.EngineDirectory.MakeRelativeTo(DirectoryReference.GetCurrentDirectory()); MakeApk(ToolChain, InTarget.TargetName, InTarget.ProjectDirectory.FullName, BaseSoName, RelativeEnginePath, bForDistribution: false, CookFlavor: &quot;&quot;,bMakeSeparateApks: ShouldMakeSeparateApks(), bIncrementalPackage: true, bDisallowPackagingDataInApk: false, bDisallowExternalFilesDir: true); // if we made any non-standard .apk files, the generated debugger settings may be wrong if (ShouldMakeSeparateApks() &amp;&amp; (InTarget.OutputPaths.Count &gt; 1 || !InTarget.OutputPaths[0].FullName.Contains(&quot;-armv7-es2&quot;))) &#123; Console.WriteLine(&quot;================================================================================================================================&quot;); Console.WriteLine(&quot;Non-default apk(s) have been made: If you are debugging, you will need to manually select one to run in the debugger properties!&quot;); Console.WriteLine(&quot;================================================================================================================================&quot;); &#125; return true;&#125; 这真是好坑的一个点…我看 UE4.18 UBT 的源码中是一样的，都是默认关闭的。明明有这个选项，却默认给关闭了，但是还没有任何的提示，这真是比较蛋疼的事情。 总结 其实改动引擎代码和使用 manifest 各有好处： 改动代码的好处是可以任意指定路径（当然不一定合理），但缺点是需要源码版引擎； 使用 Manifest 的好处是不需要源码版引擎，但是只能使用 InternalFilesDir(Shipping) 或者ExternalFilesDir(not-shipping)； 顺道吐槽一下 UE，一个选项没作用，还把它在设置里暴露出来干嘛…","tags":[{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"Data","slug":"Data","permalink":"https://ue5wiki.com/tags/Data/"}],"categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"}]},{"title":"Export Recast Navigation Data from UE4","date":"2019-11-01T09:18:13.000Z","path":"wiki/20203/","text":"最新版本已支持 UE5，详见 github 的 UE5.0 分支：ue4-export-nav-data/tree/UE5.0。 Recast Navigation是一个开源的游戏导航 / 寻路引擎，可以为游戏中的 AI 提供寻路计算。UE 和 Unity 都是集成了 RecastNavigation 来为游戏提供导航和寻路计算 (当然是修改过的版本)，UE 的模块NavigationSystem 以及 NavMesh 中可以看到相关的代码实现。最近有个需求是要将客户端的地图信息导出给非 UE 网络架构的服务端，用于在服务器上对玩家位置的校验，想到可以把客户端的生成的导航数据导出作为客户端世界的 地图 ，所以折腾了一下写了一个 UE 的插件（开源在 Github 上：**ue4-export-nav-data）实现了 直接 ** 将 UE 生成的导航数据导出，有兴趣的可以直接去看具体的代码。根据导出的导航数据可以完整地在非 UE 网络架构的服务端上实现基于 Recast Navigation 的寻路计算，而且与 UE 无缝衔接。 **2019.12.04 Update:** 本插件已上架虚幻商城，购买链接ExportNavigation，为了程序员情怀支持开源，所以该项目在 Github 上的开源仓库不会关闭，但基本不会更新，如果该插件对你有用，欢迎在商城购买支持作者。 Recast Navigation首先，先来简单介绍一下编译 Recast 的 github 开源版本，UE 引擎中使用的 recast 就是基于该开源版本修改的，截止到 UE_4.22.3，UE 使用的 recast 版本为v1.4(可以从Source/Runtime/Navmesh/Recast-Readme.txt 中查看不同引擎版本使用的 recast 版本信息)。RecastNavigation 在 Github 上的源码地址：recastnavigation.recastnavigation的代码中提供了导航网格生成与计算寻路的工具RecastDemo，可以作为在项目中集成 RecastNavigation 的案例。 README.md里面写了各个平台的编译流程，我在这里详细展开一下 Windows 下编译流程。 首先下载premake5，并将其添加到系统 PATH 路径 clone RecastNavigation 的代码 下载 SDL2（选择 Development Libraries），并将其解压到recastnavigation\\RecastDemo\\Contrib 目录下，将文件夹改名为SDL，目录结构为： 123456D:\\recastnavigation\\RecastDemo\\Contrib\\SDL&gt;tree /a+---docs+---include\\---lib +---x64 \\---x86 在 recastnavigation\\RecastDemo 目录下执行命令 premake5 vs2017(vs201x 取决于你当前系统中安装的版本)，它会在RecastDemo 目录下创建 build/vs2017 目录，里面是 VS 项目的解决方案。 打开RecastDemo\\Build\\vs2017\\recastnavigation.sln，编译即可。 编译出来 RecastDemo.exe 位置在RecastDemo\\Bin。 123456789101112131415161718192021C:\\Users\\imzlp\\source\\repos\\recastnavigation\\RecastDemo\\Bin&gt;tree /a /f文件夹 PATH 列表 卷序列号为 000002D0 ECDB:6872C:.| .gitignore| DroidSans.ttf| RecastDemo.exe| RecastDemo.pdb| SDL2.dll| Tests.exe| Tests.pdb|+---Meshes| dungeon.obj| nav_test.obj| undulating.obj|\\---TestCases movement_test.txt nav_mesh_test.txt raycast_test.txt 其中关键的几个文件：DroidSans.ttf/RecastDemo.exe/SDL2.dll/Meshs/。 注意：必须把 obj 文件放到 Meshs/ 目录下才可以被 RecastDemo 识别。 之后就可以打开 RecastDemo.exe 在默认提供的三个 obj 的模型上进行导航数据生成的测试了，通过 Build 生成，然后 Save 保存会在 RecastDemo.exe 所在的目录产生一个 .bin 文件，即使用 recast 生成的导航数据。 注意 ：从 UE 导出 Navmesh 的含义是，把 UE 寻路范围内的模型导出，再通过RecastDemo 在该模型的基础上生成寻路数据。这也导致了在 UE 中添加影响寻路的框，导出 Navmesh 在 RecastDemo 生成时无法生效。 Plugin: ue-export-nav-data该插件是从 UE 中导出 RecastNavigation 的工具，分为两个模块：ExportNavRuntime与 ExportNavEditor，编辑器模块提供了 UE 中编辑器ToolBar 的按钮，在编辑器中导出导航数据。 点击之后选择路径，会在选择的路径下生成两个文件：.bin与obj，在 Windows 下会自动在资源管理器中打开导出目录。 bin：UE 构建完成的导航数据，给外部服务器使用。 obj：UE 中放置寻路的 Mesh，可以从 RecastDemo 中生成 bin 文件。 另外，我提供了 NavData 可以在运行时导出，但是 NavMesh 不支持，因为 UE 的导航是预计算的，具体可以看 UFlibExportNavData 中提供的方法。 我在 C++ 和蓝图中也提供了从导出的 bin 中验证位置是否是合法的寻路位置的两种方法： 12bool UFlibExportNavData::IsValidNavigationPointInNavbin(const FString&amp; InNavBinPath, const FVector&amp; Point, const FVector InExtern = FVector::ZeroVector);bool UFlibExportNavData::IsValidNavigationPointInNavObj(class UdtNavMeshWrapper* InDtNavObject ,const FVector&amp; Point, const FVector InExtern = FVector::ZeroVector); 可以与 UE 中提供的 UNavigationSystemV1::ProjectPointToNavigation 来对比验证导出数据是否匹配。 还有一个传入起始点来获取导航路径点的方法： 1bool FindDetourPathByNavMesh(dtNavMesh* InNavMesh ,const FVector3&amp; InStart, const FVector3&amp; InEnd, std::vector&lt;FVector3&gt;&amp; OutPaths); 可以与引擎中 UNavigationSystemV1::FindPathToLocationSynchrously 的结果一致，传入游戏中的世界坐标，函数内部有转换，返回的也是世界坐标。 该插件其优点为： 并非先从 UE 导出 NavMesh 的 .obj 再使用 RecastDemo 生成，而是直接从 UE 导出bin，当然我也保留了导出 NavMesh 为obj； 因为是直接从 UE 生成之后的导航数据导出，所以是所见即所得，解决导出 NavMesh 再 RecastDemo 生成导航网格时无法避免某些区域不生成寻路，以及避免 UE 与 RecastDemo 各种寻路参数的不一致产生的寻路数据不一致； 额外抽取出 ue 的 ue-detour 版本，可以无缝集成到外部服务器中，客户端坐标与服务端坐标无需转换(当然 UE 的坐标与 Recast 的坐标需要转换，但是内部已经处理，使用时不需要手动转换)。 UE 的坐标系与 Recast 的坐标系之间的转换可以使用 UE4RecastHelper 的两个函数： 123456789101112namespace UE4RecastHelper&#123; FCustomVector Recast2UnrealPoint(const FCustomVector&amp; Vector) &#123; return FCustomVector(-Vector.X, -Vector.Z, Vector.Y); &#125; FCustomVector Unreal2RecastPoint(const FCustomVector&amp; Vector) &#123; return FCustomVector(-Vector.X, Vector.Z, -Vector.Y); &#125;&#125;; Library: ue-recast-detour这个是我从 UE 代码中抽取出的 recast detour 库，在 UE 源码的路径下为Runtime/Navmesh/Detour，主要目的是保证 UE 客户端与外部服务器的验证方法一致。 因为在 github 上的 RecastNavigation 要高于 UE 使用的版本，而且前面提到 UE 在 recast 的基础上做了不少改动，为了防止代码的差异造成的不同结果，我将 ue 使用 (以及魔改) 过的版本抽出来供外部使用，这样可以确保客户端和服务端的结果是一致的。 代码放在了 github：ue4-recast-detour，该仓库的 Detour/ 目录下为 Detour 的库的全部代码。其余的代码是我实现的与 UE 进行验证和 UE 与 Recast 坐标转换的库 UE4RecastHelper 类以及实现的一个简单的命令行程序，用来测试 UE 中的世界位置是否在 bin 中的寻路数据中合法。 UE4RecastHelper目前 (2019.11.01) 提供了 dtNavMesh 与bin文件之间 serialize/deserialize 的方法；以及与 UE 中函数 UNavigationSystemV1::ProjectPointToNavigation 实现方法相同的函数UE4RecastHelper::dtIsValidNavigationPoint，用来验证点是否是合法的寻路点，保证了 UE 客户端与外部服务器的验证方法一致。 Detour所支持的操作都可以在服务器上实现(因为已经从 UE 里拿到了导航数据)，可以根据需求扩展。 再简单说一下 ue-detour.exe 这个工具怎么用，直接在命令行启动 ue4-detour.exe 会提示用法。首先，要先从 UE 中将导航数据导出，这里需要用到的只有 .bin 文件，如生成在 D:\\NavData。 然后找到 ue4-detour.exe 就可以使用下列命令了： 123456D:\\&gt;ue4-detour.exeUsage: ue4-detour.exe dtNavMesh.bin Loc.X Loc.Y,loc.Z Extren.X Extern.Y Extren.ZPS:&#123;Extern.X Extern.Y Extern.Z&#125; can be ignored,default is &#123;10.f 10.f 10.f&#125;For Example: ue4-detour.exe dtNavMesh.bin -770.003 -593.709 130.267 10.0 10.0 10.0 在蓝图中也可以直接加载 .bin 进行测试： End本篇文章用到的开源仓库： Recast Navigation ue4-export-nav-data ue4-recast-detour Update2021.05.27 Update： 插件支持 UE5，支持导出 UE5 的 NavMesh 数据及导航网格 数据与 ue-detour 验证成功","tags":[{"name":"Recast","slug":"Recast","permalink":"https://ue5wiki.com/tags/Recast/"},{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://ue5wiki.com/tags/Navigation/"}],"categories":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/categories/NavMesh/"}]},{"title":"UE4 Lighting","date":"2019-10-31T00:00:00.000Z","path":"wiki/external1598530572/","text":"本篇文章为外部内容，请点击链接跳转至原站点：UE4 Lighting。","tags":[{"name":"Lighting","slug":"Lighting","permalink":"https://ue5wiki.com/tags/Lighting/"}],"categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"Lighting","slug":"Rendering/Lighting","permalink":"https://ue5wiki.com/categories/Rendering/Lighting/"}],"is_external":true,"jump_to":"https://papalqi.cn/ue4-lighting%E7%B3%BB%E5%88%971/"},{"title":"MD5 的分片校验","date":"2019-10-08T14:48:07.000Z","path":"wiki/42464/","text":"有一个需求：对下载的文件执行 MD5 运算。在 UE 中可以使用 FMD5Hash 来进行 MD5 计算，但是只能指定文件加载： 12FMD5Hash FileHash = FMD5Hash::HashFile(*InFile);FString HashValue = LexToString(FileHash); 但是当文件比较大的时候如果等文件下载完再执行校验耗时会很长，所以我想有没有办法边下边进行 MD5 的计算，因为知道 MD5 是基于摘要的，所以觉得边下边校验的方法应该可行。我查了一下相关的实现，找到 OpenSSL 中有相关的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// openssl/md5.h#ifndef HEADER_MD5_H#define HEADER_MD5_H#include &lt;openssl/e_os2.h&gt;#include &lt;stddef.h&gt;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#ifdef OPENSSL_NO_MD5#error MD5 is disabled.#endif/* * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! * ! MD5_LONG has to be at least 32 bits wide. If it&#x27;s wider, then ! * ! MD5_LONG_LOG2 has to be defined along. ! * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */#if defined(__LP32__)#define MD5_LONG unsigned long#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)#define MD5_LONG unsigned long#define MD5_LONG_LOG2 3/* * _CRAY note. I could declare short, but I have no idea what impact * does it have on performance on none-T3E machines. I could declare * int, but at least on C90 sizeof(int) can be chosen at compile time. * So I&#x27;ve chosen long... * &lt;appro@fy.chalmers.se&gt; */#else#define MD5_LONG unsigned int#endif#define MD5_CBLOCK 64#define MD5_LBLOCK (MD5_CBLOCK/4)#define MD5_DIGEST_LENGTH 16typedef struct MD5state_st &#123; MD5_LONG A,B,C,D; MD5_LONG Nl,Nh; MD5_LONG data[MD5_LBLOCK]; unsigned int num; &#125; MD5_CTX;#ifdef OPENSSL_FIPSint private_MD5_Init(MD5_CTX *c);#endifint MD5_Init(MD5_CTX *c);int MD5_Update(MD5_CTX *c, const void *data, size_t len);int MD5_Final(unsigned char *md, MD5_CTX *c);unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);void MD5_Transform(MD5_CTX *c, const unsigned char *b);#ifdef __cplusplus&#125;#endif#endif 其中提供的 MD5 计算可以分开操作的有三个函数： 123int MD5_Init(MD5_CTX *c);int MD5_Update(MD5_CTX *c, const void *data, size_t len);int MD5_Final(unsigned char *md, MD5_CTX *c); 其中的 MD5_Update 就是我们需要的函数。 所以使用的伪代码为： 123456789101112131415161718192021MD5_CTX Md5CTX;void Request()&#123; MD5_Init(&amp;Md5CTX);&#125;void TickRequestProgress(char* InData,uint32 InLength)&#123; MD5_Update(&amp;Md5CTX,InData,InLength);&#125;void RequestCompleted()&#123; unsigned char digest[16] = &#123; 0 &#125;; MD5_Final(digest, &amp;Md5CTX); char md5string[33]; for (int i = 0; i &lt; 16; ++i) std::sprintf(&amp;md5string[i * 2], &quot;%02x&quot;, (unsigned int)digest[i]); // result pritf(&quot;MD5:%s&quot;,md5string);&#125; 这样当文件下载完，MD5 计算就完成了。 注：在 UE4 中 (~4.24) 提供的 OpenSSL 在 Win 下只支持到 VS2015，可以自己把这个限制给去掉(VS2015 的链接库在 VS2017 中使用也没有问题)。","tags":[{"name":"MD5","slug":"MD5","permalink":"https://ue5wiki.com/tags/MD5/"}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"}]},{"title":"Oculus Quest Development with UE4","date":"2019-09-24T10:41:10.000Z","path":"wiki/30042/","text":"Oculus Quest是 Oculus 发布的新一代支持 6DoF 的 VR 一体机设备，不需要连接 PC 以及额外的定位基站，而且支持 Guardian，当戴着头显走出定位边界时，头显中会立即显示现实中的画面，防止玩家误碰出现意外情况。Oculus Quest使用两个 Pentile OLED 的屏幕，单眼分辨率为 1440x1600，刷新率为72Hz，使用的是arm 架构的高通骁龙 835 处理器，与两年前的 Android 旗舰级的处理器相同 (如小米 6、三星 S8)。Quest 使用的是Oculus Insight(inside-out tracing) 定位方案，使用四枚摄像头进行位置追踪，分别位于头显面板的四角。发布会时对 Oculus Insight 的介绍：Oculus Insight VR Positional Tracking System (Sep 2018) 以及国外的一个老哥对 Quest 追踪范围的测试视频：Quest Distance Test. Oculus Quest64G 存储版本的售价为 399 刀，128G 的为 499 刀，不计税的价格大概是 3500；相比较 HTC 的同类新产品 (HTC Vive Focus) 是便宜了不少，与 PC-Base VR 相比那就更具优势了，还不需要一台高性能的主机，我觉得 6DoF 的 VR 一体机设备一定是未来的趋势！ 国庆前的 OC6，Oculus 发布了 Oculus Link 和 finger tracking 两项技术，十分厉害，十分看好。 整套 Quest 设备的大小与 10.5 寸的 iPad 差不多，提个小包就能带走： Quest 设备的参数细节不再多说，本篇文章的主要内容是使用 UE 来开发 Quest 项目时的环境部署、开发文档、调试工具以及额外的注意事项，会持续更新。 首先想要在 Quest 上打包测试应用需要先打开 Quest 的开发者模式。 首先用一根 Type-C 的数据线将 Quest 连接至电脑，在头显中会提示是否允许 USB 调试，勾选允许。之后就可以在 PC 上用 Adb 连接到 Quest 了，Quest 上的系统也是基于 Android 的，可以使用 Adb 进行调试。 1adb shell 就可以连接到 Quest 设备了，可以查看 /system/build.props 查看设备信息。我导出了一份：build.props。 也可以直接使用 adb 来安装 apk： 1adb install xxxx.apk 另外可以使用 SideQuest 这个开源工具在 PC 上管理基于 Android 的 VR 设备，当然 Quest 也适用，可以安装或者卸载软件。 Oculus Developer Mode在进行真正的开发环境设置之前，需要将 Quest 开启 开发者模式 ，设置开发者模式的前提是需要在Oculus Dashboard 上加入或者 创建 开发者组织。 然后使用具有开发者组织的 Oculus 账号登陆移动端的OculusApp： iOS 版本的可以从 App Store 安装：Oculus for iOS Android 可以从 Google Play 安装：Oculus for Android，国内没有 GMS 环境的可以从我下载的 apk 直接安装:下载地址. 安装之后，登录账号，找到与账号关联的 Quest 设备，选择 更多设置 ： 然后找到 开发者模式，启用即可。 启用之后就可以在 Quest 里的 Library 下看到Unknow Source，也就是未知来源应用了(后续测试安装的都在这个分类下)。 NVIDIA CodeWorks for Android因为本质上 Quest 跑的就是 Android 系统，所以我们打包的游戏就是安卓上的 apk，那么为了能顺利打包成功 apk，则需要安装 Android 的开发环境。我们需要安装 android-sdk/jdk/android-ndk/gradle/apache-ant 等一系列环境，不过一个好消息是，NVIDIA 有一个 NVIDIA CodeWorks for Android 能够极大简化安装 Android 开发环境的流程。 各个平台的 CodeWorks for Android 安装包可以从 UE 引擎的下列目录找到： 1UE_4.23_Source\\Engine\\Extras\\AndroidWorks\\Win64 也可以从 NVIDIA 的 Download Center 下载。启动安装，选择 安装目录 和下载目录： 安装完成之后打开安装路径(默认在C:\\NVPACK\\)，启动Chooser.exe： 选择 Standard 之后点击右下角的 Next 即可开始下载并安装。鉴于国内的网络环境实在太差，有些库确实下载不下来，我把 Standard 下所有的都下载下来了，下载地址：CodeWorks_1R7，下载之后将其放到安装 CodeWorks 时选择的下载目录中，然后重新启动 Chooser.exe，点击Next 它会自己验证并且安装。 如果不想安装 CodeWorks，则可以仅仅只下载 Android 环境：NVPACK_1R7u1_20190923，然后把下面的环境变量添加进系统中。 安装完成之后会在系统中自动添加下列环境变量： Environment var NAME Value ANDROID_HOME C:\\NVPACK\\android-sdk-windows ANDROID_NDK_ROOT C:\\NVPACK\\android-ndk-r14b ANT_HOME C:\\NVPACK\\apache-ant-1.8.2 GRADLE_HOME C:\\NVPACK\\gradle-4.1 JAVA_HOME C:\\NVPACK\\jdk1.8.0_77 NDK_ROOT C:\\NVPACK\\android-ndk-r14b NDKROOT C:\\NVPACK\\android-ndk-r14b NVPACK_NDK_TOOL_VERSION 4.9 NVPACK_NDK_VERSION android-ndk-r14b NVPACK_ROOT D:\\NVPACK 这些环境变量在 UE 项目的 Project Setting-Android SDK 中被用到。 注意：最好确保环境变量的路径中没有特殊字符，纯数字 + 字母最好的。 Create Quest Project with UE4首先启动 Unreal Engine，我使用是从 EpicLauncher 安装的 UE_4.21.2 版本。为了方便测试，我创建了一个 VR Template 项目，注意 Target 选为Mobile： 创建完成启动 UE Editor 之后，先检查 Oculus VR 插件有没有启用。 打开 Project Setting-Engin-Input 确认 Mobile-Default Touch Interface 是none： 打开 Project Setting-Engine-Rending 确认 Mobile HDR 是关闭的： 打开 Project Setting-Platform-Android SDK 这里主要是设置 Android 开发环境的路径，如 SDK/NDK/JDK，可以看上图的提示，如果不指定就会从系统中查找指定 NAME 的环境变量，因为我们安装 CodeWorks 时它已经帮我们添加了，此处可以忽略，如果是自己安装的环境则需要在这里指定或者直接添加到系统的环境变量。 打开 Priject Setting-Platform-Android 分别执行 Configure Now 和Accept SDK License。 注意：如果不执行 Accept SDK License 会在 Launch 时遇到 License not accepted 错误。 1License not accepted. SDK License must be accepted in the Android project settings to deploy your app to the device. 将 Minimum SDK Version 设置为 25，Target SDK Version 设置为26。 以及启用 Enable FullScreen Immersive on KitKat and above device。 之后向下滚动找到Advanced APK Packing，并启用下列两项： Configure the AndroidManifest for deployment to Oculus Mobile Rmove Oculus Signature File From Distribution APK 打开 Priject Setting-Project-Supported Platforms 启用Android； 将该 VR 模板项目的 Editor Startup Map 以及 Game Default Map 改为MotionControllerMap； 使用 Type-C 的 USB 线将 Quest 连接至 PC； 关闭 Editor，重启项目； 重启项目之后即可在编辑器工具栏的 Launch 下找到 Quest： 启动即可开始编译并在 Quest 中测试当前项目 (会被自动安装到 Quest 中，在Unknow Source 下)。 如果在 Launch 或者打包时遇到 :app:assembleDebug 错误，则将 Project Setting-Platform-Android 下的 Enable Grade instead of Ant 关闭即可；如果非要用 grade 则检查 JAVE_HOME 环境变量设置的路径中是否含有特殊字符，最好只有数字 + 字母。 如果想要使用 Vulkan，则需要将 UE 升级到 4.22.2+. 解决 Quest 只追踪一只手柄 在第一次启动之后测试发现，在游戏中同一时刻只有一只手柄可以被控制，无法同时使用两只手柄。本来以为是 bug，查了一些资料后发现，这是因为没有在打包时强制指定要求 6DoF，详见文档：Enabling 6DoF head tracking。项目中默认的是没有指定 3DoF 还是 6DoF，默认是3DoF 的，所以只有一只手柄能够追踪。 解决的办法是在 Intermediate/Android/APK/AndroidManifest.xml 中添添加： 1234&lt;uses-feature android:name=&quot;android.hardware.vr.headtracking&quot; android:version=&quot;1&quot; android:required=&quot;true&quot; /&gt; 但是，因为 AndroidManifest.xml 是被生成出来的，我们直接修改文件也会被覆盖，所以应该添加到项目的设置中： 看介绍，也可以编辑在 Build/Android/ManifestRequirementsOverride.txt(若不存在，手动创建)，它会 替换 生成的 AndroidManifest.xml 中的 Requirements 部分，所以需要把已经生成的 AndroidManifest.xml 的Requirements部分加上强制启用 6DoF 的user-feature保存到 Build/Android/ManifestRequirementsOverride.txt 中： 1234567891011121314&lt;!-- Requirements --&gt;&lt;uses-sdk android:minSdkVersion=&quot;25&quot; android:targetSdkVersion=&quot;25&quot; /&gt;&lt;uses-feature android:name=&quot;android.hardware.vr.headtracking&quot; android:version=&quot;1&quot; android:required=&quot;true&quot; /&gt;&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&lt;uses-permission android:name=&quot;com.android.vending.CHECK_LICENSE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;!-- Supported texture compression formats (cooked) --&gt;&lt;supports-gl-texture android:name=&quot;GL_KHR_texture_compression_astc_ldr&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt; 重新运行或打包即可。 How to Fix Only One Controller Tracking on Oculus Quest (after the v7 update - using UE 4.22) Package and Install在 UE 中打包 Android 程序时有这个几个不同的可选 Texture 格式，目的是针对不同的硬件使用不同格式的压缩纹理： Not all Android devices are made the same. In particular, there are 4 different kinds of rendering hardware. They each support different formats of compressed textures. Format Description ETC1 Supported by all Android based devices but cannot compress alpha textures (they are stored uncompressed). Recommend using an RGB and a separate alpha texture if need alpha to get better compression. ETC2 Supported by all OpenGL 3.x class devices and supports alpha compression. ATC Supported by Qualcomm Adreno GPUs and supports alpha compression. DXT Supported by Nvidia Tegra GPUs and supports alpha compression. PVRTC supported by PowerVR GPUs and supports alpha compression. ASTC Latest Texture compression format allowing more quality control by specifying block size and supports alpha compression. Available on some devices at this point and will be required for Vulkan Level 1. UE 文档的详细介绍：Android Development Reference 因为 Quest 使用的是 高通骁龙 835，所以打包时选择 ATC 即可。 打包完成之后在 Binaries/Android 目录下会有如下文件： 123456+---Binaries| \\---Android| Install_QuestTemp-armv7-es2.bat| main.1.com.imzlp.QuestTemp.obb| QuestTemp-armv7-es2.apk| Uninstall_QuestTemp-armv7-es2.bat 其中的 apk 与obb就是我们打包出来的游戏程序和数据包。可以使用 adb 命令来安装 apk 和拷贝 obb 数据包。 123adb install QuestTemp-armv7-es2.apk20002 KB/s (47579881 bytes in 2.322s)Success 然后将数据包拷贝到 /sdcard/Android/obb/com.imzlp.QuestTemp/ 目录下： 1adb push main.1.com.imzlp.QuestTemp.obb /sdcard/Android/obb/com.imzlp.QuestTemp/main.1.com.imzlp.QuestTemp.obb 当然直接执行 Install_QuestTemp-armv7-es2.bat 也是可以的，它里面也是执行了这么几条指令。 VR Template Video我简单录了一个这个 VR Template 在 Quest 上运行的一个视频：Oculus Quest Template，可以看到定位还是十分稳定的。 PC View不同于 PC VR 在测试时可以直接把 VR 视角显示在 PC 显示器上，Quest 的视角想要在 PC 上实时预览 Quest 的视角除了投屏之外可以使用 scrcpy 这个开源工具，它是专门用于显示和控制 Android 设备的，我经常用它来控制手机，需要使用数据线连接设备，使用 adb 连接。scrcpy在对 Quest 使用时显示的是双眼视角： Debug and Performance那么我们怎么查看在 Quest 运行的程序的参数呢，比如帧率、机器的负载情况。可以使用 Android 的 Debug 工具 adb 与logcat命令来查看：Android Debugging，以及 logcat 支持的参数：Logcat 命令行工具。 首先，将 Quest 使用 USB 连接 PC，启动游戏，然后在 cmd 的窗口中输入以下命令： 1adb logcat -s VrApi 之后就会看到一堆的输出： 12345678910111213141516171819202122232425262728293031323334353637C:\\Users\\visionsmile&gt;adb logcat -s VrApi--------- beginning of system--------- beginning of main09-28 23:00:12.250 18371 18386 D VrApi : targetSDKVersion 2509-28 23:00:12.256 18371 18386 I VrApi : DEVICE MODEL NUMBER = Quest09-28 23:00:12.256 18371 18386 I VrApi : DEVICE HARDWARE = monterey09-28 23:00:12.256 18371 18386 I VrApi : DEVICE BUILD NAME = user-358570.9320.009-28 23:00:12.256 18371 18386 I VrApi : DEVICE BUILD TYPE = user09-28 23:00:12.256 18371 18386 I VrApi : DEVICE OS VERSION = 7.1.109-28 23:00:12.256 18371 18386 I VrApi : VRAPI VERSION = 1.1.25.0-171385671-171385671 Sep 7 2019 04:35:06 Development RELEASE09-28 23:00:12.256 18371 18386 I VrApi : VRAPI LOADER VERSION = 1.1.16.009-28 23:00:12.256 18371 18386 I VrApi : VRDRIVER VERSION = 8.0.0.148.62609-28 23:00:12.256 18371 18386 I VrApi : APP NAME = QuestTemp09-28 23:00:12.256 18371 18386 I VrApi : APP VERSION = 1.0 versionCode 1 internalVersionName &lt;none&gt;09-28 23:00:12.256 18371 18386 I VrApi : APP VR TYPE = vr_only09-28 23:00:12.256 18371 18386 I VrApi : APP PACKAGE NAME = com.imzlp.QuestTemp09-28 23:00:12.256 18371 18386 I VrApi : APP ACTIVITY CLASS = com.epicgames.ue4.GameActivity09-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_ALLOW_POWER_SAVE = 109-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_RESET_WINDOW_FULLSCREEN = 109-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_NATIVE_WINDOW = 109-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_FRONT_BUFFER_PROTECTED = 009-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_FRONT_BUFFER_565 = 009-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_FRONT_BUFFER_SRGB = 009-28 23:00:12.256 18371 18386 I VrApi : ovrModeParms::VRAPI_MODE_FLAG_CREATE_CONTEXT_NO_ERROR = 009-28 23:00:12.256 18371 18386 I VrApi : HMD sensor attached.09-28 23:00:12.264 18371 18386 I VrApi : Client side frame sync enabled09-28 23:00:12.276 18371 18386 I VrApi : OVR::Stats thread started09-28 23:00:12.287 18371 18386 I VrApi : System brightness = 25509-28 23:00:12.295 18371 18519 D VrApi : targetSDKVersion 2509-28 23:00:12.300 18371 18386 I VrApi : Set brightness to 25509-28 23:00:12.303 18371 18386 I VrApi : Set DND mode to true09-28 23:00:12.329 18371 18386 I VrApi : System DND mode = true09-28 23:00:12.329 18371 18386 I VrApi : ---------- vrapi_EnterVrMode [end] ----------09-28 23:00:12.365 18371 18520 I VrApi : ovr_HandleHmdEvents: HMT was mounted09-28 23:00:13.532 18371 18519 I VrApi : FPS=23,Prd=47ms,Tear=0,Early=0,Stale=1,VSnc=1,Lat=1,Fov=0,CPU4/GPU=3/3,1958/515MHz,OC=FF,TA=0/E0/E0,SP=N/F/F,Mem=1804MHz,Free=1588MB,PSM=0,PLS=0,Temp=28.0C/0.0C,TW=3.40ms,App=10.26ms,GD=3.30ms,CPU&amp;GPU=9.47ms,LCnt=1,GPU%=0.62,CPU%=0.29(W0.33)09-28 23:00:14.341 18371 18519 I VrApi : FPS=72,Prd=45ms,Tear=1,Early=62,Stale=10,VSnc=1,Lat=1,Fov=0,CPU4/GPU=3/3,1958/515MHz,OC=FF,TA=0/E0/E0,SP=N/F/F,Mem=1804MHz,Free=1592MB,PSM=0,PLS=0,Temp=28.0C/0.0C,TW=3.75ms,App=8.58ms,GD=0.00ms,CPU&amp;GPU=9.06ms,LCnt=1,GPU%=0.76,CPU%=0.27(W0.32)09-28 23:00:15.341 18371 18519 I VrApi : FPS=72,Prd=45ms,Tear=0,Early=69,Stale=0,VSnc=1,Lat=1,Fov=0,CPU4/GPU=2/3,1651/515MHz,OC=FF,TA=0/E0/E0,SP=N/F/F,Mem=1804MHz,Free=1593MB,PSM=0,PLS=0,Temp=28.0C/0.0C,TW=2.96ms,App=9.17ms,GD=0.65ms,CPU&amp;GPU=9.24ms,LCnt=1,GPU%=0.77,CPU%=0.27(W0.33) 可以看到 VrApi 输出的内容： 1FPS=72,Prd=45ms,Tear=0,Early=69,Stale=0,VSnc=1,Lat=1,Fov=0,CPU4/GPU=2/3,1651/515MHz,OC=FF,TA=0/E0/E0,SP=N/F/F,Mem=1804MHz,Free=1593MB,PSM=0,PLS=0,Temp=28.0C/0.0C,TW=2.96ms,App=9.17ms,GD=0.65ms,CPU&amp;GPU=9.24ms,LCnt=1,GPU%=0.77,CPU%=0.27(W0.33) 这是当前 Quest 中的跑游戏时设备的各种参数。这些参数的含义可以从 Oculus Quest 的文档中查看： Basic Performance Stats through Logcat Capture video for QuestOculus 的 CTO 是游戏开发界的传奇人物——约翰·卡马克 (john camark)，他近期(2019.10.18) 在 twitter 提到了在 Go/Quest 中满帧录屏的一个方法： twitter link：If you want to capture full 60/72 fps video on Go/Quest instead of half rate, you can ‘adb shell setprop debug.oculus.fullRateCapture 1’. 即使用 adb 命令： 1$ adb shell setprop debug.oculus.fullRateCapture 1 Documents and TutorialOculus Quest 的开发文档： Oculus Quest - Unreal Application Performance Analysis Quest Virtual Reality Check (VRC) Guidelines UE 的 Android 开发文档： Android Development Reference 视频教程： Using UE4 to Develop for Oculus Rift and Oculus Quest | Unreal Fest Europe 2019 | Unreal Engine How to Build for Oculus Quest using Unreal Engine How to Fix Only One Controller Tracking on Oculus Quest (after the v7 update - using UE 4.22) Oculus Quest Performance Profiling and Performance Optimization Assets Download本文内所有的资源： CodeWorks_1R7 NVPACK_1R7u1_20190923 SideQuest scrcpy Oculus Quest VR Template Project：QuestTemp 打包出来的 QuestTemp：QuestTemp-armv7-es2.7z OtherNot-PC based VR: Google VR Oculus Quest","tags":[{"name":"VR","slug":"VR","permalink":"https://ue5wiki.com/tags/VR/"},{"name":"Oculus Quest","slug":"Oculus-Quest","permalink":"https://ue5wiki.com/tags/Oculus-Quest/"},{"name":"Oculus","slug":"Oculus","permalink":"https://ue5wiki.com/tags/Oculus/"}],"categories":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"}]},{"title":"UE 构建系统：Target 和 Module","date":"2019-09-12T13:14:22.000Z","path":"wiki/16643/","text":"Module 是构成 Unreal 的基本元素，每一个 Module 封装和实现了一组功能，并且可以供其他的 Module 使用，整个 Unreal Engine 就是靠各个 Module 组合驱动的，连我们创建的游戏项目本身，都是一个单独的 Module。 那么 UE 又是怎么创建和构建这这些 Module 的呢？这是写这篇文章的主要目的，研究一下 Unreal 的构建系统以及它们 (Target 和 Module) 支持的各种属性。 建议在看这篇文章之前先看一下我之前的这篇文章：Build flow of the Unreal Engine4 project，主要内容是大致过一遍 UE 的构建流程，本篇文章只是 UE 构建系统中的一环。 对于 UE 项目比较熟悉的都知道，当使用 UE 创建一个 C++ 游戏项目时，会在项目路径下创建 Source 文件夹，默认包含了下列文件： 12345678910Example\\GWorld\\Source&gt;tree /a /f| GWorld.Target.cs| GWorldEditor.Target.cs|\\---GWorld GWorld.Build.cs GWorld.cpp GWorld.h GWorldGameModeBase.cpp GWorldGameModeBase.h 其中，*.Target.cs与 *.Build.cs 是 Unreal 构建系统的实际控制者，UBT 通过扫描这两个文件来确定整个编译环境，它们也是本篇文章研究的重点。它们的职责各不相同： *.Target.cs控制的是生成的可执行程序的外部编译环境，就是所谓的Target。比如，生成的是什么Type(Game/Client/Server/Editor/Program)，开不开启 RTTI(bForceEnableRTTI)，CRT 使用什么方式链接(bUseStaticCRT) 等等。 *.Build.cs控制的是 Module 编译过程，由它来控制所属 Module 的对其他 Module 的依赖、文件包含、链接、宏定义等等相关的操作，*.Build.cs告诉 UE 的构建系统，它是一个 Module，并且编译的时候要做哪些事情。 以一言以蔽之：与外部编译环境相关的都归 *.target.cs 管，与 Module 自身相关的都归 *.build.cs 管。 插个题外话，在 GWorld.h 和GWorld.cpp中定义的是 Module 真正的执行逻辑，使用 IMPLEMENT_MODULE 定义。UE 中所有的 Module 都是继承自IModuleInterface，具有以下接口： 123456789101112class IModuleInterface&#123;public: virtual ~IModuleInterface(); virtual void StartupModule(); virtual void PreUnloadCallback(); virtual void PostLoadCallback(); virtual void ShutdownModule(); virtual bool SupportsDynamicReloading(); virtual bool SupportsAutomaticShutdown(); virtual bool IsGameModule(); const&#125;; 通过 IModuleInterface 来驱动 Module 的启动与关闭，不过一般 Game Module 不使用这个控制游戏流程。这部分的详细内容可以看我之前的文章：UE4 Modules:Load and Startup Target每一个基于 Unreal 的项目，都有一个 Tergat.cs，具有一个继承自TargetRules 的类定义；并且默认需要关联着一个同名 (非必要，但建议) 的Module的定义，否则编译时会有 Module 未定义错误，它的含意时将指定的 Module 编译到 Target 中： 1UnrealBuildTool : error : Could not find definition for module &#x27;GWorld&#x27; (referenced via GWorld.Target.cs) 与 Target 关联的 Module 的名字可以通过 ExtraModuleNames 来指定： 12345678public class GWorldTarget : TargetRules&#123; public GWorldTarget(TargetInfo Target) : base(Target) &#123; Type = TargetType.Game; ExtraModuleNames.AddRange(new string[] &#123; &quot;GWorld&quot; &#125; ); &#125;&#125; 上面指定的是 GWorld，UBT 解析的时候就会去找GWorld 这个 Module 的定义，也就是 GWorld.build.cs 这个文件中的 GWorld 类定义，如果没有就会产生上面的 Module 未定义错误。 注意，与 Target 关联的 Module 不仅仅只是一个指定的名字这么简单，所有代码中使用的 XXXX_API 都是与 Module 的名字相关的。 如果我进行以下改动：ExtraModuleNames.AddRange(new string[] &#123; &quot;GWorldAAA&quot; &#125; );，那么需要对项目中所有的源文件进行的改动有： 将原有的 GWorld.build.cs 文件改名为 GWorldAAA.build.cs，并将文件内容的所有GWorld 替换为GWorldAAA； 将项目内所有头文件的 GWORLD_API 改名为 GWORLDAAA_API，因为XXX_API 的导出符号是依赖于 ModuleName 的； 实在是个不小的工作量，所以还是建议将 ExtraModuleNames 中指定的名字与 Game Module 同名。通过上面的内容，我们可以知道了 Target.cs 是如何与 Build.cs 关联的。那么，其实 Game/Server/Client/Editor 的Target可以共用同一个 Module，将他们的ExtraModuleNames 都设置成同一个就可以了(如果你想要针对每个 Target 类型单独写也可以)。 TargetRules的代码在 UnrealBuildTools/Configuration/ModuleRules（ReadOnlyTargetRules 也定义其中），可以看一下所支持参数的默认值；UE 对 Target 支持属性的描述文档：Targets。 但是 UE 的官方文档里面也只是代码里的注释，有些描述看了之后摸不着头脑，后面我会分析一下 TargetRule 一些属性的含义，先埋个坑。 Type(TargetType)TargetRules中的属性 Type，其类型为TargetType，定义为TargetRules.cs 中，是指定项目要编译出来的是什么程序。 Game - A standalone game which requires cooked data to run. Client - Same as Game, but does not include any server code. Useful for networked games. Server - Same as Game, but does not include any client code. Useful for dedicated servers in networked games. Editor - A target which extends the Unreal Editor. Program - A standalone utility program built on top of the Unreal Engine. LinkType(TargetLinkType)TargetRules中的 LinkType，其类型为TargetLinkType，定义在TargetRules.cs 中，是指定项目的链接类型。 TargetLinkType具有三个枚举值： 123456789101112131415161718192021/// &lt;summary&gt;/// Specifies how to link all the modules in this target/// &lt;/summary&gt;[Serializable]public enum TargetLinkType&#123; /// &lt;summary&gt; /// Use the default link type based on the current target type /// &lt;/summary&gt; Default, /// &lt;summary&gt; /// Link all modules into a single binary /// &lt;/summary&gt; Monolithic, /// &lt;summary&gt; /// Link modules into individual dynamic libraries /// &lt;/summary&gt; Modular,&#125; TargetLinkType.Default是 LinkType 的默认值，在此种状态下，如果当前 Target 的Type为 Editor 则使用 Modular 类型，链接所有的模块的方式为动态链接库。 TargetLinkType.Modular：以动态链接库的方式链接 Module TargetLinkType.Monolithic：将所有的模块链接到单个文件(静态链接) 可以通过修改 LinkType 来修改。 1234567891011121314151617181920212223/// &lt;summary&gt;/// Backing storage for the LinkType property./// &lt;/summary&gt;[RequiresUniqueBuildEnvironment][CommandLine(&quot;-Monolithic&quot;, Value =&quot;Monolithic&quot;)][CommandLine(&quot;-Modular&quot;, Value =&quot;Modular&quot;)]TargetLinkType LinkTypePrivate = TargetLinkType.Default;/// &lt;summary&gt;/// Specifies how to link modules in this target (monolithic or modular). This is currently protected for backwards compatibility. Call the GetLinkType() accessor/// until support for the deprecated ShouldCompileMonolithic() override has been removed./// &lt;/summary&gt;public TargetLinkType LinkType&#123; get &#123; return (LinkTypePrivate != TargetLinkType.Default) ? LinkTypePrivate : ((Type == global::UnrealBuildTool.TargetType.Editor) ? TargetLinkType.Modular : TargetLinkType.Monolithic); &#125; set &#123; LinkTypePrivate = value; &#125;&#125; Name(string)Target 的名字，只读属性，传进来的项目名字。 Platform(UnrealTargetPlatform)Platform的类型为UnrealTargetPlatform，它是一个枚举，定义在UnrealBuildTool\\Configuration\\UEBuildTarget.cs。 它记录着当前 Target 的平台信息，如 Win32/Win64 等等，目前 UE_4.22 的版本支持的平台为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public enum UnrealTargetPlatform&#123; /// &lt;summary&gt; /// Unknown target platform /// &lt;/summary&gt; Unknown, /// &lt;summary&gt; /// 32-bit Windows /// &lt;/summary&gt; Win32, /// &lt;summary&gt; /// 64-bit Windows /// &lt;/summary&gt; Win64, /// &lt;summary&gt; /// Mac /// &lt;/summary&gt; Mac, /// &lt;summary&gt; /// XboxOne /// &lt;/summary&gt; XboxOne, /// &lt;summary&gt; /// Playstation 4 /// &lt;/summary&gt; PS4, /// &lt;summary&gt; /// iOS /// &lt;/summary&gt; IOS, /// &lt;summary&gt; /// Android /// &lt;/summary&gt; Android, /// &lt;summary&gt; /// HTML5 /// &lt;/summary&gt; HTML5, /// &lt;summary&gt; /// Linux /// &lt;/summary&gt; Linux, /// &lt;summary&gt; /// All desktop platforms /// &lt;/summary&gt; AllDesktop, /// &lt;summary&gt; /// TVOS /// &lt;/summary&gt; TVOS, /// &lt;summary&gt; /// Nintendo Switch /// &lt;/summary&gt; Switch, /// &lt;summary&gt; /// NDA&#x27;d platform Quail /// &lt;/summary&gt; Quail, /// &lt;summary&gt; /// Confidential platform /// &lt;/summary&gt; Lumin,&#125; 我们可以在 build.cs 或者 target.cs 中通过判断 Platform 来做不同的事情。 如： 1234if(Target.Platform != UnrealTargetPlatform.Win32 &amp;&amp; Target.Platform != UnrealTargetPlatform.Win64)&#123; PublicDefinitions.Add(&quot;HAVE_PTHREAD&quot;);&#125; IsInPlatformGroup这是一个函数 bool IsInPlatformGroup(UnrealPlatformGroup Group)，定义在TargetRules.cs 中，它用来判断当前的 Platform 是否输入某一组。 需要传入的参数为 UnrealTargetformGroup 枚举类型，它定义在 UEBuildTarget.cs 中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// Platform groups/// &lt;/summary&gt;public enum UnrealPlatformGroup&#123; /// &lt;summary&gt; /// this group is just to lump Win32 and Win64 into Windows directories, removing the special Windows logic in MakeListOfUnsupportedPlatforms /// &lt;/summary&gt; Windows, /// &lt;summary&gt; /// Microsoft platforms /// &lt;/summary&gt; Microsoft, /// &lt;summary&gt; /// Apple platforms /// &lt;/summary&gt; Apple, /// &lt;summary&gt; /// making IOS a group allows TVOS to compile IOS code /// &lt;/summary&gt; IOS, /// &lt;summary&gt; /// Unix platforms /// &lt;/summary&gt; Unix, /// &lt;summary&gt; /// Android platforms /// &lt;/summary&gt; Android, /// &lt;summary&gt; /// Sony platforms /// &lt;/summary&gt; Sony, /// &lt;summary&gt; /// Target all desktop platforms (Win64, Mac, Linux) simultaneously /// &lt;/summary&gt; AllDesktop,&#125; Configuration(UnrealTargetConfiguration)当前编译的配置，类型为 UnrealTargetConfiguration 的枚举，定义在 UEBuildTarget.cs 中，由 VS 中的 Configuration 构造而来，如： Development Shipping DebugGame Debug Test Unknow 也就是通过这个设置，UBT 才在编译环境中添加了下列宏： 123456789101112131415161718192021222324public override void SetUpConfigurationEnvironment(ReadOnlyTargetRules Target, CppCompileEnvironment GlobalCompileEnvironment, LinkEnvironment GlobalLinkEnvironment)&#123; // other code UnrealTargetConfiguration CheckConfig = Target.Configuration; switch (CheckConfig) &#123; default: case UnrealTargetConfiguration.Debug: GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_DEBUG=1&quot;); break; case UnrealTargetConfiguration.DebugGame: // Default to Development; can be overridden by individual modules. case UnrealTargetConfiguration.Development: GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_DEVELOPMENT=1&quot;); break; case UnrealTargetConfiguration.Shipping: GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_SHIPPING=1&quot;); break; case UnrealTargetConfiguration.Test: GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_TEST=1&quot;); break;bUseDebugCRT &#125; // other code&#125; Architecture(string)所运行的平台的架构信息：x86/arm等等。 CppStandard(CppStandardVersion)用于指定编译项目时所用的 C++ 标准版本（在新版本引擎 (4.23) 中才有）。CppStandardVersion： Latast Cpp17 Cpp14 这个选项本质上就是将 /std:c++xxx 添加到 VS 的编译选项中。 1234567891011121314151617void AppendCLArguments_CPP(CppCompileEnvironment CompileEnvironment, List&lt;string&gt; Arguments)&#123; // other code... if(CompileEnvironment.CppStandard &gt;= CppStandardVersion.Latest) &#123; Arguments.Add(&quot;/std:c++latest&quot;); &#125; else if(CompileEnvironment.CppStandard &gt;= CppStandardVersion.Cpp17) &#123; Arguments.Add(&quot;/std:c++17&quot;); &#125; else if(CompileEnvironment.CppStandard &gt;= CppStandardVersion.Cpp14) &#123; Arguments.Add(&quot;/std:c++14&quot;); &#125; // other code...&#125; bUseDebugCRT(bool)用来控制输出的 Runtime Librart 类型是 MT 还是 MD； 还用来控制添加 _DEBUG 和NODEBUG宏： 123456789101112public override void SetUpConfigurationEnvironment(ReadOnlyTargetRules Target, CppCompileEnvironment GlobalCompileEnvironment, LinkEnvironment GlobalLinkEnvironment)&#123; if (GlobalCompileEnvironment.bUseDebugCRT) &#123; GlobalCompileEnvironment.Definitions.Add(&quot;_DEBUG=1&quot;); // the engine doesn&#x27;t use this, but lots of 3rd party stuff does &#125; else &#123; GlobalCompileEnvironment.Definitions.Add(&quot;NDEBUG=1&quot;); // the engine doesn&#x27;t use this, but lots of 3rd party stuff does &#125; // other code&#125; ProjectDefinitions(List&lt;string&gt;)为当前项目添加的宏定义，在整个项目中可用。 GlobalDefinitions(List&lt;string&gt;)添加在整个 Target 中都可以用的宏定义。 bShouldCompileAsDLL(bool)将 Target 编译为 DLL，为 true 时要求 LinkType 为Monolithic。 12345/// &lt;summary&gt;/// Whether this target should be compiled as a DLL. Requires LinkType to be set to TargetLinkType.Monolithic./// &lt;/summary&gt;[RequiresUniqueBuildEnvironment]public bool bShouldCompileAsDLL = false; AdditionalCompilerArguments(String)传递给编译器的参数。 AdditionalLinkerArguments(String)传递给连接器的参数。 bUsesSlate(bool)控制打包时时候把 Slate 相关的图片资源打包到 pak 中。 Module与 Target 类似，每一个 Unreal 的 Module，都有一个专属的ModuleName.Build.cs 里面定义着专属的 ModuleName 类，它由 ModuleRules 继承而来，我们对 Module 构建时进行的操作就是通过它来控制。 注意：不管是 Game Module 还是 Plugin Module，只要是 项目依赖 的 Module，编译时它们都会接收到当前使用的 Target 信息。 ModuleRules的代码在 UnrealBuildTools/Configuration/ModuleRules，同样可以看一下支持的属性默认值；UE 对Modules 描述的官方文档：Modules，这里也同样只有代码的注释内容，没有实际例子，我就先来分析一些在工程中常见的 Build.cs 中属性的含义。 *.Build.cs中可以通过它构造接收的 ReadOnlyTargetRules Target 参数来获取 *.Target.cs 中的属性信息。 1234567891011using UnrealBuildTool;using System.IO;public class GWorld : ModuleRules&#123; public GWorld(ReadOnlyTargetRules ReadOnlyTargetRules) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; // something &#125;&#125; 通过 Target 对象，可以在 *.build.cs 中控制对不同的平台(Platform)，架构(Architecture)，以及其他的选项来对 Module 进行不同的操作(比如定义不同的宏 / 包含不同的 ThridParty/ 链接不同的 Lib 等等)。 ModuleDirectory string ModuleDirectory：项目的源码路径 PROJECT_NAME/Source/PROJECT_NAME 的绝对路径。 EngineDirectory string EngineDirectory：引擎目录 Engine/ 在当前环境的绝对路径。 PublicAdditionalLibraries添加静态链接库文件 (注意与PublicLibraryPaths 的区别)，一般是用于第三方库的链接。 12345678PublicAdditionalLibraries.AddRange( new string[] &#123; Path.Combine(ThridPartyPath,&quot;protobuf/lib/Win64/MD/Release&quot;,&quot;libprotobuf.lib&quot;), Path.Combine(ThridPartyPath,&quot;protobuf/lib/Win64/MD/Release&quot;,&quot;libprotobuf-lite.lib&quot;), Path.Combine(ThridPartyPath,&quot;protobuf/lib/Win64/MD/Release&quot;,&quot;libprotoc.lib&quot;), &#125;); 详细的内容可以看：Linking Static Libraries Using The Build System 同样可以用在 DLL 的导入库，与 PublicDelayLoadDLLs 和RuntimeDependencies配合使用。 PublicAdditionalShadowFiles当执行远程编译的时候，指定当前模块需要复制到远程服务器上的文件，确保能够链接成功。 如远程打包 IOS 平台时，需要把当前模块依赖的静态链接库添加到里面（如 Game 模块依赖某个插件中的 External 模块）。 RuntimeDependencies list&lt;RuntimeDependency&gt; RuntimeDependencies：Module 在运行时依赖的文件 (.so/.dll 等)，打包时将会拷贝到存储目录。 在打包 Windows 时会直接把文件拷贝到打包的对应目录下，但是在 Android 上会把文件放到 Apk 包的 main.obb.webp 中。 PublicDelayLoadDLLs List&lt;string&gt; PublicDelayLoadDLLs：延迟加载的 DLL 列表，通常用于第三方库。 123// build.csPublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, &quot;myExternalLib.lib&quot;));PublicDelayLoadDLLs.Add(&quot;myExternalLib.dll&quot;); 含义是不在程序启动时立即加载 DLL 的列表，等到首次需要使用他们的符号后再进行加载。这样可以在模块的 StartupModule 中自行指定位置并加载他们，从而实现可以不把 dll 放到 exe 的目录。 123456FString AbsPath = FileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*MyLibPath);FPlatformProcess::AddDllDirectory(AbsPath)FPlatformProcess::PushDllDirectory(*AbsPath);// direct call dll function// or load dll handle// void* DLLHandle3 = FPlatformProcess::GetDllHandle(L&quot;myExternalLib.dll&quot;); PS：配合 PublicAdditionalLibraries 可以用在使用 DLL 导入库的第三方库。 使用 PublicAdditionalLibraries 添加 lib DLL 的名字添加至 PublicDelayLoadDLLs 使用 RuntimeDependencies 打包时拷贝 dll 如果拷贝到的目录不是 exe 路径，需要 StartupModule 里执行 AddDllDirectory 和PushDllDirectory把 dll 的路径添加到里面 PublicDelayLoadDLLs 只添加 xxxx.dll 就可以了，不需要路径。 我使用 GoogleInstantPreview 测试使用 DLL+ 导入库并将 DLL 放在非 exe 目录的例子：ue4-plugin-GoogleInstanceIns.7z Runtime error when referencing external library in Unreal Engine How Unreal Build Tool works PublicDefinitions List&lt;string&gt; PublicDefinitions：为当前 Module 添加公开宏定义，等同于传统 VS 项目在项目设置中添加一个预处理宏。 它被 UBT 分析之后会在产生一个 Definitions.PROJECT_NAME.h 的头文件，里面定了各种宏。 1Intermediate\\Build\\Win64\\UE4Editor\\Development\\ReflectionExample\\Definitions.ReflectionExample.h PublicSystemIncludePaths List&lt;string&gt; PublicSystemIncludePaths：文档介绍是用于添加系统的 Include 路径，与 PublicIncludePaths 的区别是会跳过头文件解析检查(但是经我测试，使用这种方式包含的代码依然会检测下列错误(UE_4.20)): 1error : Expected mpack-platform.h to be first header included. 注意：如果不指定路径，则默认的 IncludePath 路径是Engine/Source。 比如： 12345PublicSystemIncludePaths.AddRange( new string[] &#123; &quot;TEST_LIB&quot; &#125;); 它表示的路径是： 1D:\\UnrealEngine\\Epic\\UE_4.21\\Engine\\Source\\TEST_LIB 所有可以在 *.build.cs 中指定的*IncludePaths，默认的路径都是Engine/Source. PrivateRuntimeLibraryPaths List&lt;string&gt; PrivateRuntimeLibraryPaths：运行时库的搜索路径。例如 .so 或者.dll。 PublicRuntimeLibraryPaths List&lt;string&gt; PublicRuntimeLibraryPaths：运行时库的搜索路径。例如 .so 或者.dll。 因为动态链接库的查找路径默认只有： 系统的 PATH 路径； 可执行程序的当前目录； 如果我们的动态链接库在其他的位置，运行时就会错误，可以通过 PublicRuntimeLibraryPaths 或者 PrivateRuntimeLibraryPaths 来添加。 PublicLibraryPaths添加链接库文件的 路径，如在源码中使用的: 1#pragma comment(lib,&quot;Lua.lib&quot;) 可以通过 PublicLibraryPaths 来添加依赖的 Lib。 DynamicallyLoadedModuleNames List&lt;string&gt; DynamicallyLoadedModuleNames：添加需要运行时动态加载的 Module，使用 FModuleManager::LoadModuleChecked&lt;MODULE_TYPE&gt;(TEXT(&quot;MODULE_NAME&quot;)) 等函数启动。 12// e.gFModuleManager::LoadModuleChecked&lt; IAIModule &gt;(&quot;AIModule&quot; ); PublicDependencyModuleNames List&lt;string&gt; PublicDependencyModuleNames：添加对执行 Module 的源文件依赖，自动添加所依赖 Module 的 Public 和Private源文件包含。 PrivateDependencyModuleNames List&lt;string&gt; PrivateDependencyModuleNames：与 PublicDependencyModuleNames 不同的是，意味着所依赖的 Module 中的源文件只可以在 Private 中使用。 假如现在有一个模块 A，还有一个模块 B，他们中都是 UE 的 Module/Public 和Module/Private的文件结构。 如果 B 中依赖 A，如果使用的是 PrivateDependencyModuleNames 的方式添加的依赖，则 A 模块的源文件只可以在 B 的 Private 目录下的源文件中使用，在 Public 目录下的源文件使用时会报 No such file or directory 的错误。 如果使用的是 PublicDependencyModuleNames 方式添加的依赖，则 A 的源文件在 B 的 Public 与Private中都可用。 除了上述的区别之外，还影响依赖于 B 模块的模块 ，当一个模块 C 依赖模块 B 的时候，只能访问到 B 模块的 PublicDependencyModule 中的模块暴露出来的类。例如，C 依赖 B，B 依赖 A；那么，假如 C 想访问 A 中的类则有两种方式： 在 C 的依赖中添加上 A 模块 确保 B 在 PublicDependencyModuleNames 依赖中添加的 A 模块，这样 C 就可以间接的访问到 A。 经过测试发现，其实对于 游戏模块 (PROJECT_NAME/Source/PROJECT_NAME.target.cs) 使用而言，所依赖的模块是使用 PublicDependencyModuleNames 还是 PrivateDependencyModuleNames 包含，没什么区别。使用 Private 方式依赖的 Module 中的头文件依然可以在游戏模块的 Public 中用，这一点与插件等其他模块有所不同（但是这只有在所依赖的模块不是 bUsePreCompiled 的基础上的，如果所依赖的模块是 bUsePreCompiled 的，则与其他的模块一样，PrivateDependencyModuleNames依赖的模块不可以在 Pulibc 目录下的源文件使用），这个行为比较奇怪：有时候出错有时又不出错。 注意：在游戏项目中使用依赖其他 Module 时尽量确定性需求地使用 PrivateDependencyModuleNames 或者PublicDependencyModuleNames，在组合其他的选项时可能会有一些奇怪的行为。 相关的讨论： What is the difference between PublicDependencyModuleNames and PrivateDependencyModuleNames Explanation of Source Code folder structure? bPreCompile 与 bUsePreCompiled123456789/// &lt;summary&gt;/// Whether this module should be precompiled. Defaults to the bPrecompile flag from the target. Clear this flag to prevent a module being precompiled./// &lt;/summary&gt;public bool bPrecompile;/// &lt;summary&gt;/// Whether this module should use precompiled data. Always true for modules created from installed assemblies./// &lt;/summary&gt;public bool bUsePrecompiled; 这个两个属性需要组合来使用。 考虑下列需求：如果我们写好的一个模块 A 希望拿给别人来用，但是又不想把所有代码开放出来，该怎么办？ 在传统的 C++ 领域，我应该会说：把代码编译成 DLL，然后把头文件和 DLL 发放给用户就可以啦。对！其实 bPreCompile 和bUsePreCompiled就是做的类似的事情。 当我们对模块 A 进行编译之前，在它的 *.build.cs 中添加： 123456789public class A : ModuleRules&#123; public A(ReadOnlyTargetRules Target) : base(Target) &#123; // ... bPreCompile=true; // ... &#125;&#125; 然后编译模块 A。编译完成之后，将模块 A 的 Source/Private 删除 (删除之前请确保你已经备份)，然后删除模块目录下的Intermediate，但是要保留Binaries 目录。最后，打开模块 A 的 A.build.cs，将bPreCompile=true; 删掉，然后再添加： 123456789public class A : ModuleRules&#123; public A(ReadOnlyTargetRules Target) : base(Target) &#123; // ... bUsePreCompiled=true; // ... &#125;&#125; 此时我们想要实现的目标都已经完成了：不发布实现代码(Private)，发布预先编译好的二进制，但是这样无法进行静态链接，如果只是暴露给蓝图使用可以，在其他的 Module 中使用它的符号会有符号未定义错误。 OptimizeCode(CodeOptimization)这个属性是用来控制当前模块是否要开启优化代码，在我们用 VS 调试时，有时候会看到“变量已被优化，因而不可用”，这就是因为被优化了。 可以使用它来关闭优化： 12// build.csOptimizeCode = CodeOptimization.Never; CodeOptimization支持几种值，默认是Default，开启优化： Never Default InNonDebugBuilds InShippingBuildsOnly 相关的代码： 12345678910111213141516// UnrealBuildTool/Configutation/UEBuildModuleCPP.cspublic static bool ShouldEnableOptimization(ModuleRules.CodeOptimization Setting, UnrealTargetConfiguration Configuration, bool bIsEngineModule)&#123; switch(Setting) &#123; case ModuleRules.CodeOptimization.Never: return false; case ModuleRules.CodeOptimization.Default: case ModuleRules.CodeOptimization.InNonDebugBuilds: return (Configuration == UnrealTargetConfiguration.Debug)? false : (Configuration != UnrealTargetConfiguration.DebugGame || bIsEngineModule); case ModuleRules.CodeOptimization.InShippingBuildsOnly: return (Configuration == UnrealTargetConfiguration.Shipping); default: return true; &#125;&#125; 这个函数在 UEBuildModuleCPP.cs 的CreateModuleCompileEnvironment中调用，将结果赋值给了 CppCompileEnvironment.bOptimizeCode，进而又在VCToolChain.cs 中被使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374UnrealBuildTool\\Platform\\Windows\\VCToolChain.csvoid AppendCLArguments_Global(CppCompileEnvironment CompileEnvironment, List&lt;string&gt; Arguments)&#123; // other code ... // // Debug // if (CompileEnvironment.Configuration == CppConfiguration.Debug) &#123; // Disable compiler optimization. Arguments.Add(&quot;/Od&quot;); // Favor code size (especially useful for embedded platforms). Arguments.Add(&quot;/Os&quot;); // Allow inline method expansion unless E&amp;C support is requested if (!CompileEnvironment.bSupportEditAndContinue &amp;&amp; CompileEnvironment.bUseInlining) &#123; Arguments.Add(&quot;/Ob2&quot;); &#125; if ((CompileEnvironment.Platform == CppPlatform.Win32) || (CompileEnvironment.Platform == CppPlatform.Win64)) &#123; Arguments.Add(&quot;/RTCs&quot;); &#125; &#125; // // Development and LTCG // else &#123; if(!CompileEnvironment.bOptimizeCode) &#123; // Disable compiler optimization. Arguments.Add(&quot;/Od&quot;); &#125; else &#123; // Maximum optimizations. Arguments.Add(&quot;/Ox&quot;); // Favor code speed. Arguments.Add(&quot;/Ot&quot;); // Coalesce duplicate strings Arguments.Add(&quot;/GF&quot;); // Only omit frame pointers on the PC (which is implied by /Ox) if wanted. if (CompileEnvironment.bOmitFramePointers == false &amp;&amp; ((CompileEnvironment.Platform == CppPlatform.Win32) || (CompileEnvironment.Platform == CppPlatform.Win64))) &#123; Arguments.Add(&quot;/Oy-&quot;); &#125; &#125; // Allow inline method expansion Arguments.Add(&quot;/Ob2&quot;); // // LTCG // if (CompileEnvironment.bAllowLTCG) &#123; // Enable link-time code generation. Arguments.Add(&quot;/GL&quot;); &#125; &#125; // other code...&#125; 可以看到，在 Debug 的环境下，是默认关闭优化的。在非 Debug 时根据 CompileEnvironment.bOptimizeCode 的值来决定是否开启优化。调试效果：当使用默认时（OptimizeCode = CodeOptimization.Default;）: 当关闭代码优化时(OptimizeCode = CodeOptimization.Never;)： 建议使用OptimizeCode = CodeOptimization.InShippingBuildsOnly;。 注意：这个选项和普通的 C++ 项目在 VS 中的 Properties-Configuration-C/C++-Optimization-Optimization 的设置时一样的。 bEnableUndefinedIdentifierWarnings (bool)是否启用在预处理代码 #if 中使用未定义标识符的警告。 1#if GOOGLE_PROTOBUF_USE_UNALIGNED 如果这个宏未定义，在启用 bEnableUndefinedIdentifierWarnings 的情况下会产生 C4688 错误。 相关的代码时定义在 UBT 的代码中的: 123456789101112// Source\\Programs\\UnrealBuildTool\\Platform\\Windows\\VCToolChain.csif(WindowsPlatform.bUseVCCompilerArgs &amp;&amp; CompileEnvironment.bEnableUndefinedIdentifierWarnings)&#123; if (CompileEnvironment.bUndefinedIdentifierWarningsAsErrors) &#123; Arguments.Add(&quot;/we4668&quot;); &#125; else &#123; Arguments.Add(&quot;/w44668&quot;); &#125;&#125; bUseRTTI (bool)UE4 默认关闭了 RTTI，所以在工程的代码中写了类似 typeid 的代码，会产生下列错误： 123In file included from C:\\UnrealProject_\\Source\\GWorld\\Private\\Modules\\Flibs\\FLibIniConfigHelper.cpp:10:C:/UnrealProject_/Source/GWorld/Public/Modules/Flibs\\FlibMateReflectionHelper.h(29,41): error: cannot use typeid with -fno-rtti FString EnumTypeName = ANSI_TO_TCHAR(typeid(ENUM_TYPE).name()); 解决办法只有两个：去掉 rtti 相关的代码，或者在当前 Module 的build.cs中把 bUseRTTI 设置为true。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"UBT","slug":"BuildSystem/UBT","permalink":"https://ue5wiki.com/categories/BuildSystem/UBT/"}]},{"title":"UnrealPak","date":"2019-09-09T11:26:34.000Z","path":"wiki/35741/","text":"UnrealPak 是 UE 的资源打包工具，当进行打包和热更资源时需要把 Cook 后的 uasset 资源打包成一个 pak 文件，供运行时加载。它支持的参数: 1234567891011121314151617181920212223242526Usage:UnrealPak &lt;PakFilename&gt; -TestUnrealPak &lt;PakFilename&gt; -List [-ExcludeDeleted]UnrealPak &lt;PakFilename&gt; &lt;GameUProjectName&gt; &lt;GameFolderName&gt; -ExportDependencies=&lt;OutputFileBase&gt; -NoAssetRegistryCache -ForceDependsGatheringUnrealPak &lt;PakFilename&gt; -Extract &lt;ExtractDir&gt; [-Filter=&lt;filename&gt;]UnrealPak &lt;PakFilename&gt; -Create=&lt;ResponseFile&gt; [Options]UnrealPak &lt;PakFilename&gt; -Dest=&lt;MountPoint&gt;UnrealPak &lt;PakFilename&gt; -Repack [-Output=Path] [-ExcludeDeleted] [Options]UnrealPak &lt;PakFilename1&gt; &lt;PakFilename2&gt; -diffUnrealPak &lt;PakFolder&gt; -AuditFiles [-OnlyDeleted] [-CSV=&lt;filename&gt;] [-order=&lt;OrderingFile&gt;] [-SortByOrdering]UnrealPak &lt;PakFilename&gt; -WhatsAtOffset [offset1] [offset2] [offset3] [...]UnrealPak &lt;PakFolder&gt; -GeneratePIXMappingFile -OutputPath=&lt;Path&gt;UnrealPak -TestEncryptionOptions: -blocksize=&lt;BlockSize&gt; -bitwindow=&lt;BitWindow&gt; -compress -encrypt -order=&lt;OrderingFile&gt; -diff (requires 2 filenames first) -enginedir (specify engine dir for when using ini encryption configs) -projectdir (specify project dir for when using ini encryption configs) -encryptionini (specify ini base name to gather encryption settings from) -extracttomountpoint (Extract to mount point path of pak file) -encryptindex (encrypt the pak file index, making it unusable in unrealpak without supplying the key) -compressionformat[s]=&lt;Format[,format2,...]&gt; (set the format(s) to compress with, falling back on failures) 直接在编辑器中执行打包的命令(UE4.22.3，这里在指定了加密)： 123456789&quot;D:\\UnrealEngine\\UE_4.22\\Engine\\Binaries\\Win64\\UnrealPak.exe&quot; &quot;C:\\Users\\Administrator\\Documents\\Unreal Projects\\Mobile422\\Saved\\StagedBuilds\\WindowsNoEditor\\Mobile422\\Content\\Paks\\Mobile422-WindowsNoEditor.pak&quot; -create=&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.22\\PakList_Mobile422-WindowsNoEditor.txt&quot; -cryptokeys=&quot;C:\\Users\\Administrator\\Documents\\Unreal Projects\\Mobile422\\Saved\\Cooked\\WindowsNoEditor\\Mobile422\\Metadata\\Crypto.json&quot; -order=&quot;C:\\Users\\Administrator\\Documents\\Unreal Projects\\Mobile422\\Build\\WindowsNoEditor\\FileOpenOrder\\CookerOpenOrder.log&quot; -encryptindex -patchpaddingalign=2048 -compressionformats= &quot;C:\\Users\\Administrator\\Documents\\Unreal Projects\\Mobile422\\Mobile422.uproject&quot; -multiprocess -abslog=&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\C+Program+Files+Epic+Games+UE_4.22\\UnrealPak-Mobile422-WindowsNoEditor-2020.02.11-18.48.15.txt&quot; cryptokeys 指定参数的结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;$types&quot;:&#123; &quot;UnrealBuildTool.EncryptionAndSigning+CryptoSettings, UnrealBuildTool, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null&quot;:&quot;1&quot;, &quot;UnrealBuildTool.EncryptionAndSigning+EncryptionKey, UnrealBuildTool, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null&quot;:&quot;2&quot;, &quot;UnrealBuildTool.EncryptionAndSigning+SigningKeyPair, UnrealBuildTool, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null&quot;:&quot;3&quot;, &quot;UnrealBuildTool.EncryptionAndSigning+SigningKey, UnrealBuildTool, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null&quot;:&quot;4&quot; &#125;, &quot;$type&quot;:&quot;1&quot;, &quot;EncryptionKey&quot;:&#123; &quot;$type&quot;:&quot;2&quot;, &quot;Name&quot;:&quot;Embedded&quot;, &quot;Guid&quot;:&quot;00000000-0000-0000-0000-000000000000&quot;, &quot;Key&quot;:&quot;+c0unLTPVpJ8E2MAs3SrUh/bRHasFOvq1kKXnmZBZcw=&quot; &#125;, &quot;SigningKey&quot;:&#123; &quot;$type&quot;:&quot;3&quot;, &quot;PublicKey&quot;:&#123; &quot;$type&quot;:&quot;4&quot;, &quot;Exponent&quot;:&quot;AQAB&quot;, &quot;Modulus&quot;:&quot;m48Hq1rQKqljGUBCVku+qxFoa1oVBXghOWKSPArwl9uixba6pxlgqyV/BINWRYQMzgcdKPvGgusRIlalPqEEQB9XibCqJahUpxszoNkhH33cWSpMKZ8XWNmnvAZvtebpqtJYVP1ebqNGvCEm+e54dsxvRJJGmcOB6Wi36/l4c9/+zgNF5BZQItOlDc8OCYlttAvDhgExDow4leNuU/nBh12rcKD4P0KmIYdPzFBYgTe18DyJ12GKf2rStFF9VDlTsp+Gl7ZejPzQ7/CsX0eSHHplsZjjCB6mlmBStFOY7OWMLS/pnYAQ6Ywnaf+tBNz4Fd9eBBxwD0Vn+dU4YDxEJYvZuVkOqyio581jHn5U7rjTofzTyHvy5tzWuYF52R2dGkcTBgjkbmE0Z6nkZ2TdPEog15eZClsHHMseyzhBa3LCC2nmnvZqppV4+Ijj5e1XKEobPOgVZMejXNukW1dzfX9gMf1NrOD2KX2cnyPT6IvP6zu5Cztiy3rVtBiDtQIaQnaCsix8t0+oh5aqzhj6GrblcYs1JX/uy0OYO+hO/yTLET378TehhRjYbnHQsS2PBqBVM6i7hK7xT1TxuUE5oJYJULDWmOn9AZKmnzkx+VyQgmqmNA/L0vJqOhsDvvA29UGNEn5junydqkQlLP4OovlZcoic2R/tYPFcwMKPp68=&quot; &#125;, &quot;PrivateKey&quot;:&#123; &quot;$type&quot;:&quot;4&quot;, &quot;Exponent&quot;:&quot;URhnOOSPQp7VG5FxGq2wLQ+k3FJUQEy+GWOYxbk8KKNwtbt/Fy+agBMtuZOuLKmhjWrIpU0+i78rM7cFur3qXI5TUFZ1Jj2eIhxrphoKnu99FmcLEIICtFp0Y/rbyv1RmBSvh9E+kMebvw2KGlVVl8JNhRnyZtdHEoWN7YV+zeSNuGDh8h6pJkN8b15PuXZhQw9RKa3WRsNy/3PCVkNILsOI7L+VZTQ3Zl0q3DghlaHNZlkeyLp/uSnArayUdWlTBq8H0ZtyaAlgBhFNnh/CkQFenpnz2EKSO4aMGo6NkIjbYEYoK5t119z0S56JbzGA71iDqW3VxK5KxZcDLItU8yGp7zi6SPAJXvUxg/8rnXRZ/nm+8KVLwi3Itog8DWYR7zx4weNd2Tx4JvHx+FatLnM3ut6yiUiaW6uL0Zg+yLg1PXy5bEwlAlke/9c/Z7gyY+cLQVMv525LgMQQDje/wNaQT2QosN5Cum+5jPq/0BYB4kXeotvASS2FLRJyo43JjmyfP6oQLOtSNDqbf1jl4JtjoCXBFAZKz6cR4RP1CWst4mMLUJqgOjQeSdd5ihdYZErKPzlLpghQixC/dx3W0ISzkp9b22Ee302bHQHwio+4Gc8B2e/Iabd8TQZuq8LY9BSrllHda8NsG3TFt3hEC+fjdhbz5ur4nd1xgtPtP00=&quot;, &quot;Modulus&quot;:&quot;m48Hq1rQKqljGUBCVku+qxFoa1oVBXghOWKSPArwl9uixba6pxlgqyV/BINWRYQMzgcdKPvGgusRIlalPqEEQB9XibCqJahUpxszoNkhH33cWSpMKZ8XWNmnvAZvtebpqtJYVP1ebqNGvCEm+e54dsxvRJJGmcOB6Wi36/l4c9/+zgNF5BZQItOlDc8OCYlttAvDhgExDow4leNuU/nBh12rcKD4P0KmIYdPzFBYgTe18DyJ12GKf2rStFF9VDlTsp+Gl7ZejPzQ7/CsX0eSHHplsZjjCB6mlmBStFOY7OWMLS/pnYAQ6Ywnaf+tBNz4Fd9eBBxwD0Vn+dU4YDxEJYvZuVkOqyio581jHn5U7rjTofzTyHvy5tzWuYF52R2dGkcTBgjkbmE0Z6nkZ2TdPEog15eZClsHHMseyzhBa3LCC2nmnvZqppV4+Ijj5e1XKEobPOgVZMejXNukW1dzfX9gMf1NrOD2KX2cnyPT6IvP6zu5Cztiy3rVtBiDtQIaQnaCsix8t0+oh5aqzhj6GrblcYs1JX/uy0OYO+hO/yTLET378TehhRjYbnHQsS2PBqBVM6i7hK7xT1TxuUE5oJYJULDWmOn9AZKmnzkx+VyQgmqmNA/L0vJqOhsDvvA29UGNEn5junydqkQlLP4OovlZcoic2R/tYPFcwMKPp68=&quot; &#125; &#125;, &quot;bEnablePakSigning&quot;:true, &quot;bEnablePakIndexEncryption&quot;:true, &quot;bEnablePakIniEncryption&quot;:true, &quot;bEnablePakUAssetEncryption&quot;:true, &quot;bEnablePakFullAssetEncryption&quot;:true, &quot;bDataCryptoRequired&quot;:true, &quot;PakEncryptionRequired&quot;:true, &quot;PakSigningRequired&quot;:true, &quot;SecondaryEncryptionKeys&quot;:[ &#123; &quot;$type&quot;:&quot;2&quot;, &quot;Name&quot;:&quot;Key1&quot;, &quot;Guid&quot;:&quot;757096074E55F5FCA962949C55209CCB&quot;, &quot;Key&quot;:&quot;SsukCy4DShNsMi5e9jUpMWJi5qtTA+rLeIoTHRtjM0o=&quot; &#125; ]&#125; 它是根据 Project Setting-Crypto 中的设置生成的。 UnrealPak 比较常用的命令组合： 12345678# 将 COOCKED_ASSET_FOLDER 路径下所有 cookedd 的资源打包到一个 pak 里面，并执行压缩 unrealpak.exe NEW_PAK_FILE_NAME.pak -create=COOCKED_ASSET_FOLDER -compress# 加密 pak，需要指定32 位的 AES key，要执行加密 -encrypt/-encrtptindex/-aes 缺一不可。unrealpak.exe NEW_PAK_FILE_NAME.pak -create=COOCKED_ASSET_FOLDER -compress -encrypt -encryptindex -aes=32BIT_AES_KEY# 查看 pak 中的资源列表unrealpak.exe PAK_FILE_NAME.pak -list# 查看加密的 pak 中的资源列表unrealpak.exe NEW_PAK_FILE_NAME.pak -list -aes=32BIT_AES_KEY 相关工具： AES 的在线加解密工具 UnrealPakViewer umodel 在 Project Setting-Project-Crypto 中可以选择加密项目并且直接生成EncryptionKey： UnrealPak 是一个 StandaloneApplication 程序，它的启动代码在：Engine/Source/Programs/UnrealPak/Private/UnrealPak.cpp.但是它只是一个转发函数，真正的实现代码是在引擎中的 ExecuteUnrealPak 函数，其在引擎中的位置为Engine/Source/Developer/PakFileUtilities/Private/PakFileUtilities.cpp UnrealPak 为 pak 生成 sig: 注意：在 UE4.23+ 引擎版本中，在指定 cryptokeys 参数时，需要同时指定-sign。 1$ UnrealPak.exe D:\\TEST_SIG.pak -create=&quot;XXXXXXX.txt&quot; -cryptokeys=&quot;Crypto.json&quot; 其中 Crypto.json 文件在你使用编辑器打包的时候会生成，它是根据 Project Setting-Crypto 中的设置生成的，保存在路径： 1PROJECT_DIRECTORY\\Saved\\Cooked\\WindowsNoEditor\\PROJECT_NAME\\Metadata\\Crypto.json 注意 PROJECT_DIRECTORY 和PROJECT_NAME都换成你自己的。 Crypto.json这个文件的生成是在 AutomationTool 这个工具里面的，相关的代码在： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Source\\Programs\\AutomationTool\\Scripts\\CopyBuildToStagingDirectory.Automation.cs/// &lt;summary&gt;/// Creates a pak file using staging context (single manifest)/// &lt;/summary&gt;/// &lt;param name=&quot;Params&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;SC&quot;&gt;&lt;/param&gt;private static void CreatePakUsingStagingManifest(ProjectParams Params, DeploymentContext SC)&#123; LogInformation(&quot;Creating pak using staging manifest.&quot;); DumpManifest(SC, CombinePaths(CmdEnv.LogFolder, &quot;PrePak&quot; + (SC.DedicatedServer ? &quot;_Server&quot; : &quot;&quot;))); var UnrealPakResponseFile = CreatePakResponseFileFromStagingManifest(SC, SC.FilesToStage.UFSFiles); List&lt;PakFileRules&gt; PakRulesList = GetPakFileRules(Params, SC); List&lt;string&gt; PakList = new List&lt;string&gt;(); List&lt;string&gt; FilesToRemove = new List&lt;string&gt;(); // Apply the pak file rules, this can remove things but will not override the pak file name foreach (var StagingFile in UnrealPakResponseFile) &#123; bool bExcludeFromPaks = false; ApplyPakFileRules(PakRulesList, StagingFile, PakList, out bExcludeFromPaks); if (bExcludeFromPaks) &#123; FilesToRemove.Add(StagingFile.Key); &#125; &#125; foreach (var FileToRemove in FilesToRemove) &#123; UnrealPakResponseFile.Remove(FileToRemove); &#125; EncryptionAndSigning.CryptoSettings PakCryptoSettings = EncryptionAndSigning.ParseCryptoSettings(DirectoryReference.FromFile(Params.RawProjectPath), SC.StageTargetPlatform.IniPlatformType); FileReference CryptoKeysCacheFilename = FileReference.Combine(SC.MetadataDir, &quot;Crypto.json&quot;); PakCryptoSettings.Save(CryptoKeysCacheFilename); List&lt;CreatePakParams&gt; PakInputs = new List&lt;CreatePakParams&gt;(); PakInputs.Add(new CreatePakParams(SC.ShortProjectName, UnrealPakResponseFile, Params.Compressed, null)); CreatePaks(Params, SC, PakInputs, PakCryptoSettings, CryptoKeysCacheFilename);&#125; EncryptionAndSigning这个类是定义在UnrealBuildTool\\System\\EncryptionAndSigning，在里面可以看到对 DefaultCrypto.ini 文件的解析。","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Tools","slug":"Tools","permalink":"https://ue5wiki.com/tags/Tools/"},{"name":"UnrealPak","slug":"UnrealPak","permalink":"https://ue5wiki.com/tags/UnrealPak/"},{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"VisualStudio 调试 UE 项目技巧","date":"2019-09-08T12:24:45.000Z","path":"wiki/14373/","text":"在 VS 中调试时显示对象值 打开引擎路径: 1Engine\\Extras\\VisualStudioDebugging 该路径下会有一个 UE4.natvis.zip 文件，将其拷贝到 VS 的下列路径中： 1C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Packages\\Debugger\\Visualizers 然后重启启动调试，就可以在调试窗口看到对象值了。 调试独立运行的 UE 项目 在 UE 的编辑器模式下以 Standalone 方式运行，在 VS 中是没办法及时 Attach to process 上的。比如我们想要在 standalone 模式下调试引擎和项目，在 editor 下直接启动会创建一个新的进程，在 VS 中手动点 Attach to process 是很不方便的，也没有那么及时 (因为点完启动在等我们在 VS 中 attach 到进程上有可能引擎都已经启动完毕了)。 幸好 UE 提供了一个插件：UnrealVS，该插件的 VS 安装程序在引擎的 Engine\\Extras\\UnrealVS 目录下，根据你的 VS 版本选择安装。安装完之后启动 VS，在 View-&gt;Toolbars-&gt;UnrealVS 启用，就会在 VS 的工具栏看到了。在这里选择你的项目： 后面的框是命令行框，填入的参数会在启动时传递给程序 (具体介绍看UnrealVS 里面的描述)，所以我们可以在后面填参数使其以独立模式启动 (可以从Command-Line Arguments 查看支持的参数)： 1&quot;$(SolutionDir)$(ProjectName).uproject&quot; -game -windowed -log -verbose 这样就会在 VS 中使用 F5 启动项目时自动 attach 的到进程上的。 关闭代码优化 在调试时关闭 Target 或者指定模块的代码优化，能够更好的分析问题。ModuleRules的 OptimizeCode 属性是用来控制当前模块是否要开启优化代码，在我们用 VS 调试时，有时候会看到“变量已被优化，因而不可用”，这就是因为被优化了。可以使用它来关闭优化： 12// build.csOptimizeCode = CodeOptimization.Never; 具体的分析见这篇内容：变量已被优化，因而不可用。","tags":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/tags/Debugging/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://ue5wiki.com/tags/Visual-Studio/"},{"name":"调试","slug":"调试","permalink":"https://ue5wiki.com/tags/%E8%B0%83%E8%AF%95/"}],"categories":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/categories/Debugging/"}]},{"title":"UBT 中 EULA 的内容分发限制","date":"2019-08-24T14:15:36.000Z","path":"wiki/9050/","text":"UE 的 EULA License Grant/(A) 中明确说明了，使用 UE 开发并再分发的内容不得包含 未 Cook 的源格式 和基于 引擎工具 开发的付费内容，本篇文章研究一下 EULA 里对内容分发的具体内容和从技术上怎么绕过这个限制。 There is no restriction on your Distribution of a Product made using the Licensed Technology that does not include any Engine Code or any Paid Content Distributed in uncooked source format (in each case, including as modified by you under the License) and does not require any Licensed Technology (including as modified by you under the License) to run (“Unrestricted Products”). For clarity, the foregoing does not constitute a license under any patents, copyrights, trademarks, trade secrets or other intellectual property rights, whether by implication, estoppel or otherwise. 而 EULA 中对于 Engine Tools 的定义是： “Engine Tools” means (a) editors and other tools included in the Engine Code; (b) any code and modules in either the Developer or Editor folders, including in object code format, whether statically or dynamically linked; and (c) other software that may be used to develop standalone products based on the Licensed Technology. 这意味着开发者无法在游戏内容中使用 Editor 与Developer下的任何模块。用户协议是具有 法律效力 的协议文件，我本着要折腾一下的精神并且想顺便看一下 UE 是怎么实现这个限制的，仅作记录分析用，并不会对内容进行收费的二次分发 或用在正式的项目中。我读了一下 UBT 的处理逻辑，UBT 的代码只需要简单地改几处。 注意：在正式的发行版本中这么做是违反 UE 的 EULA 的，强烈不建议在正式项目中这么做。本文代码和编译均基于 UE_4.18 版本(本地通过源码编译出的引擎)，本文介绍的操作不适用从 EpicLauncher 安装的引擎，文末会写原因。 在 UE 中，当打包的游戏 (Target is Game) 为Shipping的时候，如果工程中中包含了 Editor/Developer 的模块，会报下列错误： 1UATHelper: Packaging (Windows (64-bit)): ERROR: ERROR: Non-editor build cannot depend on non-redistributable modules. C:\\Users\\imzlp\\Documents\\Unreal Projects\\EULA418\\Binaries\\Win64\\EULA418-Win64-Shipping.exe depends on &#x27;DesktopPlatform&#x27;. 意思就是 DesktopPlatform 是不可再发行的模块，你不能在 Game 中用，通过查看 UBT 的代码发现这个异常是在 UBT 的 CheckForEULAViolation 中抛出的： 1234567891011121314151617181920212223242526272829303132333435363738394041// Source/Programs/UnrealBuildTools/Configuration/UEBuildTarget.csprivate void CheckForEULAViolation()&#123; if (TargetType != TargetType.Editor &amp;&amp; TargetType != TargetType.Program &amp;&amp; Configuration == UnrealTargetConfiguration.Shipping &amp;&amp; Rules.bCheckLicenseViolations) &#123; bool bLicenseViolation = false; foreach (UEBuildBinary Binary in AppBinaries) &#123; List&lt;UEBuildModule&gt; AllDependencies = Binary.GetAllDependencyModules(true, false); IEnumerable&lt;UEBuildModule&gt; NonRedistModules = AllDependencies.Where((DependencyModule) =&gt; !IsRedistributable(DependencyModule) &amp;&amp; DependencyModule.Name != AppName ); if (NonRedistModules.Count() != 0) &#123; IEnumerable&lt;UEBuildModule&gt; NonRedistDeps = AllDependencies.Where((DependantModule) =&gt; DependantModule.GetDirectDependencyModules().Intersect(NonRedistModules).Any() ); string Message = string.Format(&quot;Non-editor build cannot depend on non-redistributable modules. &#123;0&#125; depends on &#x27;&#123;1&#125;&#x27;.&quot;, Binary.ToString(), string.Join(&quot;&#x27;, &#x27;&quot;, NonRedistModules)); if (NonRedistDeps.Any()) &#123; Message = string.Format(&quot;&#123;0&#125;\\nDependant modules &#x27;&#123;1&#125;&#x27;&quot;, Message, string.Join(&quot;&#x27;, &#x27;&quot;, NonRedistDeps)); &#125; if(Rules.bBreakBuildOnLicenseViolation) &#123; Log.TraceError(&quot;ERROR: &#123;0&#125;&quot;, Message); &#125; else &#123; Log.TraceWarning(&quot;WARNING: &#123;0&#125;&quot;, Message); &#125; bLicenseViolation = true; &#125; &#125; if (Rules.bBreakBuildOnLicenseViolation &amp;&amp; bLicenseViolation) &#123; throw new BuildException(&quot;Non-editor build cannot depend on non-redistributable modules.&quot;); &#125; &#125;&#125; 关键的判断是 IsRedistributable 这个方法(概念等同于 C++ 里的成员函数)： 1234567891011121314// Source/Programs/UnrealBuildTools/Configuration/UEBuildTarget.cspublic static bool IsRedistributable(UEBuildModule Module)&#123; if(Module.Rules != null &amp;&amp; Module.Rules.IsRedistributableOverride.HasValue) &#123; return Module.Rules.IsRedistributableOverride.Value; &#125; if(Module.RulesFile != null) &#123; return !Module.RulesFile.IsUnderDirectory(UnrealBuildTool.EngineSourceDeveloperDirectory) &amp;&amp; !Module.RulesFile.IsUnderDirectory(UnrealBuildTool.EngineSourceEditorDirectory); &#125; return true;&#125; 这里做的判断是模块是不是属于 Editor/Developer 的，是就返回true，从而进行下面的异常抛出。为了测试我将这里直接修改为return true; 只是改了上面之后还是打包不成功，不过现在的错误变成了链接错误。继续看 UBT 的代码后发现还有一个地方对打包是 Shipping 的模式做了判断（前后的 // ... 表示省略了不相关代码）： 12345678910111213141516171819202122232425262728293031323334353637383940414243// Source/Programs/UnrealBuildTools/Configuration/UEBuildTarget.csprotected void AddPrecompiledModules()&#123; // ... bool bAllowDeveloperModules = false; if(Configuration != UnrealTargetConfiguration.Shipping) &#123; Directories.Add(UnrealBuildTool.EngineSourceDeveloperDirectory); bAllowDeveloperModules = true; &#125; // Find all the modules that are not part of the standard set HashSet&lt;string&gt; FilteredModuleNames = new HashSet&lt;string&gt;(); foreach (string ModuleName in ModuleNames) &#123; FileReference ModuleFileName = RulesAssembly.GetModuleFileName(ModuleName); if (Directories.Any(x =&gt; ModuleFileName.IsUnderDirectory(x))) &#123; string RelativeFileName = ModuleFileName.MakeRelativeTo(UnrealBuildTool.EngineSourceDirectory); if (ExcludeFolders.All(x =&gt; RelativeFileName.IndexOf(x, StringComparison.InvariantCultureIgnoreCase) == -1) &amp;&amp; !PrecompiledModules.Any(x =&gt; x.Name == ModuleName)) &#123; FilteredModuleNames.Add(ModuleName); &#125; &#125; &#125; // Add all the plugins which aren&#x27;t already being built foreach(UEBuildPlugin PrecompilePlugin in PrecompilePlugins) &#123; foreach (ModuleDescriptor ModuleDescriptor in PrecompilePlugin.Descriptor.Modules) &#123; if (ModuleDescriptor.IsCompiledInConfiguration(Platform, TargetType, bAllowDeveloperModules &amp;&amp; Rules.bBuildDeveloperTools, Rules.bBuildEditor, Rules.bBuildRequiresCookedData)) &#123; string RelativeFileName = RulesAssembly.GetModuleFileName(ModuleDescriptor.Name).MakeRelativeTo(UnrealBuildTool.EngineDirectory); if (!ExcludeFolders.Any(x =&gt; RelativeFileName.Contains(x)) &amp;&amp; !PrecompiledModules.Any(x =&gt; x.Name == ModuleDescriptor.Name)) &#123; FilteredModuleNames.Add(ModuleDescriptor.Name); &#125; &#125; &#125; &#125; // ...&#125; 将上面关于 bAllowDeveloperModules 的部分注释掉，然后直接： 12Directories.Add(UnrealBuildTool.EngineSourceDeveloperDirectory);bool bAllowDeveloperModules=true; 重新编译 UBT 即可。 然后可以写个简单的例子测试了，比如使用 Developer 下的 DesktopPlatform 来调用系统的选择文件。首先在 *.build.cs 中添加 DesktopPlatform 模块依赖： 12PublicDependencyModuleNames.AddRange(new string[] &#123; &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;InputCore&quot; ,&quot;DesktopPlatform&quot;&#125;);PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;DesktopPlatform&quot; &#125;); 然后写一个简单的函数暴露给蓝图： 123456789101112131415161718192021222324252627282930313233343536373839// .hUCLASS()class EULA418_API UFileOperatorFlib : public UBlueprintFunctionLibrary&#123; GENERATED_BODY() UFUNCTION(BlueprintCallable) static FString ExtendGetOpenFileName();&#125;;// .cpp#include &quot;FileOperatorFlib.h&quot;#include &quot;Developer/DesktopPlatform/Public/DesktopPlatformModule.h&quot;#include &quot;Paths.h&quot;FString UFileOperatorFlib::ExtendGetOpenFileName()&#123; IDesktopPlatform* DesktopPlatform = FDesktopPlatformModule::Get(); if (DesktopPlatform) &#123; TArray&lt;FString&gt; OpenFilenames; const bool bOpened = DesktopPlatform-&gt;OpenFileDialog( nullptr, TEXT(&quot;OpenFileDialog&quot;), FString(TEXT(&quot;&quot;)), TEXT(&quot;&quot;), TEXT(&quot;All Files (*.*)&quot;), EFileDialogFlags::None, OpenFilenames ); if (OpenFilenames.Num() &gt; 0) &#123; return FPaths::ConvertRelativePathToFull(OpenFilenames[0]); &#125; &#125; return TEXT(&quot;&quot;);&#125; 正常的情况下，将上面的代码打包 Shipping 会产生文章最开始的错误，但是我们改过之后可以打包成功并且可以正确执行，这个简单的工程和打包的内容可以在 这里 下载。启动之后按下数字键 1(不是Num 1) 即可打开 windows 的选择文件窗口，选择之后会将选择的文件的路径显示到屏幕上。 注意：需要使用源码版引擎编译项目，如果编译时具有 noexcept 的错误，则可以在项目的 *.target.cs 中添加 bForceEnableExceptions = true;。 重新编译项目会编译引擎内的模块(打开从 EpicLauncher 安装的引擎文件夹就可以知道，默认 Editor/Developer 的模块是没有编译出静态链接库的，这也是不能用从 EpicLauncher 安装的引擎来执行本文的操作的原因)。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"EULA","slug":"EULA","permalink":"https://ue5wiki.com/tags/EULA/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"PixelStreaming：基本概念与上手初探","date":"2019-07-30T22:32:01.000Z","path":"wiki/614690b4/","text":"PixelStreaming 是 UE_4.21 开始支持的一项技术，简单来说就是能够将游戏跑在服务器上，你可以通过浏览器来玩，玩家端不需要额外操作，只需要一个浏览器，所有的逻辑处理和渲染都在“云”端执行。它不仅仅只是一个插件 (虽然有 PixelStreamingPlugin 这个插件，但它只是PixelStreaming 实现中的一环)，其实现具有一套独立与 UE 游戏的设计和组织方式。本篇文章主要介绍 PixelStreaming 中的基本概念和使用 PixelStreaming 的 Demo 的实际体验。 来看一下 UE 自己的介绍： Run your Unreal Engine application on a server in the cloud, and stream its rendered frames and audio to browsers and mobile devices over WebRTC. PixelStreaming 的数据传输使用的是WebRTC，P2P 的连接延迟更低。 注意：本文所描述内容的测试引擎为 UE_4.22.3，目前 PixelStreaming 只能运行在 Windows 平台 (依赖于模块D3DX11 和NvVideoEncoder库)。 UE 提供的 PixelStreaming 展示案例的代码分成了几个部分： PixelStreamingPlugin：提供渲染帧与音频数据的捕获与编码，并创建一个链接将音频和渲染帧的数据传递给 WebRTC 服务器，使用的是 UE 的插件方式编写和使用。 WebRTCProxy：应用 / 游戏与 WebServer 交流的中间层，作用是将游戏内编码好的渲染帧数据 (.h264) 与音频数据传递给 WebServer，并从 WebServer 上接收到的用户输入再传递给应用 / 游戏，从而可以从浏览器上控制游戏。使用 UE 的 Program 方式编写。 WebServer：PixelStreaming 设计的组织方式中，WebServer是由两个模块组成：SignalingWebServer与Matchmaker，使用的是 nodejs 编写。 SignallingWebServer：启动一个 HTTP 服务，从 WebRTC 接收渲染帧和音频数据传递给浏览器客户端，并接收远程用户的输入 (键盘、鼠标等) 再传递给 WebRTC。 MatchMakerServer：如果只是启动一个游戏实例和单个的 SignallingWebServer，那么使用浏览器访问的玩家操作的都是同一个游戏实例，他们的键盘和鼠标操作都会相互干扰。解决这个的问题的办法使用MatchMakerServer，但是这种方式也是需要启动多套 游戏实例 /WebRTCProxy 以及SignallingWebServer，供外部用户每个人访问不同的游戏实例，使每个浏览器访问的客户端具有不同的连接。 用户访问单个实例的流程如下图： 后续我会逐个分析一下它们各自的代码实现(上周末的简单分析了一下 PixelStreamingPlugin 的实现)，这篇文章的目的是介绍基本概念和简单的 PixelStreamingDemo 上手。 本篇文章的参考资料主要是 UE 文档库中对于 PixelStreaming 的介绍，以及我读代码了解到的实现方式，目前官方文档页面的描述不是特别详细，有些细节和可以用的参数命令没有提及，还是看代码靠谱。 PixelStreamingDemo基本概念介绍完毕，下面进入实际的上手环节。 Launch Game首先创建一个 C++ 项目，我选择了一个第三人称模板： 创建完成之后，打开 Edit-Plugins 搜索启用PixelStreaming: 然后重启编辑器。 与 UE 的官网介绍 (Getting Started with Pixel Streaming) 的需要打包不同，只要使用 Standalone 模式启动项目就可以加载 PixelStreamingPlugin，这样可以省去每次都要打包的麻烦。 为了方便添加启动参数，可以使用我之前写的一个工具：UE4 Launcher并为其添加启动参数-game/-log/-AudioMixer(PixelStreamingPlugin 需要这个参数): 注:PixelStreamingPlugin 支持启动时指定要连接的 WebRTCProxy 的地址与端口，可以在上面的启动参数列表中添加。 -PixelStreamingIP=&lt;value&gt;：指定 WebRTCProxy 服务器的地址，默认为0.0.0.0. -PixelStreamingPort=&lt;value&gt;：指定 WebRTCProxy 服务器的端口，默认为8124. 然后点击 Launch Configuration 即可以 Standalone 模式启动项目。 启动之后可以从 Log 窗口中看到 PixelStreaming 的 Log 输出： WebRTCProxy经过上面的操作游戏启动完成之后，可以启动 WebRTC 了，打开引擎目录： 1Engine\\Source\\Programs\\PixelStreaming\\WebRTCProxy\\bin 可以看到目录下有五个文件： 123452019/07/29 01:21 110 Start_AWS_WebRTCProxy.bat2019/07/29 01:21 473 Start_AWS_WebRTCProxy.ps12019/07/29 01:21 38 Start_WebRTCProxy.bat2019/07/29 01:21 18,032,016 WebRTCProxy.exe2019/07/29 01:21 15,511,552 WebRTCProxy.pdb 需要做的只有双击 Start_WebRTCProxy.bat 启动(它里面也仅仅只是启动了WebRTCProxy.exe). 启动之后可以看到连接信息： 此时在打开游戏项目的 Log 窗口可以看到如下内容： 1[2019.07.30-08.18.49:324][758]PixelStreamingNet: Accepted connection from WebRTC Proxy: 127.0.0.1:2703 表明 PixelStreamingPlugin 与 WebRTCProxy 已经连接成功了。 WebRTCProxy也可以指定游戏内 PixelStreamingPlugin 设定的端口，以及 SignallingWebServer 的地址 / 端口，可以通过 -help 参数来查看 WebRTCProxy 支持的参数（这部分的实现代码在 Engine/Source/Programs/PixelStreaming/WebRTCProxy/src/WebRTCProxy.cpp 中）： 1234567891011121314151617181920212223242526272829303132333435E:\\UnrealEngine\\Epic\\UE_4.22\\Engine\\Source\\Programs\\PixelStreaming\\WebRTCProxy\\bin&gt;WebRTCProxy.exe -helpWebRTCProxyCopyright 1998-2019 Epic Games, Inc. All Rights Reserved.Parameters:-helpShows this help-Cirrus=&lt;IP:Port&gt;The Cirrus server to connect to. If not specified. it defaults to 127.0.0.1:8888-StunServer=&lt;IP:Port&gt;Stun server to use.-UE4Port=&lt;Port&gt;The port UE4 is listening on-AutoSetBitrateIf specified, it forcibly sends a bitrate request to UE4 once a client getsquality control ownership-PlanBIf specified, it will use PlanB sdp semantics. Default is UnifiedPlan.-dbgwindow=[Proxy|WebRTC|All|None]If running under the debugger (e.g: Visual Studio), it specifies what logs tosend to the Output Window. Proxy - Only logs from WebRTCProxy itself will be displayed. WebRTC - Only logs from WebRTC internals will be displayed. All - (Default) Both WebRTCProxy and WebRTC internal logs are displayed. None - No logs sent to the Output Window-LocalTimeIf specified, it will use local time in logging, instead of UTC. 其中： -Cirrus=&lt;IP:Port&gt;用来指定与 SignallingWebServer 通信的端口(默认为127.0.0.1:8888). -UEPort=&lt;Port&gt;：用来指定与该 WebRTCProxy 关联的 UE 应用的端口(PixelStreamingPlugin 中的连接端口，默认为127.0.0.1:8124) SignallingWebServer当游戏与 WebRTCProxy 都启动完毕之后，需要开始启动真正供浏览器可访问的 HTTP 服务器了。 首先需要安装 node，下载安装之后将其添加到系统的 PATH 路径，通过命令node -v 与npm -v测试是否安装成功： 1234C:\\Users\\imzlp\\Desktop&gt;node -vv10.16.0C:\\Users\\imzlp\\Desktop&gt;npm -v6.9.0 如上图则没有问题，可以启动 SignallingWebServer 了，打开引擎目录： 1Engine\\Source\\Programs\\PixelStreaming\\WebServers\\SignallingWebServer 里面有一堆的文件，需要启动的是 run.bat 或者 runNoSetup.bat(他们两个唯一的区别为是否执行npm install)，如果你是第一次打开，则 以管理员权限 启动run.bat，后续直接启动runNoSetup.bat 即可。 经过一堆的 npm 包的下载与安装之后，启动成功： 此时打开 WebRTCProxy 的窗口界面，可以看到以下内容： 此时所有需要启动的服务都已启动完毕。 注：SignallingWebServer默认连接 127.0.0.1:8888 的 WebRTCProxy，并开启一个 80 端口的 HTTP 服务。 使用 --proxyPort &lt;Port&gt; 可以修改监听的 WebRTCProxy 端口，或者写在 SignallingWebSerber/config.json 配置下。 使用 --httpPort &lt;Port&gt; 可以修改启动的 HTTP 服务器的端口。 打开浏览器输入 http://127.0.0.1(使用的是默认端口 80，不然需要指定端口号https://127.0.0.1:xxxx) 就可以看到以下界面： 鼠标点击即可进入游戏画面： 其他的移动设备如果在同一个网段，也是可以直接连接的： 我也录了一个简单的视频(在 ipad 上操作)： MatchMakerServer在文章的最开始，我简单说明了一下 MatchMakerServer 的用途，下面简单说一下如何做。 先来看 UE 对 MatchMakerServer 的职责图： 用法为：在启动单个的 SignallingWebServer 时，指定参数启用Matchmaker： 1runNoSetup.bat --UseMatchmaker --matchmakeAddress 127.0.0.1 --matchmakerPort 9999 然后启动MatchmakerServer，找到以下路径： 1Engine\\Source\\Programs\\PixelStreaming\\WebServers\\Matchmaker 直接启动 run.bat 的默认 httpPort 为 90,matchmakerPort为 9999，即上面运行 SignallingWebServer 时指定的--matchmakerPort 9999，可以自己使用参数替换。 1run.bat --httpPort 88 --matchmakerPort 9988 下面使用的是默认的 httpPort/matchmakePort 端口 然后访问 http:127.0.0.1:90，可以看到与单独启动的SignallingWebServer 一样，但是不允许其他的客户端再加入到当前的会话中来，会提示WARNING: No empty Cirrus servers are available。 除非同时运行多套 游戏 /WebRTCProxy/SignallingWebServer，使每个玩家独占一套不相互干扰，这也是MatchmakerServer 的作用所在。 结语Pixel Streaming 这种“云”游戏的思路很好，但是目前的硬件环境和带宽瓶颈还是很大的问题，在我测试体验的过程中，局域网连接比较流畅，在设定最高 60fps 的情况下可以跑到满帧，但是也是会出现偶尔掉帧的情况。 Google 也推出了云游戏平台Stadia，但是离真的可以落地还很远，但是目前做一些行业应用还是可以的（比如雪佛兰的汽车展示2020 CORVETTE STINGRAY）。","tags":[{"name":"PixelStreaming","slug":"PixelStreaming","permalink":"https://ue5wiki.com/tags/PixelStreaming/"}],"categories":[{"name":"PixelStreaming","slug":"PixelStreaming","permalink":"https://ue5wiki.com/categories/PixelStreaming/"}]},{"title":"UE 加载和查找 DLL 模块分析","date":"2019-07-16T18:23:29.000Z","path":"wiki/31203/","text":"在 Windows 上，UE 的模块在非 IS_MONOLITHIC(打包成一个单独的可执行文件的 单片模式 (Monolithic)) 模式下，是通过查找 DLL 来加载模块的。可以调用 FModuleManager 下的 LoadModuleWithFailureReason/LoadModuleChecked 等函数，通过传入 Module 的字符串名字来加载。本篇文章算是 UE4 Modules:Load and Startup 的扩展和补充，与之不同的是，这篇文章的 侧重点 在于 Module 的 DLL 的查找和加载的细节 而不是 引擎启动和加载 Module 的时机和顺序。 首先，还记得 MODULE_NAME_API 这个宏的作用吗? 在 Windows 平台上它的宏定义是__declspec(dllexport)，导出到 DLL，意味着 UE 的模块就是一个 DLL。 使用 FModuleManager::LoadModuleWithFailureReason 加载 Module 的基本的调用流程为 (这几个函数均在FModuleManager 下)：在 LoadModuleWithFailureReason 中调用 AddModule，在其中又调用FindModulePaths-&gt;FindModulePathsInDirectory 来查找模块。 FindModulePathsFModuleManager::FindModulePaths的逻辑也比较简单，它接收 Module 的名字和 返回 ModuleName-DLLPath的TMap。 它内部的逻辑就是从 引擎 / 引擎插件 / 项目及插件 的 Binaries 路径依次调用FindModulePathsInDirectory： 12345678910111213141516171819void FModuleManager::FindModulePaths(const TCHAR* NamePattern, TMap&lt;FName, FString&gt; &amp;OutModulePaths, bool bCanUseCache /*= true*/) const&#123; // .... USING CACHE PATH .... // Search through the engine directory FindModulePathsInDirectory(FPlatformProcess::GetModulesDirectory(), false, NamePattern, OutModulePaths); // Search any engine directories for (int Idx = 0; Idx &lt; EngineBinariesDirectories.Num(); Idx++) &#123; FindModulePathsInDirectory(EngineBinariesDirectories[Idx], false, NamePattern, OutModulePaths); &#125; // Search any game directories for (int Idx = 0; Idx &lt; GameBinariesDirectories.Num(); Idx++) &#123; FindModulePathsInDirectory(GameBinariesDirectories[Idx], true, NamePattern, OutModulePaths); &#125;&#125; 上面代码的上半部分从缓存路径中查找就不解释了，重要的是下面三个路径的查找： FPlatformProcess::GetModulesDirectory() EngineBinariesDirectories GameBinariesDirectories FPlatformProcess::GetModulesDirectory()为相对于当前引擎的 Binaries: 1L&quot;../../../Engine/Binaries/Win64&quot; EngineBinariesDirectories与 GameBinariesDirectories 这两个数组均通过 FModuleManager::AddBinariesDirectory 函数添加进来的。 这个函数有三处调用： FModuleManager::Get FEngineLoop::PreInit(Enterprise Project) FPluginManager::ConfigureEnabledPlugin FPluginManager::MountNewlyCreatedPlugin EngineBinariesDirectories中存储的是引擎目录中 Plugins 的Binaries的路径： 1L&quot;../../../Engine/Plugins/&quot; GameBinariesDirectories中存储的路径为当前工程以及当前工程目录下的插件的 Binaries 路径，比如Binaries/Win64: 小节一下：UE 加载 Module 时查找的路径依次为 引擎的 Binaries 路径(Engine/Binaries/Win64) 引擎中插件的 Binaries 路径(Engine/Plugins/${PLUGIN_NAME}/Win64) ** 游戏项目的 Binaries 及项目目录下所有插件的 Binaries 路径 ($&#123;PROJECT_NAME&#125;/Binaries 以及$&#123;PROJECT_NAME&#125;/Plugins/$&#123;PLUGIN_NAME&#125;/Binaries)**。 FindModulePathsInDirectory而且，在 FModuleManager::FindModulePathsInDirectory 这个函数中，每传进来一个路径是通过 FModuleEnumerator::QueryModules 来得到当前路径下的有效 Modules 的。 123// Runtime/Core/Private/Modules/ModuleManager.cpp// FModuleManager::FindModulePathsInDirectoryQueryModulesDelegate.Execute(SearchDirectoryName, bIsGameDirectory, ValidModules); 这个调用的派发事件在 FModuleEnumerator::RegisterWithModuleManager() 中绑定，执行的函数为FModuleEnumerator::QueryModules： 12345678void FModuleEnumerator::QueryModules(const FString&amp; InDirectoryName, bool bIsGameDirectory, TMap&lt;FString, FString&gt;&amp; OutModules) const&#123; FModuleManifest Manifest; if(FModuleManifest::TryRead(FModuleManifest::GetFileName(InDirectoryName, bIsGameDirectory), Manifest) &amp;&amp; Manifest.BuildId == BuildId) &#123; OutModules = Manifest.ModuleNameToFileName; &#125;&#125; FModuleManifest::GetFileName返回的是传进来的 Binaries 目录下的 *.modules 文件，每一个编译出来的 Module 的 Binaries 路径下都会有这个文件，随便打开一个看一下内容： 123456789101112131415161718192021222324// Engime/Binaires/Win64/UE4Editor.mosules&#123; &quot;BuildId&quot;: &quot;3709383&quot;, &quot;Modules&quot;: &#123; &quot;ActorPickerMode&quot;: &quot;UE4Editor-ActorPickerMode.dll&quot;, &quot;AddContentDialog&quot;: &quot;UE4Editor-AddContentDialog.dll&quot;, &quot;AdvancedPreviewScene&quot;: &quot;UE4Editor-AdvancedPreviewScene.dll&quot;, &quot;Advertising&quot;: &quot;UE4Editor-Advertising.dll&quot;, &quot;AIGraph&quot;: &quot;UE4Editor-AIGraph.dll&quot;, &quot;AIModule&quot;: &quot;UE4Editor-AIModule.dll&quot;, // ..... &quot;WindowsNoEditorTargetPlatform&quot;: &quot;UE4Editor-WindowsNoEditorTargetPlatform.dll&quot;, &quot;WindowsPlatformEditor&quot;: &quot;UE4Editor-WindowsPlatformEditor.dll&quot;, &quot;WindowsServerTargetPlatform&quot;: &quot;UE4Editor-WindowsServerTargetPlatform.dll&quot;, &quot;WindowsTargetPlatform&quot;: &quot;UE4Editor-WindowsTargetPlatform.dll&quot;, &quot;WorkspaceMenuStructure&quot;: &quot;UE4Editor-WorkspaceMenuStructure.dll&quot;, &quot;WorldBrowser&quot;: &quot;UE4Editor-WorldBrowser.dll&quot;, &quot;XAudio2&quot;: &quot;UE4Editor-XAudio2.dll&quot;, &quot;XGEController&quot;: &quot;UE4Editor-XGEController.dll&quot;, &quot;XmlParser&quot;: &quot;UE4Editor-XmlParser.dll&quot;, &quot;XMPP&quot;: &quot;UE4Editor-XMPP.dll&quot; &#125;&#125; 可以看到，其中的 json 对应了 ModuleName 和其 DLL。 然后调用 FModuleManifest::TryRead 将调用 FModuleManifest::GetFileName 得到的 *.modules 文件解析成一个 FModuleManifest 结构，包含 BuildId 与TMap&lt;FString,FString&gt;的 ModuleName-DLLName 的关联容器。 此时 FModuleManager::FindModulePaths 的任务已经全部完成，通过它得到了指定模块中的所有 Module 和 Module 对应的 DLL 信息，此时工作流转回到 FModuleManager::AddModule 中。 AddModule后续的 FModuleManager::AddModule 执行就中规中矩了。从得到的 Map 中将所要添加的 Module 的信息提取出来，组成一个 ModuleInfoRef 对象: 1typedef TSharedRef&lt;FModuleInfo, ESPMode::ThreadSafe&gt; ModuleInfoRef; 并将其添加至 Module 的列表中(FModuleManager::Get().AddModuleToModulesList(InModuleName, ModuleInfo)). PS：在 FModuleManager::AddModule 的代码中有一个风骚的技巧： 1234ON_SCOPE_EXIT&#123; FModuleManager::Get().AddModuleToModulesList(InModuleName, ModuleInfo);&#125;; 这段代码的意思是在退出当前的作用域 (Scope) 时执行 &#123;&#125; 中的逻辑，简单地来说，它定义了一个当前作用域的对象并托管了一个 Lambda，在离开当前作用域的时候通过 C++ 的 RAII 机制来调用托管的 Lambda，但它的具体实现不是这篇文章的主题，有时间再来单独分析。 FindModuleWithFailureReason在 FModuleManager::AddModule 执行完毕之后，将指定模块的 DLL 信息，存放到了 FModuleManager::Modules 中，接下来就可以得到这个模块的句柄了： 1234567891011121314151617181920IModuleInterface* FModuleManager::LoadModuleWithFailureReason(const FName InModuleName, EModuleLoadResult&amp; OutFailureReason, bool bWasReloaded /*=false*/)&#123; // .... IModuleInterface* LoadedModule = nullptr; OutFailureReason = EModuleLoadResult::Success; // Update our set of known modules, in case we don&#x27;t already know about this module AddModule(InModuleName); // Grab the module info. This has the file name of the module, as well as other info. ModuleInfoRef ModuleInfo = Modules.FindChecked(InModuleName); if (ModuleInfo-&gt;Module.IsValid()) &#123; // Assign the already loaded module into the return value, otherwise the return value gives the impression the module failed load! LoadedModule = ModuleInfo-&gt;Module.Get(); // .... &#125; // ...&#125; 因为所有的模块在 ModuleName.cpp 中都使用了 IMPLEMENT_MODULE 及其衍生宏来注册模块，所以它们都继承了 IModuleInterface，其中有StartupModule 和ShutdownModule，获取到句柄，启动的时候调用的就是每个模块里定义的逻辑了。 注：模块的 StartupModule 是在 FModuleManager::LoadModuleWithFailureReason 中调用的。不管是 LoadModule 或者 LoadModuleChecked 最终都是调用到 LoadModuleWithFailureReason 进行实际的加载和启动的。 同理，FModuleManager::UnLoadModule中执行了模块的ShutdownModule。 UE 设计的这一套 Module 架构还是很方便的，但是也是 UE 的工具链实在是太完善了，自成一套体系，有些想要剥离出来某些功能比较麻烦。","tags":[{"name":"Module","slug":"Module","permalink":"https://ue5wiki.com/tags/Module/"},{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"编辑器模式下焦点不在窗口内的卡顿","date":"2019-07-09T08:45:46.000Z","path":"wiki/96599194/","text":"在 Windows 等平台上运行 UE 时在编辑器内 Play 游戏，若当前的焦点不在编辑器 /VR 应用内，会减少对 CPU 的占用，从而出现卡顿的问题 (打包出来不会出现这个问题)。 其实是因为 UE 在编辑器环境下做了不在焦点内的检测： 1234567891011121314151617181920212223242526272829303132333435363738394041// Runtime/ApplicationCore/Private/Windows/WindowsPlatformApplicationMisc.cppvoid FWindowsPlatformApplicationMisc::PumpMessages(bool bFromMainLoop)&#123; if (!bFromMainLoop) &#123; TGuardValue&lt;bool&gt; PumpMessageGuard(GPumpingMessagesOutsideOfMainLoop, true ); // Process pending windows messages, which is necessary to the rendering thread in some rare cases where D3D // sends window messages (from IDXGISwapChain::Present) to the main thread owned viewport window. WinPumpSentMessages(); return; &#125; GPumpingMessagesOutsideOfMainLoop = false; WinPumpMessages(); // Determine if application has focus bool HasFocus = FApp::UseVRFocus() ? FApp::HasVRFocus() : FWindowsPlatformApplicationMisc::IsThisApplicationForeground(); // If editor thread doesn&#x27;t have the focus, don&#x27;t suck up too much CPU time. if(GIsEditor) &#123; static bool HadFocus=1; if(HadFocus &amp;&amp; !HasFocus) &#123; // Drop our priority to speed up whatever is in the foreground. SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL); &#125; else if(HasFocus &amp;&amp; !HadFocus) &#123; // Boost our priority back to normal. SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL); &#125; if(!HasFocus) &#123; // Sleep for a bit to not eat up all CPU time. FPlatformProcess::Sleep(0.005f); &#125; HadFocus = HasFocus; &#125; // ...&#125; 只需要把 FPlatformProcess::Sleep(0.005f); 这一行注释掉就可以了。 这个需求是因为想要在非 DS 架构下多开在编辑器进行测试，因为不在焦点就会 sleep，所以会造成收发包的卡顿。","tags":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"}]},{"title":"变量已被优化，因而不可用。","date":"2019-07-08T15:04:21.000Z","path":"wiki/12876/","text":"在调试时关闭 Target 或者指定模块的代码优化，能够更好的分析问题。ModuleRules的 OptimizeCode 属性是用来控制当前模块是否要开启优化代码，在我们用 VS 调试时，有时候会看到“变量已被优化，因而不可用”，这就是因为被优化了。可以使用它来关闭优化： 12// build.csOptimizeCode = CodeOptimization.Never; CodeOptimization支持几种值，默认是Default，开启优化： Never Default InNonDebugBuilds InShippingBuildsOnly 相关的代码： 12345678910111213141516// UnrealBuildTool/Configutation/UEBuildModuleCPP.cspublic static bool ShouldEnableOptimization(ModuleRules.CodeOptimization Setting, UnrealTargetConfiguration Configuration, bool bIsEngineModule)&#123; switch(Setting) &#123; case ModuleRules.CodeOptimization.Never: return false; case ModuleRules.CodeOptimization.Default: case ModuleRules.CodeOptimization.InNonDebugBuilds: return (Configuration == UnrealTargetConfiguration.Debug)? false : (Configuration != UnrealTargetConfiguration.DebugGame || bIsEngineModule); case ModuleRules.CodeOptimization.InShippingBuildsOnly: return (Configuration == UnrealTargetConfiguration.Shipping); default: return true; &#125;&#125; 这个函数在 UEBuildModuleCPP.cs 的CreateModuleCompileEnvironment中调用，将结果赋值给了 CppCompileEnvironment.bOptimizeCode，进而又在VCToolChain.cs 中被使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374UnrealBuildTool\\Platform\\Windows\\VCToolChain.csvoid AppendCLArguments_Global(CppCompileEnvironment CompileEnvironment, List&lt;string&gt; Arguments)&#123; // other code ... // // Debug // if (CompileEnvironment.Configuration == CppConfiguration.Debug) &#123; // Disable compiler optimization. Arguments.Add(&quot;/Od&quot;); // Favor code size (especially useful for embedded platforms). Arguments.Add(&quot;/Os&quot;); // Allow inline method expansion unless E&amp;C support is requested if (!CompileEnvironment.bSupportEditAndContinue &amp;&amp; CompileEnvironment.bUseInlining) &#123; Arguments.Add(&quot;/Ob2&quot;); &#125; if ((CompileEnvironment.Platform == CppPlatform.Win32) || (CompileEnvironment.Platform == CppPlatform.Win64)) &#123; Arguments.Add(&quot;/RTCs&quot;); &#125; &#125; // // Development and LTCG // else &#123; if(!CompileEnvironment.bOptimizeCode) &#123; // Disable compiler optimization. Arguments.Add(&quot;/Od&quot;); &#125; else &#123; // Maximum optimizations. Arguments.Add(&quot;/Ox&quot;); // Favor code speed. Arguments.Add(&quot;/Ot&quot;); // Coalesce duplicate strings Arguments.Add(&quot;/GF&quot;); // Only omit frame pointers on the PC (which is implied by /Ox) if wanted. if (CompileEnvironment.bOmitFramePointers == false &amp;&amp; ((CompileEnvironment.Platform == CppPlatform.Win32) || (CompileEnvironment.Platform == CppPlatform.Win64))) &#123; Arguments.Add(&quot;/Oy-&quot;); &#125; &#125; // Allow inline method expansion Arguments.Add(&quot;/Ob2&quot;); // // LTCG // if (CompileEnvironment.bAllowLTCG) &#123; // Enable link-time code generation. Arguments.Add(&quot;/GL&quot;); &#125; &#125; // other code...&#125; 可以看到，在 Debug 的环境下，是默认关闭优化的。在非 Debug 时根据 CompileEnvironment.bOptimizeCode 的值来决定是否开启优化。调试效果：当使用默认时（OptimizeCode = CodeOptimization.Default;）: 当关闭代码优化时(OptimizeCode = CodeOptimization.Never;)： 建议使用OptimizeCode = CodeOptimization.InShippingBuildsOnly;。 注意：这个选项和普通的 C++ 项目在 VS 中的 Properties-Configuration-C/C++-Optimization-Optimization 的设置时一样的。","tags":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/tags/Debugging/"}],"categories":[{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/categories/Debugging/"}]},{"title":"网络质量测试","date":"2019-07-08T15:02:53.000Z","path":"wiki/12589/","text":"可以使用几个命令参数模拟比较差的网络环境，从而测试 UE 联机的网络质量和 bug 检测。 Setting Description PktLag Delays the sending of a packet by the amount of time specified in milliseconds PktLagVariance Provides some randomness to the amount of time a packet is delayed, +/- the amount specified in milliseconds PktLoss Specifies a percentage chance of an outbound packet being discarded to simulate packet loss PktDup Specifies a percentage chance to send a duplicate packet PktOrder Sends packets out of order when enabled (1 = enabled, 0 = disabled) 可以通过三种不同的方式来控制：命令行参数、控制台命令以及引擎 ini 配置。 在命令行启动： 1SettingName=Value 在控制台设置： 1Net SettingName=Value 以及在引擎配置 (DefaultEngine.ini) 中： 123456[PacketSimulationSettings]PktLag=0PktLagVariance=0PktLoss=0PktOrder=0PktDup=0 Finding Network-based Exploits Network Profiler","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"},{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/tags/Network/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"}],"categories":[{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"}]},{"title":"ue4program","date":"2019-07-08T12:02:34.000Z","path":"wiki/10027/","text":"UE 的很多工具链，是基于 UE 自身的功能编译出来的程序，如 UnrealPak、UnrealFrontEnd、UnrealVersionSelector 等，它们都是 Target 为Program的类型的工程。但是 UE 本身并没有提供创建这种工程的方法，所以我写了一个创建工具，能够方便地创建 Standalone Application 的模板工程，能够把 UE 当作一个大号的第三方库开发命令行合作或 GUI 程序。 首先，下载 我写的hxhb/ue4program，将其添加到系统的 PATH 路径中。添加之后的用法如下： 12# ue4program.exe ProgramName$ ue4program.exe StandaloneApplication 此时会在当前目录下创建出一个 StandaloneApplication 文件夹，其目录结构如下： 123456789101112131415161718192021222324252627StandaloneApplication│ GenerateProgramProject.bat│ OpenProgramProject.bat│ StandaloneApplication.Build.cs│ StandaloneApplication.Target.cs│├─Resources│ Icon.ico│ Resource.h│ Resource.rc│ VersionResource.inl│└─Source ├─Private │ │ RealExecutionMain.cpp │ │ StandaloneApplication.cpp │ │ │ ├─Console │ │ ConsoleMain.cpp │ │ │ └─Windows │ WindowsMain.cpp │ └─Public RealExecutionMain.h StandaloneApplication.h StandaloneApplicationLog.h 本篇文章着重需要分析的是 *.target.cs 与*.build.cs这两个文件.创建出来之后，需要将 StandaloneApplication 文件夹移动到 Engine\\Source\\Programs 下，UE 所有的辅助程序 (UHT/UBT 等) 都在这个目录之下。然后，运行 GenerateProgramProject.bat，这是我仿照 UE 的GenerateProjectFiles.bat 写的一个脚本，通过调用 UBT 来创建 Standalone Application 程序，命令如下： 12# bash path in Engine\\Source\\Programs\\StandaloneApplication$ UnrealBuildTool.exe -notinstallengine -ProjectFiles StandaloneApplication 注意 ：直接在安装版引擎中使用上面的命令会报错(不允许创建非 Game 项目)，因为虽然传入了-notinstallengine 参数，但是对 Engine/Build/InstalledBuild.txt 文件检测的优先级高于-notinstallengine： 1234Zhalipeng MINGW64 /d/UE_4.18/Engine/Source/Programs/StandaloneApplication (master)$ ../../../../Engine/Binaries/DotNET/UnrealBuildTool.exe -notinstallengine -ProjectFiles StandaloneApplicationERROR: UnrealBuildTool Exception: A game project path was not specified, which is required when generating project files using an installed build or passing -game on the command line 我写的脚本中做了检测，如果使用的是安装版引擎会先重命名 InstalledBuild.txt，生产完毕后会恢复(但是我还是建议不要在安装版引擎中执行)。其执行完毕后会在Engine\\Intermediate\\ProjectFiles 下生成： 123StandaloneApplication.vcxprojStandaloneApplication.vcxproj.filtersStandaloneApplication.vcxproj.user 其实就是将当前项目添加到 UE 的解决方案，执行完毕之后，打开引擎根目录下的 UE4.sln, 就可以看到创建的项目了： 先来编译运行看一下结果： 资料： Create A Standalone Application in UE4 UE4Launcher","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Standalone Application","slug":"Standalone-Application","permalink":"https://ue5wiki.com/tags/Standalone-Application/"},{"name":"Tools","slug":"Tools","permalink":"https://ue5wiki.com/tags/Tools/"},{"name":"ue4program","slug":"ue4program","permalink":"https://ue5wiki.com/tags/ue4program/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"UE4Launcher","date":"2019-07-06T12:42:12.000Z","path":"wiki/10556/","text":"hxhb/UE4Launcher是我使用 UE 的 Program 模式写的一个便捷的 UE Project 启动器，可以方便地加入启动参数，选择引擎版本，可以从 hxhb/UE4Launcher/release 下载并安装，也支持 UE5。hxhb/UE4Launcher目前具有的功能如下: 获取当前系统环境注册的所有引擎版本 打开 Project，并支持任意数量的启动参数 加载 / 保存 / 编辑配置文件 从命令行启动配置文件 支持写入注册表关联文件及右键菜单 ( 以管理员权限运行) 关联 .uproject 右键菜单生成配置文件(.uejson) 关联配置文件 .uejson 可快速编辑 关联 .uejson 的右键菜单，支持编辑和启动配置 支持检测当前项目是否有 sln，可支持直接启动项目 sln(v0.16) 主界面：编辑配置文件:.uproject文件的右键菜单关联：.uejson文件的右键菜单关联：命令行的参数支持： -g：-g参数后跟 .uproject 文件，为 .uproject 生成 .uejson 配置文件; -e：-e参数后跟 .uejson 文件，打开窗口以编辑该配置文件; -c：-c参数后跟 .uejson 文件，启动该配置(不会打开编辑窗口) 123456# generate LauncherConf_ShooterGame.uejson$ UE4Launcher.exe -g ShooterGame.uproject# Launch Edit Window with .uejson$ UE4Launcher.exe -e LauncherConf_ShooterGame.uejson# Launch Conf$ UE4Launcher.exe -c LauncherConf_ShooterGame.uejson 源码中也支持非常简单的扩展 UE 的其他工具，比如 UBT/AutomationTool 等，都可以增加为启动的工具 (Editor/Editor-cmd 为默认)。PS: 功能实现的也比较仓促，后续有时间可以增加一个列表面板，将其扩展为一个完整的 Launcher。 v0.17Download Link 添加启动工具的配置化 优化配置的 json 结构 现在可以不用修改代码来添加 UE 的其他工具了，第一次启动时会在 UE4Launcher.exe 所在的目录下生成一个 LaunchTools.json 的文件： 123456789101112131415161718192021222324&#123; &quot;LaunchTools&quot;: [ &#123; &quot;ToolName&quot;: &quot;UE4Editor&quot;, &quot;PreArgs&quot;: &quot;&quot;, &quot;BinPath&quot;: &quot;Engine/Binaries/Win64&quot; &#125;, &#123; &quot;ToolName&quot;: &quot;UE4Editor-cmd&quot;, &quot;PreArgs&quot;: &quot;&quot;, &quot;BinPath&quot;: &quot;Engine/Binaries/Win64&quot; &#125;, &#123; &quot;ToolName&quot;: &quot;UnrealFrontend&quot;, &quot;PreArgs&quot;: &quot;&quot;, &quot;BinPath&quot;: &quot;Engine/Binaries/Win64&quot; &#125;, &#123; &quot;ToolName&quot;: &quot;NetworkProfiler&quot;, &quot;PreArgs&quot;: &quot;&quot;, &quot;BinPath&quot;: &quot;Engine/Binaries/DotNET&quot; &#125; ]&#125; 这是默认的四个工具，可以按照相同的格式在这里添加。 参数说明： ToolName：该工具的 exe 名，去掉后缀； PreArgs：启动时默认传递什么参数； BinPath：相对于引擎的路径； v0.16Download Link Fix bugs Support launch project sln with Visual Studio v0.15Download Link Fix bugs Ignore project and launch params when just selected program. Support Launch UnrealFrontend and NetworkProfiler and custom additional tools v0.14Download Links Fix bugs Add installer icon.","tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Tools","slug":"Tools","permalink":"https://ue5wiki.com/tags/Tools/"},{"name":"Launcher","slug":"Launcher","permalink":"https://ue5wiki.com/tags/Launcher/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"UE 中 Log 实现代码分析","date":"2019-06-08T14:33:10.000Z","path":"wiki/39534/","text":"在 UE 中，经常需要在 C++ 代码中打印日志，UE 也提供了方法来创建出可以通过 UE_LOG 打印日志的宏。首先，先来看一下 UE_LOG 是什么，它是个宏，使用的方法： 1UE_LOG(LogTemp,Log,TEXT(&quot;&quot;)); 它被定义在Core/Public/Logging/LogMacros.h： 123456789101112131415161718192021222324252627282930313233/** * A macro that outputs a formatted message to log if a given logging category is active at a given verbosity level * @param CategoryName name of the logging category * @param Verbosity, verbosity level to test against * @param Format, format text ***/#define UE_LOG(CategoryName, Verbosity, Format, ...) \\&#123; \\ static_assert(TIsArrayOrRefOfType&lt;decltype(Format), TCHAR&gt;::Value, &quot;Formatting string must be a TCHAR array.&quot;); \\ static_assert((ELogVerbosity::Verbosity &amp; ELogVerbosity::VerbosityMask) &lt; ELogVerbosity::NumVerbosity &amp;&amp; ELogVerbosity::Verbosity &gt; 0, &quot;Verbosity must be constant and in range.&quot;); \\ CA_CONSTANT_IF((ELogVerbosity::Verbosity &amp; ELogVerbosity::VerbosityMask) &lt;= ELogVerbosity::COMPILED_IN_MINIMUM_VERBOSITY &amp;&amp; (ELogVerbosity::Warning &amp; ELogVerbosity::VerbosityMask) &lt;= FLogCategory###CategoryName::CompileTimeVerbosity) \\ &#123; \\ UE_LOG_EXPAND_IS_FATAL(Verbosity, PREPROCESSOR_NOTHING, if (!CategoryName.IsSuppressed(ELogVerbosity::Verbosity))) \\ &#123; \\ auto UE_LOG_noinline_lambda = [](const auto&amp; LCategoryName, const auto&amp; LFormat, const auto&amp;... UE_LOG_Args) FORCENOINLINE \\ &#123; \\ TRACE_LOG_MESSAGE(LCategoryName, Verbosity, LFormat, UE_LOG_Args...) \\ UE_LOG_EXPAND_IS_FATAL(Verbosity, \\ &#123; \\ FMsg::Logf_Internal(UE_LOG_SOURCE_FILE(__FILE__), __LINE__, LCategoryName.GetCategoryName(), ELogVerbosity::Verbosity, LFormat, UE_LOG_Args...); \\ _DebugBreakAndPromptForRemote(); \\ FDebug::ProcessFatalError(); \\ &#125;, \\ &#123; \\ FMsg::Logf_Internal(nullptr, 0, LCategoryName.GetCategoryName(), ELogVerbosity::Verbosity, LFormat, UE_LOG_Args...); \\ &#125; \\ ) \\ &#125;; \\ UE_LOG_noinline_lambda(CategoryName, Format, ###__VA_ARGS__); \\ UE_LOG_EXPAND_IS_FATAL(Verbosity, CA_ASSUME(false);, PREPROCESSOR_NOTHING) \\ &#125; \\ &#125; \\&#125; 可以看到，使用 UE_LOG 时传入的第一个参数，是一个对象，后面的参数则是一个枚举值以及输出的 Formater，以及更多的参数（用于匹配 Formater 中的占位符）。 UE 提供了几种方法来创建 Log 的 Category： 123DECLARE_LOG_CATEGORY_EXTERN(LogCategoryName,All,All);DECLARE_LOG_CATEGORY_CLASS(LogCategoryName2,All,All);DECLARE_LOG_CATEGORY_EXTERN_HELPER(LogCategoryName3,All,All); 挨个来看一下它们的定义，其实他们都是定义了一个类，并需要创建出一个对象，可以用来传递给 UE_LOG 的第一个参数，而后两个参数则都是 ELogVerbosity 的枚举值，用于给当前的 LogCategory 指定运行时和编译时的日志等级。看一下这个枚举的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Enum that defines the verbosity levels of the logging system. * Also defines some non-verbosity levels that are hacks that allow * breaking on a given log line or setting the color.**/namespace ELogVerbosity&#123; enum Type : uint8 &#123; /** Not used */ NoLogging = 0, /** Always prints a fatal error to console (and log file) and crashes (even if logging is disabled) */ Fatal, /** * Prints an error to console (and log file). * Commandlets and the editor collect and report errors. Error messages result in commandlet failure. */ Error, /** * Prints a warning to console (and log file). * Commandlets and the editor collect and report warnings. Warnings can be treated as an error. */ Warning, /** Prints a message to console (and log file) */ Display, /** Prints a message to a log file (does not print to console) */ Log, /** * Prints a verbose message to a log file (if Verbose logging is enabled for the given category, * usually used for detailed logging) */ Verbose, /** * Prints a verbose message to a log file (if VeryVerbose logging is enabled, * usually used for detailed logging that would otherwise spam output) */ VeryVerbose, // Log masks and special Enum values All = VeryVerbose, NumVerbosity, VerbosityMask = 0xf, SetColor = 0x40, // not actually a verbosity, used to set the color of an output device BreakOnLog = 0x80 &#125;;&#125; 可以根据自己的需求来指定不同的日志等级。 DECLARE_LOG_CATEGORY_EXTERN1234567891011/** * A macro to declare a logging category as a C++ &quot;extern&quot;, usually declared in the header and paired with DEFINE_LOG_CATEGORY in the source. Accessible by all files that include the header. * @param CategoryName, category to declare * @param DefaultVerbosity, default run time verbosity * @param CompileTimeVerbosity, maximum verbosity to compile into the code **/#define DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity) \\extern struct FLogCategory###CategoryName : public FLogCategory&lt;ELogVerbosity::DefaultVerbosity, ELogVerbosity::CompileTimeVerbosity&gt; \\&#123; \\ FORCEINLINE FLogCategory###CategoryName() : FLogCategory(TEXT(#CategoryName)) &#123;&#125; \\&#125; CategoryName; 如果有以下声明： 1DECLARE_LOG_CATEGORY_EXTERN(LogCategoryName,All,All); 宏展开之后就为： 1234extern struct FLogCategoryLogCategoryName : public FLogCategory&lt;ELogVerbosity::All, ELogVerbosity::All&gt;&#123; FORCEINLINE FLogCategoryLogCategoryName() : FLogCategory(TEXT(&quot;LogCategoryName&quot;)) &#123;&#125;&#125; LogCategoryName; 其实就是继承自 FLogCategory 的一个类定义，并且 声明 了一个 LogCategoryName 的对象。注意，这里只是声明，还需要定义，不然在编译时会有未定义错误，所以就需要在 cpp 里写代码进行定义，UE 也提供了一个宏： 1DEFINE_LOG_CATEGORY(LogCategoryName); 它的定义就很简单了，只是定义一个对象而已： 12345/** * A macro to define a logging category, usually paired with DECLARE_LOG_CATEGORY_EXTERN from the header. * @param CategoryName, category to define**/#define DEFINE_LOG_CATEGORY(CategoryName) FLogCategory###CategoryName CategoryName; 对象经过定义之后就可以在 UE_LOG 使用了。这种分离声明和定义的方式可以用在暴露给外部使用的情况，别的文件或者模块只需要包含具有声明的头文件即可。 DECLARE_LOG_CATEGORY_CLASSDECLARE_LOG_CATEGORY_CLASS宏的实现就比 DECLARE_LOG_CATEGORY_EXTERN 多做了一些操作，它定义了一个结构并 创建出一个 static 对象 ，不需要自己再使用DEFINE_LOG_CATEGRORY 进行定义。 1234567891011121314151617181920/** * A macro to define a logging category as a C++ &quot;static&quot;. This should ONLY be declared in a source file. Only accessible in that single file. * @param CategoryName, category to declare * @param DefaultVerbosity, default run time verbosity * @param CompileTimeVerbosity, maximum verbosity to compile into the code**/#define DEFINE_LOG_CATEGORY_STATIC(CategoryName, DefaultVerbosity, CompileTimeVerbosity) \\static struct FLogCategory###CategoryName : public FLogCategory&lt;ELogVerbosity::DefaultVerbosity, ELogVerbosity::CompileTimeVerbosity&gt; \\&#123; \\ FORCEINLINE FLogCategory###CategoryName() : FLogCategory(TEXT(#CategoryName)) &#123;&#125; \\&#125; CategoryName;/** * A macro to declare a logging category as a C++ &quot;class static&quot; * @param CategoryName, category to declare * @param DefaultVerbosity, default run time verbosity * @param CompileTimeVerbosity, maximum verbosity to compile into the code**/#define DECLARE_LOG_CATEGORY_CLASS(CategoryName, DefaultVerbosity, CompileTimeVerbosity) \\ DEFINE_LOG_CATEGORY_STATIC(CategoryName, DefaultVerbosity, CompileTimeVerbosity) 它的声明会展开为： 1234static struct FLogCategoryLogCategoryName : public FLogCategory&lt;ELogVerbosity::All, ELogVerbosity::All&gt;&#123; FORCEINLINE FLogCategoryLogCategoryName() : FLogCategory(TEXT(&quot;LogCategoryName&quot;)) &#123;&#125;&#125; LogCategoryName; 可以看到，和 DECLARE_LOG_CATEGORY_EXTERN 的区别在于： 去掉了 extern 修饰符 增加了 static 修饰符，定义对象 使用这个宏的用途一般直接写在.cpp 文件中，只供当前的翻译单元使用。 DECLARE_LOG_CATEGORY_EXTERN_HELPERDECLARE_LOG_CATEGORY_EXTERN_HELPER这个宏只是 DECLARE_LOG_CATEGORY_EXTERN 的封装，并没有自己做什么特别的事情，和 DECLARE_LOG_CATEGORY_EXTERN 的用法完全一致。 123// Platform specific logs, set here to make it easier to use them from anywhere// need another layer of macro to help using a define in a define#define DECLARE_LOG_CATEGORY_EXTERN_HELPER(A,B,C) DECLARE_LOG_CATEGORY_EXTERN(A,B,C) 后记 DECLARE_LOG_CATEGORY_EXTERN 也可以通过 XXXX_API 的方式修饰并导出符号，使其可以在外部模块中使用。","tags":[],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UE 接入 SteamSDK 及相关资料","date":"2019-05-27T23:02:17.000Z","path":"wiki/3231/","text":"游戏上架 Steam 必须要接入 SteamSDK，本篇文章简单介绍一下在 UE4 中接入SteamSDK 的方法，后续与接入 Steam 平台服务相关的内容也会放到这篇文章中。 SteamSDK 的接入可以使游戏与 Steam 的社区整合，Steam 拥有很好的社区生态，这一点是 Epic 刚出的 Epic Games Store 目前比不了的~(当然我是支持市场竞争的。 废话不多说，首先，检查引擎目录下: 1Engine\\Binaries\\ThirdParty\\Steamworks\\Steamv139 该目录下是否有 Win32/Win64 文件夹，以及其中是否具有以下几个文件： 1steam_api.dll steamclient.dll tier0_s.dll vstdlib_s.dll 如果没有可以从 Steam 的安装目录拷贝过来。 之后打开项目，打开Plugins - Online Platfrom，确保启用以下三个插件： Online Subsystem NULL Online Subsystem Steam Online Subsystem Utils 打开项目的 *.target.cs 文件，加入bUsesSteam = true;: 123456789101112using UnrealBuildTool;using System.Collections.Generic;public class SanguoWarriorsTarget : TargetRules&#123; public SanguoWarriorsTarget(TargetInfo Target) : base(Target) &#123; Type = TargetType.Game; bUsesSteam = true; ExtraModuleNames.AddRange(new string[] &#123; &quot;SanguoWarriors&quot; &#125; ); &#125;&#125; 打开项目的*.build.cs，额外添加 OnlineSubsystem 的模块依赖： 1234567891011PublicDependencyModuleNames.AddRange( new string[] &#123; &quot;OnlineSubsystem&quot;, &quot;OnlineSubsystemUtils&quot;, &#125;);PrivateDependencyModuleNames.AddRange( new string[] &#123; &quot;OnlineSubsystem&quot;, &quot;OnlineSubsystemUtils&quot; &#125;); 打开项目目录下的 Config/DefaultEngine.ini，加入(或编辑) 以下内容： 12345678910111213[/Script/Engine.Engine]!NetDriverDefinitions=ClearArray+NetDriverDefinitions=(DefName=&quot;GameNetDriver&quot;,DriverClassName=&quot;/Script/OnlineSubsystemSteam.SteamNetDriver&quot;,DriverClassNameFallback=&quot;/Script/OnlineSubsystemUtils.IpNetDriver&quot;)[OnlineSubsystem]DefaultPlatformService=SteamPollingIntervalInMs=20[OnlineSubsystemSteam]bEnabled=trueSteamDevAppId=480GameServerQueryPort=27015bRelaunchInSteam=false 注意修改 SteamDevAppId 项为你自己的 Steam 内容的 AppID.上面的操作完毕之后，打开 Steam(必须启动 Steam 才可以在游戏中使用 Shift+Tab) 唤出 Steam 的界面。 然后可以使用 Standalone 模式运行游戏，进入游戏后按下 Shift+Tab 如果可以唤出 Steam，即为成功。 如果日志中出现这样的警告： 123456789101112[2019.03.18-06.02.22:971][186]LogOnline: Warning: STEAM: Steamworks: SteamUtils() failed![2019.03.18-06.02.22:971][186]LogOnline: Warning: STEAM: Steamworks: SteamUser() failed![2019.03.18-06.02.22:972][186]LogOnline: Warning: STEAM: Steamworks: SteamFriends() failed![2019.03.18-06.02.22:972][186]LogOnline: Warning: STEAM: Steamworks: SteamRemoteStorage() failed![2019.03.18-06.02.22:973][186]LogOnline: Warning: STEAM: Steamworks: SteamUserStats() failed![2019.03.18-06.02.22:973][186]LogOnline: Warning: STEAM: Steamworks: SteamMatchmakingServers() failed![2019.03.18-06.02.22:973][186]LogOnline: Warning: STEAM: Steamworks: SteamApps() failed![2019.03.18-06.02.22:973][186]LogOnline: Warning: STEAM: Steamworks: SteamNetworking() failed![2019.03.18-06.02.22:974][186]LogOnline: Warning: STEAM: Steamworks: SteamMatchmaking() failed![2019.03.18-06.02.22:974][186]LogOnline: Display: STEAM: OnlineSubsystemSteam::Shutdown()[2019.03.18-06.02.22:975][186]LogOnline: Warning: STEAM: Steam API failed to initialize![2019.03.18-06.02.22:975][186]LogOnline: Display: STEAM: OnlineSubsystemSteam::Shutdown() 这是因为启动游戏时，没有打开 Steam，先启动 Steam 再启动游戏即可。 打包需要注意的事情：使用 Shipping 模式打包，打包完成后在打包输出的 $ProjectName\\Binaries\\Win64 下新建文件 steam_appid.txt，将你的 AppID 填入其中即可（如 480(Steam 的测试 AppID)）。 外部资料 Steamworks 文献库","tags":[{"name":"Steam","slug":"Steam","permalink":"https://ue5wiki.com/tags/Steam/"},{"name":"SteamSDK","slug":"SteamSDK","permalink":"https://ue5wiki.com/tags/SteamSDK/"}],"categories":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://ue5wiki.com/categories/Gameplay/"}]},{"title":"UE 代码分析：GConfig 的加载","date":"2019-05-27T22:57:58.000Z","path":"wiki/2386/","text":"UE4 中提供了一套非常成熟的 INI 文件配置机制，引擎中也使用了 ini 作为引擎和项目的配置文件。本篇文章来简单分析一下引擎中 GConfig 的加载。 UE 中定义了一堆的全局 ini： 12345678910111213141516171819// Runtime/Core/Private/Misc/CoreGlobals.cppFString GEngineIni; /* Engine ini filename *//** Editor ini file locations - stored per engine version (shared across all projects). Migrated between versions on first run. */FString GEditorIni; /* Editor ini filename */FString GEditorKeyBindingsIni; /* Editor Key Bindings ini file */FString GEditorLayoutIni; /* Editor UI Layout ini filename */FString GEditorSettingsIni; /* Editor Settings ini filename *//** Editor per-project ini files - stored per project. */FString GEditorPerProjectIni; /* Editor User Settings ini filename */FString GCompatIni;FString GLightmassIni; /* Lightmass settings ini filename */FString GScalabilityIni; /* Scalability settings ini filename */FString GHardwareIni; /* Hardware ini filename */FString GInputIni; /* Input ini filename */FString GGameIni; /* Game ini filename */FString GGameUserSettingsIni; /* User Game Settings ini filename */ 但是并没有直接硬编码指定 ini 是在哪里的，其加载的过程为：在 FEngineLoop::AppInit(LaunchEngineLoop.cpp) 中通过调用 FConfigCacheIni::InitializeConfigSystem 来执行加载 ini 文件，其定义在ConfigCacheIni.cpp： FConfigCacheIni::InitializeConfigSystem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// --------------------------------// # FConfigCacheIni::InitializeConfigSystem declaration/** * Creates GConfig, loads the standard global ini files (Engine, Editor, etc), * fills out GEngineIni, etc. and marks GConfig as ready for use */static void InitializeConfigSystem();// --------------------------------void FConfigCacheIni::InitializeConfigSystem()&#123; // Perform any upgrade we need before we load any configuration files FConfigManifest::UpgradeFromPreviousVersions(); // create GConfig GConfig = new FConfigCacheIni(EConfigCacheType::DiskBacked); // load the main .ini files (unless we&#x27;re running a program or a gameless UE4Editor.exe, DefaultEngine.ini is required). const bool bIsGamelessExe = !FApp::HasProjectName(); const bool bDefaultEngineIniRequired = !bIsGamelessExe &amp;&amp; (GIsGameAgnosticExe || FApp::IsProjectNameEmpty()); bool bEngineConfigCreated = FConfigCacheIni::LoadGlobalIniFile(GEngineIni, TEXT(&quot;Engine&quot;), nullptr, bDefaultEngineIniRequired); if (!bIsGamelessExe) &#123; // Now check and see if our game is correct if this is a game agnostic binary if (GIsGameAgnosticExe &amp;&amp; !bEngineConfigCreated) &#123; const FText AbsolutePath = FText::FromString(IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*FPaths::GetPath(GEngineIni)) ); //@todo this is too early to localize const FText Message = FText::Format(NSLOCTEXT(&quot;Core&quot;, &quot;FirstCmdArgMustBeGameName&quot;, &quot;&#x27;&#123;0&#125;&#x27; must exist and contain a DefaultEngine.ini.&quot;), AbsolutePath ); if (!GIsBuildMachine) &#123; FMessageDialog::Open(EAppMsgType::Ok, Message); &#125; FApp::SetProjectName(TEXT(&quot;&quot;)); // this disables part of the crash reporter to avoid writing log files to a bogus directory if (!GIsBuildMachine) &#123; exit(1); &#125; UE_LOG(LogInit, Fatal,TEXT(&quot;%s&quot;), *Message.ToString()); &#125; &#125; FConfigCacheIni::LoadGlobalIniFile(GGameIni, TEXT(&quot;Game&quot;)); FConfigCacheIni::LoadGlobalIniFile(GInputIni, TEXT(&quot;Input&quot;));#if WITH_EDITOR // load some editor specific .ini files FConfigCacheIni::LoadGlobalIniFile(GEditorIni, TEXT(&quot;Editor&quot;)); // Upgrade editor user settings before loading the editor per project user settings FConfigManifest::MigrateEditorUserSettings(); FConfigCacheIni::LoadGlobalIniFile(GEditorPerProjectIni, TEXT(&quot;EditorPerProjectUserSettings&quot;)); // Project agnostic editor ini files static const FString EditorSettingsDir = FPaths::Combine(*FPaths::GameAgnosticSavedDir(), TEXT(&quot;Config&quot;)) + TEXT(&quot;/&quot;); FConfigCacheIni::LoadGlobalIniFile(GEditorSettingsIni, TEXT(&quot;EditorSettings&quot;), nullptr, false, false, true, *EditorSettingsDir); FConfigCacheIni::LoadGlobalIniFile(GEditorLayoutIni, TEXT(&quot;EditorLayout&quot;), nullptr, false, false, true, *EditorSettingsDir); FConfigCacheIni::LoadGlobalIniFile(GEditorKeyBindingsIni, TEXT(&quot;EditorKeyBindings&quot;), nullptr, false, false, true, *EditorSettingsDir);#endif#if PLATFORM_DESKTOP // load some desktop only .ini files FConfigCacheIni::LoadGlobalIniFile(GCompatIni, TEXT(&quot;Compat&quot;)); FConfigCacheIni::LoadGlobalIniFile(GLightmassIni, TEXT(&quot;Lightmass&quot;));#endif // Load scalability settings. FConfigCacheIni::LoadGlobalIniFile(GScalabilityIni, TEXT(&quot;Scalability&quot;)); // Load driver blacklist FConfigCacheIni::LoadGlobalIniFile(GHardwareIni, TEXT(&quot;Hardware&quot;)); // Load user game settings .ini, allowing merging. This also updates the user .ini if necessary. FConfigCacheIni::LoadGlobalIniFile(GGameUserSettingsIni, TEXT(&quot;GameUserSettings&quot;)); // now we can make use of GConfig GConfig-&gt;bIsReadyForUse = true; FCoreDelegates::ConfigReadyForUse.Broadcast();&#125; FConfigCacheIni::LoadGlobalIniFile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// --------------------------------// # FConfigCacheIni::LoadGlobalIniFile declaration/** * Loads and generates a destination ini file and adds it to GConfig: * - Looking on commandline for override source/dest .ini filenames * - Generating the name for the engine to refer to the ini * - Loading a source .ini file hierarchy * - Filling out an FConfigFile * - Save the generated ini * - Adds the FConfigFile to GConfig * * @param FinalIniFilename The output name of the generated .ini file (in Game\\Saved\\Config) * @param BaseIniName The &quot;base&quot; ini name, with no extension (ie, Engine, Game, etc) * @param Platform The platform to load the .ini for (if NULL, uses current) * @param bForceReload If true, the destination .in will be regenerated from the source, otherwise this will only process if the dest isn&#x27;t in GConfig * @param bRequireDefaultIni If true, the Default*.ini file is required to exist when generating the final ini file. * @param bAllowGeneratedIniWhenCooked If true, the engine will attempt to load the generated/user INI file when loading cooked games * @param GeneratedConfigDir The location where generated config files are made. * @return true if the final ini was created successfully. */static bool LoadGlobalIniFile(FString&amp; FinalIniFilename, const TCHAR* BaseIniName, const TCHAR* Platform=NULL, bool bForceReload=false, bool bRequireDefaultIni=false, bool bAllowGeneratedIniWhenCooked=true, const TCHAR* GeneratedConfigDir = *FPaths::GeneratedConfigDir());// --------------------------------bool FConfigCacheIni::LoadGlobalIniFile(FString&amp; FinalIniFilename, const TCHAR* BaseIniName, const TCHAR* Platform, bool bForceReload, bool bRequireDefaultIni, bool bAllowGeneratedIniWhenCooked, const TCHAR* GeneratedConfigDir)&#123; // figure out where the end ini file is FinalIniFilename = GetDestIniFilename(BaseIniName, Platform, GeneratedConfigDir); // Start the loading process for the remote config file when appropriate if (FRemoteConfig::Get()-&gt;ShouldReadRemoteFile(*FinalIniFilename)) &#123; FRemoteConfig::Get()-&gt;Read(*FinalIniFilename, BaseIniName); &#125; FRemoteConfigAsyncIOInfo* RemoteInfo = FRemoteConfig::Get()-&gt;FindConfig(*FinalIniFilename); if (RemoteInfo &amp;&amp; (!RemoteInfo-&gt;bWasProcessed || !FRemoteConfig::Get()-&gt;IsFinished(*FinalIniFilename))) &#123; // Defer processing this remote config file to until it has finish its IO operation return false; &#125; // need to check to see if the file already exists in the GConfigManager&#x27;s cache // if it does exist then we are done, nothing else to do if (!bForceReload &amp;&amp; GConfig-&gt;FindConfigFile(*FinalIniFilename) != nullptr) &#123; //UE_LOG(LogConfig, Log, TEXT( &quot;Request to load a config file that was already loaded: %s&quot;), GeneratedIniFile ); return true; &#125; // make a new entry in GConfig (overwriting what&#x27;s already there) FConfigFile&amp; NewConfigFile = GConfig-&gt;Add(FinalIniFilename, FConfigFile()); return LoadExternalIniFile(NewConfigFile, BaseIniName, *FPaths::EngineConfigDir(), *FPaths::SourceConfigDir(), true, Platform, bForceReload, true, bAllowGeneratedIniWhenCooked, GeneratedConfigDir);&#125; FConfigCacheIni::LoadLocalIniFile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// --------------------------------// # FConfigCacheIni::LoadLocalIniFile declaration/** * Load an ini file directly into an FConfigFile, and nothing is written to GConfig or disk. * The passed in .ini name can be a &quot;base&quot; (Engine, Game) which will be modified by platform and/or commandline override, * or it can be a full ini filenname (ie WrangleContent) loaded from the Source config directory * * @param ConfigFile The output object to fill * @param IniName Either a Base ini name (Engine) or a full ini name (WrangleContent). NO PATH OR EXTENSION SHOULD BE USED! * @param bIsBaseIniName true if IniName is a Base name, which can be overridden on commandline, etc. * @param Platform The platform to use for Base ini names, NULL means to use the current platform * @param bForceReload force reload the ini file from disk this is required if you make changes to the ini file not using the config system as the hierarchy cache will not be updated in this case * @return true if the ini file was loaded successfully */static bool LoadLocalIniFile(FConfigFile&amp; ConfigFile, const TCHAR* IniName, bool bIsBaseIniName, const TCHAR* Platform=NULL, bool bForceReload=false);// --------------------------------bool FConfigCacheIni::LoadLocalIniFile(FConfigFile&amp; ConfigFile, const TCHAR* IniName, bool bIsBaseIniName, const TCHAR* Platform, bool bForceReload )&#123; DECLARE_SCOPE_CYCLE_COUNTER(TEXT(&quot;FConfigCacheIni::LoadLocalIniFile&quot; ), STAT_FConfigCacheIni_LoadLocalIniFile, STATGROUP_LoadTime ); FString EngineConfigDir = FPaths::EngineConfigDir(); FString SourceConfigDir = FPaths::SourceConfigDir(); if (bIsBaseIniName) &#123; FConfigFile* BaseConfig = GConfig-&gt;FindConfigFileWithBaseName(IniName); // If base ini, try to use an existing GConfig file to set the config directories instead of assuming defaults if (BaseConfig) &#123; FIniFilename* EngineFilename = BaseConfig-&gt;SourceIniHierarchy.Find(EConfigFileHierarchy::EngineDirBase); if (EngineFilename) &#123; EngineConfigDir = FPaths::GetPath(EngineFilename-&gt;Filename) + TEXT(&quot;/&quot;); &#125; FIniFilename* GameFilename = BaseConfig-&gt;SourceIniHierarchy.Find(EConfigFileHierarchy::GameDirDefault); if (GameFilename) &#123; SourceConfigDir = FPaths::GetPath(GameFilename-&gt;Filename) + TEXT(&quot;/&quot;); &#125; &#125; &#125; return LoadExternalIniFile(ConfigFile, IniName, *EngineConfigDir, *SourceConfigDir, bIsBaseIniName, Platform, bForceReload, false);&#125; FConfigCacheIni::LoadExternalIniFile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// --------------------------------// # FConfigCacheIni::LoadExternalIniFile declaration/** * Load an ini file directly into an FConfigFile from the specified config folders, optionally writing to disk. * The passed in .ini name can be a &quot;base&quot; (Engine, Game) which will be modified by platform and/or commandline override, * or it can be a full ini filenname (ie WrangleContent) loaded from the Source config directory * * @param ConfigFile The output object to fill * @param IniName Either a Base ini name (Engine) or a full ini name (WrangleContent). NO PATH OR EXTENSION SHOULD BE USED! * @param EngineConfigDir Engine config directory. * @param SourceConfigDir Game config directory. * @param bIsBaseIniName true if IniName is a Base name, which can be overridden on commandline, etc. * @param Platform The platform to use for Base ini names * @param bForceReload force reload the ini file from disk this is required if you make changes to the ini file not using the config system as the hierarchy cache will not be updated in this case * @param bWriteDestIni write out a destination ini file to the Saved folder, only valid if bIsBaseIniName is true * @param bAllowGeneratedIniWhenCooked If true, the engine will attempt to load the generated/user INI file when loading cooked games * @param GeneratedConfigDir The location where generated config files are made. * @return true if the ini file was loaded successfully */static bool LoadExternalIniFile(FConfigFile&amp; ConfigFile, const TCHAR* IniName, const TCHAR* EngineConfigDir, const TCHAR* SourceConfigDir, bool bIsBaseIniName, const TCHAR* Platform=NULL, bool bForceReload=false, bool bWriteDestIni=false, bool bAllowGeneratedIniWhenCooked = true, const TCHAR* GeneratedConfigDir = *FPaths::GeneratedConfigDir());// --------------------------------bool FConfigCacheIni::LoadExternalIniFile(FConfigFile&amp; ConfigFile, const TCHAR* IniName, const TCHAR* EngineConfigDir, const TCHAR* SourceConfigDir, bool bIsBaseIniName, const TCHAR* Platform, bool bForceReload, bool bWriteDestIni, bool bAllowGeneratedIniWhenCooked, const TCHAR* GeneratedConfigDir)&#123; // if bIsBaseIniName is false, that means the .ini is a ready-to-go .ini file, and just needs to be loaded into the FConfigFile if (!bIsBaseIniName) &#123; // generate path to the .ini file (not a Default ini, IniName is the complete name of the file, without path) FString SourceIniFilename = FString::Printf(TEXT(&quot;%s/%s.ini&quot;), SourceConfigDir, IniName); // load the .ini file straight up LoadAnIniFile(*SourceIniFilename, ConfigFile); ConfigFile.Name = IniName; &#125; else &#123; FString DestIniFilename = GetDestIniFilename(IniName, Platform, GeneratedConfigDir); GetSourceIniHierarchyFilenames(IniName, Platform, EngineConfigDir, SourceConfigDir, ConfigFile.SourceIniHierarchy, false ); if (bForceReload) &#123; ClearHierarchyCache(IniName); &#125; // Keep a record of the original settings ConfigFile.SourceConfigFile = new FConfigFile(); // now generate and make sure it&#x27;s up to date (using IniName as a Base for an ini filename) const bool bAllowGeneratedINIs = true; bool bNeedsWrite = GenerateDestIniFile(ConfigFile, DestIniFilename, ConfigFile.SourceIniHierarchy, bAllowGeneratedIniWhenCooked, true); ConfigFile.Name = IniName; // don&#x27;t write anything to disk in cooked builds - we will always use re-generated INI files anyway. if (bWriteDestIni &amp;&amp; (!FPlatformProperties::RequiresCookedData() || bAllowGeneratedIniWhenCooked) // We shouldn&#x27;t save config files when in multiprocess mode, // otherwise we get file contention in XGE shader builds. &amp;&amp; !FParse::Param(FCommandLine::Get(), TEXT(&quot;Multiprocess&quot;))) &#123; // Check the config system for any changes made to defaults and propagate through to the saved. ConfigFile.ProcessSourceAndCheckAgainstBackup(); if (bNeedsWrite) &#123; // if it was dirtied during the above function, save it out now ConfigFile.Write(DestIniFilename); &#125; &#125; &#125; // GenerateDestIniFile returns true if nothing is loaded, so check if we actually loaded something return ConfigFile.Num() &gt; 0;&#125; 这个函数中最重要的部分就是调用了GetSourceIniHierarchyFilenames，它把当前传入的 baseName 的 ini 在 Engine 和项目下的所有 ini 文件都收集了起来。 这就是为什么我们看到其实 GConfig 中很多都是 Saved/Config 下的 ini，里面内容是空的，但是我们怎么查到项目里的设置的呢？这是因为 UE 把这么多个 ini 合并了： 这些 ini 的的内容都会加载进来。 GetDestIniFilename1234567891011121314151617181920212223242526272829303132333435363738// Runtime/Source/Core/Private/Misc/ConfigCacheIni.cpp/** * Calculates the name of a dest (generated) .ini file for a given base (ie Engine, Game, etc) * * @param IniBaseName Base name of the .ini (Engine, Game) * @param PlatformName Name of the platform to get the .ini path for (nullptr means to use the current platform) * @param GeneratedConfigDir The base folder that will contain the generated config files. * * @return Standardized .ini filename */static FString GetDestIniFilename(const TCHAR* BaseIniName, const TCHAR* PlatformName, const TCHAR* GeneratedConfigDir)&#123; // figure out what to look for on the commandline for an override FString CommandLineSwitch = FString::Printf(TEXT(&quot;%sINI=&quot;), BaseIniName); // if it&#x27;s not found on the commandline, then generate it FString IniFilename; if (FParse::Value(FCommandLine::Get(), *CommandLineSwitch, IniFilename) == false) &#123; FString Name(PlatformName ? PlatformName : ANSI_TO_TCHAR(FPlatformProperties::PlatformName())); FString BaseIniNameString = BaseIniName; if (BaseIniNameString.Contains(GeneratedConfigDir)) &#123; IniFilename = BaseIniNameString; &#125; else &#123; // put it all together IniFilename = FString::Printf(TEXT(&quot;%s%s/%s.ini&quot;), GeneratedConfigDir, *Name, BaseIniName); &#125; &#125; // standardize it! FPaths::MakeStandardFilename(IniFilename); return IniFilename;&#125; 而 FPaths::GeneratedConfigDir 获取的路径是当前项目的 Saved 下的 Config： 123456789// Paths.cppFString FPaths::GeneratedConfigDir()&#123;#if PLATFORM_MAC return FPlatformProcess::UserPreferencesDir();#else return FPaths::ProjectSavedDir() + TEXT(&quot;Config/&quot;);#endif&#125; 即在 Windows 平台上项目启动时创建的全局 G*Ini 文件读取的都是 Saved/Config/Windows 下的 .ini。 而且在 GetDestIniFilename 的实现中也可以看到，G*Ini的配置也是可以从 CommandLine 传入的，可以替换掉默认的 Saved/Config/Platform 下的 ini: 12// 使用指定的 Engine.iniUE4Editor.exe uprojectPath -EngineINI=&quot;D:\\\\CustomEngine.ini&quot; 扩展阅读 ConfigurationFiles Config Files, Read &amp; Write to Config Files UE4 中 Config 的使用","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"GConfig","slug":"GConfig","permalink":"https://ue5wiki.com/tags/GConfig/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"打包时路径过长的错误","date":"2019-05-27T22:32:01.000Z","path":"wiki/491e08f5/","text":"在打包的时候遇到这个错误： 1Couldn&#x27;t save package,filename is too long 是因为某些资源在 Windows 上的绝对路径长度超过了 260 个字符，这是 NTFS 的限制。所以，将项目路径移动到磁盘根目录，或者减少目录层级即可。引擎中相关的代码在： 1234567891011// Source/Editor/UnrealEd/Private/CookOnTheFlyServer.cpp(UE4.18.3)// need to subtract 32 because the SavePackage code creates temporary files with longer file names then the one we provide// projects may ignore this restriction if desiredconst int32 CompressedPackageFileLengthRequirement = bConsiderCompressedPackageFileLengthRequirements ? 32 : 0;const FString FullFilename = FPaths::ConvertRelativePathToFull(PlatFilename);if (FullFilename.Len() &gt;= (PLATFORM_MAX_FILEPATH_LENGTH - CompressedPackageFileLengthRequirement))&#123; LogCookerMessage(FString::Printf(TEXT(&quot;Couldn&#x27;t save package, filename is too long: %s&quot;), *PlatFilename), EMessageSeverity::Error); UE_LOG(LogCook, Error, TEXT(&quot;Couldn&#x27;t save package, filename is too long :%s&quot;), *PlatFilename); Result = ESavePackageResult::Error;&#125; 而各个平台的 PLATFORM_MAX_FILEPATH_LENGTH 均定义在 Runtime/Core/Public 相关的平台下。Windows 是使用的另一个宏WINDOWS_MAX_PATH： 123456D:\\UnrealEngine\\Offical_Source\\4.18\\Engine\\Source\\Runtime\\Core\\Public\\Windows\\WIndowsPlatform.h: 57 #define PLATFORM_HAS_BSD_TIME 0 58 #define PLATFORM_USE_PTHREADS 0 59: #define PLATFORM_MAX_FILEPATH_LENGTH WINDOWS_MAX_PATH 60 #define PLATFORM_HAS_BSD_SOCKET_FEATURE_WINSOCKETS 1 61 #define PLATFORM_USES_MICROSOFT_LIBC_FUNCTIONS 1 WINDOWS_MAX_PATH这个宏定义在 Runtime/Core/Private/Windows/MinimalWindowsApi.h 中： 1#define WINDOWS_MAX_PATH 260 显然 UE 并没有使用 Windows 提供的 MAX_PATH 宏，硬编码为了 260，即在 UE 中 Windows 上的文件路径最大长度为 260 个字符 (在启用bConsiderCompressedPackageFileLengthRequirements 时还要减去 32 个字符)，虽然 Windows10 要 [移除 260 字符的限制](Microsoft removes 260 character limit for NTFS Path in new Windows 10 Insider Preview)， 但是貌似 UE 没有跟进的打算 (UE4.22 Released 支持了长文件名的特性 (实验性))。bConsiderCompressedPackageFileLengthRequirements 选项可以加在 Saved/Config/Windows/Engine.ini 下（默认为true）： 12[CookSettings]bConsiderCompressedPackageFileLengthRequirements = true 这个配置是在 Cook 时会被加载用来判断是否考虑引擎生成的文件名长度： 12345678// Source/Editor/UnrealEd/Private/CookOnTheFlyServer.cpp(UE4.18.3)// need to subtract 32 because the SavePackage code creates temporary files with longer file names then the one we providebool UCookOnTheFlyServer::ShouldConsiderCompressedPackageFileLengthRequirements() const&#123; bool bConsiderCompressedPackageFileLengthRequirements = true; GConfig-&gt;GetBool(TEXT(&quot;CookSettings&quot;), TEXT(&quot;bConsiderCompressedPackageFileLengthRequirements&quot;), bConsiderCompressedPackageFileLengthRequirements, GEditorIni); return bConsiderCompressedPackageFileLengthRequirements;&#125; 在 UCookOnTheFlyServer::SaveCookedPackage 中需要通过它来决定将系统支持的 MAX_PATH 减去 32 之后的结果，用来判断资源路径是否超出限制。 外部阅读： Naming Files, Paths, and Namespaces","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"Instanced Stereo Rendering","date":"2019-05-27T22:32:01.000Z","path":"wiki/6e35506b/","text":"在 UE4.11 中引入了 Instanced Stereo Rendering, 其原理是通过单次 draw call 来绘制双眼，进而来缩短渲染线程的时间和提高 GPU 的性能。 开启方式 (ProjectSetting-Engine-Rending)：","tags":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/tags/VirtualReality/"}],"categories":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"}]},{"title":"HandleNetworkFailure","date":"2019-05-27T22:32:01.000Z","path":"wiki/639023d5/","text":"在 UE 中当网络连接出现错误时会调用 UEngine::HandleNetworkFailure 来接收错误消息和处理错误，错误的类型为枚举 ENetworkFailure::Type, 标识了几种网络的错误类型。 以 Server 拒绝玩家的加入为例，在 UE 的这套网络架构中，使用 CreateSession/JoinSession 的方式来创建 / 加入游戏，可以通过 AGameModeBase::Prelogin 以及 overwrite 了该成员函数的子类来拒绝玩家的加入，方法为返回的 ErrorMessage 不为空即为拒绝： 12345678910/** * Accept or reject a player attempting to join the server. Fails login if you set the ErrorMessage to a non-empty string. * PreLogin is called before Login. Significant game time may pass before Login is called * * @param Options The URL options (e.g. name/spectator) the player has passed * @param Address The network address of the player * @param UniqueId The unique id the player has passed to the server * @param ErrorMessage When set to a non-empty value, the player will be rejected using the error message set */virtual void PreLogin(const FString&amp; Options, const FString&amp; Address, const FUniqueNetIdRepl&amp; UniqueId, FString&amp; ErrorMessage); GameMode 的 PreLogin 调用栈为： 当玩家被拒绝加入游戏时，服务器会发送给当前连接的客户端错误消息： 123// call in server send to client// function is UWorld::NotifyControlMessageFNetControlMessage&lt;NMT_Failure&gt;::Send(Connection, ErrorMsg); PS：FNetControlMessage&lt;T&gt;::Send的实现是由 DEFINE_CONTROL_CHANNEL_MESSAGE_ONEPARAM 宏包裹的，其定义在文件 DataChannel.h 中。该消息会发送到客户端上，通过 UEngine::HandleNetworkError 来使客户端来处理该错误，在其中会通知到 UGameInstance::HandleNetworkError，但是并没有把ErrorMessage 传递给 GameInstance, 我们可以通过继承 UGameEngine 重写 HandleNetworkError 来将 ErrorMessage 传递给外部。 PS: 玩家被拒绝之后会回到项目设置里的 Game Default Map 中。","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"}]},{"title":"UGameInstance::HandleNetworkError","date":"2019-05-27T22:32:01.000Z","path":"wiki/5167fe85/","text":"当网络链接出现错误时，会调用该函数 (服务端拒绝玩家加入时也会调用)。 调用栈为（可以继承 UEngine 来替换 Engine 实现）： 1UEngine::HandleNetworkError -&gt; UEngine::HandleNetworkFailure_NotifyGameInstance -&gt; GameInstance-&gt;HandleNetworkError(FailureType, bIsServer); VS 断点调用栈： UEngine::HandleNetworkFailure实现为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Runtime\\Source\\Runtime\\Engine\\Private\\UnrealEngine.cppvoid UEngine::HandleNetworkFailure(UWorld *World, UNetDriver *NetDriver, ENetworkFailure::Type FailureType, const FString&amp; ErrorString)&#123; UE_LOG(LogNet, Log, TEXT(&quot;NetworkFailure: %s, Error: &#x27;%s&#x27;&quot;), ENetworkFailure::ToString(FailureType), *ErrorString); if (!NetDriver) &#123; return; &#125; // Only handle failure at this level for game or pending net drivers. FName NetDriverName = NetDriver-&gt;NetDriverName; if (NetDriverName == NAME_GameNetDriver || NetDriverName == NAME_PendingNetDriver) &#123; // If this net driver has already been unregistered with this world, then don&#x27;t handle it. if (World) &#123; if (!FindNamedNetDriver(World, NetDriverName)) &#123; // This netdriver has already been destroyed (probably waiting for GC) return; &#125; &#125; // Give the GameInstance a chance to handle the failure. HandleNetworkFailure_NotifyGameInstance(World, NetDriver, FailureType); ENetMode FailureNetMode = NetDriver-&gt;GetNetMode(); // NetMode of the driver that failed bool bShouldTravel = true; switch (FailureType) &#123; case ENetworkFailure::FailureReceived: break; case ENetworkFailure::PendingConnectionFailure: // TODO stop the connecting movie break; case ENetworkFailure::ConnectionLost: // Hosts don&#x27;t travel when clients disconnect bShouldTravel = (FailureNetMode == NM_Client); break; case ENetworkFailure::ConnectionTimeout: // Hosts don&#x27;t travel when clients disconnect bShouldTravel = (FailureNetMode == NM_Client); break; case ENetworkFailure::NetGuidMismatch: case ENetworkFailure::NetChecksumMismatch: // Hosts don&#x27;t travel when clients have actor issues bShouldTravel = (FailureNetMode == NM_Client); break; case ENetworkFailure::NetDriverAlreadyExists: case ENetworkFailure::NetDriverCreateFailure: case ENetworkFailure::OutdatedClient: case ENetworkFailure::OutdatedServer: default: break; &#125; if (bShouldTravel) &#123; CallHandleDisconnectForFailure(World, NetDriver); &#125; &#125;&#125;void UEngine::HandleNetworkFailure_NotifyGameInstance(UWorld *World, UNetDriver *NetDriver, ENetworkFailure::Type FailureType)&#123; bool bIsServer = true; if (NetDriver != nullptr) &#123; bIsServer = NetDriver-&gt;GetNetMode() != NM_Client; &#125; if (World != nullptr &amp;&amp; World-&gt;GetGameInstance() != nullptr) &#123; World-&gt;GetGameInstance()-&gt;HandleNetworkError(FailureType, bIsServer); &#125; else &#123; // Since the UWorld passed in might be null, as well as the NetDriver&#x27;s UWorld, // go through the world contexts until we find the one with this net driver. for (auto&amp; Context : WorldList) &#123; if (Context.PendingNetGame != nullptr &amp;&amp; Context.PendingNetGame-&gt;NetDriver == NetDriver &amp;&amp; Context.OwningGameInstance != nullptr) &#123; // Use the GameInstance from the current context. Context.OwningGameInstance-&gt;HandleNetworkError(FailureType, bIsServer); &#125; &#125; &#125;&#125; ENetworkFailure 的声明： 12345678910111213141516171819202122232425262728293031// Runtime\\Engine\\Classes\\Engine\\EngineBaseType.h/** Types of network failures broadcast from the engine */UENUM(BlueprintType)namespace ENetworkFailure&#123; enum Type &#123; /** A relevant net driver has already been created for this service */ NetDriverAlreadyExists, /** The net driver creation failed */ NetDriverCreateFailure, /** The net driver failed its Listen() call */ NetDriverListenFailure, /** A connection to the net driver has been lost */ ConnectionLost, /** A connection to the net driver has timed out */ ConnectionTimeout, /** The net driver received an NMT_Failure message */ FailureReceived, /** The client needs to upgrade their game */ OutdatedClient, /** The server needs to upgrade their game */ OutdatedServer, /** There was an error during connection to the game */ PendingConnectionFailure, /** NetGuid mismatch */ NetGuidMismatch, /** Network checksum mismatch */ NetChecksumMismatch &#125;;&#125;","tags":[{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"}]},{"title":"HTC Vive Tracker Developer Guide","date":"2019-04-03T11:41:23.000Z","path":"wiki/2125/","text":"HTC 发布的 Vive 配件 Vive Tracker 可以用来扩展与 SteamVR 连接的设备。而且还具有 Pogo 引脚，可以自己 DIY 出特殊功能的配件，最近看到了一些使用 Vive Tracker 来实现的非常棒的创意。相关的资料和技术细节在本篇文章里整理辑录。 HTC Vive Tacker一些使用 Vive Tracker 来实现的非常棒的创意：使用 Vive Tracker 来为移动手机加入位置追踪，使手机可以加入 VR 游戏以及为 Daydream 增加位置追踪： MOBILE ROOM SCALE Vive Tracker Powers Google Daydream Wireless Room Scale Hack Mobile Room Scale Experiences with Vive Tracker 注：它的实现实际上是 PC 创建房间并作为 Server，让移动设备通过网络加入游戏并具有 Camera，然后在 Server 上将追踪到的 Tracker 位置信息同步到移动设备上并修改 Camera 的位置，移动设备上的画面就是 Camera 修改后的，使其看起来像手机具有位置追踪，很鸡贼的一个做法(我预计使用 Tracker 为 DayDream 增加位置追踪也是相同的做法)。 使用 Vive Tracker 的引脚扩展，做出特殊功能的硬件设备(喷雾罐)： Virtual Graffiti by Master of Shapes: HTC 也开源了一个使用三个 Tracker 进行全身 IK 的实现：vive_ik_demoVIVE Tracker 官方推荐的案例教程：New Project Code and Tutorials Released for VIVE TrackerHTC Vive Tracker 的指南 v1.6： 相关资讯：Vive Tracker Now Available for Developer Purchase Set Vive Controller/Tracker TypeVive Tracker 可以用来追踪位置，但是它并不仅仅只能用来追踪位置那么简单。正常情况下 Tracker 识别后的默认类型是tracker，但是再某些情况下希望用 tracker 来代替手柄实现操作，如： 将 Tracker 当作 MR 的第三个摄像机，替代需要的第三只手柄 用 Tracker 或者 Tracker 做的外设来替代手柄玩游戏 实现上面两个目标需要将 Tacker 的类型修改为 controller，让基站认为 Tracker 是 Controller。HTC 曾经提供过一个工具用来修改 Tracker 的类型:Vive Tracker Role Changer(这个版本是 v0.8 的，最新的是 v1.0，但是由于 一些原因 HTC 停止了这个软件的下载)。 不使用这个工具，也可以实现相同的功能 (我这里演示的是将 Controller 修改为 Tracker 做示例)，方法如下。 首先，拔掉电脑上的其他任何 VR 设备，然后使用 USB 线将 Controller/Tracker 连接到计算机。打开 Steam 的安装路径(SteamVR)： 1Steam\\steamapps\\common\\SteamVR\\tools\\lighthouse\\bin\\win64 找到lighthouse_console.exe，在控制台中运行： 1234567891011121314151617181920C:\\Program Files (x86)\\Steam\\steamapps\\common\\SteamVR\\tools\\lighthouse\\bin\\win64&gt;lighthouse_console.exeue_version: lighthouse_console.exe (buildbot_vortex-windows_steamvr_rel_win64@vortex-windows) 04924513Attached lighthouse receiver devices: 3 LHR-AE438993lighthouse_console: Connected to receiver LHR-AE438993Attempting HID Open IMU: LHR-AE438993Lighthouse IMU HID openedLHR-AE438993: Firmware Version 1518829406 watchman@runner-watchman 2018-02-17 FPGA 531(2.19/0/2) BL 1517470641Data request is out of rangeRequest Starting:0x0Ending:0x18Max Address is:0x3LHR-AE438993: Successfully fetched gyro/accelerometer range modes from the device. GyroRangeMode:3 AccelRangeMode:2Attempting HID Open Optical: LHR-AE438993Lighthouse Optical HID openedAttempting HID Open VrController: LHR-AE438993Lighthouse VrController HID openedLHR-AE438993: Read config of 2214 bytes from [vid:28de, pid:2300] (LHR-AE438993) and inflated to 9317 byteslh&gt; 会检测到当前插入的设备 LHR-AE438993 并进入 lh 的控制台。在 lh 控制台里输入命令: 123lh&gt; downloadconfigLHR-AE438993: Read config of 2214 bytes from [vid:28de, pid:2300] (LHR-AE438993) and inflated to 9317 bytesWrote 9317 bytes to LHR-AE438993.json 会在当前目录下产生一个 LHR-*.json 文件，其中内容如下：一代手柄： 123456789101112131415161718192021222324252627&#123; &quot;acc_bias&quot;: [ -0.163, 0.08808, -0.2593 ], &quot;acc_scale&quot;: [ 1, 1, 0.9959 ], &quot;device_class&quot;: &quot;controller&quot;, &quot;device_pid&quot;: 8210, &quot;device_serial_number&quot;: &quot;LHR-F7099945&quot;, &quot;device_vid&quot;: 10462, &quot;gyro_bias&quot;: [ 0.01332, -0.003239, 0.01065 ], &quot;gyro_scale&quot;: [ 1.0, 1.0, 1.0 ], // ...&#125; 二代手柄： 1234567891011121314151617181920212223242526272829&#123; &quot;device_class&quot;: &quot;controller&quot;, &quot;device_pid&quot;: 8960, &quot;device_serial_number&quot;: &quot;LHR-AE438993&quot;, &quot;device_vid&quot;: 10462, &quot;firmware_config&quot;: &#123; &quot;bwd_config&quot;: &quot;0x392B&quot;, &quot;charge_current_low_temp_ma&quot;: 256, &quot;charge_current_ma&quot;: 512, &quot;charge_current_nominal_ac_ma&quot;: 768, &quot;charge_current_nominal_usb_ma&quot;: 512, &quot;charge_term_current_ma&quot;: 128, &quot;charge_voltage_limit_mv&quot;: 4400, &quot;charging_low_temp_threshold_c&quot;: 10, &quot;mode&quot;: &quot;controller&quot;, &quot;radio&quot;: true, &quot;recharge_voltage_mv&quot;: 100, &quot;sensor_env_on_pin_a&quot;: 0, &quot;spi_flash&quot;: false, &quot;sys_min_voltage_mv&quot;: 3500, &quot;trackpad&quot;: true, &quot;trigger&quot;: true, &quot;trigger_adc_max&quot;: 3900, &quot;trigger_adc_min&quot;: 300, &quot;trigger_adc_zero&quot;: 400, &quot;vrc&quot;: true &#125;, // ...&#125; 可以看到 device_class 标识着当前设备的类型。可以将其值改为controller/generic_tracker(我这里是将 controller 变成 tracker，反过来也同理): 1&quot;device_class&quot;: &quot;generic_tracker&quot;, 保存并关闭文件，回到 lh 控制台的命令行窗口，输入以下命令： 1lh&gt;uploadconfig 完成之后输入 exit 退出 lh(不要直接关闭窗口)，重启 SteamVR, 然后它的设备类型就变成的Tracker. 相关链接： Vive Tracker Role Changer (current ue_version: 1.0) Need Vive tracker role changer 1.0, could someone reupload? SteamVR 多驱动支持 需要修改 Steam 目录下的 config/steamvr.vrsetting 文件，在这个 json 格式的文件中的 steamvr 项下增加activateMultipleDrivers： 1234567&#123; &quot;steamvr&quot; : &#123; &quot;lastVersionNotice&quot; : &quot;1.3.20&quot;, &quot;lastVersionNoticeDate&quot; : &quot;1553731712&quot;, &quot;activateMultipleDrivers&quot; : true &#125;&#125; 保存之后重启 SteamVR 即可。 在拍摄 MR 视频时使用第三只 Controller 来作为虚拟摄像机，但是如果没有第三只 Controller 可以用一个工具来虚拟出一个 Controller:VirtualControllerDriver，需要启动 SteamVR 的多驱动支持。","tags":[{"name":"HTC Vive","slug":"HTC-Vive","permalink":"https://ue5wiki.com/tags/HTC-Vive/"},{"name":"Vive Tracker","slug":"Vive-Tracker","permalink":"https://ue5wiki.com/tags/Vive-Tracker/"},{"name":"VR","slug":"VR","permalink":"https://ue5wiki.com/tags/VR/"}],"categories":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"}]},{"title":"Create A Standalone Application in UE4","date":"2019-03-30T22:32:01.000Z","path":"wiki/3824a03c/","text":"虽然 UE 是个 游戏引擎 ，但并不是只能写游戏——你甚至可以用来写 Win32 GUI 程序😏. 通常，我们使用 Editor 创建一个 UE 的游戏项目，然后在其基础上构建自己的类并在游戏中使用。但是如果不想要创建一个游戏项目，UE 也支持可以独立运行的程序 (Standalone Application)，能够从main 函数来自主构建自己的程序，完全控制启用哪些 Modules，而不依赖于引擎本身的逻辑架构，也可以将其作为学习和测试 UE 模块的轻便方法。 注 ：UE 并没有提供直接创建 Standalone Application 的方法，我自己写了一个创建Program 项目的工具：hxhb/ue4program，并实现了一个独立运行工具的 Demo：hxhb/UE4Launcher。 Forward本文的内容实践需要使用 本地从源码构建出来的引擎 (源码版引擎) 而非 从 EpicGameLauncher 安装的引擎 (安装版引擎)，我之前的文章里介绍过 UBT 是检测是否存在Engine/Build/InstalledBuild.txt 该文件，来判断引擎是从 Launcher 安装的还是从源码编译的，但是源码版和安装版并不是只有这么多区别，一些 ThridParty 的 build.cs 是不一样的，会造成源码版和安装版引擎对于相同的代码会有不同的编译行为(比如Engine/Source/ThirdParty/HarfBuzz)，虽然这些问题也可是可以搞定的，但是我不建议你那么做。 Create Program首先，下载 我写的hxhb/ue4program，将其添加到系统的 PATH 路径中。添加之后的用法如下： 12# ue4program.exe ProgramName$ ue4program.exe StandaloneApplication 此时会在当前目录下创建出一个 StandaloneApplication 文件夹，其目录结构如下： 123456789101112131415161718192021222324252627StandaloneApplication│ GenerateProgramProject.bat│ OpenProgramProject.bat│ StandaloneApplication.Build.cs│ StandaloneApplication.Target.cs│├─Resources│ Icon.ico│ Resource.h│ Resource.rc│ VersionResource.inl│└─Source ├─Private │ │ RealExecutionMain.cpp │ │ StandaloneApplication.cpp │ │ │ ├─Console │ │ ConsoleMain.cpp │ │ │ └─Windows │ WindowsMain.cpp │ └─Public RealExecutionMain.h StandaloneApplication.h StandaloneApplicationLog.h 本篇文章着重需要分析的是 *.target.cs 与*.build.cs这两个文件.创建出来之后，需要将 StandaloneApplication 文件夹移动到 Engine\\Source\\Programs 下，UE 所有的辅助程序 (UHT/UBT 等) 都在这个目录之下。然后，运行 GenerateProgramProject.bat，这是我仿照 UE 的GenerateProjectFiles.bat 写的一个脚本，通过调用 UBT 来创建 Standalone Application 程序，命令如下： 12# bash path in Engine\\Source\\Programs\\StandaloneApplication$ UnrealBuildTool.exe -notinstallengine -ProjectFiles StandaloneApplication 注意 ：直接在安装版引擎中使用上面的命令会报错(不允许创建非 Game 项目)，因为虽然传入了-notinstallengine 参数，但是对 Engine/Build/InstalledBuild.txt 文件检测的优先级高于-notinstallengine： 1234Zhalipeng MINGW64 /d/UE_4.18/Engine/Source/Programs/StandaloneApplication (master)$ ../../../../Engine/Binaries/DotNET/UnrealBuildTool.exe -notinstallengine -ProjectFiles StandaloneApplicationERROR: UnrealBuildTool Exception: A game project path was not specified, which is required when generating project files using an installed build or passing -game on the command line 我写的脚本中做了检测，如果使用的是安装版引擎会先重命名 InstalledBuild.txt，生产完毕后会恢复(但是我还是建议不要在安装版引擎中执行)。其执行完毕后会在Engine\\Intermediate\\ProjectFiles 下生成： 123StandaloneApplication.vcxprojStandaloneApplication.vcxproj.filtersStandaloneApplication.vcxproj.user 其实就是将当前项目添加到 UE 的解决方案，执行完毕之后，打开引擎根目录下的 UE4.sln, 就可以看到创建的项目了： 先来编译运行看一下结果： Program *.target.csUBT 支持数种 Target 类型(通过枚举类型 TargetType 来指定): Game: 独立运行的游戏; Client: 与 Game 相同，但不包含任何服务器代码; Server: 与 Game 相同，但不包含任何客户端代码; Editor:UE 编辑器的扩展; Program: 独立运行的程序; 1234567891011121314// Engine/Source/Programs/UnrealBuildTool/Configuration/TargetRules.cspublic enum TargetType&#123; // Cooked monolithic game executable (GameName.exe). Also used for a game-agnostic engine executable (UE4Game.exe or RocketGame.exe) Game, // Uncooked modular editor executable and DLLs (UE4Editor.exe, UE4Editor*.dll, GameName*.dll) Editor, // Cooked monolithic game client executable (GameNameClient.exe, but no server code) Client, // Cooked monolithic game server executable (GameNameServer.exe, but no client code) Server, // Program (standalone program, e.g. ShaderCompileWorker.exe, can be modular or monolithic depending on the program) Program,&#125; 关于 .target.cs 的文档介绍：UnrealBuildTool/Targets. hxhb/ue4program创建生成的 *.target.cs 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using UnrealBuildTool;using System.Collections.Generic;[SupportedPlatforms(UnrealPlatformClass.All)]public class StandaloneApplicationTarget : TargetRules&#123; public StandaloneApplicationTarget(TargetInfo Target) : base(Target) &#123; Type = TargetType.Program; LinkType = TargetLinkType.Monolithic; LaunchModuleName = &quot;StandaloneApplication&quot;; ExtraModuleNames.Add(&quot;EditorStyle&quot;); &#125; public override void SetupGlobalEnvironment( TargetInfo Target, ref LinkEnvironmentConfiguration OutLinkEnvironmentConfiguration, ref CPPEnvironmentConfiguration OutCPPEnvironmentConfiguration ) &#123; // Lean and mean bCompileLeanAndMeanUE = true; // No editor or editor-only data is needed bBuildEditor = false; // Whether to compile WITH_EDITORONLY_DATA disabled. Only Windows will use this, other platforms force this to false. //bBuildWithEditorOnlyData = false; // Compile out references from Core to the rest of the engine bCompileAgainstEngine = false; // Enabled for all builds that include the CoreUObject project. Disabled only when building standalone apps that only link with Core. bCompileAgainstCoreUObject = true; // Whether to include plugin support. bCompileWithPluginSupport = true; // Enable exceptions for all modules bForceEnableExceptions = false; // Enable RTTI for all modules. // bForceEnableRTTI = true; // If ture the program entrance is WinMain,otherwise entrance is main bIsBuildingConsoleApplication = false; &#125;&#125; 目前，最需要关注的参数只有三个： Type：需要指定为需要构建的目标类型TargetType.Program. LinkType：指定为 TargetLinkType.Monolithic 则将目标编译成一个单个的可执行文件(不依赖任何 DLL). bIsBuildingConsoleApplication：ture支持 Console，函数入口为 main;false 则不支持 Console，主函数入口为WinMain. 其他参数的 (RTTI/Exceptions) 均能在用到时根据需求从文档查询。 Program *.Build.csProgram 的 *.Build.cs 与普通的游戏项目的没有区别 (因为 Game 是一个模块，Program 也是)，唯一的区别就是将这些模块构建成什么样的目标类型(由*.target.cs 决定)。","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Standalone Application","slug":"Standalone-Application","permalink":"https://ue5wiki.com/tags/Standalone-Application/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UE 模块的加载与启动分析","date":"2019-03-19T11:11:57.000Z","path":"wiki/24007/","text":"UE 是模块化的架构，Engine/Game Project/StandaloneApplication/Plugins 都是 Module(Unreal Engine API Reference列出了 Engine 提供的 Module 列表)，本篇文章从 FModuleManager 的代码来分析一下 UE 的 Module 是如何通过 FModuleManager::LoadModule 加载和启动的。 Forward 本文的 UE 代码引用均为 4.21 版本。 注意 ：本文中说的IS_MONOLITHIC 是模块使用者的 *.target.cs 中的 LinkType, 可以使用TargetLinkType.Monolithic 来指定。 TargetLinkType.Monolithic(单片模式)的含义是将所有的代码放到一个单独的可执行文件中，编译时使用实现包含或者静态链接等方式，不依赖其他 Module 的 DLL。 Module API Specifiers详见：Programming/ModulesModule API Specifiers FModuleManager::LoadModule或者 FModuleManager::LoadModuleWithFailureReason 的调用会执行被加载 Module 的StartupModule. Module Implementation在 UE 中，项目的宏是 IMPLEMENT_PRIMARY_GAME_MODULE，在创建项目后它一般是在ProjectName.cpp 中定义： 1IMPLEMENT_PRIMARY_GAME_MODULE(FDefaultGameModuleImpl, VRExpansion, &quot;VRExpansion&quot; ); FDefaultGameModuleImpl是一个继承自 FDefaultModuleImpl 又间接继承自 IModuleInterface 的类，没有重写 IModuleInterface 的任何函数，仅作为一层封装的默认实现 (游戏项目的启动也不需要通过 Module 的 StartupModule 驱动)。在 Module 中可以传入自己继承自IModuleInterface 的类，重写其中的接口，就可以在 Module 加载时做特定的行为了 (IModuleInterface 的接口列在后面)。 IMPLEMENT_PRIMARY_GAME_MODULE宏首先替换到 IMPLEMENT_GAME_MODULE 然后又继续替换到的也是 IMPLEMENT_MODULE. 在目前的引擎实现里看，这三个宏没有区别： IMPLEMENT_PRIMARY_GAME_MODULE IMPLEMENT_GAME_MODULE IMPLEMENT_MODULE 一般插件中使用的都是 IMPLEMENT_MODULE(该宏定义在Runtime\\Core\\Public\\Modules\\ModuleManger.h 中): 12345678910111213141516171819202122232425262728#if IS_MONOLITHIC // If we&#x27;re linking monolithically we assume all modules are linked in with the main binary. #define IMPLEMENT_MODULE(ModuleImplClass, ModuleName) \\ /** Global registrant object for this module when linked statically */ \\ static FStaticallyLinkedModuleRegistrant&lt; ModuleImplClass &gt; ModuleRegistrant##ModuleName(#ModuleName); \\ /** Implement an empty function so that if this module is built as a statically linked lib, */ \\ /** static initialization for this lib can be forced by referencing this symbol */ \\ void EmptyLinkFunctionForStaticInitialization##ModuleName()&#123;&#125; \\ PER_MODULE_BOILERPLATE_ANYLINK(ModuleImplClass, ModuleName)#else #define IMPLEMENT_MODULE(ModuleImplClass, ModuleName) \\ \\ /**/ \\ /* InitializeModule function, called by module manager after this module&#x27;s DLL has been loaded */ \\ /**/ \\ /* @return Returns an instance of this module */ \\ /**/ \\ extern &quot;C&quot; DLLEXPORT IModuleInterface* InitializeModule() \\ &#123; \\ return new ModuleImplClass(); \\ &#125; \\ PER_MODULE_BOILERPLATE \\ PER_MODULE_BOILERPLATE_ANYLINK(ModuleImplClass, ModuleName)#endif //IS_MONOLITHIC 这个宏的含义是定义和导出一个通用的模块接口，供外部来驱动这个 Module 启动 / 停止或者其他，这个宏是必须的，有这个宏才能被 UE 的模块机制驱动。 IS_MONOLITHIC在编译目标的 target.cs 中LinkType是 TargetLinkType.Monolithic 的情况下，则编译时使用的时 IS_MONOLITHIC 逻辑。这种模式下 Module 的 IMPLEMENT_MODULE 宏则是构造了一个 FStaticallyLinkedModuleRegistrant&lt;ModuleImplClass&gt; 的 static 对象，在它的构造函数中会调用 FModuleManager::RegisterStaticallyLinkedModule 来将其添加到一个 TMap 对象 (FModuleManager::StaticallyLinkedModuleInitializers) 中，供后续 LoadModule 时查找: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849template&lt; class ModuleClass &gt;class FStaticallyLinkedModuleRegistrant&#123;public: /** * Explicit constructor that registers a statically linked module */ FStaticallyLinkedModuleRegistrant(const ANSICHAR* InModuleName ) &#123; // Create a delegate to our InitializeModule method FModuleManager::FInitializeStaticallyLinkedModule InitializerDelegate = FModuleManager::FInitializeStaticallyLinkedModule::CreateRaw( this, &amp;FStaticallyLinkedModuleRegistrant&lt;ModuleClass&gt;::InitializeModule ); // Register this module FModuleManager::Get().RegisterStaticallyLinkedModule( FName(InModuleName), // Module name InitializerDelegate ); // Initializer delegate &#125; /** * Creates and initializes this statically linked module. * * The module manager calls this function through the delegate that was created * in the @see FStaticallyLinkedModuleRegistrant constructor. * * @return A pointer to a new instance of the module. */ IModuleInterface* InitializeModule() &#123; return new ModuleClass(); &#125;&#125;;class FModuleManager&#123;// ...public: void RegisterStaticallyLinkedModule(const FName InModuleName, const FInitializeStaticallyLinkedModule&amp; InInitializerDelegate ) &#123; StaticallyLinkedModuleInitializers.Add(InModuleName, InInitializerDelegate); &#125;private: /** Map of module names to a delegate that can initialize each respective statically linked module */ typedef TMap&lt; FName, FInitializeStaticallyLinkedModule &gt; FStaticallyLinkedModuleInitializerMap; FStaticallyLinkedModuleInitializerMap StaticallyLinkedModuleInitializers;// ...&#125;; IS_MONOLITHIC的情况下，函数 FModuleManager::LoadModuleWithFailureReason(调用FModuleManager::LoadModule 实现上也是转发到这里)通过对 TMapModuleName-InitializerDelegate(FStaticallyLinkedModuleRegistrant::InitializeModule)的查找，可以得到一个指定模块的 IModuleInterface 接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// FModuleManager::LoadModuleWithFailureReason (Runtime\\Core\\Private\\Modules\\ModuleManager.cpp)IModuleInterface* FModuleManager::LoadModuleWithFailureReason(const FName InModuleName, EModuleLoadResult&amp; OutFailureReason)&#123; // something.... // Make sure this isn&#x27;t a module that we had previously loaded, and then unloaded at shutdown time. // // If this assert goes off, your trying to load a module during the shutdown phase that was already // cleaned up. The easiest way to fix this is to change your code to query for an already-loaded // module instead of trying to load it directly. checkf((!ModuleInfo-&gt;bWasUnloadedAtShutdown), TEXT(&quot;Attempted to load module &#x27;%s&#x27; that was already unloaded at shutdown. FModuleManager::LoadModule() was called to load a module that was previously loaded, and was unloaded at shutdown time. If this assert goes off, your trying to load a module during the shutdown phase that was already cleaned up. The easiest way to fix this is to change your code to query for an already-loaded module instead of trying to load it directly.&quot;), *InModuleName.ToString()); // Check if we&#x27;re statically linked with the module. Those modules register with the module manager using a static variable, // so hopefully we already know about the name of the module and how to initialize it. const FInitializeStaticallyLinkedModule* ModuleInitializerPtr = StaticallyLinkedModuleInitializers.Find(InModuleName); if (ModuleInitializerPtr != nullptr) &#123; const FInitializeStaticallyLinkedModule&amp; ModuleInitializer(*ModuleInitializerPtr); // Initialize the module! ModuleInfo-&gt;Module = TUniquePtr&lt;IModuleInterface&gt;(ModuleInitializer.Execute()); if (ModuleInfo-&gt;Module.IsValid()) &#123; // Startup the module ModuleInfo-&gt;Module-&gt;StartupModule(); // The module might try to load other dependent modules in StartupModule. In this case, we want those modules shut down AFTER this one because we may still depend on the module at shutdown. ModuleInfo-&gt;LoadOrder = FModuleInfo::CurrentLoadOrder++; // Module was started successfully! Fire callbacks. ModulesChangedEvent.Broadcast(InModuleName, EModuleChangeReason::ModuleLoaded); // Set the return parameter LoadedModule = ModuleInfo-&gt;Module.Get(); &#125; else &#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; because InitializeModule function failed (returned nullptr.)&quot;), *InModuleName.ToString()); OutFailureReason = EModuleLoadResult::FailedToInitialize; &#125; &#125;#if IS_MONOLITHIC else &#123; // Monolithic builds that do not have the initializer were *not found* during the build step, so return FileNotFound // (FileNotFound is an acceptable error in some case - ie loading a content only project) UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Module &#x27;%s&#x27; not found - its StaticallyLinkedModuleInitializers function is null.&quot;), *InModuleName.ToString()); OutFailureReason = EModuleLoadResult::FileNotFound; &#125;#endif// something....&#125;; !IS_MONOLITHIC在 !IS_MONOLITHIC 的情况下，它是导出了一个 IModuleInterface* InitializeModule() 的符号 (在target.cs 中没有指定为 LinkType.Monolithic(IS_MONOLITHIC) 的情况下每个 Module 是单独的链接库 (lib/dll))。 在使用 FModuleManager::LoadModuleWithFailureReason 来加载指定 Module 时，首先通过 FModuleManager::FindModulePaths 来获取 Module 的链接库 (DLL) 路径：它会依次查找: FPlatformProcess::GetModulesDirectory EngineBinariesDirectories GameBinariesDirectories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#if !IS_MONOLITHICvoid FModuleManager::FindModulePaths(const TCHAR* NamePattern, TMap&lt;FName, FString&gt; &amp;OutModulePaths, bool bCanUseCache /*= true*/) const&#123; if (!ModulePathsCache) &#123; ModulePathsCache.Emplace(); const bool bCanUseCacheWhileGeneratingIt = false; FindModulePaths(TEXT(&quot;*&quot;), ModulePathsCache.GetValue(), bCanUseCacheWhileGeneratingIt); &#125; if (bCanUseCache) &#123; // Try to use cache first if (const FString* ModulePathPtr = ModulePathsCache-&gt;Find(NamePattern)) &#123; OutModulePaths.Add(FName(NamePattern), *ModulePathPtr); return; &#125; // Wildcard for all items if (FCString::Strcmp(NamePattern, TEXT(&quot;*&quot;)) == 0) &#123; OutModulePaths = ModulePathsCache.GetValue(); return; &#125; // Wildcard search if (FCString::Strchr(NamePattern, TEXT(&#x27;*&#x27;)) || FCString::Strchr(NamePattern, TEXT(&#x27;?&#x27;))) &#123; bool bFoundItems = false; FString NamePatternString(NamePattern); for (const TPair&lt;FName, FString&gt;&amp; CacheIt : ModulePathsCache.GetValue()) &#123; if (CacheIt.Key.ToString().MatchesWildcard(NamePatternString)) &#123; OutModulePaths.Add(CacheIt.Key, *CacheIt.Value); bFoundItems = true; &#125; &#125; if (bFoundItems) &#123; return; &#125; &#125; &#125; // Search through the engine directory FindModulePathsInDirectory(FPlatformProcess::GetModulesDirectory(), false, NamePattern, OutModulePaths); // Search any engine directories for (int Idx = 0; Idx &lt; EngineBinariesDirectories.Num(); Idx++) &#123; FindModulePathsInDirectory(EngineBinariesDirectories[Idx], false, NamePattern, OutModulePaths); &#125; // Search any game directories for (int Idx = 0; Idx &lt; GameBinariesDirectories.Num(); Idx++) &#123; FindModulePathsInDirectory(GameBinariesDirectories[Idx], true, NamePattern, OutModulePaths); &#125;&#125;void FModuleManager::FindModulePathsInDirectory(const FString&amp; InDirectoryName, bool bIsGameDirectory, const TCHAR* NamePattern, TMap&lt;FName, FString&gt; &amp;OutModulePaths) const&#123; // Figure out the BuildId if it&#x27;s not already set. if (!BuildId.IsSet()) &#123; FString FileName = FModuleManifest::GetFileName(FPlatformProcess::GetModulesDirectory(), false); FModuleManifest Manifest; if (!FModuleManifest::TryRead(FileName, Manifest)) &#123; UE_LOG(LogModuleManager, Fatal, TEXT(&quot;Unable to read module manifest from &#x27;%s&#x27;. Module manifests are generated at build time, and must be present to locate modules at runtime.&quot;), *FileName) &#125; BuildId = Manifest.BuildId; &#125; // Find all the directories to search through, including the base directory TArray&lt;FString&gt; SearchDirectoryNames; IFileManager::Get().FindFilesRecursive(SearchDirectoryNames, *InDirectoryName, TEXT(&quot;*&quot;), false, true); SearchDirectoryNames.Insert(InDirectoryName, 0); // Enumerate the modules in each directory for(const FString&amp; SearchDirectoryName: SearchDirectoryNames) &#123; FModuleManifest Manifest; if (FModuleManifest::TryRead(FModuleManifest::GetFileName(SearchDirectoryName, bIsGameDirectory), Manifest) &amp;&amp; Manifest.BuildId == BuildId.GetValue()) &#123; for (const TPair&lt;FString, FString&gt;&amp; Pair : Manifest.ModuleNameToFileName) &#123; if (Pair.Key.MatchesWildcard(NamePattern)) &#123; OutModulePaths.Add(FName(*Pair.Key), *FPaths::Combine(*SearchDirectoryName, *Pair.Value)); &#125; &#125; &#125; &#125;&#125;#endif 得到链接库的路径之后就通过 FPlatformProcess::GetDllExport 来获取 DLL 中的 IModuleInterface::InitializeModule 函数指针，然后调用 IModuleInterface::StartupModule 启动这个模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// FModuleManager::LoadModuleWithFailureReason (Runtime\\Core\\Private\\Modules\\ModuleManager.cpp)IModuleInterface* FModuleManager::LoadModuleWithFailureReason(const FName InModuleName, EModuleLoadResult&amp; OutFailureReason)&#123; // something....// Make sure that any UObjects that need to be registered were already processed before we go and// load another module. We just do this so that we can easily tell whether UObjects are present// in the module being loaded.if (bCanProcessNewlyLoadedObjects)&#123; ProcessLoadedObjectsCallback.Broadcast();&#125;// Try to dynamically load the DLLUE_LOG(LogModuleManager, Verbose, TEXT(&quot;ModuleManager: Load Module &#x27;%s&#x27; DLL &#x27;%s&#x27;&quot;), *InModuleName.ToString(), *ModuleInfo-&gt;Filename);if (ModuleInfo-&gt;Filename.IsEmpty() || !FPaths::FileExists(ModuleInfo-&gt;Filename))&#123; TMap&lt;FName, FString&gt; ModulePathMap; FindModulePaths(*InModuleName.ToString(), ModulePathMap); if (ModulePathMap.Num() != 1) &#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; - %d instances of that module name found.&quot;), *InModuleName.ToString(), ModulePathMap.Num()); OutFailureReason = EModuleLoadResult::FileNotFound; return nullptr; &#125; ModuleInfo-&gt;Filename = MoveTemp(TMap&lt;FName, FString&gt;::TIterator(ModulePathMap).Value());&#125;// Determine which file to load for this module.const FString ModuleFileToLoad = FPaths::ConvertRelativePathToFull(ModuleInfo-&gt;Filename);// Clear the handle and set it again below if the module is successfully loadedModuleInfo-&gt;Handle = nullptr;// Skip this check if file manager has not yet been initializedif (FPaths::FileExists(ModuleFileToLoad))&#123; ModuleInfo-&gt;Handle = FPlatformProcess::GetDllHandle(*ModuleFileToLoad); if (ModuleInfo-&gt;Handle != nullptr) &#123; // First things first. If the loaded DLL has UObjects in it, then their generated code&#x27;s // static initialization will have run during the DLL loading phase, and we&#x27;ll need to // go in and make sure those new UObject classes are properly registered. &#123; // Sometimes modules are loaded before even the UObject systems are ready. We need to assume // these modules aren&#x27;t using UObjects. if (bCanProcessNewlyLoadedObjects) &#123; // OK, we&#x27;ve verified that loading the module caused new UObject classes to be // registered, so we&#x27;ll treat this module as a module with UObjects in it. ProcessLoadedObjectsCallback.Broadcast(); &#125; &#125; // Find our &quot;InitializeModule&quot; global function, which must exist for all module DLLs FInitializeModuleFunctionPtr InitializeModuleFunctionPtr =(FInitializeModuleFunctionPtr)FPlatformProcess::GetDllExport(ModuleInfo-&gt;Handle, TEXT(&quot;InitializeModule&quot;)); if (InitializeModuleFunctionPtr != nullptr) &#123; if (ModuleInfo-&gt;Module.IsValid()) &#123; // Assign the already loaded module into the return value, otherwise the return value gives the impression the module failed load! LoadedModule = ModuleInfo-&gt;Module.Get(); &#125; else &#123; // Initialize the module! ModuleInfo-&gt;Module = TUniquePtr&lt;IModuleInterface&gt;(InitializeModuleFunctionPtr()); if (ModuleInfo-&gt;Module.IsValid()) &#123; // Startup the module ModuleInfo-&gt;Module-&gt;StartupModule(); // The module might try to load other dependent modules in StartupModule. In this case, we want those modules shut down AFTER this one because we may still depend on the module at shutdown. ModuleInfo-&gt;LoadOrder = FModuleInfo::CurrentLoadOrder++; // Module was started successfully! Fire callbacks. ModulesChangedEvent.Broadcast(InModuleName, EModuleChangeReason::ModuleLoaded); // Set the return parameter LoadedModule = ModuleInfo-&gt;Module.Get(); &#125; else &#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; because InitializeModule function failed (returned nullptr.)&quot;), *ModuleFileToLoad); FPlatformProcess::FreeDllHandle(ModuleInfo-&gt;Handle); ModuleInfo-&gt;Handle = nullptr; OutFailureReason = EModuleLoadResult::FailedToInitialize; &#125; &#125; &#125; else &#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; because InitializeModule function was not found.&quot;), *ModuleFileToLoad); FPlatformProcess::FreeDllHandle(ModuleInfo-&gt;Handle); ModuleInfo-&gt;Handle = nullptr; OutFailureReason = EModuleLoadResult::FailedToInitialize; &#125; &#125; else &#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; because the file couldn&#x27;t be loaded by the OS.&quot;), *ModuleFileToLoad); OutFailureReason = EModuleLoadResult::CouldNotBeLoadedByOS; &#125;&#125;else&#123; UE_LOG(LogModuleManager, Warning, TEXT(&quot;ModuleManager: Unable to load module &#x27;%s&#x27; because the file &#x27;%s&#x27; was not found.&quot;), *InModuleName.ToString(), *ModuleFileToLoad); OutFailureReason = EModuleLoadResult::FileNotFound;&#125; // something....&#125; IModuleInterface不论是通过 IS_MONOLITHIC 还是 !IS_MONOLITHIC 的方式，最终得到的都是 Module 的 IModuleInterface(Runtime\\Core\\Public\\Modules\\ModuleInterface.h) 接口，它里面声明了通用的 Module 接口： 123456789101112131415161718192021222324252627282930313233343536class IModuleInterface&#123;public: // Note: Even though this is an interface class we need a virtual destructor here because modules are deleted via a pointer to this interface virtual ~IModuleInterface()&#123;&#125; // Called right after the module DLL has been loaded and the module object has been created // Load dependent modules here, and they will be guaranteed to be available during ShutdownModule. ie: // FModuleManager::Get().LoadModuleChecked(TEXT(&quot;HTTP&quot;)); virtual void StartupModule()&#123;&#125; // Called before the module has been unloaded virtual void PreUnloadCallback()&#123;&#125; // Called after the module has been reloaded virtual void PostLoadCallback()&#123;&#125; // Called before the module is unloaded, right before the module object is destroyed. // During normal shutdown, this is called in reverse order that modules finish StartupModule(). // This means that, as long as a module references dependent modules in it&#x27;s StartupModule(), it // can safely reference those dependencies in ShutdownModule() as well. virtual void ShutdownModule()&#123;&#125; // Override this to set whether your module is allowed to be unloaded on the fly // @return Whether the module supports shutdown separate from the rest of the engine. virtual bool SupportsDynamicReloading()&#123;return true;&#125; // Override this to set whether your module would like cleanup on application shutdown // @return Whether the module supports shutdown on application exit virtual bool SupportsAutomaticShutdown()&#123;return true;&#125; // Returns true if this module hosts gameplay code // @return True for &quot;gameplay modules&quot;, or false for engine code modules, plugins, etc. virtual bool IsGameModule() const&#123;return false;&#125;&#125;; Load Modules when the Engine Launch前面提到，UE 是模块化的架构，引擎的实现就是靠各个模块组合驱动的，所以在引擎启动的时候会启动各种相应的模块。引擎的启动入口是在 Launch 模块中，由各个平台的 main 函数转发到 GuardedMain(Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp) 中。在 GuardedMain 中依次执行 GEngineLoop.PreInit(CmdLine) 和GEngineLoop.Init() 在 FEngingLoop::PreInit 中，通过依次调用 FEngineLoop::LoadCoreModules(LaunchEngineLoop.cpp#L1480) 和FEngineLoop::LoadPreInitModules(LaunchEngineLoop.cpp#L1572)来加载引擎启动所必须的模块，模块的加载顺序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// LaunchEngineLoop.cppFEngineLoop::PreInit()&#123; // ... // L1480 // Load Core modules required for everything else to work (needs to be loaded before InitializeRenderingCVarsCaching) if (!LoadCoreModules()) &#123; UE_LOG(LogInit, Error, TEXT(&quot;Failed to load Core modules.&quot;)); return 1; &#125; // ... // L1572 LoadPreInitModules(); // ... // L2015 // note: Since 4.20 add ELoadingPhase::PreEarlyLoadingScreen Support. // Load up all modules that need to hook into the loading screen if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PreEarlyLoadingScreen) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PreEarlyLoadingScreen)) &#123; return 1; &#125; // ... // L2202 if (!LoadStartupCoreModules()) &#123; // At least one startup module failed to load, return 1 to indicate an error return 1; &#125; // ... // L2211 // Load up all modules that need to hook into the loading screen if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PreLoadingScreen) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PreLoadingScreen)) &#123; return 1; &#125; // ... // L2310 if (!LoadStartupModules()) &#123; // At least one startup module failed to load, return 1 to indicate an error return 1; &#125; // ... // L2457 // Load all the post-engine init modules ensure(IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit)); ensure(IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostEngineInit)); // ... // L3044 // Load all the post-engine init modules if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostEngineInit)) &#123; GIsRequestingExit = true; return 1; &#125; // ... // L4279 // Load &quot;pre-init&quot; plugin modules if (!ProjectManager.LoadModulesForProject(ELoadingPhase::PostConfigInit) || !PluginManager.LoadModulesForEnabledPlugins(ELoadingPhase::PostConfigInit)) &#123; return false; &#125; // ...&#125; EnginePreInit 时加载 Module 的几个函数实现： FEngineLoop::LoadCoreModules FEngineLoop::LoadCoreModules 12345678910// LaunchEngineLoop.cpp#L2679bool FEngineLoop::LoadCoreModules()&#123; // Always attempt to load CoreUObject. It requires additional pre-init which is called from its module&#x27;s StartupModule method.#if WITH_COREUOBJECT return FModuleManager::Get().LoadModule(TEXT(&quot;CoreUObject&quot;)) != nullptr;#else return true;#endif&#125; FEngineLoop::LoadPreInitModules FEngineLoop::LoadPreInitModules 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// LaunchEngineLoop.cpp#L2690void FEngineLoop::LoadPreInitModules()&#123; DECLARE_SCOPE_CYCLE_COUNTER(TEXT(&quot;Loading PreInit Modules&quot;), STAT_PreInitModules, STATGROUP_LoadTime); // GGetMapNameDelegate is initialized here#if WITH_ENGINE FModuleManager::Get().LoadModule(TEXT(&quot;Engine&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;Renderer&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;AnimGraphRuntime&quot;)); FPlatformApplicationMisc::LoadPreInitModules();#if !UE_SERVER if (!IsRunningDedicatedServer()) &#123; if (!GUsingNullRHI) &#123; // This needs to be loaded before InitializeShaderTypes is called FModuleManager::Get().LoadModuleChecked&lt;ISlateRHIRendererModule&gt;(&quot;SlateRHIRenderer&quot;); &#125; &#125;#endif FModuleManager::Get().LoadModule(TEXT(&quot;Landscape&quot;)); // Initialize ShaderCore before loading or compiling any shaders, // But after Renderer and any other modules which implement shader types. FModuleManager::Get().LoadModule(TEXT(&quot;ShaderCore&quot;));#if WITH_EDITORONLY_DATA // Load the texture compressor module before any textures load. They may // compress asynchronously and that can lead to a race condition. FModuleManager::Get().LoadModule(TEXT(&quot;TextureCompressor&quot;));#endif#endif // WITH_ENGINE#if (WITH_EDITOR &amp;&amp; !(UE_BUILD_SHIPPING || UE_BUILD_TEST)) // Load audio editor module before engine class CDOs are loaded FModuleManager::Get().LoadModule(TEXT(&quot;AudioEditor&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;AnimationModifiers&quot;));#endif&#125; FPlatformApplicationMisc::LoadPreInitModules FPlatformApplicationMisc::LoadPreInitModules 12345678910111213141516// FPlatformApplicationMisc::LoadPreInitModulesvoid FWindowsPlatformApplicationMisc::LoadPreInitModules()&#123; // D3D11 is not supported on WinXP, so in this case we use the OpenGL RHI if(FWindowsPlatformMisc::VerifyWindowsVersion(6, 0)) &#123; //#todo-rco: Only try on Win10 const bool bForceD3D12 = FParse::Param(FCommandLine::Get(), TEXT(&quot;d3d12&quot;)) || FParse::Param(FCommandLine::Get(), TEXT(&quot;dx12&quot;)); if (bForceD3D12) &#123; FModuleManager::Get().LoadModule(TEXT(&quot;D3D12RHI&quot;)); &#125; FModuleManager::Get().LoadModule(TEXT(&quot;D3D11RHI&quot;)); &#125; FModuleManager::Get().LoadModule(TEXT(&quot;OpenGLDrv&quot;));&#125; FEngineLoop::LoadStartupCoreModules FEngineLoop::LoadStartupCoreModules 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// LaunchEngineLoop.cpp#L2739bool FEngineLoop::LoadStartupCoreModules()&#123; FScopedSlowTask SlowTask(100); DECLARE_SCOPE_CYCLE_COUNTER(TEXT(&quot;Loading Startup Modules&quot;), STAT_StartupModules, STATGROUP_LoadTime); bool bSuccess = true; // Load all Runtime modules SlowTask.EnterProgressFrame(10); &#123; FModuleManager::Get().LoadModule(TEXT(&quot;Core&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;Networking&quot;)); &#125; SlowTask.EnterProgressFrame(10); FPlatformApplicationMisc::LoadStartupModules(); // initialize messaging SlowTask.EnterProgressFrame(10); if (FPlatformProcess::SupportsMultithreading()) &#123; FModuleManager::LoadModuleChecked&lt;IMessagingModule&gt;(&quot;Messaging&quot;); &#125; // Init Scene Reconstruction support#if !UE_SERVER if (!IsRunningDedicatedServer()) &#123; FModuleManager::LoadModuleChecked&lt;IMRMeshModule&gt;(&quot;MRMesh&quot;); &#125;#endif SlowTask.EnterProgressFrame(10);#if WITH_EDITOR FModuleManager::LoadModuleChecked&lt;IEditorStyleModule&gt;(&quot;EditorStyle&quot;);#endif //WITH_EDITOR // Load UI modules SlowTask.EnterProgressFrame(10); if (!IsRunningDedicatedServer()) &#123; FModuleManager::Get().LoadModule(&quot;Slate&quot;);#if !UE_BUILD_SHIPPING // Need to load up the SlateReflector module to initialize the WidgetSnapshotService FModuleManager::Get().LoadModule(&quot;SlateReflector&quot;);#endif // !UE_BUILD_SHIPPING &#125;#if WITH_EDITOR // In dedicated server builds with the editor, we need to load UMG/UMGEditor for compiling blueprints. // UMG must be loaded for runtime and cooking. FModuleManager::Get().LoadModule(&quot;UMG&quot;);#else if (!IsRunningDedicatedServer()) &#123; // UMG must be loaded for runtime and cooking. FModuleManager::Get().LoadModule(&quot;UMG&quot;); &#125;#endif //WITH_EDITOR // Load all Development modules SlowTask.EnterProgressFrame(20); if (!IsRunningDedicatedServer()) &#123;#if WITH_UNREAL_DEVELOPER_TOOLS FModuleManager::Get().LoadModule(&quot;MessageLog&quot;); FModuleManager::Get().LoadModule(&quot;CollisionAnalyzer&quot;);#endif //WITH_UNREAL_DEVELOPER_TOOLS &#125;#if WITH_UNREAL_DEVELOPER_TOOLS FModuleManager::Get().LoadModule(&quot;FunctionalTesting&quot;);#endif //WITH_UNREAL_DEVELOPER_TOOLS SlowTask.EnterProgressFrame(30);#if (WITH_EDITOR &amp;&amp; !(UE_BUILD_SHIPPING || UE_BUILD_TEST)) // HACK: load BT editor as early as possible for statically initialized assets (non cooked BT assets needs it) // cooking needs this module too FModuleManager::Get().LoadModule(TEXT(&quot;BehaviorTreeEditor&quot;)); // Ability tasks are based on GameplayTasks, so we need to make sure that module is loaded as well FModuleManager::Get().LoadModule(TEXT(&quot;GameplayTasksEditor&quot;)); IAudioEditorModule* AudioEditorModule = &amp;FModuleManager::LoadModuleChecked&lt;IAudioEditorModule&gt;(&quot;AudioEditor&quot;); AudioEditorModule-&gt;RegisterAssetActions(); // Load the StringTableEditor module to register its asset actions FModuleManager::Get().LoadModule(&quot;StringTableEditor&quot;); if(!IsRunningDedicatedServer()) &#123; // VREditor needs to be loaded in non-server editor builds early, so engine content Blueprints can be loaded during DDC generation FModuleManager::Get().LoadModule(TEXT(&quot;VREditor&quot;)); &#125; // ----------------------------------------------------- // HACK: load EQS editor as early as possible for statically initialized assets (non cooked EQS assets needs it) // cooking needs this module too bool bEnvironmentQueryEditor = false; GConfig-&gt;GetBool(TEXT(&quot;EnvironmentQueryEd&quot;), TEXT(&quot;EnableEnvironmentQueryEd&quot;), bEnvironmentQueryEditor, GEngineIni); if (bEnvironmentQueryEditor#if WITH_EDITOR || GetDefault&lt;UEditorExperimentalSettings&gt;()-&gt;bEQSEditor#endif // WITH_EDITOR ) &#123; FModuleManager::Get().LoadModule(TEXT(&quot;EnvironmentQueryEditor&quot;)); &#125; // We need this for blueprint projects that have online functionality. //FModuleManager::Get().LoadModule(TEXT(&quot;OnlineBlueprintSupport&quot;)); if (IsRunningCommandlet()) &#123; FModuleManager::Get().LoadModule(TEXT(&quot;IntroTutorials&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;Blutility&quot;)); &#125;#endif //(WITH_EDITOR &amp;&amp; !(UE_BUILD_SHIPPING || UE_BUILD_TEST))#if WITH_ENGINE // Load runtime client modules (which are also needed at cook-time) if(!IsRunningDedicatedServer()) &#123; FModuleManager::Get().LoadModule(TEXT(&quot;Overlay&quot;)); &#125; FModuleManager::Get().LoadModule(TEXT(&quot;MediaAssets&quot;));#endif FModuleManager::Get().LoadModule(TEXT(&quot;ClothingSystemRuntime&quot;));#if WITH_EDITOR FModuleManager::Get().LoadModule(TEXT(&quot;ClothingSystemEditor&quot;));#endif FModuleManager::Get().LoadModule(TEXT(&quot;PacketHandler&quot;)); return bSuccess;&#125; FPlatformApplicationMisc::LoadStartupModules FPlatformApplicationMisc::LoadStartupModules 123456789101112// FPlatformApplicationMisc::LoadStartupModulesvoid FWindowsPlatformApplicationMisc::LoadStartupModules()&#123;#if !UE_SERVER FModuleManager::Get().LoadModule(TEXT(&quot;XAudio2&quot;)); FModuleManager::Get().LoadModule(TEXT(&quot;HeadMountedDisplay&quot;));#endif // !UE_SERVER#if WITH_EDITOR FModuleManager::Get().LoadModule(TEXT(&quot;SourceCodeAccess&quot;));#endif //WITH_EDITOR&#125; FEngineLoop::LoadStartupModules FEngineLoop::LoadStartupModules 12345678910111213141516171819202122232425262728// LaunchEngineLoop.cpp#L2884bool FEngineLoop::LoadStartupModules()&#123; FScopedSlowTask SlowTask(3); SlowTask.EnterProgressFrame(1); // Load any modules that want to be loaded before default modules are loaded up. if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PreDefault) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PreDefault)) &#123; return false; &#125; SlowTask.EnterProgressFrame(1); // Load modules that are configured to load in the default phase if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::Default) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::Default)) &#123; return false; &#125; SlowTask.EnterProgressFrame(1); // Load any modules that want to be loaded after default modules are loaded up. if (!IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostDefault) || !IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostDefault)) &#123; return false; &#125; return true;&#125; 可以从上面的代码看到引擎 PreInit 启动的模块，以及启动的插件的模块(根据插件的 LoadingPhase 来决定启动时机)。 Load Plugin Modules在上文中整理的代码中可以看到，项目的插件 Module 也是在 FEngineLoop::PreInit 中加载的。写过 UE 的插件的都知道，UE 的插件配置 (.uplugin) 里面有两个选项：Type和LoadingPhase: 1234567891011121314151617181920212223&#123; &quot;FileVersion&quot;: 3, &quot;Version&quot;: 1, &quot;VersionName&quot;: &quot;1.0&quot;, &quot;FriendlyName&quot;: &quot;TaskTools&quot;, &quot;Description&quot;: &quot;&quot;, &quot;Category&quot;: &quot;Other&quot;, &quot;CreatedBy&quot;: &quot;&quot;, &quot;CreatedByURL&quot;: &quot;&quot;, &quot;DocsURL&quot;: &quot;&quot;, &quot;MarketplaceURL&quot;: &quot;&quot;, &quot;SupportURL&quot;: &quot;&quot;, &quot;CanContainContent&quot;: true, &quot;IsBetaVersion&quot;: false, &quot;Installed&quot;: false, &quot;Modules&quot;: [ &#123; &quot;Name&quot;: &quot;TaskTools&quot;, &quot;Type&quot;: &quot;Runtime&quot;, &quot;LoadingPhase&quot;: &quot;Default&quot; &#125; ]&#125; 其中的 Modules 下的 Type 和LoadingPhase决定了引擎启动时该 Plugin 下的 Module 是否加载以及加载的时机。Type 是必要参数，LadingPhase 是可选参数，默认是 Default. Type：决定了在不同运行环境的项目是否加载 Module LoadingPhase：决定了该 Module 的加载时机 Plugin:Type(Required) Sets the type of Module. Valid options are Runtime, RuntimeNoCommandlet, Developer, Editor, EditorNoCommandlet, and Program. This type determines which types of applications this Plugin’s Module is suitable for loading in. For example, some plugins may include modules that are only designed to be loaded when the editor is running. Runtime modules will be loaded in all cases, even in shipped games. Developer modules will only be loaded in development runtime or editor builds, but never in shipping builds. Editor modules will only be loaded when the editor is starting up. Your Plugin can use a combination of modules of different types. Type 可选的项如下 (在FModuleDescriptor::Read 从 json 中读入)： 123456789101112131415161718192021222324252627282930namespace EHostType&#123; enum Type &#123; // Any target using the UE4 runtime Runtime, // Any target except for commandlet RuntimeNoCommandlet, // Any target or program RuntimeAndProgram, // Loaded only in cooked builds CookedOnly, // Loaded only when the engine has support for developer tools enabled Developer, // Loaded only by the editor Editor, // Loaded only by the editor, except when running commandlets EditorNoCommandlet, // Loaded only by programs Program, // Loaded only by servers ServerOnly, // Loaded only by clients ClientOnly, // NOTE: If you add a new value, make sure to update the ToString() method below! Max &#125;; // ...&#125; Plugin:LoadingPhase(Optional).uplugin Module LoadingPhase Descriptors. If specified, controls when the plugin is loaded at start-up. This is an advanced option that should not normally be required. The valid options are Default(which is used when no LoadingPhase is specified), PreDefault, and PostConfigInit. PostConfigInit enables the module to be loaded before the engine has finished starting up key subsystems. PreDefault loads just before the normal phase. Typically, this is only needed if you expect game modules to depend directly on content within your plugin, or types declared within the plugin’s code. 如果 .upugin 中没有指定 LoadingPhase 项，则默认是Default，LoadingPhase 的可选项如下: 1234567891011121314151617181920212223242526272829namespace ELoadingPhase&#123; enum Type &#123; /** Loaded before the engine is fully initialized, immediately after the config system has been initialized. Necessary only for very low-level hooks */ PostConfigInit, /** Loaded before the engine is fully initialized for modules that need to hook into the loading screen before it triggers */ PreLoadingScreen, /** Right before the default phase */ PreDefault, /** Loaded at the default loading point during startup (during engine init, after game modules are loaded.) */ Default, /** Right after the default phase */ PostDefault, /** After the engine has been initialized */ PostEngineInit, /** Do not automatically load this module */ None, // NOTE: If you add a new value, make sure to update the ToString() method below! Max &#125;;&#125; FProjectManager::LoadModulesForProjectFEngineLoop::PreInit中通过对 IProjectManager::Get().LoadModulesForProject 的调用来加载指定 LoadingPhase 的插件 Module： 12// Runtime\\Project\\Private\\ModuleDescriptor.cppbool FProjectManager::LoadModulesForProject(const ELoadingPhase::Type LoadingPhase ) 它里面将 Module 的加载转发到了 FModuleDescriptor::LoadModulesForPhase，并对调用的结果做了错误检测(平常见到的插件的编译失败就是在这一步提示的)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool FProjectManager::LoadModulesForProject(const ELoadingPhase::Type LoadingPhase )&#123; DECLARE_SCOPE_CYCLE_COUNTER(TEXT(&quot;Loading Game Modules&quot;), STAT_GameModule, STATGROUP_LoadTime); bool bSuccess = true; if (CurrentProject.IsValid()) &#123; TMap&lt;FName, EModuleLoadResult&gt; ModuleLoadFailures; FModuleDescriptor::LoadModulesForPhase(LoadingPhase, CurrentProject-&gt;Modules, ModuleLoadFailures); if (ModuleLoadFailures.Num() &gt; 0 ) &#123; FText FailureMessage; for (auto FailureIt = ModuleLoadFailures.CreateConstIterator(); FailureIt; ++FailureIt) &#123; const EModuleLoadResult FailureReason = FailureIt.Value(); if(FailureReason != EModuleLoadResult::Success) &#123; const FText TextModuleName = FText::FromName(FailureIt.Key()); if (FailureReason == EModuleLoadResult::FileNotFound) &#123; FailureMessage = FText::Format(LOCTEXT(&quot;PrimaryGameModuleNotFound&quot;, &quot;The game module &#x27;&#123;0&#125;&#x27; could not be found. Please ensure that this module exists and that it is compiled.&quot;), TextModuleName ); &#125; else if (FailureReason == EModuleLoadResult::FileIncompatible) &#123; FailureMessage = FText::Format(LOCTEXT(&quot;PrimaryGameModuleIncompatible&quot;, &quot;The game module &#x27;&#123;0&#125;&#x27; does not appear to be up to date. This may happen after updating the engine. Please recompile this module and try again.&quot;), TextModuleName ); &#125; else if (FailureReason == EModuleLoadResult::FailedToInitialize) &#123; FailureMessage = FText::Format(LOCTEXT(&quot;PrimaryGameModuleFailedToInitialize&quot;, &quot;The game module &#x27;&#123;0&#125;&#x27; could not be successfully initialized after it was loaded.&quot;), TextModuleName ); &#125; else if (FailureReason == EModuleLoadResult::CouldNotBeLoadedByOS) &#123; FailureMessage = FText::Format(LOCTEXT(&quot;PrimaryGameModuleCouldntBeLoaded&quot;, &quot;The game module &#x27;&#123;0&#125;&#x27; could not be loaded. There may be an operating system error or the module may not be properly set up.&quot;), TextModuleName ); &#125; else &#123; ensure(0); // If this goes off, the error handling code should be updated for the new enum values! FailureMessage = FText::Format(LOCTEXT(&quot;PrimaryGameModuleGenericLoadFailure&quot;, &quot;The game module &#x27;&#123;0&#125;&#x27; failed to load for an unspecified reason. Please report this error.&quot;), TextModuleName ); &#125; // Just report the first error break; &#125; &#125; FMessageDialog::Open(EAppMsgType::Ok, FailureMessage); bSuccess = false; &#125; &#125; return bSuccess;&#125; FModuleDescriptor::LoadModulesForPhase1234567891011121314151617181920212223242526272829303132// Runtime\\Project\\Private\\ModuleDescriptor.cpp// LoadingPhase - is want load Module LoadingPhase Descriptor// Modules - is current project all modoules(CurrentProject-&gt;Modules)// ModuleLoadErrors - is module-moduleLoadError mappingvoid FModuleDescriptor::LoadModulesForPhase(ELoadingPhase::Type LoadingPhase, const TArray&lt;FModuleDescriptor&gt;&amp; Modules, TMap&lt;FName, EModuleLoadResult&gt;&amp; ModuleLoadErrors)&#123; FScopedSlowTask SlowTask(Modules.Num()); for (int Idx = 0; Idx &lt; Modules.Num(); Idx++) &#123; SlowTask.EnterProgressFrame(1); const FModuleDescriptor&amp; Descriptor = Modules[Idx]; // Don&#x27;t need to do anything if this module is already loaded if (!FModuleManager::Get().IsModuleLoaded(Descriptor.Name)) &#123; if (LoadingPhase == Descriptor.LoadingPhase &amp;&amp; Descriptor.IsLoadedInCurrentConfiguration()) &#123; // @todo plugin: DLL search problems. Plugins that statically depend on other modules within this plugin may not be found? Need to test this. // NOTE: Loading this module may cause other modules to become loaded, both in the engine or game, or other modules // that are part of this project or plugin. That&#x27;s totally fine. EModuleLoadResult FailureReason; IModuleInterface* ModuleInterface = FModuleManager::Get().LoadModuleWithFailureReason(Descriptor.Name, FailureReason); if (ModuleInterface == nullptr) &#123; // The module failed to load. Note this in the ModuleLoadErrors list. ModuleLoadErrors.Add(Descriptor.Name, FailureReason); &#125; &#125; &#125; &#125;&#125; 该函数的实现就是对当前项目的所有模块进行一次遍历，当遍历 Module 的 LoadingPhase 匹配传入的 LoadingPhase 参数以及该 Module 的 Type 符合当前的运行环境 (通过FModuleDescriptor::IsLoadedInCurrentConfiguration 来判断)，则加载 Module. FModuleDescriptor::IsLoadedInCurrentConfigurationFModuleDescriptor::IsLoadedInCurrentConfiguration的作用就是根据当前的模块的 Type 判断与当前的运行环境是否相匹配，从而返回 bool 决定是否加载 Module。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566bool FModuleDescriptor::IsLoadedInCurrentConfiguration() const&#123; // Check that the module is built for this configuration if(!IsCompiledInCurrentConfiguration()) &#123; return false; &#125; // Check that the runtime environment allows it to be loaded switch (Type) &#123; case EHostType::RuntimeAndProgram: #if (WITH_ENGINE || WITH_PLUGIN_SUPPORT) return true; #endif break; case EHostType::Runtime: #if (WITH_ENGINE || WITH_PLUGIN_SUPPORT) &amp;&amp; !IS_PROGRAM return true; #endif break; case EHostType::RuntimeNoCommandlet: #if (WITH_ENGINE || WITH_PLUGIN_SUPPORT) &amp;&amp; !IS_PROGRAM if(!IsRunningCommandlet()) return true; #endif break; case EHostType::CookedOnly: return FPlatformProperties::RequiresCookedData(); case EHostType::Developer: #if WITH_UNREAL_DEVELOPER_TOOLS return true; #endif break; case EHostType::Editor: #if WITH_EDITOR if(GIsEditor) return true; #endif break; case EHostType::EditorNoCommandlet: #if WITH_EDITOR if(GIsEditor &amp;&amp; !IsRunningCommandlet()) return true; #endif break; case EHostType::Program: #if WITH_PLUGIN_SUPPORT &amp;&amp; IS_PROGRAM return true; #endif break; case EHostType::ServerOnly: return !FPlatformProperties::IsClientOnly(); case EHostType::ClientOnly: return !IsRunningDedicatedServer(); &#125; return false;&#125; 至此，引擎启动时加载的引擎 Module 和项目的插件 Module 都启动完毕了。 ChangeLog 2019-03-20 16:24:32 增加引擎启动时加载模块的内容 2019-03-21 12:41:52 增加插件 Module 启动的内容","tags":[{"name":"Module","slug":"Module","permalink":"https://ue5wiki.com/tags/Module/"},{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"UE 项目的编译流程","date":"2019-03-16T23:09:52.000Z","path":"wiki/6362/","text":"UE 通过 UBT 来构建项目(不管是 VS 里的 Build 也好，Editor 里的 Compile 也好，最终都会调用 UBT)。UBT 和 UHT 是 UE 工具链的基石，内容太多，没办法一次性分析全部，先梳理出一个大致的轮廓，有时间再慢慢补充。 先对 UBT 和 UHT 的工作职责有一个大概介绍：UBT： Scans solution directory for modules and plug-ins Determines all modules that need to be rebuilt Invokes UHT to parse C++ headers Creates compiler &amp; linker options from .Build.cs &amp; .Target.cs Executes platform specific compilers (VisualStudio, LLVM) UHT： Parses all C++ headers containing UClasses Generates glue code for all Unreal classes &amp; functions Generated files stored in Intermediates directory VS言归正传。首先，从零开始，第一步先创建一个 C++ 项目 (BasicCode/ThridPerson 任选)，并打开 VS。 打开 VS 之后可以看到这样的 Solution 结构：在 Solution 中选中创建的 Project 点击 右键 -Properties： 可以看到，NMake-Gerneral 下的 构建命令 (Build Command) 使用的均是 Engine\\Build\\BatchFiles 目录下的 bat(在 Windows 平台)： 123456# BuildEngine\\Build\\BatchFiles\\Build.bat# ReBuildEngine\\Build\\BatchFiles\\Rebuild.bat# CleanEngine\\Build\\BatchFiles\\Clean.bat 以 Build.bat 为例： 123456789101112131415161718192021222324252627@echo offsetlocal enabledelayedexpansionREM The %~dp0 specifier resolves to the path to the directory where this .bat is located in.REM We use this so that regardless of where the .bat file was executed from, we can change toREM directory relative to where we know the .bat is stored.pushd &quot;%~dp0\\..\\..\\Source&quot;REM %1 is the game nameREM %2 is the platform nameREM %3 is the configuration nameIF EXIST ..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe ( ..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe %* -DEPLOY popd REM Ignore exit codes of 2 (&quot;ECompilationResult.UpToDate&quot;) from UBT; it&#x27;s not a failure. if &quot;!ERRORLEVEL!&quot;==&quot;2&quot; ( EXIT /B 0 ) EXIT /B !ERRORLEVEL!) ELSE ( ECHO UnrealBuildTool.exe not found in ..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe popd EXIT /B 999) 可以看到 Build.bat 将接收的参数都转发给了UnrealBuildTool.exe: 1..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe %* UBT通过 UnrealBuildTool 构建项目需要传递参数： %1 is the game name %2 is the platform name %3 is the configuration name %4 is the ProjectPath 12# ExampleUnrealBuildTool.exe ThridPerson420 Win64 Development &quot;C:\\Users\\visionsmile\\Documents\\Unreal Projects\\Examples\\ThridPerson420\\ThridPerson420.uproject&quot; -WaitMutex -FromMsBuild 然后来看一下 UnrealBuildTools 是怎么处理的： 1234567891011121314151617181920212223// Engine\\Source\\Programs\\UnrealBuildTools\\UnrealBuildTool.csprivate static int Main(string[] Arguments)&#123; // make sure we catch any exceptions and return an appropriate error code. // Some inner code already does this (to ensure the Mutex is released), // but we need something to cover all outer code as well. try &#123; return GuardedMain(Arguments); &#125; catch (Exception Exception) &#123; if (Log.IsInitialized()) &#123; Log.TraceError(&quot;UnrealBuildTool Exception: &quot; + Exception.ToString()); &#125; if (ExtendedErrorCode != 0) &#123; return ExtendedErrorCode; &#125; return (int)ECompilationResult.OtherCompilationError; &#125;&#125; 可以看到传入进来的参数。在 GuardedMain 中对引擎和传入参数做了一堆检测之后，会调用RunUBT: RulesAssembly在 RunUBT 中，有一个相当重要的函数调用UEBuildTarget.CreateTarget： 12345678910111213141516171819202122232425262728293031323334353637// Engine\\Source\\Programs\\UnrealBuildTools\\UnrealBuildTool.csinternal static ECompilationResult RunUBT(BuildConfiguration BuildConfiguration, string[] Arguments, FileReference ProjectFile, bool bCatchExceptions)&#123; // other code... if (UBTMakefile != null &amp;&amp; !bIsGatheringBuild &amp;&amp; bIsAssemblingBuild) &#123; // If we&#x27;ve loaded a makefile, then we can fill target information from this file! Targets = UBTMakefile.Targets; &#125; else &#123; DateTime TargetInitStartTime = DateTime.UtcNow; ReadOnlyBuildVersion Version = new ReadOnlyBuildVersion(BuildVersion.ReadDefault()); Targets = new List&lt;UEBuildTarget&gt;(); foreach (TargetDescriptor TargetDesc in TargetDescs) &#123; UEBuildTarget Target = UEBuildTarget.CreateTarget(TargetDesc, Arguments, bSkipRulesCompile, BuildConfiguration.SingleFileToCompile != null, BuildConfiguration.bUsePrecompiled, Version); if ((Target == null) &amp;&amp; (BuildConfiguration.bCleanProject)) &#123; continue; &#125; Targets.Add(Target); &#125; if (UnrealBuildTool.bPrintPerformanceInfo) &#123; double TargetInitTime = (DateTime.UtcNow - TargetInitStartTime).TotalSeconds; Log.TraceInformation(&quot;Target init took &quot; + TargetInitTime + &quot;s&quot;); &#125; &#125; // other code ...&#125; UEBuildTarget.CreateTarget的定义在 Configuration/UEBuildTarget.cs 中。它在里面构造了一个 RulesAssembly 的对象，它是用来读取和构造项目中的 target.cs 和 Module 的 build.cs 的。RulesAssembly的构造调用栈如下： RulesAssembly的构造函数接收了一堆参数： 1public RulesAssembly(DirectoryReference BaseDir, IReadOnlyList&lt;PluginInfo&gt; Plugins, List&lt;FileReference&gt; ModuleFiles, List&lt;FileReference&gt; TargetFiles, Dictionary&lt;FileReference, PluginInfo&gt; ModuleFileToPluginInfo, FileReference AssemblyFileName, bool bContainsEngineModules, bool bUseBackwardsCompatibleDefaults, bool bReadOnly, bool bSkipCompile, RulesAssembly Parent BaseDir：项目目录 Plugins：项目依赖的所有插件的 .uplugin 文件的绝对路径 ModuleFiles：是当前 Target 中的所有 Module(Game Module 和所有插件内的 Module)的 .build.cs 文件的绝对路径 TargetFiles：当前 Target 中所有的 target.cs 的文件绝对路径 ModuleFileToPluginInfo：插件的信息 map，Module 的 build.cs 文件与 Module 的基本信息 AssemblyFileName：项目的 BuildRules 的 DLL 文件绝对路径 (该文件位于(Intermediate/Build/BuildRules 下，是调用 UnrealVersionSelector 生成 VS 项目时创建的)) 12// e.gC:\\Users\\imzlp\\Documents\\Unreal Projects\\GWorld\\Intermediate\\Build\\BuildRules\\GWorldModuleRules.dll 其他参数(不是本篇文章的重点) RulesAssembly类中定义了两个重要的成员：TargetNameToTargetFile和 ModuleNameToModuleFile，在构造函数中把当前的项目中中所有定义的TargetRules 和ModuleRules都添加到了里面。 下面是 RulesAssembly 的构造函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// UnrealBuildTool/System/RulesAssembly.cs/// &lt;summary&gt;/// Constructor. Compiles a rules assembly from the given source files./// &lt;/summary&gt;/// &lt;param name=&quot;BaseDir&quot;&gt;The base directory for this assembly&lt;/param&gt;/// &lt;param name=&quot;Plugins&quot;&gt;All the plugins included in this assembly&lt;/param&gt;/// &lt;param name=&quot;ModuleFiles&quot;&gt;List of module files to compile&lt;/param&gt;/// &lt;param name=&quot;TargetFiles&quot;&gt;List of target files to compile&lt;/param&gt;/// &lt;param name=&quot;ModuleFileToPluginInfo&quot;&gt;Mapping of module file to the plugin that contains it&lt;/param&gt;/// &lt;param name=&quot;AssemblyFileName&quot;&gt;The output path for the compiled assembly&lt;/param&gt;/// &lt;param name=&quot;bContainsEngineModules&quot;&gt;Whether this assembly contains engine modules. Used to initialize the default value for ModuleRules.bTreatAsEngineModule.&lt;/param&gt;/// &lt;param name=&quot;bUseBackwardsCompatibleDefaults&quot;&gt;Whether modules in this assembly should use backwards-compatible defaults.&lt;/param&gt;/// &lt;param name=&quot;bReadOnly&quot;&gt;Whether the modules and targets in this assembly are installed, and should be created with the bUsePrecompiled flag set&lt;/param&gt; /// &lt;param name=&quot;bSkipCompile&quot;&gt;Whether to skip compiling this assembly&lt;/param&gt;/// &lt;param name=&quot;Parent&quot;&gt;The parent rules assembly&lt;/param&gt;public RulesAssembly(DirectoryReference BaseDir, IReadOnlyList&lt;PluginInfo&gt; Plugins, List&lt;FileReference&gt; ModuleFiles, List&lt;FileReference&gt; TargetFiles, Dictionary&lt;FileReference, PluginInfo&gt; ModuleFileToPluginInfo, FileReference AssemblyFileName, bool bContainsEngineModules, bool bUseBackwardsCompatibleDefaults, bool bReadOnly, bool bSkipCompile, RulesAssembly Parent)&#123; this.BaseDir = BaseDir; this.Plugins = Plugins; this.ModuleFileToPluginInfo = ModuleFileToPluginInfo; this.bContainsEngineModules = bContainsEngineModules; this.bUseBackwardsCompatibleDefaults = bUseBackwardsCompatibleDefaults; this.bReadOnly = bReadOnly; this.Parent = Parent; // Find all the source files List&lt;FileReference&gt; AssemblySourceFiles = new List&lt;FileReference&gt;(); AssemblySourceFiles.AddRange(ModuleFiles); AssemblySourceFiles.AddRange(TargetFiles); // Compile the assembly if (AssemblySourceFiles.Count &gt; 0) &#123; List&lt;string&gt; PreprocessorDefines = GetPreprocessorDefinitions(); CompiledAssembly = DynamicCompilation.CompileAndLoadAssembly(AssemblyFileName, AssemblySourceFiles, PreprocessorDefines: PreprocessorDefines, DoNotCompile: bSkipCompile); &#125; // Setup the module map foreach (FileReference ModuleFile in ModuleFiles) &#123; string ModuleName = ModuleFile.GetFileNameWithoutAnyExtensions(); if (!ModuleNameToModuleFile.ContainsKey(ModuleName)) &#123; ModuleNameToModuleFile.Add(ModuleName, ModuleFile); &#125; &#125; // Setup the target map foreach (FileReference TargetFile in TargetFiles) &#123; string TargetName = TargetFile.GetFileNameWithoutAnyExtensions(); if (!TargetNameToTargetFile.ContainsKey(TargetName)) &#123; TargetNameToTargetFile.Add(TargetName, TargetFile); &#125; &#125; // ignore other code..&#125; 编译环境：构造 Target 并执行 Target 的主要作用是收集和设定项目的编译信息用于编译真正的可执行程序的设置，类似于在 VS 中的项目设置。 在 RunUBT 中会对传入的参数（Platform/Configuration 等）做提取，并添加上一系列参数，之后通过调用 UEBuildTarget.CreateTarget，创建一个UBuildTarget 的对象： 1234567891011121314// UnrealBuildTool/Configuration/UEBuildTarget.cs// 执行 `target.cs` 中的逻辑，并构造出一个 URBduileTarget 对象public static UEBuildTarget CreateTarget(TargetDescriptor Desc, string[] Arguments, bool bSkipRulesCompile, bool bCompilingSingleFile, bool bUsePrecompiled, ReadOnlyBuildVersion Version)&#123; DateTime CreateTargetStartTime = DateTime.UtcNow; RulesAssembly RulesAssembly = RulesCompiler.CreateTargetRulesAssembly(Desc.ProjectFile, Desc.Name, bSkipRulesCompile, bUsePrecompiled, Desc.ForeignPlugin); FileReference TargetFileName; TargetRules RulesObject = RulesAssembly.CreateTargetRules(Desc.Name, Desc.Platform, Desc.Configuration, Desc.Architecture, Desc.ProjectFile, Version, Arguments, out TargetFileName); // ...&#125; 在 CreateTarget 中又调用了 RulesAssembly.CreateTargetRules(获取target.cs 文件，以及将最基本的编译环境信息构造出 TargetInfo 并传递给 CreateTargetRulesInstance 用于创建 TargetRules 对象)： 1234567891011121314151617181920212223242526// UnrealBuildTool/System/RulesAssembly.cs/// &lt;summary&gt;/// Creates a target rules object for the specified target name./// &lt;/summary&gt;/// &lt;param name=&quot;TargetName&quot;&gt;Name of the target&lt;/param&gt;/// &lt;param name=&quot;Platform&quot;&gt;Platform being compiled&lt;/param&gt;/// &lt;param name=&quot;Configuration&quot;&gt;Configuration being compiled&lt;/param&gt;/// &lt;param name=&quot;Architecture&quot;&gt;Architecture being built&lt;/param&gt;/// &lt;param name=&quot;ProjectFile&quot;&gt;Path to the project file for this target&lt;/param&gt;/// &lt;param name=&quot;Version&quot;&gt;The current build version&lt;/param&gt;/// &lt;param name=&quot;Arguments&quot;&gt;Command line arguments for this target&lt;/param&gt;/// &lt;param name=&quot;TargetFileName&quot;&gt;The original source file name of the Target.cs file for this target&lt;/param&gt;/// &lt;returns&gt;The build target rules for the specified target&lt;/returns&gt;public TargetRules CreateTargetRules(string TargetName, UnrealTargetPlatform Platform, UnrealTargetConfiguration Configuration, string Architecture, FileReference ProjectFile, ReadOnlyBuildVersion Version, string[] Arguments, out FileReference TargetFileName)&#123; // ignore conditional check code... // Return the target file name to the caller TargetFileName = TargetNameToTargetFile[TargetName]; // Currently, we expect the user&#x27;s rules object type name to be the same as the module name + &#x27;Target&#x27; string TargetTypeName = TargetName + &quot;Target&quot;; // The build module must define a type named &#x27;&lt;TargetName&gt;Target&#x27; that derives from our &#x27;TargetRules&#x27; type. // 通过构造 TargetInfo 对象，将基本的编译环境信息传递给 `target.cs` 中定义的构造函数 return CreateTargetRulesInstance(TargetTypeName, new TargetInfo(TargetName, Platform, Configuration, Architecture, ProjectFile, Version), Arguments);&#125; 获得项目的 *.Target.cs 文件，然后调用 CreateTargetRulesInstance 构造出一个 TargetRules 的对象（target.cs中构造的就是这个类型的对象），并执行 target.cs 中的构造函数中的代码。 12345678910111213141516171819202122232425262728293031323334353637383940// UnrealBuildTool/System/RulesAssembly.cs// 获取定义在 target.cs 中的 TargetRules 对象，并调用其构造函数 /// Construct an instance of the given target rules/// &lt;param name=&quot;TypeName&quot;&gt;Type name of the target rules&lt;/param&gt;/// &lt;param name=&quot;TargetInfo&quot;&gt;Target configuration information to pass to the constructor&lt;/param&gt;/// &lt;param name=&quot;Arguments&quot;&gt;Command line arguments for this target&lt;/param&gt;/// &lt;returns&gt;Instance of the corresponding TargetRules&lt;/returns&gt;protected TargetRules CreateTargetRulesInstance(string TypeName, TargetInfo TargetInfo, string[] Arguments)&#123; // The build module must define a type named &#x27;&lt;TargetName&gt;Target&#x27; that derives from our &#x27;TargetRules&#x27; type. Type RulesType = CompiledAssembly.GetType(TypeName); if (RulesType == null) &#123; throw new BuildException(&quot;Expecting to find a type to be declared in a target rules named &#x27;&#123;0&#125;&#x27;. This type must derive from the &#x27;TargetRules&#x27; type defined by Unreal Build Tool.&quot;, TypeName); &#125; // Create an instance of the module&#x27;s rules object, and set some defaults before calling the constructor. TargetRules Rules = (TargetRules)FormatterServices.GetUninitializedObject(RulesType); Rules.bUseBackwardsCompatibleDefaults = bUseBackwardsCompatibleDefaults; // Find the constructor ConstructorInfo Constructor = RulesType.GetConstructor(new Type[] &#123; typeof(TargetInfo) &#125;); if(Constructor == null) &#123; throw new BuildException(&quot;No constructor found on &#123;0&#125; which takes an argument of type TargetInfo.&quot;, RulesType.Name); &#125; // Invoke the regular constructor try &#123; Constructor.Invoke(Rules, new object[] &#123; TargetInfo &#125;); &#125; catch (Exception Ex) &#123; throw new BuildException(Ex, &quot;Unable to instantiate instance of &#x27;&#123;0&#125;&#x27; object type from compiled assembly &#x27;&#123;1&#125;&#x27;. Unreal Build Tool creates an instance of your module&#x27;s &#x27;Rules&#x27; object in order to find out about your module&#x27;s requirements. The CLR exception details may provide more information: &#123;2&#125;&quot;, TypeName, Path.GetFileNameWithoutExtension(CompiledAssembly.Location), Ex.ToString()); &#125; // ignore other code...&#125; 经过上面的一波操作之后，我们现在已经从 target.cs 中得到了 TargetRules 对象，它代表了当前项目的编译环境，代码列了一堆，看着有点烦人，他们的调用栈如下： 编译目标：ModuleModule是 UE 中真正用来执行的一个个小目标文件，编译出 exe 或者 DLL（通过启动模块编译出 exe，非启动模块编译出 DLL，或者静态链接到 exe 中）。 在上面的执行完毕之后，UBT 会开始读取和分析项目中的ModuleRules，并通过它们构造出一个个UEBuildModule，用于后续的编译处理。 在 RunUBT-&gt;UEBuildTarget.Build-&gt;PreBuidSetup，可以理解真正的执行逻辑是在PreBuildSetup 中执行的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// UEBuildTarget.cs/// &lt;summary&gt;/// Setup target before build. This method finds dependencies, sets up global environment etc./// &lt;/summary&gt;public void PreBuildSetup(UEToolChain TargetToolChain)&#123; // Describe what&#x27;s being built. Log.TraceVerbose(&quot;Building &#123;0&#125; - &#123;1&#125; - &#123;2&#125; - &#123;3&#125;&quot;, AppName, TargetName, Platform, Configuration); // Setup the target&#x27;s binaries. SetupBinaries(); // Setup the target&#x27;s plugins SetupPlugins(); // Setup the custom build steps for this target SetupCustomBuildSteps(); // Add the plugin binaries to the build foreach (UEBuildPlugin Plugin in BuildPlugins) &#123; foreach(UEBuildModuleCPP Module in Plugin.Modules) &#123; AddModuleToBinary(Module); &#125; &#125; // Add all of the extra modules, including game modules, that need to be compiled along // with this app. These modules are always statically linked in monolithic targets, but not necessarily linked to anything in modular targets, // and may still be required at runtime in order for the application to load and function properly! AddExtraModules(); // Create all the modules referenced by the existing binaries foreach(UEBuildBinary Binary in Binaries) &#123; Binary.CreateAllDependentModules(FindOrCreateModuleByName); &#125; // Bind every referenced C++ module to a binary for (int Idx = 0; Idx &lt; Binaries.Count; Idx++) &#123; List&lt;UEBuildModule&gt; DependencyModules = Binaries[Idx].GetAllDependencyModules(true, true); foreach (UEBuildModuleCPP DependencyModule in DependencyModules.OfType&lt;UEBuildModuleCPP&gt;()) &#123; if(DependencyModule.Binary == null) &#123; AddModuleToBinary(DependencyModule); &#125; &#125; &#125; // Add all the modules to the target if necessary. if(Rules.bBuildAllModules) &#123; AddAllValidModulesToTarget(); &#125; // Add the external and non-C++ referenced modules to the binaries that reference them. foreach (UEBuildModuleCPP Module in Modules.Values.OfType&lt;UEBuildModuleCPP&gt;()) &#123; if(Module.Binary != null) &#123; foreach (UEBuildModule ReferencedModule in Module.GetUnboundReferences()) &#123; Module.Binary.AddModule(ReferencedModule); &#125; &#125; &#125; if (!bCompileMonolithic) &#123; if (Platform == UnrealTargetPlatform.Win64 || Platform == UnrealTargetPlatform.Win32) &#123; // On Windows create import libraries for all binaries ahead of time, since linking binaries often causes bottlenecks foreach (UEBuildBinary Binary in Binaries) &#123; Binary.SetCreateImportLibrarySeparately(true); &#125; &#125; else &#123; // On other platforms markup all the binaries containing modules with circular references foreach (UEBuildModule Module in Modules.Values.Where(x =&gt; x.Binary != null)) &#123; foreach (string CircularlyReferencedModuleName in Module.Rules.CircularlyReferencedDependentModules) &#123; UEBuildModule CircularlyReferencedModule; if (Modules.TryGetValue(CircularlyReferencedModuleName, out CircularlyReferencedModule) &amp;&amp; CircularlyReferencedModule.Binary != null) &#123; CircularlyReferencedModule.Binary.SetCreateImportLibrarySeparately(true); &#125; &#125; &#125; &#125; &#125; // On Mac AppBinaries paths for non-console targets need to be adjusted to be inside the app bundle if (Platform == UnrealTargetPlatform.Mac &amp;&amp; !Rules.bIsBuildingConsoleApplication) &#123; TargetToolChain.FixBundleBinariesPaths(this, Binaries); &#125;&#125; 其中的： 123456789// Setup the target&#x27;s binaries.// 读取 LaunchModule, 要编译出来的可执行目标 exe，创建出启动模块的 UEBuildModuleCPP 和 UEBuildBinary(编译 exe)// UEBuildBinary 只在这里被创建SetupBinaries();// Setup the target&#x27;s plugins// 构造所有插件的 Module 并创建出编译对象 UEBuildModuleCPPSetupPlugins(); 它们直接或间接地又调用 FindOrCreateCppModuleByName，最终又会调用到CreateModuleRulesAndSetDefaults 来构造出真正的 ModuleRules 对象，并创建出 UEBuildModuleCPP 用于编译的模块： CreateModuleRulesAndSetDefaults又调用了 RulesAssembly.CreateModuleRules（注意此时执行流已经又回到RulesAssembly 来了）。 RulesAssembly.CreateModuleRules通过上面构造时存起来的 ModuleNameToModuleFile 通过 Module 名拿到 *.build.cs 文件，然后与调用 TargetRules 的构造方法一样调用 ModuleRules 的构造函数，并且将上面构造出来的 TargetRules 传递给ModuleRules。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/// &lt;summary&gt;/// Creates an instance of a module rules descriptor object for the specified module name/// &lt;/summary&gt;/// &lt;param name=&quot;ModuleName&quot;&gt;Name of the module&lt;/param&gt;/// &lt;param name=&quot;Target&quot;&gt;Information about the target associated with this module&lt;/param&gt;/// &lt;param name=&quot;ReferenceChain&quot;&gt;Chain of references leading to this module&lt;/param&gt;/// &lt;returns&gt;Compiled module rule info&lt;/returns&gt;public ModuleRules CreateModuleRules(string ModuleName, ReadOnlyTargetRules Target, string ReferenceChain)&#123; // Currently, we expect the user&#x27;s rules object type name to be the same as the module name string ModuleTypeName = ModuleName; // Make sure the module file is known to us FileReference ModuleFileName; if (!ModuleNameToModuleFile.TryGetValue(ModuleName, out ModuleFileName)) &#123; if (Parent == null) &#123; throw new BuildException(&quot;Could not find definition for module &#x27;&#123;0&#125;&#x27; (referenced via &#123;1&#125;)&quot;, ModuleName, ReferenceChain); &#125; else &#123; return Parent.CreateModuleRules(ModuleName, Target, ReferenceChain); &#125; &#125; // The build module must define a type named &#x27;Rules&#x27; that derives from our &#x27;ModuleRules&#x27; type. Type RulesObjectType = GetModuleRulesTypeInternal(ModuleName); if (RulesObjectType == null) &#123; throw new BuildException(&quot;Expecting to find a type to be declared in a module rules named &#x27;&#123;0&#125;&#x27; in &#123;1&#125;. This type must derive from the &#x27;ModuleRules&#x27; type defined by Unreal Build Tool.&quot;, ModuleTypeName, CompiledAssembly.FullName); &#125; // Create an instance of the module&#x27;s rules object try &#123; // Create an uninitialized ModuleRules object and set some defaults. ModuleRules RulesObject = (ModuleRules)FormatterServices.GetUninitializedObject(RulesObjectType); RulesObject.Name = ModuleName; RulesObject.File = ModuleFileName; RulesObject.Directory = ModuleFileName.Directory; ModuleFileToPluginInfo.TryGetValue(RulesObject.File, out RulesObject.Plugin); RulesObject.bTreatAsEngineModule = bContainsEngineModules; RulesObject.bUseBackwardsCompatibleDefaults = bUseBackwardsCompatibleDefaults &amp;&amp; Target.bUseBackwardsCompatibleDefaults; RulesObject.bPrecompile = (RulesObject.bTreatAsEngineModule || ModuleName.Equals(&quot;UE4Game&quot;, StringComparison.OrdinalIgnoreCase)) &amp;&amp; Target.bPrecompile; RulesObject.bUsePrecompiled = bReadOnly; // Call the constructor ConstructorInfo Constructor = RulesObjectType.GetConstructor(new Type[] &#123; typeof(ReadOnlyTargetRules) &#125;); if(Constructor == null) &#123; throw new BuildException(&quot;No valid constructor found for &#123;0&#125;.&quot;, ModuleName); &#125; Constructor.Invoke(RulesObject, new object[] &#123; Target &#125;); return RulesObject; &#125; catch (Exception Ex) &#123; Exception MessageEx = (Ex is TargetInvocationException &amp;&amp; Ex.InnerException != null)? Ex.InnerException : Ex; throw new BuildException(Ex, &quot;Unable to instantiate module &#x27;&#123;0&#125;&#x27;: &#123;1&#125;\\n(referenced via &#123;2&#125;)&quot;, ModuleName, MessageEx.ToString(), ReferenceChain); &#125;&#125; 我们在所有的 GameMode 与所有 Plugin 中的 build.cs 中的代码在此时执行。 Launch 模块的编译 上面写到了编译 Module，有一个Module 很特殊，那就是 Launch 模块。 任何可执行程序都会有一个执行入口，在 UE 中，每一个 Target 都会编译出一个可执行程序。引擎启动是从 Launch 模块开始的，main函数也是定义在其中的，所以需要将 Launch 模块中的 main 函数编译出一个可执行程序来。 启动模块是在 UBT 的TargetRules中指定的： 1234567891011public string LaunchModuleName&#123; get &#123; return (LaunchModuleNamePrivate == null &amp;&amp; Type != global::UnrealBuildTool.TargetType.Program)? &quot;Launch&quot; : LaunchModuleNamePrivate; &#125; set &#123; LaunchModuleNamePrivate = value; &#125;&#125; 可以在 TargetRules 中使用 LaunchModuleNamePrivate 指定一个启动模块，如果 没有指定 且 Target 类型不为 Program，则使用Launch 模块，否则使用指定的模块。即不管是 Game/Editor/Server/Client 的 Target 启动模块都是 Launch。 但是 ，因为LaunchModuleNamePrivate 在TargetRules的定义中是一个 private 成员，无法在我们继承来的 TargetRules 中赋值，所以目前也没有什么用。 在 UEBuildTarget.SetupBinaries 中被使用（上面也已经提到过了，UEBuildBinary就是我们要编译出的启动模块的可执行 exe 编译对象，并且只在这里被创建）： 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// Sets up the binaries for the target./// &lt;/summary&gt;protected void SetupBinaries()&#123; // If we&#x27;re using the new method for specifying binaries, fill in the binary configurations now if(Rules.LaunchModuleName == null) &#123; throw new BuildException(&quot;LaunchModuleName must be set for all targets.&quot;); &#125; // Create the launch module UEBuildModuleCPP LaunchModule = FindOrCreateCppModuleByName(Rules.LaunchModuleName, TargetRulesFile.GetFileName()); // Create the binary UEBuildBinary Binary = new UEBuildBinary( Type: Rules.bShouldCompileAsDLL? UEBuildBinaryType.DynamicLinkLibrary : UEBuildBinaryType.Executable, OutputFilePaths: OutputPaths, IntermediateDirectory: (!LaunchModule.RulesFile.IsUnderDirectory(UnrealBuildTool.EngineDirectory) || ShouldCompileMonolithic()) ? ProjectIntermediateDirectory : EngineIntermediateDirectory, bAllowExports: Rules.bHasExports, PrimaryModule: LaunchModule, bUsePrecompiled: LaunchModule.Rules.bUsePrecompiled &amp;&amp; OutputPaths[0].IsUnderDirectory(UnrealBuildTool.EngineDirectory) ); Binaries.Add(Binary); // Add the launch module to it LaunchModule.Binary = Binary; Binary.AddModule(LaunchModule); // Create an additional console app for the editor if (Platform == UnrealTargetPlatform.Win64 &amp;&amp; Configuration != UnrealTargetConfiguration.Shipping &amp;&amp; TargetType == TargetType.Editor) &#123; Binary.bBuildAdditionalConsoleApp = true; &#125;&#125; 执行环境如下： 可以看到这里的输出文件就是我们编译的项目 exe 了。 UHT之后会调用 UHT 来生成代码：调用的函数为 ExecuteHeaderToolIfNecessary(System/ExternalExecution.cs): 如果上一步通过 UHT 生成成功，就会执行编译的 Action 了 (ActionGraph.ExecuteActions in System/ActionGraphs.cs)： 继续进入会检测一堆引擎的构建配置（e.g:Engine/Saved/UnrealBuildTool/BuildConfiguration.xml）：我这里保持的是引擎默认的构建配置，则创建了一个 ParallelExecutor(System/ParallelExecutor.cs)，然后执行： 将当前的编译任务创建出多个 Action，并执行:开始编译代码： 后记 根据上面的分析，UE 的 build 路径是： 在 VS 中点击 Build，调用 build.bat build.bat 中调用 UBT UBT 执行 target.cs 和所有 Module 的 build.cs 中的逻辑 UBT 调用 UHT(根据 UE 的 宏标记 生成代码) UHT 生成完毕后，UBT 调用编译器 预处理 编译 链接 这个流程的关键点在：UBT 调用 UHT 生成的顺序是在调用编译器的预处理之前的，这意味着我们无法包裹 UE 的宏 (其实UCLASS/UFUNCTION 之类的不应该叫宏，应该叫 标记)，因为 UE 的宏由 UHT 先于编译器预处理了。","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"UBT 中定义的 C++ 宏","date":"2019-01-09T18:17:35.000Z","path":"wiki/5214/","text":"UE4 引擎里面定义了很多引擎中的宏和一些处理逻辑，如 WITH_ENGINE/WITH_EDITOR 等，它们部分是 UBT 通过读取 *.target.cs 文件中的配置来定义的，有些逻辑是通过读取 *.Build.cs 的配置处理的。我读了一下 UBT 的代码，抽出来部分 UBT 中配置文件 (Target.cs/Build.cs) 参数与 MACRO 的相互定义，作为速查手册。*.Target.cs的参数可以看：UnrealBuildSystem/Targets*.Build.cs的参数可以看：UnrealBuildSystem/ModuleFilesUE 的构建系统文档：Build Tools IS_PROGRAM (TargetType) Target.Program Type (TargetType): The type of target. 123// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csGlobalCompileEnvironment.Definitions.Add(String.Format(&quot;IS_PROGRAM=&#123;0&#125;&quot;, TargetType == TargetType.Program ? &quot;1&quot; : &quot;0&quot;)); ENABLE_PGO_PROFILE (bool) bPGOProfile Whether to enable Profile Guided Optimization (PGO) instrumentation in this build. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bPGOProfile)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;ENABLE_PGO_PROFILE=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;ENABLE_PGO_PROFILE=0&quot;);&#125; ENGINE_BASE_DIR_ADJUST (String) ExeBinariesSubFolder Subfolder to place executables in, relative to the default location. 123456// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif(!String.IsNullOrEmpty(Rules.ExeBinariesSubFolder))&#123; GlobalCompileEnvironment.Definitions.Add(String.Format(&quot;ENGINE_BASE_DIR_ADJUST=&#123;0&#125;&quot;, Rules.ExeBinariesSubFolder.Replace(&#x27;\\\\&#x27;, &#x27;/&#x27;).Trim(&#x27;/&#x27;).Count(x =&gt; x == &#x27;/&#x27;) + 1));&#125; WITH_DEV_AUTOMATION_TESTS (bool) bForceCompileDevelopmentAutomationTests Whether to compile development automation tests. 123456789101112131415161718// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bForceCompileDevelopmentAutomationTests)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_DEV_AUTOMATION_TESTS=1&quot;);&#125;else&#123; switch(Configuration) &#123; case UnrealTargetConfiguration.Test: case UnrealTargetConfiguration.Shipping: GlobalCompileEnvironment.Definitions.Add(&quot;WITH_DEV_AUTOMATION_TESTS=0&quot;); break; default: GlobalCompileEnvironment.Definitions.Add(&quot;WITH_DEV_AUTOMATION_TESTS=1&quot;); break; &#125;&#125; WITH_PERF_AUTOMATION_TESTS (bool) bForceCompilePerformanceAutomationTests Whether to compile performance automation tests. 123456789101112131415161718// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bForceCompilePerformanceAutomationTests)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PERF_AUTOMATION_TESTS=1&quot;);&#125;else&#123; switch (Configuration) &#123; case UnrealTargetConfiguration.Shipping: GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PERF_AUTOMATION_TESTS=0&quot;); break; default: GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PERF_AUTOMATION_TESTS=1&quot;); break; &#125;&#125; IS_MONOLITHIC (TargetLinkType) LinkType Monolithic Mode, which puts all code together in a single executable file.Module API Specifiers 12345678// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// ...bCompileMonolithic = (Rules.LinkType == TargetLinkType.Monolithic);// ... GlobalCompileEnvironment.Definitions.Add(String.Format(&quot;IS_MONOLITHIC=&#123;0&#125;&quot;, ShouldCompileMonolithic() ? &quot;1&quot; : &quot;0&quot;));// ... WITH_ENGINE (bool) bCompileAgainstEngine Enabled for all builds that include the engine project. Disabled only when building standalone apps that only link with Core. WITH_UNREAL_DEVELOPER_TOOLS bBuildDeveloperTools 1234567891011121314// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bCompileAgainstEngine)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_ENGINE=1&quot;); GlobalCompileEnvironment.Definitions.Add( String.Format(&quot;WITH_UNREAL_DEVELOPER_TOOLS=&#123;0&#125;&quot;, Rules.bBuildDeveloperTools ? &quot;1&quot; : &quot;0&quot;));&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_ENGINE=0&quot;); // Can&#x27;t have developer tools w/out engine GlobalCompileEnvironment.Definitions.Add(&quot;WITH_UNREAL_DEVELOPER_TOOLS=0&quot;);&#125; WITH_COREUOBJECT (bool)bCompileAgainstCoreUObject Enabled for all builds that include the CoreUObject project. Disabled only when building standalone apps that only link with Core. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bCompileAgainstCoreUObject)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_COREUOBJECT=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_COREUOBJECT=0&quot;);&#125; USE_STATS_WITHOUT_ENGINE (bool) bCompileWithStatsWithoutEngine Whether to include stats support even without the engine. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bCompileWithStatsWithoutEngine)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_STATS_WITHOUT_ENGINE=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_STATS_WITHOUT_ENGINE=0&quot;);&#125; WITH_PLUGIN_SUPPORT (bool) bCompileWithPluginSupport Whether to include plugin support. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bCompileWithPluginSupport)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PLUGIN_SUPPORT=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PLUGIN_SUPPORT=0&quot;);&#125; WITH_PERFCOUNTERS (bool) bWithPerfCounters Whether to include PerfCounters support. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bWithPerfCounters)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PERFCOUNTERS=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_PERFCOUNTERS=0&quot;);&#125; USE_LOGGING_IN_SHIPPING (bool) bUseLoggingInShipping Whether to turn on logging for test/shipping builds. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bUseLoggingInShipping)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_LOGGING_IN_SHIPPING=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_LOGGING_IN_SHIPPING=0&quot;);&#125; WITH_LOGGING_TO_MEMORY (bool) bLoggingToMemoryEnabled Whether to turn on logging to memory for test/shipping builds. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bLoggingToMemoryEnabled)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_LOGGING_TO_MEMORY=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_LOGGING_TO_MEMORY=0&quot;);&#125; USE_CACHE_FREED_OS_ALLOCS (bool) bUseCacheFreedOSAllocs Whether to turn on logging to memory for test/shipping builds. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bUseCacheFreedOSAllocs)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_CACHE_FREED_OS_ALLOCS=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_CACHE_FREED_OS_ALLOCS=0&quot;);&#125; USE_CHECKS_IN_SHIPPING (bool) bUseChecksInShipping Whether to turn on checks (asserts) for test/shipping builds. 12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bUseChecksInShipping)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_CHECKS_IN_SHIPPING=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;USE_CHECKS_IN_SHIPPING=0&quot;);&#125; UE_BUILD_MINIMAL (bool) bCompileLeanAndMeanUE Whether to compile lean and mean version of UE. 1234567891011// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// Propagate whether we want a lean and mean build to the C++ code.if (Rules.bCompileLeanAndMeanUE)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_MINIMAL=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;UE_BUILD_MINIMAL=0&quot;);&#125; WITH_EDITOR (bool) bBuildEditor Whether to compile the editor or not. Only desktop platforms (Windows or Mac) will use this, other platforms force this to false. 1234567891011// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// bBuildEditor has now been set appropriately for all platforms, so this is here to make sure the #define if (Rules.bBuildEditor)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_EDITOR=1&quot;);&#125;else if (!GlobalCompileEnvironment.Definitions.Contains(&quot;WITH_EDITOR=0&quot;))&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_EDITOR=0&quot;);&#125; WITH_EDITORONLY_DATA (bool) bBuildWithEditorOnlyData Whether to compile WITH_EDITORONLY_DATA disabled. Only Windows will use this, other platforms force this to false. 123456// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bBuildWithEditorOnlyData == false)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_EDITORONLY_DATA=0&quot;);&#125; WITH_SERVER_CODE (bool) bWithServerCode Compile server-only code. 1234567891011// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// Check if server-only code should be compiled out.if (Rules.bWithServerCode == true)&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_SERVER_CODE=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_SERVER_CODE=0&quot;);&#125; WITH_CEF31234567891011// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// Set the define for whether we&#x27;re compiling with CEF3if (Rules.bCompileCEF3 &amp;&amp; (Platform == UnrealTargetPlatform.Win32 || Platform == UnrealTargetPlatform.Win64 || Platform == UnrealTargetPlatform.Mac || Platform == UnrealTargetPlatform.Linux))&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_CEF3=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_CEF3=0&quot;);&#125; WITH_XGE_CONTROLLER bUseXGEController TargetType.Editor &amp;&amp; UnrealTargetPlatform is Win32/Win64 123456789101112// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csif (Rules.bUseXGEController &amp;&amp; Rules.Type == TargetType.Editor &amp;&amp; (Platform == UnrealTargetPlatform.Win32 || Platform == UnrealTargetPlatform.Win64))&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_XGE_CONTROLLER=1&quot;);&#125;else&#123; GlobalCompileEnvironment.Definitions.Add(&quot;WITH_XGE_CONTROLLER=0&quot;);&#125; UBT_MODULE_MANIFEST1234// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cs// ...GlobalCompileEnvironment.Definitions.Add(String.Format(&quot;UBT_MODULE_MANIFEST=\\&quot;&#123;0&#125;\\&quot;&quot;, ModuleManifest.GetStandardFileName(AppName, Platform, Configuration, Architecture, false))); UBT_MODULE_MANIFEST_DEBUGGAME123// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csGlobalCompileEnvironment.Definitions.Add(String.Format(&quot;UBT_MODULE_MANIFEST_DEBUGGAME=\\&quot;&#123;0&#125;\\&quot;&quot;, ModuleManifest.GetStandardFileName(AppName, Platform, UnrealTargetConfiguration.DebugGame, Architecture, true))); UBT_COMPILED_PLATFORM12345678910// Programs/UnrealBuildTool/Configuration/UEBuildTarget.cspublic UEBuildTarget(SerializationInfo Info, StreamingContext Context)&#123; // ... Platform = (UnrealTargetPlatform)Info.GetInt32(&quot;pl&quot;); // ...&#125;GlobalCompileEnvironment.Definitions.Add(&quot;UBT_COMPILED_PLATFORM=&quot; + Platform.ToString()); UBT_COMPILED_TARGET TargetType 123// Programs/UnrealBuildTool/Configuration/UEBuildTarget.csGlobalCompileEnvironment.Definitions.Add(&quot;UBT_COMPILED_TARGET=&quot; + TargetType.ToString()); WITH_PHYSX123456789101112131415161718- (bool) bCompilePhysX&gt;Whether to include PhysX support.// Programs/UnrealBuildTool/Configuration/ModuleRules.cs// SetupModulePhysXAPEXSupport(ReadOnlyTargetRules Target)// definitions used outside of PhysX/APEX need to be set here, not in PhysX.Build.cs or APEX.Build.cs, // since we need to make sure we always set it, even to 0 (because these are Private dependencies, the// defines inside their Build.cs files won&#x27;t leak out)if (Target.bCompilePhysX == true)&#123; PrivateDependencyModuleNames.Add(&quot;PhysX&quot;); PublicDefinitions.Add(&quot;WITH_PHYSX=1&quot;);&#125;else&#123; PublicDefinitions.Add(&quot;WITH_PHYSX=0&quot;);&#125; WITH_APEX Whether to include PhysX APEX support. WITH_APEX_CLOTHINGWITH_CLOTH_COLLISION_DETECTIONWITH_PHYSX_COOKING1234567891011121314151617181920212223// Programs/UnrealBuildTool/Configuration/ModuleRules.cs// SetupModulePhysXAPEXSupport(ReadOnlyTargetRules Target)if (Target.bCompileAPEX == true)&#123; if (!Target.bCompilePhysX) &#123; throw new BuildException(&quot;APEX is enabled, without PhysX. This is not supported!&quot;); &#125; PrivateDependencyModuleNames.Add(&quot;APEX&quot;); PublicDefinitions.Add(&quot;WITH_APEX=1&quot;); PublicDefinitions.Add(&quot;WITH_APEX_CLOTHING=1&quot;); PublicDefinitions.Add(&quot;WITH_CLOTH_COLLISION_DETECTION=1&quot;); PublicDefinitions.Add(&quot;WITH_PHYSX_COOKING=1&quot;); // APEX currently relies on cooking even at runtime&#125;else&#123; PublicDefinitions.Add(&quot;WITH_APEX=0&quot;); PublicDefinitions.Add(&quot;WITH_APEX_CLOTHING=0&quot;); PublicDefinitions.Add(&quot;WITH_CLOTH_COLLISION_DETECTION=0&quot;); PublicDefinitions.Add(string.Format(&quot;WITH_PHYSX_COOKING=&#123;0&#125;&quot;, Target.bBuildEditor &amp;&amp; Target.bCompilePhysX ? 1 : 0)); // without APEX, we only need cooking in editor builds&#125; WITH_NVCLOTH (bool) bCompileNvCloth Whether to include NvCloth. 1234567891011121314151617// Programs/UnrealBuildTool/Configuration/ModuleRules.cs// SetupModulePhysXAPEXSupport(ReadOnlyTargetRules Target)if (Target.bCompileNvCloth == true)&#123; if (!Target.bCompilePhysX) &#123; throw new BuildException(&quot;NvCloth is enabled, without PhysX. This is not supported!&quot;); &#125; PrivateDependencyModuleNames.Add(&quot;NvCloth&quot;); PublicDefinitions.Add(&quot;WITH_NVCLOTH=1&quot;);&#125;else&#123; PublicDefinitions.Add(&quot;WITH_NVCLOTH=0&quot;);&#125; bUsesSlate1234567891011121314// Programs/UnrealBuildTool/Configuration/UEBuildTargets.cs// void PrepareReceipts(UEToolChain ToolChain, List&lt;KeyValuePair&lt;FileReference, BuildProductType&gt;&gt; BuildProducts, List&lt;KeyValuePair&lt;FileReference, BuildProductType&gt;&gt; PrecompileOnlyBuildProducts, EHotReload HotReload)if (Rules.bUsesSlate)&#123; AddRuntimeDependenciesFromDir(DirectoryReference.Combine(UnrealBuildTool.EngineDirectory, &quot;Content&quot;, &quot;Slate&quot;), StagedFileType.UFS); AddRuntimeDependenciesFromDir(DirectoryReference.Combine(UnrealBuildTool.EngineDirectory, &quot;Content&quot;, &quot;SlateDebug&quot;), StagedFileType.UFS); if (ProjectFile != null) &#123; AddRuntimeDependenciesFromDir(DirectoryReference.Combine(ProjectDirectory, &quot;Content&quot;, &quot;Slate&quot;), StagedFileType.UFS); AddRuntimeDependenciesFromDir(DirectoryReference.Combine(ProjectDirectory, &quot;Content&quot;, &quot;SlateDebug&quot;), StagedFileType.UFS); &#125;&#125; bIsBuildingConsoleApplication True if this is a console application that’s being built. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Programs/UnrealBuildTool/Platform/Windows/VCToolChains.cs// void AppendLibArguments(LinkEnvironment LinkEnvironment, List&lt;string&gt; Arguments)void AppendLibArguments(LinkEnvironment LinkEnvironment, List&lt;string&gt; Arguments)&#123; // Prevents the linker from displaying its logo for each invocation. Arguments.Add(&quot;/NOLOGO&quot;); // Prompt the user before reporting internal errors to Microsoft. Arguments.Add(&quot;/errorReport:prompt&quot;); // // PC // if (LinkEnvironment.Platform == CppPlatform.Win32 || LinkEnvironment.Platform == CppPlatform.Win64) &#123; // Set machine type/ architecture to be 64 bit. if (LinkEnvironment.Platform == CppPlatform.Win64) &#123; Arguments.Add(&quot;/MACHINE:x64&quot;); &#125; // 32 bit executable/ target. else &#123; Arguments.Add(&quot;/MACHINE:x86&quot;); &#125; &#123; if (LinkEnvironment.bIsBuildingConsoleApplication) &#123; Arguments.Add(&quot;/SUBSYSTEM:CONSOLE&quot;); &#125; else &#123; Arguments.Add(&quot;/SUBSYSTEM:WINDOWS&quot;); &#125; &#125; &#125; // // Shipping &amp; LTCG // if (LinkEnvironment.Configuration == CppConfiguration.Shipping) &#123; // Use link-time code generation. Arguments.Add(&quot;/LTCG&quot;); &#125;&#125;","tags":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"}],"categories":[{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"}]},{"title":"UnrealVersionSelector","date":"2018-06-06T12:29:45.000Z","path":"wiki/15353/","text":"UnrealVersionSelector是 UE 的一个工具，用来关联 uproject 文件、注册引擎、选择引擎版本、生成解决方案等功能的一个工具。在对 uproject 文件点击右键时，Switch Unreal Engine Version等选项就是 UnrealVersionSelector 提供的： UnrealVersionSelector 的参数 -register：Add the current directory to the list of installations -fileassociations：Update all the settings. -switchversion：Associate with an engine label -switchversionsilent：Associate with a specific engine label -editor：Open a project with the editor -projectlist：Open the editor -game：Play a game using the editor executable -projectfiles：Generate Visual Studio project files 注册 UnrealVersionSelector如果遇到 uproject 没有文件关联的情况可以使用下列注册表修复文件关联。 保存为.reg，双击合并即可。 123456789101112131415161718192021222324252627282930313233343536373839Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.uproject]@=&quot;Unreal.ProjectFile&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile]@=&quot;Unreal Engine Project File&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\DefaultIcon]@=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell][HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\open]@=&quot;Open&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\open\\command]@=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot; /editor \\&quot;%1\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\run]@=&quot;Launch game&quot;&quot;Icon&quot;=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\run\\command]@=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot; /game \\&quot;%1\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\rungenproj]@=&quot;Generate Visual Studio project files&quot;&quot;Icon&quot;=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\rungenproj\\command]@=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot; /projectfiles \\&quot;%1\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\switchversion]@=&quot;Switch Unreal Engine version...&quot;&quot;Icon&quot;=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot;&quot;[HKEY_CLASSES_ROOT\\Unreal.ProjectFile\\shell\\switchversion\\command]@=&quot;\\&quot;C:\\\\Program Files (x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Binaries\\\\Win64\\\\UnrealVersionSelector.exe\\&quot; /switchversion \\&quot;%1\\&quot;&quot; 获取所有已注册的引擎 可以使用 IDesktopPlatform::EnumerateEngineInstallations 来获取当前系统中所有从启动器安装、以及用户使用 UnrealVersionSelector 注册的引擎版本。 12TMap&lt;FString,FString&gt; Installations;FDesktopPlatformModule::Get()-&gt;EnumerateEngineInstallations(Installations) 注册引擎 使用 UnrealVersionSelector 注册引擎时，会将注册的引擎路径写入到注册表： 1HKEY_CURRENT_USER\\SOFTWARE\\Epic Games\\Unreal Engine\\Builds 其注册表项的 lpValueName 则是生成的一个 GUID： 12345678910111213141516171819202122// DesktopPlatfromWindows.cppbool FDesktopPlatformWindows::RegisterEngineInstallation(const FString &amp;RootDir, FString &amp;OutIdentifier)&#123; bool bRes = false; if(IsValidRootDirectory(RootDir)) &#123; HKEY hRootKey; if(RegCreateKeyEx(HKEY_CURRENT_USER, InstallationsSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hRootKey, NULL) == ERROR_SUCCESS) &#123; FString NewIdentifier = FGuid::NewGuid().ToString(EGuidFormats::DigitsWithHyphensInBraces); LRESULT SetResult = RegSetValueEx(hRootKey, *NewIdentifier, 0, REG_SZ, (const BYTE*)*RootDir, (RootDir.Len() + 1) * sizeof(TCHAR)); RegCloseKey(hRootKey); if(SetResult == ERROR_SUCCESS) &#123; OutIdentifier = NewIdentifier; bRes = true; &#125; &#125; &#125; return bRes;&#125; UE 并没有直接在 IDesktopPlatfrom 中单独提供 获取用户通过使用 UnrealVersionSelector 注册的引擎列表。但是在 EnumerateEngineInstallations 中写了从注册表获取 per-user installations 引擎： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void FDesktopPlatformWindows::EnumerateEngineInstallations(TMap&lt;FString, FString&gt; &amp;OutInstallations)&#123; // Enumerate the binary installations EnumerateLauncherEngineInstallations(OutInstallations); // Enumerate the per-user installations HKEY hKey; if (RegOpenKeyEx(HKEY_CURRENT_USER, InstallationsSubKey, 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS) &#123; // Get a list of all the directories TArray&lt;FString&gt; UniqueDirectories; OutInstallations.GenerateValueArray(UniqueDirectories); // Enumerate all the installations TArray&lt;FString&gt; InvalidKeys; for (::DWORD Index = 0;; Index++) &#123; TCHAR ValueName[256]; TCHAR ValueData[MAX_PATH]; ::DWORD ValueType = 0; ::DWORD ValueNameLength = sizeof(ValueName) / sizeof(ValueName[0]); ::DWORD ValueDataSize = sizeof(ValueData); LRESULT Result = RegEnumValue(hKey, Index, ValueName, &amp;ValueNameLength, NULL, &amp;ValueType, (BYTE*)&amp;ValueData[0], &amp;ValueDataSize); if(Result == ERROR_SUCCESS) &#123; int32 ValueDataLength = ValueDataSize / sizeof(TCHAR); if(ValueDataLength &gt; 0 &amp;&amp; ValueData[ValueDataLength - 1] == 0) ValueDataLength--; FString NormalizedInstalledDirectory(ValueDataLength, ValueData); FPaths::NormalizeDirectoryName(NormalizedInstalledDirectory); FPaths::CollapseRelativeDirectories(NormalizedInstalledDirectory); if(IsValidRootDirectory(NormalizedInstalledDirectory) &amp;&amp; !UniqueDirectories.Contains(NormalizedInstalledDirectory)) &#123; OutInstallations.Add(ValueName, NormalizedInstalledDirectory); UniqueDirectories.Add(NormalizedInstalledDirectory); &#125; else &#123; InvalidKeys.Add(ValueName); &#125; &#125; else if(Result == ERROR_NO_MORE_ITEMS) &#123; break; &#125; &#125; // Remove all the keys which weren&#x27;t valid for(const FString InvalidKey: InvalidKeys) &#123; RegDeleteValue(hKey, *InvalidKey); &#125; RegCloseKey(hKey); &#125;&#125; Launcher 版引擎注册表路径 上面提到，如果非源码版引擎，使用 UnrealVersionSelector 注册时会写入到注册表： 1HKEY_CURRENT_USER\\SOFTWARE\\Epic Games\\Unreal Engine\\Builds 从 EpicGameLauncher 安装的版本则会写入到另一个注册表路径下： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\EpicGames\\Unreal Engine 其值为(从注册表导出的)： 1234Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\EpicGames\\Unreal Engine\\4.18]&quot;InstalledDirectory&quot;=&quot;C:\\\\Program Files\\\\Epic Games\\\\UE_4.18&quot; UE 提供了方法来得到从 EpicGameLauncher 安装的引擎 (通过IDesktopPlatfrom 接口)： 12TMap&lt;FString,FString&gt; Installations;FDesktopPlatformModule::Get()-&gt;EnumerateLauncherEngineInstallations(OutInstallations); 注册编译版引擎的安装路径 UE 提供了UnrealVersionSelector 工具用来选择引擎版本 / 生成 sln 等功能，其也可以用来注册本地的引擎 (非 Launcher 安装的引擎，如自己编译的源码版引擎) 到项目文件的右键 Select Unreal Engine Version... 列表中。简单分析了一下 UnrealVersionSelector 的代码，它的注册流程如下： 1234567891011121314WinMain_Func=&gt;start: WinMainMain_Func=&gt;operation: Main(Arguments)RegisterCurrentEngineDirectoryWithPrompt_Func=&gt;operation: RegisterCurrentEngineDirectoryWithPrompt()RegisterCurrentEngineDirectory_Func=&gt;operation: RegisterCurrentEngineDirectory(false)GetEngineIdentifierFromRootDir_Func=&gt;operation: FDesktopPlatformModule::Get()-&gt;GetEngineIdentifierFromRootDir(EngineRootDir, Identifier)RegisterEngineInstallation_Func=&gt;operation: RegisterEngineInstallation(RootDir, OutIdentifier)end=&gt;end: EndWinMain_Func-&gt;Main_FuncMain_Func-&gt;RegisterCurrentEngineDirectoryWithPrompt_FuncRegisterCurrentEngineDirectoryWithPrompt_Func-&gt;RegisterCurrentEngineDirectory_FuncRegisterCurrentEngineDirectory_Func-&gt;GetEngineIdentifierFromRootDir_FuncGetEngineIdentifierFromRootDir_Func-&gt;RegisterEngineInstallation_FuncRegisterEngineInstallation_Func-&gt;end 向注册表写入的操作在 FDesktopPlatformWindows::RegisterEngineInstallation 这个函数中。操作为将注册的引擎目录写入到 HKEY_CURRENT_USER\\Software\\Epic Games\\Unreal Engine\\Builds 中的字符串项中。当右键 Switch Unreal Engine Version... 的时候，会修改 .uproject 文件中的 EngineAssociation 值： 其调用流如下： 1234567891011121314151617181920WinMain_Func=&gt;start: WinMainMain_Func=&gt;operation: Main(Arguments)SwitchVersion_Func=&gt;operation: SwitchVersion(const FString&amp; ProjectFileName)GetEngineIdentifierForProject_fUNC=&gt;operation: FDesktopPlatformModule::Get()-&gt;GetEngineIdentifierForProject(ProjectFileName, Identifier) // 获取当前选择的引擎SelectEngineInstallation_Func=&gt;operation: FPlatformInstallation::SelectEngineInstallation(Identifier) // 弹出选择引擎列表框，当前选择的为默认SetEngineIdentifierForProject_func=&gt;operation: FDesktopPlatformModule::Get()-&gt;SetEngineIdentifierForProject(ProjectFileName, Identifier) // 设置选择的引擎，并写入 uproject 文件ContentOnly=&gt;condition: Is Content Only Project?GenerateProjectFiles_func=&gt;operation: GenerateProjectFiles(ProjectFileName)end=&gt;end: EndWinMain_Func-&gt;Main_FuncMain_Func-&gt;SwitchVersion_FuncSwitchVersion_Func-&gt;GetEngineIdentifierForProject_fUNCGetEngineIdentifierForProject_fUNC-&gt;SelectEngineInstallation_FuncSelectEngineInstallation_Func-&gt;SetEngineIdentifierForProject_funcSetEngineIdentifierForProject_func-&gt;ContentOnlyContentOnly(yes)-&gt;endContentOnly(no)-&gt;GenerateProjectFiles_funcGenerateProjectFiles_func-&gt;end 执行项目文件写入的操作在 FDesktopPlatformBase::SetEngineIdentifierForProject 中： 123456789101112131415161718192021222324252627282930bool FDesktopPlatformBase::SetEngineIdentifierForProject(const FString &amp;ProjectFileName, const FString &amp;InIdentifier)&#123; // Load the project file TSharedPtr&lt;FJsonObject&gt; ProjectFile = LoadProjectFile(ProjectFileName); if (!ProjectFile.IsValid()) &#123; return false; &#125; // Check if the project is a non-foreign project of the given engine installation. If so, blank the identifier // string to allow portability between source control databases. GetEngineIdentifierForProject will translate // the association back into a local identifier on other machines or syncs. FString Identifier = InIdentifier; if(Identifier.Len() &gt; 0) &#123; FString RootDir; if(GetEngineRootDirFromIdentifier(Identifier, RootDir)) &#123; const FUProjectDictionary &amp;Dictionary = GetCachedProjectDictionary(RootDir); if(!Dictionary.IsForeignProject(ProjectFileName)) &#123; Identifier.Empty(); &#125; &#125; &#125; // Set the association on the project and save it ProjectFile-&gt;SetStringField(TEXT(&quot;EngineAssociation&quot;), Identifier); return SaveProjectFile(ProjectFileName, ProjectFile);&#125; 所以如果你选择了一个项目使用编译版引擎，可以使用文本编辑器打开该项目的 .uproject 文件，可以看到其中的 EngineAssociation 项的值就是注册表中的引擎版本值。 注：UnrealVersionSelector所支持的命令行参数及其用途在UnrealVersionSelector.cpp#L224: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int Main(const TArray&lt;FString&gt;&amp; Arguments)&#123; bool bRes = false; if (Arguments.Num() == 0) &#123; // Add the current directory to the list of installations bRes = RegisterCurrentEngineDirectoryWithPrompt(); &#125; else if (Arguments.Num() == 1 &amp;&amp; Arguments[0] == TEXT(&quot;-register&quot;)) &#123; // Add the current directory to the list of installations bRes = RegisterCurrentEngineDirectory(true); &#125; else if (Arguments.Num() == 1 &amp;&amp; Arguments[0] == TEXT(&quot;-fileassociations&quot;)) &#123; // Update all the settings. bRes = UpdateFileAssociations(); &#125; else if (Arguments.Num() == 2 &amp;&amp; Arguments[0] == TEXT(&quot;-switchversion&quot;)) &#123; // Associate with an engine label bRes = SwitchVersion(Arguments[1]); &#125; else if (Arguments.Num() == 3 &amp;&amp; Arguments[0] == TEXT(&quot;-switchversionsilent&quot;)) &#123; // Associate with a specific engine label bRes = SwitchVersionSilent(Arguments[1], Arguments[2]); &#125; else if (Arguments.Num() == 2 &amp;&amp; Arguments[0] == TEXT(&quot;-editor&quot;)) &#123; // Open a project with the editor bRes = LaunchEditor(Arguments[1], L&quot;&quot;); &#125; else if (Arguments.Num() == 2 &amp;&amp; Arguments[0] == TEXT(&quot;-game&quot;)) &#123; // Play a game using the editor executable bRes = LaunchEditor(Arguments[1], L&quot;-game&quot;); &#125; else if (Arguments.Num() == 2 &amp;&amp; Arguments[0] == TEXT(&quot;-projectfiles&quot;)) &#123; // Generate Visual Studio project files bRes = GenerateProjectFiles(Arguments[1]); &#125; else &#123; // Invalid command line FPlatformMisc::MessageBoxExt(EAppMsgType::Ok, TEXT(&quot;Invalid command line&quot;), NULL); &#125; return bRes ? 0 : 1;&#125; 解决.uproject 右键生成失败 首先要查看右键菜单所使用的 UnrealVersionSelector.exe 的路径，可以打开注册表: 1HKEY_CLASSES_ROOT\\Unreal.ProjectFile 然后找到 shell\\open\\command 条目查看 UnrealVersionSelector.exe 的位置(如果没有安装过源码版引擎则默认在 EpicGamesLauncher 的 Binaries 路径下)，如： 1&quot;C:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Binaries\\Win64\\UnrealVersionSelector.exe&quot; /editor &quot;%1&quot; 然后打开 C:\\Program Files (x86)\\Epic Games\\Launcher\\Engine\\Binaries\\Win64，将UnrealVersionSelector.exe 设置为以管理员权限启动即可(右键 - 属性 - 兼容性 - 以管理员身份运行此程序)。","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"跨关卡传递 Actor 实例","date":"2018-04-28T00:43:40.000Z","path":"wiki/19376/","text":"因为 UnrealEngine 在切换关卡 (OpenLevel) 时会把当前关卡的所有对象全部销毁，但是常常我们需要保存某些对象到下一关卡中，今天读了一下相关的代码，本篇文章讲一下如何来实现。其实 Unreal 的文档是有说明的(Travelling in Multiplayer)，实现起来也并不麻烦，但是 UE 文档的一贯风格是资料是不详细的，中文资料更是十分匮乏(多是机翻，而且版本很老)，在搜索中也没有查到相关的靠谱的东西，我自己在读代码实现的过程中就随手记了一下，就当做笔记了。 UE 在 C++ 中提供了这些功能，需要在 GameMode 中开启 bUseSeamlessTravel=true, 然后使用GetSeamlessTravelActorList 来获取需要保存的 Actor 列表的。但是 ，请注意，直接使用UGameplayStatics::OpenLevel 是不行的，因为 OpenLevel 调用的是 GEngine-&gt;SetClientTravel(World,*Cmd,TravelType)，所以不会执行AGameMode::GetSeamlessTravelActorList 去获取要留存到下一关卡的 Actor。在 UE 文档的 Travelling in Multiplayer 中的 Persisting Actors across Seamless Travel 有写到只有 ServerOnly 的 GameMode 才会调用 AGameModeAGameMode::GetSeamlessTravelActorList，所以要使用UWorld::ServerTravel 来进行关卡切换。但 UE 并没有把 UWorld::ServerTravel 暴露给蓝图，所以我在测试代码中加了个暴露给蓝图的包裹函数 ACppGameMode::Z_ServerTravel,AGameMode::GetSeamlessTravelActorList 也同理，也有一个暴露给蓝图的包裹函数 ACppGameMode::GetSaveToNextLevelActors。 读了一下 UWorld::ServerTravel 的代码，其调用栈为: 1UWorld::ServerTravel -&gt; AGameModeBase::ProcessServerTravel -&gt; UWorld::SeamlessTravel -&gt; SeamlessTravelHandler::Tick 最终保留 Actor 的操作是在 FSeamlessTravelHandler::Tick 中做的，相关代码如下(前后均有省略)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596UWorld* FSeamlessTravelHandler::Tick()&#123;// ...... // mark actors we want to keep FUObjectAnnotationSparseBool KeepAnnotation; TArray&lt;AActor*&gt; KeepActors; if (AGameModeBase* AuthGameMode = CurrentWorld-&gt;GetAuthGameMode()) &#123; AuthGameMode-&gt;GetSeamlessTravelActorList(!bSwitchedToDefaultMap, KeepActors); &#125; const bool bIsClient = (CurrentWorld-&gt;GetNetMode() == NM_Client); // always keep Controllers that belong to players if (bIsClient) &#123; for (FLocalPlayerIterator It(GEngine, CurrentWorld); It; ++It) &#123; if (It-&gt;PlayerController != nullptr) &#123; KeepAnnotation.Set(It-&gt;PlayerController); &#125; &#125; &#125; else &#123; for(FConstControllerIterator Iterator = CurrentWorld-&gt;GetControllerIterator(); Iterator; ++Iterator) &#123; AController* Player = Iterator-&gt;Get(); if (Player-&gt;PlayerState || Cast&lt;APlayerController&gt;(Player) != nullptr) &#123; KeepAnnotation.Set(Player); &#125; &#125; &#125; // ask players what else we should keep for (FLocalPlayerIterator It(GEngine, CurrentWorld); It; ++It) &#123; if (It-&gt;PlayerController != nullptr) &#123; It-&gt;PlayerController-&gt;GetSeamlessTravelActorList(!bSwitchedToDefaultMap, KeepActors); &#125; &#125; // mark all valid actors specified for (AActor* KeepActor : KeepActors) &#123; if (KeepActor != nullptr) &#123; KeepAnnotation.Set(KeepActor); &#125; &#125; TArray&lt;AActor*&gt; ActuallyKeptActors; ActuallyKeptActors.Reserve(KeepAnnotation.Num()); // Rename dynamic actors in the old world&#x27;s PersistentLevel that we want to keep into the new world auto ProcessActor = [this, &amp;KeepAnnotation, &amp;ActuallyKeptActors, NetDriver](AActor* TheActor) -&gt; bool &#123; const FNetworkObjectInfo* NetworkObjectInfo = NetDriver ? NetDriver-&gt;GetNetworkObjectInfo(TheActor) : nullptr; const bool bIsInCurrentLevel = TheActor-&gt;GetLevel() == CurrentWorld-&gt;PersistentLevel; const bool bManuallyMarkedKeep = KeepAnnotation.Get(TheActor); const bool bDormant = NetworkObjectInfo &amp;&amp; NetDriver &amp;&amp; NetDriver-&gt;ServerConnection &amp;&amp; NetworkObjectInfo-&gt;DormantConnections.Contains(NetDriver-&gt;ServerConnection); const bool bKeepNonOwnedActor = TheActor-&gt;Role &lt; ROLE_Authority &amp;&amp; !bDormant &amp;&amp; !TheActor-&gt;IsNetStartupActor(); const bool bForceExcludeActor = TheActor-&gt;IsA(ALevelScriptActor::StaticClass()); // Keep if it&#x27;s in the current level AND it isn&#x27;t specifically excluded AND it was either marked as should keep OR we don&#x27;t own this actor if (bIsInCurrentLevel &amp;&amp; !bForceExcludeActor &amp;&amp; (bManuallyMarkedKeep || bKeepNonOwnedActor)) &#123; ActuallyKeptActors.Add(TheActor); return true; &#125; else &#123; if (bManuallyMarkedKeep) &#123; UE_LOG(LogWorld, Warning, TEXT(&quot;Actor &#x27;%s&#x27; was indicated to be kept but exists in level &#x27;%s&#x27;, not the persistent level. Actor will not travel.&quot;), *TheActor-&gt;GetName(), *TheActor-&gt;GetLevel()-&gt;GetOutermost()-&gt;GetName()); &#125; TheActor-&gt;RouteEndPlay(EEndPlayReason::LevelTransition); // otherwise, set to be deleted KeepAnnotation.Clear(TheActor); // close any channels for this actor if (NetDriver != nullptr) &#123; NetDriver-&gt;NotifyActorLevelUnloaded(TheActor); &#125; return false; &#125; &#125;;// ......&#125; 下面是我写的测试用的 GameMode 的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// CppGameMode.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UnrealString.h&quot;#include &quot;Engine/World.h&quot;#include &quot;Kismet/KismetSystemLibrary.h&quot;#include &quot;GameFramework/GameMode.h&quot;#include &quot;CppGameMode.generated.h&quot;UCLASS()class ACppGameMode : public AGameMode&#123; GENERATED_BODY() ACppGameMode(); void GetSeamlessTravelActorList(bool bToTransition, TArray&lt;AActor*&gt;&amp; ActorList);public: UFUNCTION(BlueprintNativeEvent, BlueprintCallable,Category=&quot;GameCore|GameMode|SeamlessTravel&quot;) void GetSaveToNextLevelActors(TArray&lt;AActor*&gt;&amp; ActorList); UFUNCTION(BlueprintNativeEvent, BlueprintCallable,Category=&quot;GameCore|GameMode|SeamlessTravel&quot;) bool Z_ServerTravel(const FString&amp; FURL, bool bAbsolute, bool bShouldSkipGameNotify);&#125;;// CppGameMode.cpp#include &quot;CppGameMode.h&quot;ACppGameMode::ACppGameMode()&#123; bUseSeamlessTravel = true;&#125;void ACppGameMode::GetSeamlessTravelActorList(bool bToTransition, TArray&lt;AActor*&gt;&amp; ActorList)&#123; GetSaveToNextLevelActors(ActorList);&#125;void ACppGameMode::GetSaveToNextLevelActors_Implementation(TArray&lt;AActor*&gt;&amp; ActorList)&#123; UKismetSystemLibrary::PrintString(this,FString(&quot;ACppGameMode::GetSaveToNextLevelActors&quot;),false,true);&#125;bool ACppGameMode::Z_ServerTravel_Implementation(const FString&amp; FURL, bool bAbsolute, bool bShouldSkipGameNotify)&#123; UWorld* WorldObj = GetWorld(); return WorldObj-&gt;ServerTravel(FURL, bAbsolute, bShouldSkipGameNotify);&#125; 然后就可以在继承自 ACppGameMode 的 Blueprint 中 Override Function 里重写 GetSaveToNextLevelActors 来在蓝图中指定哪些 Actor 可以保留到下一关卡。记得一定要在原始关卡 (切换之前的关卡) 中选择继承并实现了 GetSaveToNextLevelActors 的GameMode。 最终就可以在蓝图中使用 Z_ServerTravel 来替代 OpenLevel 来切换关卡了(上图)，从而实现在 UE 中切换关卡时传递 Actor 到目标关卡。 相关链接： Travelling in Multiplayer Keeping Actors Between Levels","tags":[{"name":"Seamless travel","slug":"Seamless-travel","permalink":"https://ue5wiki.com/tags/Seamless-travel/"}],"categories":[{"name":"Gameplay","slug":"Gameplay","permalink":"https://ue5wiki.com/categories/Gameplay/"}]},{"title":"FName/FString/FText 的区别","date":"2017-07-08T14:41:04.000Z","path":"wiki/41082/","text":"FNameFName 的字符串一般用在为资源命名或者访问资源时（比如命名的骨骼）需要使用。它使用一个轻型系统使用字符串，特定字符串会被重复使用，在数据表中也就只存储一次。 只在内存中存储一次 不区分大小写 不能被修改 查找和访问速度比较快 内部有一个 HASH 值 FName 在 Edior 中占 12 个字节，打包 8 字节，FName 的XXXX_12 这样的字符串会被分成 string part 和 number part，估计是为了想不为每个拼接的结果都在 NamePool 中创建一份吧。 FStringFSting 比较类似于标准库的std::string，区分大小写，可修改，每份实例都是单独的内存。 FTextFText 是用于本地化的类，所有需要展示的文本都需要使用 FText，它提供了以下功能： 创建本地化文本 格式化文本 从数字生成文本 从日期或时间生成文本 转换文本（大小写转换等） 文档 String Handling Text Localization UE4 FName 原理分析 UE4 底层剖析之命名系统","tags":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"String","slug":"String","permalink":"https://ue5wiki.com/tags/String/"}],"categories":[{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"}]},{"title":"在 UE 中使用 Git 进行版本控制","date":"2016-10-07T23:31:01.000Z","path":"wiki/7647/","text":"Unreal Editor 中提供的 Source Control 可以通过 Git 实现蓝图项目的 版本提交 / 版本比对 / 撤销修改 等一些基本功能，远远比不上 Git Bash 强大，但是 BluePrint 间的 Diff 还是很好用的。 在执行 UE 中的 Git 版本控制之前最好先在 Git Bash 中进行一些 Git 全局的初始化操作。 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 生成 SSH Key(邮件地址换成你自己的邮件地址): 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后一路 Enter(或者你自己设置密码)，执行完毕后会在 C:\\Users\\$&#123;userName&#125;\\(linux 则是在~/ 下) 下创建一个 .ssh 目录，其中有 id_rsa 和id_rsa.pub两个文件。 id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人(保存到 Github/GitLab 的 SSH Key 中)。 更多的 Git Bash 下的一些操作可以看这篇文章——Git 快速上手指南。 打开 UE 项目，在虚幻编辑器中点击Source Control 选中connect to Source Contorl 在弹出的窗口中 Provider 选项中选择 Git 并在 Git Path 中填入系统中 git.exe 的绝对路径。选中 Add a .gitignore file，然后点击initialize project with Git，最后点击Accept Settings 完成初始化。 现在，可以看到 Source Control 上出现了绿色的圆圈上有上下两个箭头。 这时我们需要 commit 的一次我们的工程 (同时也是对所有的文件改动进行提交。在这里因为是初始化，所以需要提交一次所有的文件)。点击Source Control 选中Submit to Source Control。 在弹出的窗口中填入提交信息 (等同于 git 中的add 与commit)，然后点 OK。 Source Control初始化完成，现在我们可以测试一下。 新建一个蓝图类 EmptyActor，只是测试我们写入一个节点。 然后在 Content Browser 中右键点击该蓝图类，Source Control-&gt;Check In对该蓝图类做一次 初始化提交。 在弹出的窗口中填入相关的信息(commit)，然后点 OK。 现在我们可以再次编辑 EmptyActor 这个蓝图类，但是我们不提交(don’t check in)。 可以通过 diff 来检测我们此次相较于上次提交的版本做了哪些修改：在该蓝图类上右键 Source Control-&gt;Diff Against Depot，会弹出diff 窗口。我们可以看到我们在该蓝图类中修改了哪些东西。 在蓝图类上右键 -&gt;Source Control下共有以下几个选项：Check In/Refresh/History/Diff Against Depot/Revert，其中 Check In 和Diff Against Depot的用途上面已经说过了。 Check In提交当前文件。 Refresh刷新当前文件 (蓝图类) 状态(status)。 History查看提交 (Check In) 的历史，也可以提供当前未提交改动与某一提交版本的区别。 Diff Against Depot查看当前未提交 (Check In) 改动与上次提交版本的区别。 Revert丢弃当前未提交 (Check In) 改动 (就是回滚到上一次 Check In 时的状态)。注意：Revert 之后需要重启引擎才会生效，这应该是 UE(4.12.5) 的一个 BUG。Revert的效果等同于直接在 Git Bash 下执行git checkout -- $&#123;filename&#125;。 UE 中集成的 Source Control::Git 是不能够直接在虚幻编辑器中直接回滚到某一提交版本的，总的来说可供操作的功能还比较少 (蓝图的节点比对还是很爽的)，但是可以结合Git Bash 来使用 Git 的其他操作(版本回退 / 分支管理 / 远程推送等等)。 需要注意的是，使用 Git Bash 来进行版本回退的话一定要关闭虚幻编辑器，因为回退需要对文件进行改动，而虚幻编辑器正在占用 (打开) 该文件 (蓝图类)，而对未占用(打开) 的文件 (蓝图类) 进行版本回退也需要重启虚幻编辑器才可以(不重启不会看到回退效果)。 使用 Git 来推送 (push) 和拉取 (pull) 远程分支的话需要在 Git Bash 中执行。同样也需要关闭虚幻编辑器。注意编辑 .gitignore 来忽略不必要的文件来节省 push/pull 时间。","tags":[{"name":"Git","slug":"Git","permalink":"https://ue5wiki.com/tags/Git/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://ue5wiki.com/tags/Source-Control/"},{"name":"版本控制","slug":"版本控制","permalink":"https://ue5wiki.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"categories":[{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"},{"name":"VersionControl","slug":"Editor/VersionControl","permalink":"https://ue5wiki.com/categories/Editor/VersionControl/"}]},{"title":"使用 Unreal Engine 4 采集 360°全景视频","date":"2016-09-05T19:44:11.000Z","path":"wiki/64044/","text":"本文部分内容摘自 Unreal Engine 的官方博客文章：从虚幻 4 中采集 360 度立体电影，其余部分为修正该文章错误和提供一个现成可行的解决方案。 采集单帧双眼图像 首先，我们需要确保启用了相应的插件。 在编辑器打开的情况下，转到 编辑（Edit）-&gt; 插件（Plugins），然后选择左边的 电影采集（Movie Capture）设置，确保对 立体全景电影采集（Stereo Panoramic Movie Capture）选择 启用（Enabled）。然后重新启动场景编辑器。 注：您可能还需要再次快速 构建 (Build)，具体取决于您是否在分支中获得了本地更改，因为工具附带的插件 dll 可能已经 陈旧。 当编辑器重新启动后，再次转到 编辑器（Editor）-&gt; 插件（Plugins）-&gt; 电影采集（Movie Capture），并再次检查其是否已启用。 打开关卡蓝图 (level Blueprint)，新建Event BeginPlay 事件，然后再新建数个 (具体依据需求而定)Execute Console Command 节点来存放我们需要执行的命令。我们可以先来一次采集测试，将下面这两条命令放入 Execute Console Command 节点中： 123SP.OutputDir F:/StereoCaptureFrames// 采集单帧SP.PanoramicScreenshot 如图： 然后就可以 启动 (Play) 项目了，此时系统可能会长时间无响应（估计有一分钟左右），然后将会有两帧影像存储到您在先前用 SP.OutputDir 指定的目录中（其实是在该目录中的一个日期与时间目录下），一个是左眼图像，另一个是右眼图像。 将左右眼图像自动组合成单一图像 这部分是我依据上面提到的官方文章修改的，也是上述文章中错误最多的部分。在执行下列步骤之前首先需要保证你使用官方插件采集全景时可以成功导出左右眼图像。 首先先将引擎中的全景采集插件 (Stereo Panoramic Movie Capture) 目录剪切 (注意是 cut 而不是 copy) 出来，一是供我们修改，二是防止和我们自己编译的有冲突。Unreal 引擎中的插件在路径 \\4.12\\Engine\\Plugins 下，在这里我们需要将其中的 StereoPanorama(\\Engine\\Plugins\\Experimental\\StereoPanorama) 剪切出来。 然后打开你要采集全景视频的项目文件夹，在项目文件夹的根目录下新建一个 Plugins 文件夹，将上一步剪切的 StereoPanorama 文件夹粘贴到这里。此时该项目的文件结构应该是这样的(碍于篇幅只列出必要文件): 后面我会着重讲到修改 SceneCapturer.cpp 中的代码来实现我们想要的功能。 现在，打开你想要采集全景视频的项目。在场景编辑器中依次打开 Edit-&gt;Plugins-&gt;Project-&gt;MovieCapture 启用 Stereo Panoramic Movie Capture 然后重启场景编辑器。再次检查 Stereo Panoramic Movie Capture 是否被启用。如果上面都 OK，那么下面就开始正式开搞。 首先，打开 \\YouProjectFolder\\Plugins\\StereoPanorama\\Source\\StereoPanorama\\Private\\SceneCapturer.cpp，大概八九百行代码的样子，而且我用 diff 对比了一下引擎版本 4.11 和 4.12 两个引擎版本的 SceneCapturer.cpp 区别，其实没有实质性的改变，就是修改了一些不合规范 (随意) 的变量命名，所以这份教程在 4.11 和 4.12 中都是通用的。 为了使我们能够方便地控制合成的开关，我们需要定义一个 bool 常量在文件的头部，这样，在我们不需要开启合并的时候修改该常量的值即可，不必再修改其余的代码。 12// Newly inserted code.Defined a const boolconst bool CombineAtlasesOnOutput = true; 现在我们需要在代码中有条件地禁用每只眼睛的输出 (通过上面定义的CombineAtlasesOnOutput 来控制)。然后找到 USceneCapturer::SaveAtlas() 的底部，找到这样一段代码： 1234IImageWrapperPtr ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::PNG);ImageWrapper-&gt;SetRaw(SphericalAtlas.GetData(), SphericalAtlas.GetAllocatedSize(), SphericalAtlasWidth, SphericalAtlasHeight, ERGBFormat::BGRA, 8);const TArray&lt;uint8&gt;&amp; PNGData = ImageWrapper-&gt;GetCompressed(100);FFileHelper::SaveArrayToFile(PNGData, *AtlasName); 这几行代码就是控制左右眼输出的，如果我们定义的 CombineAtlasesOnOutput 为true，就意味这我们需要合并两张眼睛的图像，那么我们就需要禁掉它 (左右单独输出)，如果为false 则我们需要输出左右眼的单独序列帧，所以就需要执行它。综上，可以写一个 if 语句来判断 CombineAtlasesOnOutput 的值： 1234567IImageWrapperPtr ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::PNG);if (!CombineAtlasesOnOutput)&#123; ImageWrapper-&gt;SetRaw(SphericalAtlas.GetData(), SphericalAtlas.GetAllocatedSize(), SphericalAtlasWidth, SphericalAtlasHeight, ERGBFormat::BGRA, 8); const TArray&lt;uint8&gt;&amp; PNGData = ImageWrapper-&gt;GetCompressed(100); FFileHelper::SaveArrayToFile(PNGData, *AtlasName);&#125; 这样会导致一个错误，因为 PNGData 是在 if 的作用域内定义的，如果执行到了 if 后 (被释放掉) 或者根本没有执行到 (if 判断为 false(!true)) 就会导致后面对 PNGData 的使用造成错误。在上面 if 语句之后的代码块中对 PNGData 的使用处为: 12345678910if (FStereoPanoramaManager::GenerateDebugImages-&gt;GetInt() != 0)&#123; FString FrameStringUnprojected = FString::Printf(TEXT(&quot;%s_%05d_Unprojected.webp&quot;), *Folder, CurrentFrameCount); FString AtlasNameUnprojected = OutputDir / Timestamp / FrameStringUnprojected; ImageWrapper-&gt;SetRaw(SurfaceData.GetData(), SurfaceData.GetAllocatedSize(), UnprojectedAtlasWidth, UnprojectedAtlasHeight, ERGBFormat::BGRA, 8); const TArray&lt;uint8&gt;&amp; PNGDataUnprojected = ImageWrapper-&gt;GetCompressed(100); // 原来的代码为 FFileHelper::SaveArrayToFile(PNGData, *AtlasNameUnprojected); FFileHelper::SaveArrayToFile(PNGDataUnprojected, *AtlasNameUnprojected);&#125; diff: 对禁用左右眼单帧输出部分，如果只写这部分代码，现在再执行采集是不会有任何有意义图像输出的(因为现在已经把左右眼输出禁用了)。下面继续搞将两张合并到一块的方法。 官方博文中给出了这部分代码，但是不知道是什么原因，模板类 (TArray&lt;T&gt;) 的所有参数都不见了，这样直接粘贴到代码里是无论如何也编译不过的。官方提供的代码： 12345678910111213141516171819202122232425TArraySphericalLeftEyeAtlas = SaveAtlas(TEXT(&quot;Left&quot; ), UnprojectedLeftEyeAtlas );TArraySphericalRightEyeAtlas = SaveAtlas(TEXT(&quot;Right&quot;), UnprojectedRightEyeAtlas);//*NEW* - Beginif (CombineAtlasesOnOutput)&#123; TArrayCombinedAtlas; CombinedAtlas.Append(SphericalLeftEyeAtlas); CombinedAtlas.Append(SphericalRightEyeAtlas); IImageWrapperPtr ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::JPEG); ImageWrapper-&gt;SetRaw(CombinedAtlas.GetData(), CombinedAtlas.GetAllocatedSize(), SphericalAtlasWidth, SphericalAtlasHeight * 2, ERGBFormat::BGRA, 8); const TArray&amp; PNGData = ImageWrapper-&gt;GetCompressed(100); // Generate name FString FrameString = FString::Printf(TEXT(&quot;Frame_%05d.webp&quot;), CurrentFrameCount); FString AtlasName = OutputDir / Timestamp / FrameString; FFileHelper::SaveArrayToFile(PNGData, *AtlasName); ImageWrapper.Reset();&#125;//*NEW* - END// Dump out how long the process tookFDateTime EndTime = FDateTime::UtcNow();FTimespan Duration = EndTime - StartTime;UE_LOG(LogStereoPanorama, Log, TEXT(&quot;Duration:%g seconds for frame %d&quot; ), Duration.GetTotalSeconds(), CurrentFrameCount);StartTime = EndTime; 真是满腹槽点，因为之前没读过 Unreal 引擎的代码，我还以为是我自己搞错了，后来读了相关的代码 (自己对了一下上面代码的语法) 才发现是官方代码写错了… 上面所有的 TArray 的模板参数都没有了，正确的用法是 TArray&lt;T&gt;，模板类的类型推导是在编译时计算的，而现在的问题是怎么通过现有的代码逆推回去TArray 该有的模板参数。没办法(其实有，看后面)，来一点一点分析下吧。 首先，我们可以通过以下两行代码可以确定 SphericalLeftEyeAtlas 和SphericalRightEyeAtlas是同一种类型(废话) 12TArraySphericalLeftEyeAtlas = SaveAtlas(TEXT(&quot;Left&quot; ), UnprojectedLeftEyeAtlas );TArraySphericalRightEyeAtlas = SaveAtlas(TEXT(&quot;Right&quot;), UnprojectedRightEyeAtlas); 现在我们可以通过查看引擎中已有的代码 (SaveAtlas() 的定义)来获取 SphericalLeftEyeAtlas 和SphericalRightEyeAtlas应该是什么类型，就是看下调用 SaveAtlas() 的返回类型是什么。 引擎中定义的 SaveAtlas() 返回类型为TArray&lt;FColor&gt; 1TArray&lt;FColor&gt; USceneCapturer::SaveAtlas(FString Folder, const TArray&lt;FColor&gt;&amp; SurfaceData) OK 现在可以确定 SphericalLeftEyeAtlas 和SphericalRightEyeAtlas都是 TArray&lt;FColor&gt; 了。 而后面 CombinedAtlas 的类型可以通过 SphericalLeftEyeAtlas 和SphericalRightEyeAtlas推导出来： 123TArrayCombinedAtlas;CombinedAtlas.Append(SphericalLeftEyeAtlas);CombinedAtlas.Append(SphericalRightEyeAtlas); 成员函数 append() 从其函数名可以看出来其是在用容器 TArray 定义的一个实例中添加一个元素，所以我们可以确定 CombinedAtlas 的类型和 SphericalLeftEyeAtlas 和SphericalRightEyeAtlas一样，即TArray&lt;FColor&gt;。 剩余的代码中用到 TArray&lt;T&gt; 的就只有 PNGData 了: 12const TArray&amp; PNGData = ImageWrapper-&gt;GetCompressed(100); 方法同上，我们查看一下 GetCompressed() 的定义就可以得到 PNGData 真正的类型。 GetCompressed()是 FImageWrapperBase 类中的成员： 1const TArray&lt;uint8&gt;&amp; FImageWrapperBase::GetCompressed(int32 Quality) 即得到 PNGData 真正的类型为TArray&lt;uint8&gt;&amp; 修改完的代码如下： 1234567891011121314151617181920TArray&lt;FColor&gt; SphericalLeftEyeAtlas = SaveAtlas(TEXT(&quot;Left&quot; ), UnprojectedLeftEyeAtlas );TArray&lt;FColor&gt; SphericalRightEyeAtlas = SaveAtlas(TEXT(&quot;Right&quot;), UnprojectedRightEyeAtlas);//*NEW* - Beginif (CombineAtlasesOnOutput)&#123; TArray&lt;FColor&gt; CombinedAtlas; CombinedAtlas.Append(SphericalLeftEyeAtlas); CombinedAtlas.Append(SphericalRightEyeAtlas); IImageWrapperPtr ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::JPEG); ImageWrapper-&gt;SetRaw(CombinedAtlas.GetData(), CombinedAtlas.GetAllocatedSize(), SphericalAtlasWidth, SphericalAtlasHeight * 2, ERGBFormat::BGRA, 8); const TArray&lt;uint8&gt;&amp; PNGData = ImageWrapper-&gt;GetCompressed(100); // Generate name FString FrameString = FString::Printf(TEXT(&quot;Frame_%05d.webp&quot;), CurrentFrameCount); FString AtlasName = OutputDir / Timestamp / FrameString; FFileHelper::SaveArrayToFile(PNGData, *AtlasName); ImageWrapper.Reset();&#125;//*NEW* - END 我修改好的 SceneCapturer.cpp 可以 点此下载。 此时再编译这个插件然后再启动项目就会采集并将左右眼合并成一张图片了。 其实修复上面的代码还有一个更简单的方法：在 C++11 中，其实可以不用上面写得这么麻烦去翻定义来查返回类型是什么，在定义新对象来接收调用返回的对象的时候都可以用 auto 关键字来定义，这样编译器就会自动给我们推导出所要接收的对象真正的类型。 如，上面的代码可以写为: 123456789101112131415161718192021auto SphericalLeftEyeAtlas = SaveAtlas(TEXT(&quot;Left&quot; ), UnprojectedLeftEyeAtlas );auto SphericalRightEyeAtlas = SaveAtlas(TEXT(&quot;Right&quot;), UnprojectedRightEyeAtlas);//*NEW* - Beginif (CombineAtlasesOnOutput)&#123; // 此处不可以用 auto，auto 定义的变量必须有初始值，因为若没有编译器无法推导其类型 TArray&lt;FColor&gt; CombinedAtlas; CombinedAtlas.Append(SphericalLeftEyeAtlas); CombinedAtlas.Append(SphericalRightEyeAtlas); IImageWrapperPtr ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::JPEG); ImageWrapper-&gt;SetRaw(CombinedAtlas.GetData(), CombinedAtlas.GetAllocatedSize(), SphericalAtlasWidth, SphericalAtlasHeight * 2, ERGBFormat::BGRA, 8); auto PNGData = ImageWrapper-&gt;GetCompressed(100); // Generate name FString FrameString = FString::Printf(TEXT(&quot;Frame_%05d.webp&quot;), CurrentFrameCount); FString AtlasName = OutputDir / Timestamp / FrameString; FFileHelper::SaveArrayToFile(PNGData, *AtlasName); ImageWrapper.Reset();&#125;//*NEW* - END 是不是方便了很多！但是这样写以后如果要重构的话…那画面太美。俗话说的好，动态类型一时爽，代码重构火葬场。虽然具有了 auto 的 C++ 仍然是静态类型语言，但是在编译期的类型推导足够让程序猿们造成依赖 (主要是懒) 了。 C++11 中有很多很多好用的新特性，而且我翻看 UnrealEngine 的代码也发现其中大规模运用了 C++11 的特性，所以还是要好好补充一下 C++11 特性的知识比较好。 更多 C++11 的内容可以看我这篇博文：C++11 的语法糖 采集连续的序列帧 通过上面的几个步骤我们可以顺利地采集出合并左右眼睛的单帧，但是我们终究还是需要采集连续帧然后来合并这些序列帧生成视频的。 我们可以通过这个命令来采集连续的序列帧： 1234// 采集多个连续帧数 (一段视频) 可以用 SP.PanoramicMovie，其后应该有两个参数 startime 和 endtime// startime 和 endtime 皆为帧数// 假如我要采集 1s 的视频，且已经在工程中设置其 fps 为 30，我们就可以采集从第 0 帧到第 29 帧的图像(1s)SP.PanoramicMovie 0 29 但是直接这样做会有问题，假如你项目中设置 FPS 为 30，(单独)直接加这一条命令 (SP.PanoramicMovie 0 29) 会导致你采集的帧数 30 帧并不是实际项目 1s 的帧数，如果这样采集出来合成视频的话，大概等同于快进了 4-5 倍，所以说直接这样会导致采集掉帧。其实就是因为采集视频的时候引擎不是按固定步长时间运行的。 在采集电影时，首先 一定要记住 的最重要的事情是：要按固定的时间步长运行。 假如我们需要采集一秒 30 帧的图像，我们必须要告诉引擎必须按固定的时间步长使时间流逝，除非你希望 2 秒钟的视频只有两个输出帧。 你需要依次做以下几步： 在 场景编辑器 (UE4Editor)-&gt; 编辑 (Edit)-&gt; 项目设置 (Projects settings)-&gt; 引擎 (Engine)-&gt; 一般设置 (General Settings)-&gt;Framerate 中勾选上 Fixed Frame Rate 并设置为30(依据你想要采集的 FPS) 在启动引擎时添加参数。我们可以在引擎启动时添加 -usefixedtimestep -fps= 来让引擎以固定的步长时间流逝。可以在 UE4Editor 快捷方式中添加该指令: 1X:\\Unreal\\4.12\\Engine\\Binaries\\Win64\\UE4Editor.exe -usefixedtimestep -fps=30 -notexturestreaming -notexturestreaming参数的作用是关闭 纹理流。 执行上面两步之后再使用 SP.PanoramicMovie 来采集就不会出现丢帧的效果了。 合并采集的图像序列为全景视频 通过上面几个步骤以及再参照官方文档的部分教程，我们可以顺利地得到一些序列帧。 如何将这些序列帧合并为可以播放的全景视频是当前的任务，官方那篇博文推荐的是 ffmpeg(we tend to just use ffmpeg.) 你可以自己去 ffmpeg 官网 下载，或者 在此下载 我离线的版本。 使用方法就是，将上一步下载下来的 ffmpeg.exe 放在导出全景图的目录, 然后打开 CMD 跳转到该目录后执行以下命令: 1ffmpeg -y -r 30 -i Frame_%05d.webp -vcodec mpeg4 -qscale 0.01 video.mp4 -r是帧率 (FPS)，更多的参数可以看 ffmpeg 的文档——ffmpeg Documentation 执行完毕就会在当前目录下生成一个 video.mp4 文件。 或者要是实在不想动手也可以用下面的批处理命令(注意: 不要把 ffmpeg 和该批处理放在和图片的同级的目录) 1234@echo offset /p fps=Please input FPS(1-60):set /p quality=Please input video quality(0.01-255).The smaller number more clarity:ffmpeg -y -r %fps% -i ../Frame_%%05d.webp -vcodec mpeg4 -qscale %quality% ../video.mp4 你的目录结构应该是下面这样的，才可以执行ConvertImagesToVideo.bat 含有 ConvertImagesToVideo.bat 的 ffmpeg 压缩包可以 点此下载。 资源整理 如果不想动手改代码且懒得编译的话可以 点此下载 我修改并编译好的版本，使用方法类似上面。将官方的插件文件夹中的 StereoPanorama 删掉 (或者自己留存) 之后，将前面下载的插件压缩包解压到你需要采集的项目的根目录(或者直接替换掉官方的插件)。 此时该项目的文件结构应该是这样的(碍于篇幅只列出必要文件): 然后启动项目，在场景编辑器里启用 (并添加好采集节点) 就可以开始采集全景序列帧了。 另附其他工具： 修改并编译好的StereoPanorama 修改好的SceneCapturer.cpp ffmpeg(There is no bat) ffmpeg and bat 参考文章 从虚幻 4 中采集 360 度立体电影 ffmpeg Documentation C++11 的语法糖 结语 其实写了这么多，总共精要的部分是没有多少的，主要是记录了一下 debug 的方式…另外，还是要多读引擎的代码以及不盲目的相信官方才行。","tags":[{"name":"VR","slug":"VR","permalink":"https://ue5wiki.com/tags/VR/"},{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"}],"categories":[{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"工具/资源管理","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/categories/BuildSystem/"},{"name":"开源项目","slug":"开源项目","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/categories/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"},{"name":"反射","slug":"工具/资源管理/反射","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%8F%8D%E5%B0%84/"},{"name":"UI","slug":"工具/UI","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UI/"},{"name":"DevOps","slug":"工具/DevOps","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/DevOps/"},{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/categories/Plugins/"},{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/categories/Optimization/"},{"name":"Memory","slug":"Optimization/Memory","permalink":"https://ue5wiki.com/categories/Optimization/Memory/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/categories/Rendering/"},{"name":"Landscape","slug":"Rendering/Landscape","permalink":"https://ue5wiki.com/categories/Rendering/Landscape/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"热更新/Pak","permalink":"https://ue5wiki.com/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/Pak/"},{"name":"资源审计","slug":"工具/资源审计","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"},{"name":"Logging","slug":"Logging","permalink":"https://ue5wiki.com/categories/Logging/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/categories/Debugging/"},{"name":"Android","slug":"Debugging/Android","permalink":"https://ue5wiki.com/categories/Debugging/Android/"},{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/categories/Animation/"},{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"物理系统/Chaos","permalink":"https://ue5wiki.com/categories/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/Chaos/"},{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/categories/Editor/"},{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/categories/Programming/"},{"name":"C++","slug":"Programming/C","permalink":"https://ue5wiki.com/categories/Programming/C/"},{"name":"UnrealPak","slug":"工具/UnrealPak","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UnrealPak/"},{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/categories/UE5/"},{"name":"Game Feature","slug":"UE5/Game-Feature","permalink":"https://ue5wiki.com/categories/UE5/Game-Feature/"},{"name":"UELauncher","slug":"工具/UELauncher","permalink":"https://ue5wiki.com/categories/%E5%B7%A5%E5%85%B7/UELauncher/"},{"name":"Slate","slug":"Editor/Slate","permalink":"https://ue5wiki.com/categories/Editor/Slate/"},{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/categories/Engine/"},{"name":"Material","slug":"Rendering/Material","permalink":"https://ue5wiki.com/categories/Rendering/Material/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/categories/Profiling/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/categories/Mobile/"},{"name":"IOS","slug":"Mobile/IOS","permalink":"https://ue5wiki.com/categories/Mobile/IOS/"},{"name":"Lightmass","slug":"Lightmass","permalink":"https://ue5wiki.com/categories/Lightmass/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/categories/ThirdParty/"},{"name":"UnityBuild","slug":"BuildSystem/UnityBuild","permalink":"https://ue5wiki.com/categories/BuildSystem/UnityBuild/"},{"name":"Bug","slug":"Engine/Bug","permalink":"https://ue5wiki.com/categories/Engine/Bug/"},{"name":"Lighting","slug":"Rendering/Lighting","permalink":"https://ue5wiki.com/categories/Rendering/Lighting/"},{"name":"4.25","slug":"Engine/Bug/4-25","permalink":"https://ue5wiki.com/categories/Engine/Bug/4-25/"},{"name":"Optimization","slug":"BuildSystem/Optimization","permalink":"https://ue5wiki.com/categories/BuildSystem/Optimization/"},{"name":"Android","slug":"Mobile/Android","permalink":"https://ue5wiki.com/categories/Mobile/Android/"},{"name":"DDC","slug":"Engine/DDC","permalink":"https://ue5wiki.com/categories/Engine/DDC/"},{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/categories/%E5%8F%8D%E5%B0%84/"},{"name":"Tricks","slug":"Programming/Tricks","permalink":"https://ue5wiki.com/categories/Programming/Tricks/"},{"name":"Lua","slug":"Programming/Lua","permalink":"https://ue5wiki.com/categories/Programming/Lua/"},{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/categories/NavMesh/"},{"name":"UBT","slug":"BuildSystem/UBT","permalink":"https://ue5wiki.com/categories/BuildSystem/UBT/"},{"name":"Blueprint","slug":"Programming/Blueprint","permalink":"https://ue5wiki.com/categories/Programming/Blueprint/"},{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/categories/Network/"},{"name":"DS","slug":"Network/DS","permalink":"https://ue5wiki.com/categories/Network/DS/"},{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"VirtualTexture","slug":"Rendering/VirtualTexture","permalink":"https://ue5wiki.com/categories/Rendering/VirtualTexture/"},{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/categories/Tip/"},{"name":"蓝图","slug":"Tip/蓝图","permalink":"https://ue5wiki.com/categories/Tip/%E8%93%9D%E5%9B%BE/"},{"name":"特效粒子","slug":"特效粒子","permalink":"https://ue5wiki.com/categories/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/"},{"name":"Niagara","slug":"特效粒子/Niagara","permalink":"https://ue5wiki.com/categories/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/Niagara/"},{"name":"大世界","slug":"Optimization/大世界","permalink":"https://ue5wiki.com/categories/Optimization/%E5%A4%A7%E4%B8%96%E7%95%8C/"},{"name":"UPL","slug":"Mobile/UPL","permalink":"https://ue5wiki.com/categories/Mobile/UPL/"},{"name":"BuildGraph","slug":"BuildSystem/BuildGraph","permalink":"https://ue5wiki.com/categories/BuildSystem/BuildGraph/"},{"name":"Gameplay","slug":"Gameplay","permalink":"https://ue5wiki.com/categories/Gameplay/"},{"name":"Android","slug":"开发环境/Android","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Android/"},{"name":"Mac","slug":"开发环境/Mac","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Mac/"},{"name":"Windows","slug":"开发环境/Windows","permalink":"https://ue5wiki.com/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Windows/"},{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/categories/VirtualReality/"},{"name":"RDG","slug":"Rendering/RDG","permalink":"https://ue5wiki.com/categories/Rendering/RDG/"},{"name":"PixelStreaming","slug":"PixelStreaming","permalink":"https://ue5wiki.com/categories/PixelStreaming/"},{"name":"VersionControl","slug":"Editor/VersionControl","permalink":"https://ue5wiki.com/categories/Editor/VersionControl/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://ue5wiki.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"资源管理","slug":"资源管理","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"HotPatcher","slug":"HotPatcher","permalink":"https://ue5wiki.com/tags/HotPatcher/"},{"name":"BuildSystem","slug":"BuildSystem","permalink":"https://ue5wiki.com/tags/BuildSystem/"},{"name":"target.cs","slug":"target-cs","permalink":"https://ue5wiki.com/tags/target-cs/"},{"name":"开源","slug":"开源","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E6%BA%90/"},{"name":"虚幻周报","slug":"虚幻周报","permalink":"https://ue5wiki.com/tags/%E8%99%9A%E5%B9%BB%E5%91%A8%E6%8A%A5/"},{"name":"Editor","slug":"Editor","permalink":"https://ue5wiki.com/tags/Editor/"},{"name":"构建系统","slug":"构建系统","permalink":"https://ue5wiki.com/tags/%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DevOps","slug":"DevOps","permalink":"https://ue5wiki.com/tags/DevOps/"},{"name":"Plugins","slug":"Plugins","permalink":"https://ue5wiki.com/tags/Plugins/"},{"name":"插件","slug":"插件","permalink":"https://ue5wiki.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"资源审计","slug":"资源审计","permalink":"https://ue5wiki.com/tags/%E8%B5%84%E6%BA%90%E5%AE%A1%E8%AE%A1/"},{"name":"Optimization","slug":"Optimization","permalink":"https://ue5wiki.com/tags/Optimization/"},{"name":"优化","slug":"优化","permalink":"https://ue5wiki.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"Memory","slug":"Memory","permalink":"https://ue5wiki.com/tags/Memory/"},{"name":"内存","slug":"内存","permalink":"https://ue5wiki.com/tags/%E5%86%85%E5%AD%98/"},{"name":"Rendering","slug":"Rendering","permalink":"https://ue5wiki.com/tags/Rendering/"},{"name":"Landscape","slug":"Landscape","permalink":"https://ue5wiki.com/tags/Landscape/"},{"name":"热更新","slug":"热更新","permalink":"https://ue5wiki.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Pak","slug":"Pak","permalink":"https://ue5wiki.com/tags/Pak/"},{"name":"ASTC","slug":"ASTC","permalink":"https://ue5wiki.com/tags/ASTC/"},{"name":"Logging","slug":"Logging","permalink":"https://ue5wiki.com/tags/Logging/"},{"name":"Log Timestamp","slug":"Log-Timestamp","permalink":"https://ue5wiki.com/tags/Log-Timestamp/"},{"name":"PCH","slug":"PCH","permalink":"https://ue5wiki.com/tags/PCH/"},{"name":"压缩算法","slug":"压缩算法","permalink":"https://ue5wiki.com/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"打包","slug":"打包","permalink":"https://ue5wiki.com/tags/%E6%89%93%E5%8C%85/"},{"name":"包体优化","slug":"包体优化","permalink":"https://ue5wiki.com/tags/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"},{"name":"Shader","slug":"Shader","permalink":"https://ue5wiki.com/tags/Shader/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ue5wiki.com/tags/Debugging/"},{"name":"Android","slug":"Android","permalink":"https://ue5wiki.com/tags/Android/"},{"name":"Mobile","slug":"Mobile","permalink":"https://ue5wiki.com/tags/Mobile/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://ue5wiki.com/tags/Visual-Studio/"},{"name":"VS","slug":"VS","permalink":"https://ue5wiki.com/tags/VS/"},{"name":"调试","slug":"调试","permalink":"https://ue5wiki.com/tags/%E8%B0%83%E8%AF%95/"},{"name":"Animation","slug":"Animation","permalink":"https://ue5wiki.com/tags/Animation/"},{"name":"MorphTarget","slug":"MorphTarget","permalink":"https://ue5wiki.com/tags/MorphTarget/"},{"name":"物理系统","slug":"物理系统","permalink":"https://ue5wiki.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Chaos","slug":"Chaos","permalink":"https://ue5wiki.com/tags/Chaos/"},{"name":"蓝图","slug":"蓝图","permalink":"https://ue5wiki.com/tags/%E8%93%9D%E5%9B%BE/"},{"name":"C++","slug":"C","permalink":"https://ue5wiki.com/tags/C/"},{"name":"Programming","slug":"Programming","permalink":"https://ue5wiki.com/tags/Programming/"},{"name":"UnrealPak","slug":"UnrealPak","permalink":"https://ue5wiki.com/tags/UnrealPak/"},{"name":"加密","slug":"加密","permalink":"https://ue5wiki.com/tags/%E5%8A%A0%E5%AF%86/"},{"name":"UE5","slug":"UE5","permalink":"https://ue5wiki.com/tags/UE5/"},{"name":"Modular Gameplay","slug":"Modular-Gameplay","permalink":"https://ue5wiki.com/tags/Modular-Gameplay/"},{"name":"Game Feature","slug":"Game-Feature","permalink":"https://ue5wiki.com/tags/Game-Feature/"},{"name":"Launcher","slug":"Launcher","permalink":"https://ue5wiki.com/tags/Launcher/"},{"name":"UELauncher","slug":"UELauncher","permalink":"https://ue5wiki.com/tags/UELauncher/"},{"name":"Slate","slug":"Slate","permalink":"https://ue5wiki.com/tags/Slate/"},{"name":"Details","slug":"Details","permalink":"https://ue5wiki.com/tags/Details/"},{"name":"ResScannerUE","slug":"ResScannerUE","permalink":"https://ue5wiki.com/tags/ResScannerUE/"},{"name":"Delegate","slug":"Delegate","permalink":"https://ue5wiki.com/tags/Delegate/"},{"name":"源码解析","slug":"源码解析","permalink":"https://ue5wiki.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Material","slug":"Material","permalink":"https://ue5wiki.com/tags/Material/"},{"name":"Engine","slug":"Engine","permalink":"https://ue5wiki.com/tags/Engine/"},{"name":"UEAsLib","slug":"UEAsLib","permalink":"https://ue5wiki.com/tags/UEAsLib/"},{"name":"Profiling","slug":"Profiling","permalink":"https://ue5wiki.com/tags/Profiling/"},{"name":"Subsystem","slug":"Subsystem","permalink":"https://ue5wiki.com/tags/Subsystem/"},{"name":"Asset Tools","slug":"Asset-Tools","permalink":"https://ue5wiki.com/tags/Asset-Tools/"},{"name":"TargetRules","slug":"TargetRules","permalink":"https://ue5wiki.com/tags/TargetRules/"},{"name":"IOS","slug":"IOS","permalink":"https://ue5wiki.com/tags/IOS/"},{"name":"Metal","slug":"Metal","permalink":"https://ue5wiki.com/tags/Metal/"},{"name":"Lightmass","slug":"Lightmass","permalink":"https://ue5wiki.com/tags/Lightmass/"},{"name":"Swarm Agent","slug":"Swarm-Agent","permalink":"https://ue5wiki.com/tags/Swarm-Agent/"},{"name":"AssetRegistry","slug":"AssetRegistry","permalink":"https://ue5wiki.com/tags/AssetRegistry/"},{"name":"ZSTD","slug":"ZSTD","permalink":"https://ue5wiki.com/tags/ZSTD/"},{"name":"ModularFeature","slug":"ModularFeature","permalink":"https://ue5wiki.com/tags/ModularFeature/"},{"name":"UnityBuild","slug":"UnityBuild","permalink":"https://ue5wiki.com/tags/UnityBuild/"},{"name":"Bug","slug":"Bug","permalink":"https://ue5wiki.com/tags/Bug/"},{"name":"Lighting","slug":"Lighting","permalink":"https://ue5wiki.com/tags/Lighting/"},{"name":"Texture","slug":"Texture","permalink":"https://ue5wiki.com/tags/Texture/"},{"name":"Manifest","slug":"Manifest","permalink":"https://ue5wiki.com/tags/Manifest/"},{"name":"ShaderPatcher","slug":"ShaderPatcher","permalink":"https://ue5wiki.com/tags/ShaderPatcher/"},{"name":"ES3","slug":"ES3","permalink":"https://ue5wiki.com/tags/ES3/"},{"name":"Package","slug":"Package","permalink":"https://ue5wiki.com/tags/Package/"},{"name":"DDC","slug":"DDC","permalink":"https://ue5wiki.com/tags/DDC/"},{"name":"Release","slug":"Release","permalink":"https://ue5wiki.com/tags/Release/"},{"name":"codesign","slug":"codesign","permalink":"https://ue5wiki.com/tags/codesign/"},{"name":"反射","slug":"反射","permalink":"https://ue5wiki.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"https://ue5wiki.com/tags/ThirdParty/"},{"name":"Module","slug":"Module","permalink":"https://ue5wiki.com/tags/Module/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://ue5wiki.com/tags/Protobuf/"},{"name":"ES2.0","slug":"ES2-0","permalink":"https://ue5wiki.com/tags/ES2-0/"},{"name":"Commandline","slug":"Commandline","permalink":"https://ue5wiki.com/tags/Commandline/"},{"name":"跨平台","slug":"跨平台","permalink":"https://ue5wiki.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"UnLua","slug":"UnLua","permalink":"https://ue5wiki.com/tags/UnLua/"},{"name":"UObject","slug":"UObject","permalink":"https://ue5wiki.com/tags/UObject/"},{"name":"ObjectInitializer","slug":"ObjectInitializer","permalink":"https://ue5wiki.com/tags/ObjectInitializer/"},{"name":"UProperty","slug":"UProperty","permalink":"https://ue5wiki.com/tags/UProperty/"},{"name":"UFunction","slug":"UFunction","permalink":"https://ue5wiki.com/tags/UFunction/"},{"name":"UClass","slug":"UClass","permalink":"https://ue5wiki.com/tags/UClass/"},{"name":"UStruct","slug":"UStruct","permalink":"https://ue5wiki.com/tags/UStruct/"},{"name":"UEnum","slug":"UEnum","permalink":"https://ue5wiki.com/tags/UEnum/"},{"name":"NavMesh","slug":"NavMesh","permalink":"https://ue5wiki.com/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://ue5wiki.com/tags/Navigation/"},{"name":"dSYM","slug":"dSYM","permalink":"https://ue5wiki.com/tags/dSYM/"},{"name":"UBT","slug":"UBT","permalink":"https://ue5wiki.com/tags/UBT/"},{"name":"Blueprint","slug":"Blueprint","permalink":"https://ue5wiki.com/tags/Blueprint/"},{"name":"异步","slug":"异步","permalink":"https://ue5wiki.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Build System","slug":"Build-System","permalink":"https://ue5wiki.com/tags/Build-System/"},{"name":"lua","slug":"lua","permalink":"https://ue5wiki.com/tags/lua/"},{"name":"Unreal Insight","slug":"Unreal-Insight","permalink":"https://ue5wiki.com/tags/Unreal-Insight/"},{"name":"Video","slug":"Video","permalink":"https://ue5wiki.com/tags/Video/"},{"name":"IDetailCustomization","slug":"IDetailCustomization","permalink":"https://ue5wiki.com/tags/IDetailCustomization/"},{"name":"Asset","slug":"Asset","permalink":"https://ue5wiki.com/tags/Asset/"},{"name":"EpicVerse","slug":"EpicVerse","permalink":"https://ue5wiki.com/tags/EpicVerse/"},{"name":"Script Language","slug":"Script-Language","permalink":"https://ue5wiki.com/tags/Script-Language/"},{"name":"Oodle","slug":"Oodle","permalink":"https://ue5wiki.com/tags/Oodle/"},{"name":"UnrealFrontEnd","slug":"UnrealFrontEnd","permalink":"https://ue5wiki.com/tags/UnrealFrontEnd/"},{"name":"开发环境","slug":"开发环境","permalink":"https://ue5wiki.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"DS","slug":"DS","permalink":"https://ue5wiki.com/tags/DS/"},{"name":"Wiki","slug":"Wiki","permalink":"https://ue5wiki.com/tags/Wiki/"},{"name":"Mac","slug":"Mac","permalink":"https://ue5wiki.com/tags/Mac/"},{"name":"IPA","slug":"IPA","permalink":"https://ue5wiki.com/tags/IPA/"},{"name":"VirtualTexture","slug":"VirtualTexture","permalink":"https://ue5wiki.com/tags/VirtualTexture/"},{"name":"PSO Caching","slug":"PSO-Caching","permalink":"https://ue5wiki.com/tags/PSO-Caching/"},{"name":"Tip","slug":"Tip","permalink":"https://ue5wiki.com/tags/Tip/"},{"name":"特效粒子","slug":"特效粒子","permalink":"https://ue5wiki.com/tags/%E7%89%B9%E6%95%88%E7%B2%92%E5%AD%90/"},{"name":"Niagara","slug":"Niagara","permalink":"https://ue5wiki.com/tags/Niagara/"},{"name":"内存优化","slug":"内存优化","permalink":"https://ue5wiki.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"},{"name":"Shader Patch","slug":"Shader-Patch","permalink":"https://ue5wiki.com/tags/Shader-Patch/"},{"name":"ushaderbytecode","slug":"ushaderbytecode","permalink":"https://ue5wiki.com/tags/ushaderbytecode/"},{"name":"链接库","slug":"链接库","permalink":"https://ue5wiki.com/tags/%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"UHT","slug":"UHT","permalink":"https://ue5wiki.com/tags/UHT/"},{"name":"大世界","slug":"大世界","permalink":"https://ue5wiki.com/tags/%E5%A4%A7%E4%B8%96%E7%95%8C/"},{"name":"UOD","slug":"UOD","permalink":"https://ue5wiki.com/tags/UOD/"},{"name":"UPL","slug":"UPL","permalink":"https://ue5wiki.com/tags/UPL/"},{"name":"BuildGraph","slug":"BuildGraph","permalink":"https://ue5wiki.com/tags/BuildGraph/"},{"name":"Music","slug":"Music","permalink":"https://ue5wiki.com/tags/Music/"},{"name":"Wwise","slug":"Wwise","permalink":"https://ue5wiki.com/tags/Wwise/"},{"name":"TexturePacker","slug":"TexturePacker","permalink":"https://ue5wiki.com/tags/TexturePacker/"},{"name":"图集","slug":"图集","permalink":"https://ue5wiki.com/tags/%E5%9B%BE%E9%9B%86/"},{"name":"Network","slug":"Network","permalink":"https://ue5wiki.com/tags/Network/"},{"name":"Windows","slug":"Windows","permalink":"https://ue5wiki.com/tags/Windows/"},{"name":"编译环境","slug":"编译环境","permalink":"https://ue5wiki.com/tags/%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"},{"name":"远程构建","slug":"远程构建","permalink":"https://ue5wiki.com/tags/%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA/"},{"name":"DASH","slug":"DASH","permalink":"https://ue5wiki.com/tags/DASH/"},{"name":"UE API","slug":"UE-API","permalink":"https://ue5wiki.com/tags/UE-API/"},{"name":"HTC Vive","slug":"HTC-Vive","permalink":"https://ue5wiki.com/tags/HTC-Vive/"},{"name":"VR","slug":"VR","permalink":"https://ue5wiki.com/tags/VR/"},{"name":"Oculus","slug":"Oculus","permalink":"https://ue5wiki.com/tags/Oculus/"},{"name":"FPaths","slug":"FPaths","permalink":"https://ue5wiki.com/tags/FPaths/"},{"name":"Template","slug":"Template","permalink":"https://ue5wiki.com/tags/Template/"},{"name":"GC","slug":"GC","permalink":"https://ue5wiki.com/tags/GC/"},{"name":"Lua","slug":"Lua","permalink":"https://ue5wiki.com/tags/Lua/"},{"name":"RDG","slug":"RDG","permalink":"https://ue5wiki.com/tags/RDG/"},{"name":"Data","slug":"Data","permalink":"https://ue5wiki.com/tags/Data/"},{"name":"Recast","slug":"Recast","permalink":"https://ue5wiki.com/tags/Recast/"},{"name":"MD5","slug":"MD5","permalink":"https://ue5wiki.com/tags/MD5/"},{"name":"Oculus Quest","slug":"Oculus-Quest","permalink":"https://ue5wiki.com/tags/Oculus-Quest/"},{"name":"Tools","slug":"Tools","permalink":"https://ue5wiki.com/tags/Tools/"},{"name":"EULA","slug":"EULA","permalink":"https://ue5wiki.com/tags/EULA/"},{"name":"PixelStreaming","slug":"PixelStreaming","permalink":"https://ue5wiki.com/tags/PixelStreaming/"},{"name":"Standalone Application","slug":"Standalone-Application","permalink":"https://ue5wiki.com/tags/Standalone-Application/"},{"name":"ue4program","slug":"ue4program","permalink":"https://ue5wiki.com/tags/ue4program/"},{"name":"Steam","slug":"Steam","permalink":"https://ue5wiki.com/tags/Steam/"},{"name":"SteamSDK","slug":"SteamSDK","permalink":"https://ue5wiki.com/tags/SteamSDK/"},{"name":"GConfig","slug":"GConfig","permalink":"https://ue5wiki.com/tags/GConfig/"},{"name":"VirtualReality","slug":"VirtualReality","permalink":"https://ue5wiki.com/tags/VirtualReality/"},{"name":"Vive Tracker","slug":"Vive-Tracker","permalink":"https://ue5wiki.com/tags/Vive-Tracker/"},{"name":"Seamless travel","slug":"Seamless-travel","permalink":"https://ue5wiki.com/tags/Seamless-travel/"},{"name":"String","slug":"String","permalink":"https://ue5wiki.com/tags/String/"},{"name":"Git","slug":"Git","permalink":"https://ue5wiki.com/tags/Git/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://ue5wiki.com/tags/Source-Control/"},{"name":"版本控制","slug":"版本控制","permalink":"https://ue5wiki.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]}